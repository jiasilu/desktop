/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./electron-builder.json":
/*!*******************************!*\
  !*** ./electron-builder.json ***!
  \*******************************/
/*! exports provided: publish, appId, artifactName, directories, files, protocols, afterSign, deb, linux, mac, dmg, squirrelWindows, win, nsis, default */
/***/ (function(module) {

module.exports = {"publish":[{"provider":"generic","url":"https://releases.mattermost.com/desktop/"}],"appId":"Mattermost.Desktop","artifactName":"${name}-${version}-${os}-${arch}.${ext}","directories":{"buildResources":"resources","app":"src","output":"release"},"files":["main_bundle.js","browser/**/*{.html,.css,_bundle.js}","assets/**/*","node_modules/bootstrap/dist/**","node_modules/simple-spellchecker/dict/*.dic"],"protocols":[{"name":"Mattermost","schemes":["mattermost"]}],"afterSign":"scripts/notarize.js","deb":{"synopsis":"Mattermost"},"linux":{"category":"Network;InstantMessaging","target":["deb","tar.gz","appimage"],"extraFiles":[{"filter":["LICENSE.txt","NOTICE.txt"]},{"from":"resources/linux","filter":["create_desktop_file.sh","icon.svg","README.md"]}]},"mac":{"category":"public.app-category.productivity","target":["zip","dmg"],"darkModeSupport":true,"extraResources":[{"filter":["LICENSE.txt","NOTICE.txt"]}],"hardenedRuntime":true,"gatekeeperAssess":true},"dmg":{"background":"resources/osx/DMG_BG.png","contents":[{"x":152,"y":201},{"x":445,"y":201,"type":"link","path":"/Applications"}],"iconSize":110,"iconTextSize":13},"squirrelWindows":{"iconUrl":"file://resources/icon.ico","artifactName":"${name}-setup-${version}-${arch}.${ext}"},"win":{"target":["nsis","zip"],"extraFiles":[{"filter":["LICENSE.txt","NOTICE.txt"]}]},"nsis":{"artifactName":"${name}-setup-${version}-win.${ext}"}};

/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "./src/common/JsonFileManager.js":
/*!***************************************!*\
  !*** ./src/common/JsonFileManager.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return JsonFileManager; });
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ "fs");
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_0__);
// Copyright (c) 2015-2016 Yuya Ochiai
// Copyright (c) 2016-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.


class JsonFileManager {
  constructor(file) {
    this.jsonFile = file;
    try {
      this.json = JSON.parse(fs__WEBPACK_IMPORTED_MODULE_0___default.a.readFileSync(file, 'utf-8'));
    } catch (err) {
      this.json = {};
    }
  }

  writeToFile() {
    fs__WEBPACK_IMPORTED_MODULE_0___default.a.writeFile(this.jsonFile, JSON.stringify(this.json, null, 2), (err) => {
      if (err) {
        console.error(err);
      }
    });
  }

  setJson(json) {
    this.json = json;
    this.writeToFile();
  }

  setValue(key, value) {
    this.json[key] = value;
    this.writeToFile();
  }

  getValue(key) {
    return this.json[key];
  }
}


/***/ }),

/***/ "./src/common/config/RegistryConfig.js":
/*!*********************************************!*\
  !*** ./src/common/config/RegistryConfig.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RegistryConfig; });
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events */ "events");
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var winreg__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! winreg */ "./src/node_modules/winreg/lib/registry.js");
/* harmony import */ var winreg__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(winreg__WEBPACK_IMPORTED_MODULE_1__);
// Copyright (c) 2015-2016 Yuya Ochiai
// Copyright (c) 2016-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.





const REGISTRY_HIVE_LIST = [winreg__WEBPACK_IMPORTED_MODULE_1___default.a.HKLM, winreg__WEBPACK_IMPORTED_MODULE_1___default.a.HKCU];
const BASE_REGISTRY_KEY_PATH = '\\Software\\Policies\\Mattermost';

/**
 * Handles loading config data from the Windows registry set manually or by GPO
 */
class RegistryConfig extends events__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"] {
  constructor() {
    super();
    this.initialized = false;
    this.data = {
      teams: [],
    };
  }

  /**
   * Triggers loading data from Windows registry, supports async/await
   *
   * @emits {update} emitted once all data has been loaded from the registry
   */
  async init() {
    if (process.platform === 'win32') {
      // extract DefaultServerList from the registry
      try {
        const servers = await this.getServersListFromRegistry();
        if (servers.length) {
          this.data.teams.push(...servers);
        }
      } catch (error) {
        console.log('[RegistryConfig] Nothing retrieved for \'DefaultServerList\'', error);
      }

      // extract EnableServerManagement from the registry
      try {
        const enableServerManagement = await this.getEnableServerManagementFromRegistry();
        if (enableServerManagement !== null) {
          this.data.enableServerManagement = enableServerManagement;
        }
      } catch (error) {
        console.log('[RegistryConfig] Nothing retrieved for \'EnableServerManagement\'', error);
      }

      // extract EnableAutoUpdater from the registry
      try {
        const enableAutoUpdater = await this.getEnableAutoUpdatorFromRegistry();
        if (enableAutoUpdater !== null) {
          this.data.enableAutoUpdater = enableAutoUpdater;
        }
      } catch (error) {
        console.log('[RegistryConfig] Nothing retrieved for \'EnableAutoUpdater\'', error);
      }
    }
    this.initialized = true;
    this.emit('update', this.data);
  }

  /**
   * Extracts a list of servers
   */
  async getServersListFromRegistry() {
    const defaultTeams = await this.getRegistryEntry(`${BASE_REGISTRY_KEY_PATH}\\DefaultServerList`);
    return defaultTeams.flat(2).reduce((teams, team) => {
      if (team) {
        teams.push({
          name: team.name,
          url: team.value,
        });
      }
      return teams;
    }, []);
  }

  /**
   * Determines whether server management has been enabled, disabled or isn't configured
   */
  async getEnableServerManagementFromRegistry() {
    const entries = (await this.getRegistryEntry(BASE_REGISTRY_KEY_PATH, 'EnableServerManagement'));
    const entry = entries.pop();
    return entry ? entry === '0x1' : null;
  }

  /**
   * Determines whether the auto updated has been enabled, disabled or isn't configured
   */
  async getEnableAutoUpdatorFromRegistry() {
    const entries = (await this.getRegistryEntry(BASE_REGISTRY_KEY_PATH, 'EnableAutoUpdater'));
    const entry = entries.pop();
    return entry ? entry === '0x1' : null;
  }

  /**
   * Initiates retrieval of a specific key in the Windows registry
   *
   * @param {string} key Path to the registry key to return
   * @param {string} name Name of specific entry in the registry key to retrieve (optional)
   */
  async getRegistryEntry(key, name) {
    const results = [];
    for (const hive of REGISTRY_HIVE_LIST) {
      results.push(this.getRegistryEntryValues(new winreg__WEBPACK_IMPORTED_MODULE_1___default.a({hive, key}), name));
    }
    const entryValues = await Promise.all(results);
    return entryValues.filter((value) => value);
  }

  /**
   * Handles actual retrieval of entries from a configured WindowsRegistry instance
   *
   * @param {WindowsRegistry} regKey A configured instance of the WindowsRegistry class
   * @param {string} name Name of the specific entry to retrieve (optional)
   */
  getRegistryEntryValues(regKey, name) {
    return new Promise((resolve) => {
      regKey.values((error, items) => {
        if (error || !items || !items.length) {
          resolve();
          return;
        }
        if (name) { // looking for a single entry value
          const registryItem = items.find((item) => item.name === name);
          resolve(registryItem && registryItem.value ? registryItem.value : null);
        } else { // looking for an entry list
          resolve(items);
        }
      });
    });
  }
}


/***/ }),

/***/ "./src/common/config/buildConfig.js":
/*!******************************************!*\
  !*** ./src/common/config/buildConfig.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// Copyright (c) 2015-2016 Yuya Ochiai
// Copyright (c) 2016-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

// For detailed guides, please refer to https://docs.mattermost.com/deployment/desktop-app-deployment.html

/**
 * Build-time configuration. End-users can't change these parameters.
 * @prop {Object[]} defaultTeams
 * @prop {string} defaultTeams[].name - The tab name for default team.
 * @prop {string} defaultTeams[].url - The URL for default team.
 * @prop {string} helpLink - The URL for "Help->Learn More..." menu item.
 *                           If null is specified, the menu disappears.
 * @prop {boolean} enableServerManagement - Whether users can edit servers configuration.
 *                                          Specify at least one server for "defaultTeams"
 *                                          when "enableServerManagement is set to false
 */
const buildConfig = {
  defaultTeams: [/*
    {
      name: 'example',
      url: 'https://example.com'
    }*/
  ],
  helpLink: 'https://about.mattermost.com/default-desktop-app-documentation/',
  enableServerManagement: true,
  enableAutoUpdater: true,
};

/* harmony default export */ __webpack_exports__["default"] = (buildConfig);


/***/ }),

/***/ "./src/common/config/defaultPreferences.js":
/*!*************************************************!*\
  !*** ./src/common/config/defaultPreferences.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// Copyright (c) 2015-2016 Yuya Ochiai
// Copyright (c) 2016-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

/**
 * Default user preferences. End-users can change these parameters by editing config.json
 * @param {number} version - Scheme version. (Not application version)
 */
const defaultPreferences = {
  version: 1,
  teams: [],
  showTrayIcon: false,
  trayIconTheme: 'light',
  minimizeToTray: false,
  notifications: {
    flashWindow: 0,
    bounceIcon: false,
    bounceIconType: 'informational',
  },
  showUnreadBadge: true,
  useSpellChecker: true,
  enableHardwareAcceleration: true,
  autostart: true,
  spellCheckerLocale: 'en-US',
};

/* harmony default export */ __webpack_exports__["default"] = (defaultPreferences);


/***/ }),

/***/ "./src/common/config/index.js":
/*!************************************!*\
  !*** ./src/common/config/index.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Config; });
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ "fs");
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ "path");
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! events */ "events");
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _main_Validator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../main/Validator */ "./src/main/Validator.js");
/* harmony import */ var _defaultPreferences__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./defaultPreferences */ "./src/common/config/defaultPreferences.js");
/* harmony import */ var _upgradePreferences__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./upgradePreferences */ "./src/common/config/upgradePreferences.js");
/* harmony import */ var _buildConfig__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./buildConfig */ "./src/common/config/buildConfig.js");
// Copyright (c) 2015-2016 Yuya Ochiai
// Copyright (c) 2016-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.












/**
 * Handles loading and merging all sources of configuration as well as saving user provided config
 */
class Config extends events__WEBPACK_IMPORTED_MODULE_2__["EventEmitter"] {
  constructor(configFilePath, registryConfigData = {teams: []}) {
    super();
    this.configFilePath = configFilePath;
    this.registryConfigData = registryConfigData;
    this.reload();
  }

  /**
   * Reload all sources of config data
   *
   * @param {boolean} synchronize determines whether or not to emit a synchronize event once config has been reloaded
   * @emits {update} emitted once all data has been loaded and merged
   * @emits {synchronize} emitted when requested by a call to method; used to notify other config instances of changes
   */
  reload(synchronize = false) {
    this.defaultConfigData = this.loadDefaultConfigData();
    this.buildConfigData = this.loadBuildConfigData();

    this.localConfigData = this.loadLocalConfigFile();
    this.localConfigData = this.checkForConfigUpdates(this.localConfigData);

    this.regenerateCombinedConfigData();

    this.emit('update', this.combinedData);

    if (synchronize) {
      this.emit('synchronize');
    }
  }

  /**
   * Used to save a single config property
   *
   * @param {string} key name of config property to be saved
   * @param {*} data value to save for provided key
   */
  set(key, data) {
    if (key) {
      this.localConfigData[key] = data;
      this.regenerateCombinedConfigData();
      this.saveLocalConfigData();
    }
  }

  /**
   * Used to save an array of config properties in one go
   *
   * @param {array} properties an array of config properties to save
   */
  setMultiple(properties = []) {
    if (properties.length) {
      properties.forEach(({key, data}) => {
        if (key) {
          this.localConfigData[key] = data;
        }
      });
      this.regenerateCombinedConfigData();
      this.saveLocalConfigData();
    }
  }

  setRegistryConfigData(registryConfigData = {teams: []}) {
    this.registryConfigData = Object.assign({}, registryConfigData);
    this.reload();
  }

  /**
   * Used to replace the existing config data with new config data
   *
   * @param {object} configData a new, config data object to completely replace the existing config data
   */
  replace(configData) {
    const newConfigData = configData;

    this.localConfigData = Object.assign({}, this.localConfigData, newConfigData);

    this.regenerateCombinedConfigData();
    this.saveLocalConfigData();
  }

  /**
   * Used to save the current set of local config data to disk
   *
   * @emits {update} emitted once all data has been saved
   * @emits {synchronize} emitted once all data has been saved; used to notify other config instances of changes
   * @emits {error} emitted if saving local config data to file fails
   */
  saveLocalConfigData() {
    try {
      this.writeFile(this.configFilePath, this.localConfigData, (error) => {
        if (error) {
          throw new Error(error);
        }
        this.emit('update', this.combinedData);
        this.emit('synchronize');
      });
    } catch (error) {
      this.emit('error', error);
    }
  }

  // getters for accessing the various config data inputs

  get data() {
    return this.combinedData;
  }
  get localData() {
    return this.localConfigData;
  }
  get defaultData() {
    return this.defaultConfigData;
  }
  get buildData() {
    return this.buildConfigData;
  }
  get registryData() {
    return this.registryConfigData;
  }

  // convenience getters

  get version() {
    return this.combinedData.version;
  }
  get teams() {
    return this.combinedData.teams;
  }
  get localTeams() {
    return this.localConfigData.teams;
  }
  get predefinedTeams() {
    return [...this.buildConfigData.defaultTeams, ...this.registryConfigData.teams];
  }
  get enableHardwareAcceleration() {
    return this.combinedData.enableHardwareAcceleration;
  }
  get enableServerManagement() {
    return this.combinedData.enableServerManagement;
  }
  get enableAutoUpdater() {
    return this.combinedData.enableAutoUpdater;
  }
  get autostart() {
    return this.combinedData.autostart;
  }
  get notifications() {
    return this.combinedData.notifications;
  }
  get showUnreadBadge() {
    return this.combinedData.showUnreadBadge;
  }
  get useSpellChecker() {
    return this.combinedData.useSpellChecker;
  }
  get spellCheckerLocale() {
    return this.combinedData.spellCheckerLocale;
  }
  get showTrayIcon() {
    return this.combinedData.showTrayIcon;
  }
  get trayIconTheme() {
    return this.combinedData.trayIconTheme;
  }
  get helpLink() {
    return this.combinedData.helpLink;
  }

  // initialization/processing methods

  /**
   * Returns a copy of the app's default config data
   */
  loadDefaultConfigData() {
    return this.copy(_defaultPreferences__WEBPACK_IMPORTED_MODULE_4__["default"]);
  }

  /**
   * Returns a copy of the app's build config data
   */
  loadBuildConfigData() {
    return this.copy(_buildConfig__WEBPACK_IMPORTED_MODULE_6__["default"]);
  }

  /**
   * Loads and returns locally stored config data from the filesystem or returns app defaults if no file is found
   */
  loadLocalConfigFile() {
    let configData = {};
    try {
      configData = this.readFileSync(this.configFilePath);

      // validate based on config file version
      if (configData.version > 0) {
        configData = _main_Validator__WEBPACK_IMPORTED_MODULE_3__["validateV1ConfigData"](configData);
      } else {
        configData = _main_Validator__WEBPACK_IMPORTED_MODULE_3__["validateV0ConfigData"](configData);
      }
      if (!configData) {
        throw new Error('Provided configuration file does not validate, using defaults instead.');
      }
    } catch (e) {
      console.log('Failed to load configuration file from the filesystem. Using defaults.');
      configData = this.copy(this.defaultConfigData);

      // add default team to teams if one exists and there arent currently any teams
      if (!configData.teams.length && this.defaultConfigData.defaultTeam) {
        configData.teams.push(this.defaultConfigData.defaultTeam);
      }
      delete configData.defaultTeam;

      this.writeFileSync(this.configFilePath, configData);
    }
    return configData;
  }

  /**
   * Determines if locally stored data needs to be updated and upgrades as needed
   *
   * @param {*} data locally stored data
   */
  checkForConfigUpdates(data) {
    let configData = data;
    try {
      if (configData.version !== this.defaultConfigData.version) {
        configData = Object(_upgradePreferences__WEBPACK_IMPORTED_MODULE_5__["default"])(configData);
        this.writeFileSync(this.configFilePath, configData);
        console.log(`Configuration updated to version ${this.defaultConfigData.version} successfully.`);
      }
    } catch (error) {
      console.log(`Failed to update configuration to version ${this.defaultConfigData.version}.`);
    }
    return configData;
  }

  /**
   * Properly combines all sources of data into a single, manageable set of all config data
   */
  regenerateCombinedConfigData() {
    // combine all config data in the correct order
    this.combinedData = Object.assign({}, this.defaultConfigData, this.localConfigData, this.buildConfigData, this.registryConfigData);

    // remove unecessary data pulled from default and build config
    delete this.combinedData.defaultTeam;
    delete this.combinedData.defaultTeams;

    // IMPORTANT: properly combine teams from all sources
    const combinedTeams = [];

    // - start by adding default teams from buildConfig, if any
    if (this.buildConfigData.defaultTeams && this.buildConfigData.defaultTeams.length) {
      combinedTeams.push(...this.buildConfigData.defaultTeams);
    }

    // - add registry defined teams, if any
    if (this.registryConfigData.teams && this.registryConfigData.teams.length) {
      combinedTeams.push(...this.registryConfigData.teams);
    }

    // - add locally defined teams only if server management is enabled
    if (this.enableServerManagement) {
      combinedTeams.push(...this.localConfigData.teams);
    }

    this.combinedData.teams = combinedTeams;
    this.combinedData.localTeams = this.localConfigData.teams;
    this.combinedData.buildTeams = this.buildConfigData.defaultTeams;
    this.combinedData.registryTeams = this.registryConfigData.teams;
  }

  /**
   * Returns the provided list of teams with duplicates filtered out
   *
   * @param {array} teams array of teams to check for duplicates
   */
  filterOutDuplicateTeams(teams) {
    let newTeams = teams;
    const uniqueURLs = new Set();
    newTeams = newTeams.filter((team) => {
      return uniqueURLs.has(team.url) ? false : uniqueURLs.add(team.url);
    });
    return newTeams;
  }

  /**
   * Returns the provided array fo teams with existing teams filtered out
   * @param {array} teams array of teams to check for already defined teams
   */
  filterOutPredefinedTeams(teams) {
    let newTeams = teams;

    // filter out predefined teams
    newTeams = newTeams.filter((newTeam) => {
      return this.predefinedTeams.findIndex((existingTeam) => newTeam.url === existingTeam.url) === -1; // eslint-disable-line max-nested-callbacks
    });

    return newTeams;
  }

  // helper functions

  readFileSync(filePath) {
    return JSON.parse(fs__WEBPACK_IMPORTED_MODULE_0___default.a.readFileSync(filePath, 'utf8'));
  }

  writeFile(filePath, configData, callback) {
    if (configData.version !== this.defaultConfigData.version) {
      throw new Error('version ' + configData.version + ' is not equal to ' + this.defaultConfigData.version);
    }
    const json = JSON.stringify(configData, null, '  ');
    fs__WEBPACK_IMPORTED_MODULE_0___default.a.writeFile(filePath, json, 'utf8', callback);
  }

  writeFileSync(filePath, config) {
    if (config.version !== this.defaultConfigData.version) {
      throw new Error('version ' + config.version + ' is not equal to ' + this.defaultConfigData.version);
    }

    const dir = path__WEBPACK_IMPORTED_MODULE_1___default.a.dirname(filePath);
    if (!fs__WEBPACK_IMPORTED_MODULE_0___default.a.existsSync(dir)) {
      fs__WEBPACK_IMPORTED_MODULE_0___default.a.mkdirSync(dir);
    }

    const json = JSON.stringify(config, null, '  ');
    fs__WEBPACK_IMPORTED_MODULE_0___default.a.writeFileSync(filePath, json, 'utf8');
  }

  merge(base, target) {
    return Object.assign({}, base, target);
  }

  copy(data) {
    return Object.assign({}, data);
  }
}


/***/ }),

/***/ "./src/common/config/pastDefaultPreferences.js":
/*!*****************************************************!*\
  !*** ./src/common/config/pastDefaultPreferences.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _defaultPreferences__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./defaultPreferences */ "./src/common/config/defaultPreferences.js");
// Copyright (c) 2015-2016 Yuya Ochiai
// Copyright (c) 2016-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.


const pastDefaultPreferences = {
  0: {
    url: '',
  },
};

pastDefaultPreferences[`${_defaultPreferences__WEBPACK_IMPORTED_MODULE_0__["default"].version}`] = _defaultPreferences__WEBPACK_IMPORTED_MODULE_0__["default"];

/* harmony default export */ __webpack_exports__["default"] = (pastDefaultPreferences);


/***/ }),

/***/ "./src/common/config/upgradePreferences.js":
/*!*************************************************!*\
  !*** ./src/common/config/upgradePreferences.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return upgradeToLatest; });
/* harmony import */ var _pastDefaultPreferences__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pastDefaultPreferences */ "./src/common/config/pastDefaultPreferences.js");
// Copyright (c) 2015-2016 Yuya Ochiai
// Copyright (c) 2016-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.


function deepCopy(object) {
  return JSON.parse(JSON.stringify(object));
}

function upgradeV0toV1(configV0) {
  const config = deepCopy(_pastDefaultPreferences__WEBPACK_IMPORTED_MODULE_0__["default"]['1']);
  if (config.version !== 1) {
    throw new Error('pastDefaultPreferences[\'1\'].version is not equal to 1');
  }
  config.teams.push({
    name: 'Primary team',
    url: configV0.url,
  });
  return config;
}

function upgradeToLatest(config) {
  const configVersion = config.version ? config.version : 0;
  switch (configVersion) {
  case 0:
    return upgradeToLatest(upgradeV0toV1(config));
  default:
    return config;
  }
}


/***/ }),

/***/ "./src/main.js":
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! os */ "os");
/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(os__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ "path");
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! url */ "url");
/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(url__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! electron */ "electron");
/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(electron__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var electron_is_dev__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! electron-is-dev */ "./src/node_modules/electron-is-dev/index.js");
/* harmony import */ var electron_is_dev__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(electron_is_dev__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var electron_devtools_installer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! electron-devtools-installer */ "./src/node_modules/electron-devtools-installer/dist/index.js");
/* harmony import */ var electron_devtools_installer__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(electron_devtools_installer__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var electron_log__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! electron-log */ "./src/node_modules/electron-log/index.js");
/* harmony import */ var electron_log__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(electron_log__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _electron_builder_json__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../electron-builder.json */ "./electron-builder.json");
var _electron_builder_json__WEBPACK_IMPORTED_MODULE_7___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../electron-builder.json */ "./electron-builder.json", 1);
/* harmony import */ var _main_AutoLauncher__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./main/AutoLauncher */ "./src/main/AutoLauncher.js");
/* harmony import */ var _main_CriticalErrorHandler__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./main/CriticalErrorHandler */ "./src/main/CriticalErrorHandler.js");
/* harmony import */ var _main_autoLaunch__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./main/autoLaunch */ "./src/main/autoLaunch.js");
/* harmony import */ var _common_config_RegistryConfig__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./common/config/RegistryConfig */ "./src/common/config/RegistryConfig.js");
/* harmony import */ var _common_config__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./common/config */ "./src/common/config/index.js");
/* harmony import */ var _main_certificateStore__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./main/certificateStore */ "./src/main/certificateStore.js");
/* harmony import */ var _main_mainWindow__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./main/mainWindow */ "./src/main/mainWindow.js");
/* harmony import */ var _main_menus_app__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./main/menus/app */ "./src/main/menus/app.js");
/* harmony import */ var _main_menus_tray__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./main/menus/tray */ "./src/main/menus/tray.js");
/* harmony import */ var _main_downloadURL__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./main/downloadURL */ "./src/main/downloadURL.js");
/* harmony import */ var _main_allowProtocolDialog__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./main/allowProtocolDialog */ "./src/main/allowProtocolDialog.js");
/* harmony import */ var _main_AppStateManager__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./main/AppStateManager */ "./src/main/AppStateManager.js");
/* harmony import */ var _main_cookieManager__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./main/cookieManager */ "./src/main/cookieManager.js");
/* harmony import */ var _main_utils__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./main/utils */ "./src/main/utils.js");
/* harmony import */ var _main_SpellChecker__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./main/SpellChecker */ "./src/main/SpellChecker.js");
/* harmony import */ var _main_UserActivityMonitor__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./main/UserActivityMonitor */ "./src/main/UserActivityMonitor.js");
/* harmony import */ var _utils_util__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./utils/util */ "./src/utils/util.js");
/* harmony import */ var _main_ParseArgs__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./main/ParseArgs */ "./src/main/ParseArgs.js");
// Copyright (c) 2015-2016 Yuya Ochiai
// Copyright (c) 2016-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

































// pull out required electron components like this
// as not all components can be referenced before the app is ready
const {
  app,
  Menu,
  Tray,
  ipcMain,
  nativeImage,
  dialog,
  systemPreferences,
  session,
  BrowserWindow,
} = electron__WEBPACK_IMPORTED_MODULE_3___default.a;
const criticalErrorHandler = new _main_CriticalErrorHandler__WEBPACK_IMPORTED_MODULE_9__["default"]();
const assetsDir = path__WEBPACK_IMPORTED_MODULE_1___default.a.resolve(app.getAppPath(), 'assets');
const loginCallbackMap = new Map();
const userActivityMonitor = new _main_UserActivityMonitor__WEBPACK_IMPORTED_MODULE_23__["default"]();

// Keep a global reference of the window object, if you don't, the window will
// be closed automatically when the JavaScript object is garbage collected.
let mainWindow = null;
let popupWindow = null;
let hideOnStartup = null;
let certificateStore = null;
let spellChecker = null;
let deeplinkingUrl = null;
let scheme = null;
let appState = null;
let registryConfig = null;
let config = null;
let trayIcon = null;
let trayImages = null;

// supported custom login paths (oath, saml)
const customLoginRegexPaths = [
  /^\/oauth\/authorize$/i,
  /^\/oauth\/deauthorize$/i,
  /^\/oauth\/access_token$/i,
  /^\/oauth\/[A-Za-z0-9]+\/complete$/i,
  /^\/oauth\/[A-Za-z0-9]+\/login$/i,
  /^\/oauth\/[A-Za-z0-9]+\/signup$/i,
  /^\/api\/v3\/oauth\/[A-Za-z0-9]+\/complete$/i,
  /^\/signup\/[A-Za-z0-9]+\/complete$/i,
  /^\/login\/[A-Za-z0-9]+\/complete$/i,
  /^\/login\/sso\/saml$/i,
];

// tracking in progress custom logins
const customLogins = {};

/**
 * Main entry point for the application, ensures that everything initializes in the proper order
 */
async function initialize() {
  process.on('uncaughtException', criticalErrorHandler.processUncaughtExceptionHandler.bind(criticalErrorHandler));
  global.willAppQuit = false;

  // initialization that can run before the app is ready
  initializeArgs();
  initializeConfig();
  initializeAppEventListeners();
  initializeBeforeAppReady();

  // wait for registry config data to load and app ready event
  await Promise.all([
    registryConfig.init(),
    app.whenReady(),
  ]);

  // no need to continue initializing if app is quitting
  if (global.willAppQuit) {
    return;
  }

  // initialization that should run once the app is ready
  initializeInterCommunicationEventListeners();
  initializeAfterAppReady();
  initializeMainWindowListeners();
}

// attempt to initialize the application
try {
  initialize();
} catch (error) {
  throw new Error(`App initialization failed: ${error.toString()}`);
}

//
// initialization sub functions
//

function initializeArgs() {
  global.args = Object(_main_ParseArgs__WEBPACK_IMPORTED_MODULE_25__["default"])(process.argv.slice(1));

  // output the application version via cli when requested (-v or --version)
  if (global.args.version) {
    process.stdout.write(`v.${app.getVersion()}\n`);
    process.exit(0); // eslint-disable-line no-process-exit
  }

  hideOnStartup = Object(_main_utils__WEBPACK_IMPORTED_MODULE_21__["shouldBeHiddenOnStartup"])(global.args);

  global.isDev = electron_is_dev__WEBPACK_IMPORTED_MODULE_4___default.a && !global.args.disableDevMode; // this doesn't seem to be right and isn't used as the single source of truth

  if (global.args['data-dir']) {
    app.setPath('userData', path__WEBPACK_IMPORTED_MODULE_1___default.a.resolve(global.args['data-dir']));
  }
}

function initializeConfig() {
  registryConfig = new _common_config_RegistryConfig__WEBPACK_IMPORTED_MODULE_11__["default"]();
  config = new _common_config__WEBPACK_IMPORTED_MODULE_12__["default"](app.getPath('userData') + '/config.json');
  config.on('update', handleConfigUpdate);
  config.on('synchronize', handleConfigSynchronize);
}

function initializeAppEventListeners() {
  app.on('second-instance', handleAppSecondInstance);
  app.on('window-all-closed', handleAppWindowAllClosed);
  app.on('browser-window-created', handleAppBrowserWindowCreated);
  app.on('activate', handleAppActivate);
  app.on('before-quit', handleAppBeforeQuit);
  app.on('certificate-error', handleAppCertificateError);
  app.on('gpu-process-crashed', handleAppGPUProcessCrashed);
  app.on('login', handleAppLogin);
  app.on('will-finish-launching', handleAppWillFinishLaunching);
  app.on('web-contents-created', handleAppWebContentsCreated);
}

function initializeBeforeAppReady() {
  certificateStore = _main_certificateStore__WEBPACK_IMPORTED_MODULE_13__["default"].load(path__WEBPACK_IMPORTED_MODULE_1___default.a.resolve(app.getPath('userData'), 'certificate.json'));

  // prevent using a different working directory, which happens on windows running after installation.
  const expectedPath = path__WEBPACK_IMPORTED_MODULE_1___default.a.dirname(process.execPath);
  if (process.cwd() !== expectedPath && !electron_is_dev__WEBPACK_IMPORTED_MODULE_4___default.a) {
    console.warn(`Current working directory is ${process.cwd()}, changing into ${expectedPath}`);
    process.chdir(expectedPath);
  }

  // can only call this before the app is ready
  if (config.enableHardwareAcceleration === false) {
    app.disableHardwareAcceleration();
  }

  trayImages = getTrayImages();

  // If there is already an instance, quit this one
  const gotTheLock = app.requestSingleInstanceLock();
  if (!gotTheLock) {
    app.exit();
    global.willAppQuit = true;
  }

  if (!config.spellCheckerLocale) {
    config.set('spellCheckerLocale', _main_SpellChecker__WEBPACK_IMPORTED_MODULE_22__["default"].getSpellCheckerLocale(app.getLocale()));
  }

  _main_allowProtocolDialog__WEBPACK_IMPORTED_MODULE_18__["default"].init(mainWindow);

  if (electron_is_dev__WEBPACK_IMPORTED_MODULE_4___default.a) {
    console.log('In development mode, deeplinking is disabled');
  } else if (_electron_builder_json__WEBPACK_IMPORTED_MODULE_7__["protocols"] && _electron_builder_json__WEBPACK_IMPORTED_MODULE_7__["protocols"][0] && _electron_builder_json__WEBPACK_IMPORTED_MODULE_7__["protocols"][0].schemes && _electron_builder_json__WEBPACK_IMPORTED_MODULE_7__["protocols"][0].schemes[0]) {
    scheme = _electron_builder_json__WEBPACK_IMPORTED_MODULE_7__["protocols"][0].schemes[0];
    app.setAsDefaultProtocolClient(scheme);
  }
}

function initializeInterCommunicationEventListeners() {
  ipcMain.on('reload-config', handleReloadConfig);
  ipcMain.on('login-credentials', handleLoginCredentialsEvent);
  ipcMain.on('download-url', handleDownloadURLEvent);
  ipcMain.on('notified', handleNotifiedEvent);
  ipcMain.on('update-title', handleUpdateTitleEvent);
  ipcMain.on('update-menu', handleUpdateMenuEvent);
  ipcMain.on('update-dict', handleUpdateDictionaryEvent);
  ipcMain.on('checkspell', handleCheckSpellingEvent);
  ipcMain.on('get-spelling-suggestions', handleGetSpellingSuggestionsEvent);
  ipcMain.on('get-spellchecker-locale', handleGetSpellcheckerLocaleEvent);
  ipcMain.on('reply-on-spellchecker-is-ready', handleReplyOnSpellcheckerIsReadyEvent);
  if (shouldShowTrayIcon()) {
    ipcMain.on('update-unread', handleUpdateUnreadEvent);
  }
}

function initializeMainWindowListeners() {
  mainWindow.on('closed', handleMainWindowClosed);
  mainWindow.on('unresponsive', criticalErrorHandler.windowUnresponsiveHandler.bind(criticalErrorHandler));
  mainWindow.webContents.on('crashed', handleMainWindowWebContentsCrashed);
}

//
// config event handlers
//

function handleConfigUpdate(configData) {
  if (process.platform === 'win32' || process.platform === 'linux') {
    const appLauncher = new _main_AutoLauncher__WEBPACK_IMPORTED_MODULE_8__["default"]();
    const autoStartTask = config.autostart ? appLauncher.enable() : appLauncher.disable();
    autoStartTask.then(() => {
      console.log('config.autostart has been configured:', config.autostart);
    }).catch((err) => {
      console.log('error:', err);
    });
  }

  ipcMain.emit('update-menu', true, configData);
}

function handleConfigSynchronize() {
  if (mainWindow) {
    mainWindow.webContents.send('reload-config');
  }
}

function handleReloadConfig() {
  config.reload();
}

//
// app event handlers
//

// activate first app instance, subsequent instances will quit themselves
function handleAppSecondInstance(event, argv) {
  // Protocol handler for win32
  // argv: An array of the second instance’s (command line / deep linked) arguments
  if (process.platform === 'win32') {
    deeplinkingUrl = getDeeplinkingURL(argv);
    if (deeplinkingUrl) {
      mainWindow.webContents.send('protocol-deeplink', deeplinkingUrl);
    }
  }

  // Someone tried to run a second instance, we should focus our window.
  if (mainWindow) {
    if (mainWindow.isMinimized()) {
      mainWindow.restore();
    } else {
      mainWindow.show();
    }
  }
}

function handleAppWindowAllClosed() {
  // On OS X it is common for applications and their menu bar
  // to stay active until the user quits explicitly with Cmd + Q
  if (process.platform !== 'darwin') {
    app.quit();
  }
}

function handleAppBrowserWindowCreated(error, newWindow) {
  // Screen cannot be required before app is ready
  const {screen} = electron__WEBPACK_IMPORTED_MODULE_3___default.a;
  resizeScreen(screen, newWindow);
}

function handleAppActivate() {
  mainWindow.show();
}

function handleAppBeforeQuit() {
  // Make sure tray icon gets removed if the user exits via CTRL-Q
  if (trayIcon && process.platform === 'win32') {
    trayIcon.destroy();
  }
  global.willAppQuit = true;
}

function handleAppCertificateError(event, webContents, url, error, certificate, callback) {
  if (certificateStore.isTrusted(url, certificate)) {
    event.preventDefault();
    callback(true);
  } else {
    let detail = `URL: ${url}\nError: ${error}`;
    if (certificateStore.isExisting(url)) {
      detail = 'Certificate is different from previous one.\n\n' + detail;
    }
    dialog.showMessageBox(mainWindow, {
      title: 'Certificate Error',
      message: 'There is a configuration issue with this Mattermost server, or someone is trying to intercept your connection. You also may need to sign into the Wi-Fi you are connected to using your web browser.',
      type: 'error',
      buttons: [
        'More Details',
        'Cancel Connection',
      ],
      cancelId: 1,
    }, (response) => {
      if (response === 0) {
        dialog.showMessageBox(mainWindow, {
          title: 'Certificate Error',
          message: `Certificate from "${certificate.issuerName}" is not trusted.`,
          detail,
          type: 'error',
          buttons: [
            'Trust Insecure Certificate',
            'Cancel Connection',
          ],
          cancelId: 1,
        }, (responseTwo) => { //eslint-disable-line max-nested-callbacks
          if (responseTwo === 0) {
            certificateStore.add(url, certificate);
            certificateStore.save();
            webContents.loadURL(url);
          }
        });
      }
    });
    callback(false);
  }
}

function handleAppGPUProcessCrashed(event, killed) {
  console.log(`The GPU process has crashed (killed = ${killed})`);
}

function handleAppLogin(event, webContents, request, authInfo, callback) {
  event.preventDefault();
  loginCallbackMap.set(JSON.stringify(request), callback);
  mainWindow.webContents.send('login-request', request, authInfo);
}

function handleAppWillFinishLaunching() {
  // Protocol handler for osx
  app.on('open-url', (event, url) => {
    event.preventDefault();
    deeplinkingUrl = getDeeplinkingURL([url]);
    if (app.isReady()) {
      function openDeepLink() {
        try {
          if (deeplinkingUrl) {
            mainWindow.webContents.send('protocol-deeplink', deeplinkingUrl);
            mainWindow.show();
          }
        } catch (err) {
          setTimeout(openDeepLink, 1000);
        }
      }
      openDeepLink();
    }
  });
}

function handleAppWebContentsCreated(dc, contents) {
  // initialize custom login tracking
  customLogins[contents.id] = {
    inProgress: false,
  };

  contents.on('will-attach-webview', (event, webPreferences) => {
    webPreferences.nodeIntegration = false;
    webPreferences.contextIsolation = true;
  });

  contents.on('will-navigate', (event, url) => {
    const contentID = event.sender.id;
    const parsedURL = parseURL(url);

    if (isTrustedURL(parsedURL) || isTrustedPopupWindow(event.sender)) {
      return;
    }
    if (parsedURL.protocol === 'mailto:') {
      return;
    }
    if (customLogins[contentID].inProgress) {
      return;
    }

    electron_log__WEBPACK_IMPORTED_MODULE_6___default.a.info(`Untrusted URL blocked: ${url}`);
    //event.preventDefault();
  });

  // handle custom login requests (oath, saml):
  // 1. are we navigating to a supported local custom login path from the `/login` page?
  //    - indicate custom login is in progress
  // 2. are we finished with the custom login process?
  //    - indicate custom login is NOT in progress
  contents.on('did-start-navigation', (event, url) => {
    const contentID = event.sender.id;
    const parsedURL = parseURL(url);

    if (!isTrustedURL(parsedURL)) {
      return;
    }

    if (isCustomLoginURL(parsedURL)) {
      customLogins[contentID].inProgress = true;
    } else if (customLogins[contentID].inProgress) {
      customLogins[contentID].inProgress = false;
    }
  });

  contents.on('new-window', (event, url) => {
    event.preventDefault();
    if (!isTrustedURL(url)) {
      electron_log__WEBPACK_IMPORTED_MODULE_6___default.a.info(`Untrusted popup window blocked: ${url}`);
      return;
    }
    if (isTeamUrl(url) === true) {
      electron_log__WEBPACK_IMPORTED_MODULE_6___default.a.info(`${url} is a known team, preventing to open a new window`);
      return;
    }
    if (popupWindow && popupWindow.getURL() === url) {
      electron_log__WEBPACK_IMPORTED_MODULE_6___default.a.info(`Popup window already open at provided url: ${url}`);
      return;
    }
    if (!popupWindow) {
      popupWindow = new BrowserWindow({
        backgroundColor: '#fff', // prevents blurry text: https://electronjs.org/docs/faq#the-font-looks-blurry-what-is-this-and-what-can-i-do
        parent: mainWindow,
        show: false,
        webPreferences: {
          nodeIntegration: false,
          contextIsolation: true,
        },
      });
      popupWindow.once('ready-to-show', () => {
        popupWindow.show();
      });
      popupWindow.once('closed', () => {
        popupWindow = null;
      });
    }
    popupWindow.loadURL(url);
  });

  // implemented to temporarily help solve for https://community-daily.mattermost.com/core/pl/b95bi44r4bbnueqzjjxsi46qiw
  contents.on('before-input-event', (event, input) => {
    if (!input.shift && !input.control && !input.alt && !input.meta) {
      // hacky fix for https://mattermost.atlassian.net/browse/MM-19226
      if ((input.key === 'Escape' || input.key === 'f') && input.type === 'keyDown') {
        // only do this when in fullscreen on a mac
        if (mainWindow.isFullScreen() && process.platform === 'darwin') {
          mainWindow.webContents.send('exit-fullscreen');
        }
      }
      return;
    }

    if ((process.platform === 'darwin' && !input.meta) || (process.platform !== 'darwin' && !input.control)) {
      return;
    }

    // handle certain keyboard shortcuts manually
    switch (input.key) { // eslint-disable-line padded-blocks

    // Manually handle zoom-in/out/reset keyboard shortcuts
    // - temporary fix for https://mattermost.atlassian.net/browse/MM-19031 and https://mattermost.atlassian.net/browse/MM-19032
    case '-':
      mainWindow.webContents.send('zoom-out');
      break;
    case '=':
      mainWindow.webContents.send('zoom-in');
      break;
    case '0':
      mainWindow.webContents.send('zoom-reset');
      break;

    // Manually handle undo/redo keyboard shortcuts
    // - temporary fix for https://mattermost.atlassian.net/browse/MM-19198
    case 'z':
      if (input.shift) {
        mainWindow.webContents.send('redo');
      } else {
        mainWindow.webContents.send('undo');
      }
      break;

    // Manually handle copy/cut/paste keyboard shortcuts
    case 'c':
      mainWindow.webContents.send('copy');
      break;
    case 'x':
      mainWindow.webContents.send('cut');
      break;
    case 'v':
      if (input.shift) {
        mainWindow.webContents.send('paste-and-match');
      } else {
        mainWindow.webContents.send('paste');
      }
      break;
    default:
      // allows the input event to proceed if not handled by a case above
      return;
    }
    event.preventDefault();
  });
}

function initializeAfterAppReady() {
  app.setAppUserModelId('Mattermost.Desktop'); // Use explicit AppUserModelID

  const appStateJson = path__WEBPACK_IMPORTED_MODULE_1___default.a.join(app.getPath('userData'), 'app-state.json');
  appState = new _main_AppStateManager__WEBPACK_IMPORTED_MODULE_19__["default"](appStateJson);
  if (wasUpdated(appState.lastAppVersion)) {
    clearAppCache();
  }
  appState.lastAppVersion = app.getVersion();

  if (!global.isDev) {
    Object(_main_autoLaunch__WEBPACK_IMPORTED_MODULE_10__["default"])();
  }

  if (global.isDev) {
    electron_devtools_installer__WEBPACK_IMPORTED_MODULE_5___default()(electron_devtools_installer__WEBPACK_IMPORTED_MODULE_5__["REACT_DEVELOPER_TOOLS"]).
      then((name) => console.log(`Added Extension:  ${name}`)).
      catch((err) => console.log('An error occurred: ', err));
  }

  // Protocol handler for win32
  if (process.platform === 'win32') {
    const args = process.argv.slice(1);
    if (Array.isArray(args) && args.length > 0) {
      deeplinkingUrl = getDeeplinkingURL(args);
    }
  }

  Object(_main_cookieManager__WEBPACK_IMPORTED_MODULE_20__["default"])(session.defaultSession);

  mainWindow = Object(_main_mainWindow__WEBPACK_IMPORTED_MODULE_14__["default"])(config.data, {
    hideOnStartup,
    trayIconShown: process.platform === 'win32' || config.showTrayIcon,
    linuxAppIcon: path__WEBPACK_IMPORTED_MODULE_1___default.a.join(assetsDir, 'appicon.png'),
    deeplinkingUrl,
  });

  criticalErrorHandler.setMainWindow(mainWindow);

  config.setRegistryConfigData(registryConfig.data);
  mainWindow.registryConfigData = registryConfig.data;

  // listen for status updates and pass on to renderer
  userActivityMonitor.on('status', (status) => {
    mainWindow.webContents.send('user-activity-update', status);
  });

  // start monitoring user activity (needs to be started after the app is ready)
  userActivityMonitor.startMonitoring();

  if (shouldShowTrayIcon()) {
    // set up tray icon
    trayIcon = new Tray(trayImages.normal);
    if (process.platform === 'darwin') {
      trayIcon.setPressedImage(trayImages.clicked.normal);
      systemPreferences.subscribeNotification('AppleInterfaceThemeChangedNotification', () => {
        switchMenuIconImages(trayImages, systemPreferences.isDarkMode());
        trayIcon.setImage(trayImages.normal);
      });
    }

    trayIcon.setToolTip(app.getName());
    trayIcon.on('click', () => {
      if (!mainWindow.isVisible() || mainWindow.isMinimized()) {
        if (mainWindow.isMinimized()) {
          mainWindow.restore();
        } else {
          mainWindow.show();
        }
        mainWindow.focus();
        if (process.platform === 'darwin') {
          app.dock.show();
        }
      } else {
        mainWindow.focus();
      }
    });

    trayIcon.on('right-click', () => {
      trayIcon.popUpContextMenu();
    });
    trayIcon.on('balloon-click', () => {
      if (process.platform === 'win32' || process.platform === 'darwin') {
        if (mainWindow.isMinimized()) {
          mainWindow.restore();
        } else {
          mainWindow.show();
        }
      }

      if (process.platform === 'darwin') {
        app.dock.show();
      }

      mainWindow.focus();
    });
  }

  if (process.platform === 'darwin') {
    session.defaultSession.on('will-download', (event, item) => {
      const filename = item.getFilename();
      const savePath = dialog.showSaveDialog({
        title: filename,
        defaultPath: os__WEBPACK_IMPORTED_MODULE_0___default.a.homedir() + '/Downloads/' + filename,
      });

      if (savePath) {
        item.setSavePath(savePath);
      } else {
        item.cancel();
      }
    });
  }

  ipcMain.emit('update-menu', true, config.data);

  ipcMain.emit('update-dict');

  // supported permission types
  const supportedPermissionTypes = [
    'media',
    'geolocation',
    'notifications',
    'fullscreen',
    'openExternal',
  ];

  // handle permission requests
  // - approve if a supported permission type and the request comes from the renderer or one of the defined servers
  session.defaultSession.setPermissionRequestHandler((webContents, permission, callback) => {
    // is the requested permission type supported?
    if (!supportedPermissionTypes.includes(permission)) {
      callback(false);
      return;
    }

    // is the request coming from the renderer?
    if (webContents.id === mainWindow.webContents.id) {
      callback(true);
      return;
    }

    // get the requesting webContents url
    const requestingURL = webContents.getURL();

    // is the target url trusted?
    const matchingTeamIndex = config.teams.findIndex((team) => {
      return requestingURL.startsWith(team.url);
    });

    callback(matchingTeamIndex >= 0);
  });
}

//
// ipc communication event handlers
//

function handleLoginCredentialsEvent(event, request, user, password) {
  const callback = loginCallbackMap.get(JSON.stringify(request));
  if (callback != null) {
    callback(user, password);
  }
}

function handleDownloadURLEvent(event, url) {
  Object(_main_downloadURL__WEBPACK_IMPORTED_MODULE_17__["default"])(mainWindow, url, (err) => {
    if (err) {
      dialog.showMessageBox(mainWindow, {
        type: 'error',
        message: err.toString(),
      });
      console.log(err);
    }
  });
}

function handleNotifiedEvent() {
  if (process.platform === 'win32' || process.platform === 'linux') {
    if (config.notifications.flashWindow === 2) {
      mainWindow.flashFrame(true);
    }
  }

  if (process.platform === 'darwin' && config.notifications.bounceIcon) {
    app.dock.bounce(config.notifications.bounceIconType);
  }
}

function handleUpdateTitleEvent(event, arg) {
  mainWindow.setTitle(arg.title);
}

function handleUpdateUnreadEvent(event, arg) {
  if (process.platform === 'win32') {
    const overlay = arg.overlayDataURL ? nativeImage.createFromDataURL(arg.overlayDataURL) : null;
    if (mainWindow) {
      mainWindow.setOverlayIcon(overlay, arg.description);
    }
  }

  if (trayIcon && !trayIcon.isDestroyed()) {
    if (arg.sessionExpired) {
      // reuse the mention icon when the session is expired
      trayIcon.setImage(trayImages.mention);
      if (process.platform === 'darwin') {
        trayIcon.setPressedImage(trayImages.clicked.mention);
      }
      trayIcon.setToolTip('Session Expired: Please sign in to continue receiving notifications.');
    } else if (arg.mentionCount > 0) {
      trayIcon.setImage(trayImages.mention);
      if (process.platform === 'darwin') {
        trayIcon.setPressedImage(trayImages.clicked.mention);
      }
      trayIcon.setToolTip(arg.mentionCount + ' unread mentions');
    } else if (arg.unreadCount > 0) {
      trayIcon.setImage(trayImages.unread);
      if (process.platform === 'darwin') {
        trayIcon.setPressedImage(trayImages.clicked.unread);
      }
      trayIcon.setToolTip(arg.unreadCount + ' unread channels');
    } else {
      trayIcon.setImage(trayImages.normal);
      if (process.platform === 'darwin') {
        trayIcon.setPressedImage(trayImages.clicked.normal);
      }
      trayIcon.setToolTip(app.getName());
    }
  }
}

function handleUpdateMenuEvent(event, configData) {
  const aMenu = _main_menus_app__WEBPACK_IMPORTED_MODULE_15__["default"].createMenu(mainWindow, configData, global.isDev);
  Menu.setApplicationMenu(aMenu);

  // set up context menu for tray icon
  if (shouldShowTrayIcon()) {
    const tMenu = _main_menus_tray__WEBPACK_IMPORTED_MODULE_16__["default"].createMenu(mainWindow, configData, global.isDev);
    if (process.platform === 'darwin' || process.platform === 'linux') {
      // store the information, if the tray was initialized, for checking in the settings, if the application
      // was restarted after setting "Show icon on menu bar"
      if (trayIcon) {
        trayIcon.setContextMenu(tMenu);
        mainWindow.trayWasVisible = true;
      } else {
        mainWindow.trayWasVisible = false;
      }
    } else if (trayIcon) {
      trayIcon.setContextMenu(tMenu);
    }
  }
}

// localeSelected might be null, if that's the case, use config's locale
function handleUpdateDictionaryEvent(_, localeSelected) {
  if (config.useSpellChecker) {
    const locale = localeSelected || config.spellCheckerLocale;
    try {
      spellChecker = new _main_SpellChecker__WEBPACK_IMPORTED_MODULE_22__["default"](
        locale,
        path__WEBPACK_IMPORTED_MODULE_1___default.a.resolve(app.getAppPath(), 'node_modules/simple-spellchecker/dict'),
        (err) => {
          if (err) {
            console.error(err);
          }
        });
    } catch (e) {
      console.error('couldn\'t load a spellchecker for locale');
    }
  }
}

function handleCheckSpellingEvent(event, word) {
  let res = null;
  if (config.useSpellChecker && spellChecker.isReady() && word !== null) {
    res = spellChecker.spellCheck(word);
  }
  event.returnValue = res;
}

function handleGetSpellingSuggestionsEvent(event, word) {
  if (config.useSpellChecker && spellChecker.isReady() && word !== null) {
    event.returnValue = spellChecker.getSuggestions(word, 10);
  } else {
    event.returnValue = [];
  }
}

function handleGetSpellcheckerLocaleEvent(event) {
  event.returnValue = config.spellCheckerLocale;
}

function handleReplyOnSpellcheckerIsReadyEvent(event) {
  if (!spellChecker) {
    return;
  }

  if (spellChecker.isReady()) {
    event.sender.send('spellchecker-is-ready');
    return;
  }
  spellChecker.once('ready', () => {
    event.sender.send('spellchecker-is-ready');
  });
}

//
// mainWindow event handlers
//

function handleMainWindowClosed() {
  // Dereference the window object, usually you would store windows
  // in an array if your app supports multi windows, this is the time
  // when you should delete the corresponding element.
  mainWindow = null;
}

function handleMainWindowWebContentsCrashed() {
  throw new Error('webContents \'crashed\' event has been emitted');
}

//
// helper functions
//

function parseURL(url) {
  if (!url) {
    return null;
  }
  if (url instanceof url__WEBPACK_IMPORTED_MODULE_2__["URL"]) {
    return url;
  }
  try {
    return new url__WEBPACK_IMPORTED_MODULE_2__["URL"](url);
  } catch (e) {
    return null;
  }
}

function isTeamUrl(url) {
  const parsedURL = parseURL(url);
  if (!parsedURL) {
    return null;
  }
  if (isCustomLoginURL(parsedURL)) {
    return false;
  }
  const nonTeamUrlPaths = ['plugins', 'signup', 'login', 'admin', 'channel', 'post', 'api', 'oauth'];
  return !(nonTeamUrlPaths.some((testPath) => parsedURL.pathname.toLowerCase().startsWith(`/${testPath}/`)));
}

function isTrustedURL(url) {
  const parsedURL = parseURL(url);
  if (!parsedURL) {
    return false;
  }
  const teamURLs = config.teams.reduce((urls, team) => {
    const parsedTeamURL = parseURL(team.url);
    if (parsedTeamURL) {
      return urls.concat(parsedTeamURL);
    }
    return urls;
  }, []);
  for (const teamURL of teamURLs) {
    if (parsedURL.origin === teamURL.origin) {
      return true;
    }
  }
  return false;
}

function isTrustedPopupWindow(webContents) {
  if (!webContents) {
    return false;
  }
  if (!popupWindow) {
    return false;
  }
  return BrowserWindow.fromWebContents(webContents) === popupWindow;
}

function isCustomLoginURL(url) {
  const parsedURL = parseURL(url);
  if (!parsedURL) {
    return false;
  }
  if (!isTrustedURL(parsedURL)) {
    return false;
  }
  const urlPath = parsedURL.pathname;
  for (const regexPath of customLoginRegexPaths) {
    if (urlPath.match(regexPath)) {
      return true;
    }
  }
  return false;
}

function getTrayImages() {
  switch (process.platform) {
  case 'win32':
    return {
      normal: nativeImage.createFromPath(path__WEBPACK_IMPORTED_MODULE_1___default.a.resolve(assetsDir, 'windows/tray.ico')),
      unread: nativeImage.createFromPath(path__WEBPACK_IMPORTED_MODULE_1___default.a.resolve(assetsDir, 'windows/tray_unread.ico')),
      mention: nativeImage.createFromPath(path__WEBPACK_IMPORTED_MODULE_1___default.a.resolve(assetsDir, 'windows/tray_mention.ico')),
    };
  case 'darwin':
  {
    const icons = {
      light: {
        normal: nativeImage.createFromPath(path__WEBPACK_IMPORTED_MODULE_1___default.a.resolve(assetsDir, 'osx/MenuIcon.png')),
        unread: nativeImage.createFromPath(path__WEBPACK_IMPORTED_MODULE_1___default.a.resolve(assetsDir, 'osx/MenuIconUnread.png')),
        mention: nativeImage.createFromPath(path__WEBPACK_IMPORTED_MODULE_1___default.a.resolve(assetsDir, 'osx/MenuIconMention.png')),
      },
      clicked: {
        normal: nativeImage.createFromPath(path__WEBPACK_IMPORTED_MODULE_1___default.a.resolve(assetsDir, 'osx/ClickedMenuIcon.png')),
        unread: nativeImage.createFromPath(path__WEBPACK_IMPORTED_MODULE_1___default.a.resolve(assetsDir, 'osx/ClickedMenuIconUnread.png')),
        mention: nativeImage.createFromPath(path__WEBPACK_IMPORTED_MODULE_1___default.a.resolve(assetsDir, 'osx/ClickedMenuIconMention.png')),
      },
    };
    switchMenuIconImages(icons, systemPreferences.isDarkMode());
    return icons;
  }
  case 'linux':
  {
    const theme = config.trayIconTheme;
    try {
      return {
        normal: nativeImage.createFromPath(path__WEBPACK_IMPORTED_MODULE_1___default.a.resolve(assetsDir, 'linux', theme, 'MenuIconTemplate.png')),
        unread: nativeImage.createFromPath(path__WEBPACK_IMPORTED_MODULE_1___default.a.resolve(assetsDir, 'linux', theme, 'MenuIconUnreadTemplate.png')),
        mention: nativeImage.createFromPath(path__WEBPACK_IMPORTED_MODULE_1___default.a.resolve(assetsDir, 'linux', theme, 'MenuIconMentionTemplate.png')),
      };
    } catch (e) {
      //Fallback for invalid theme setting
      return {
        normal: nativeImage.createFromPath(path__WEBPACK_IMPORTED_MODULE_1___default.a.resolve(assetsDir, 'linux', 'light', 'MenuIconTemplate.png')),
        unread: nativeImage.createFromPath(path__WEBPACK_IMPORTED_MODULE_1___default.a.resolve(assetsDir, 'linux', 'light', 'MenuIconUnreadTemplate.png')),
        mention: nativeImage.createFromPath(path__WEBPACK_IMPORTED_MODULE_1___default.a.resolve(assetsDir, 'linux', 'light', 'MenuIconMentionTemplate.png')),
      };
    }
  }
  default:
    return {};
  }
}

function switchMenuIconImages(icons, isDarkMode) {
  if (isDarkMode) {
    icons.normal = icons.clicked.normal;
    icons.unread = icons.clicked.unread;
    icons.mention = icons.clicked.mention;
  } else {
    icons.normal = icons.light.normal;
    icons.unread = icons.light.unread;
    icons.mention = icons.light.mention;
  }
}

function getDeeplinkingURL(args) {
  if (Array.isArray(args) && args.length) {
    // deeplink urls should always be the last argument, but may not be the first (i.e. Windows with the app already running)
    const url = args[args.length - 1];
    if (url && scheme && url.startsWith(scheme) && _utils_util__WEBPACK_IMPORTED_MODULE_24__["default"].isValidURI(url)) {
      return url;
    }
  }
  return null;
}

function shouldShowTrayIcon() {
  if (process.platform === 'win32') {
    return true;
  }
  if (['darwin', 'linux'].includes(process.platform) && config.showTrayIcon === true) {
    return true;
  }
  return false;
}

function wasUpdated(lastAppVersion) {
  return lastAppVersion !== app.getVersion();
}

function clearAppCache() {
  if (mainWindow) {
    console.log('Clear cache after update');
    mainWindow.webContents.session.clearCache(() => {
      //Restart after cache clear
      mainWindow.reload();
    });
  } else {
    //Wait for mainWindow
    setTimeout(clearAppCache, 100);
  }
}

function isWithinDisplay(state, display) {
  // given a display, check if window is within it
  return (state.x > display.maxX || state.y > display.maxY || state.x < display.minX || state.y < display.minY);
}

function getValidWindowPosition(state) {
  // Check if the previous position is out of the viewable area
  // (e.g. because the screen has been plugged off)
  const boundaries = _utils_util__WEBPACK_IMPORTED_MODULE_24__["default"].getDisplayBoundaries();
  const isDisplayed = boundaries.reduce(
    (prev, display) => {
      return prev || isWithinDisplay(state, display);
    },
    false);

  if (isDisplayed) {
    Reflect.deleteProperty(state, 'x');
    Reflect.deleteProperty(state, 'y');
    Reflect.deleteProperty(state, 'width');
    Reflect.deleteProperty(state, 'height');
  }

  return state;
}

function resizeScreen(screen, browserWindow) {
  function handle() {
    const position = browserWindow.getPosition();
    const size = browserWindow.getSize();
    const validPosition = getValidWindowPosition({
      x: position[0],
      y: position[1],
      width: size[0],
      height: size[1],
    });
    browserWindow.setPosition(validPosition.x || 0, validPosition.y || 0);
  }

  browserWindow.on('restore', handle);
  handle();
}


/***/ }),

/***/ "./src/main/AppStateManager.js":
/*!*************************************!*\
  !*** ./src/main/AppStateManager.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AppStateManager; });
/* harmony import */ var _common_JsonFileManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/JsonFileManager */ "./src/common/JsonFileManager.js");
/* harmony import */ var _Validator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Validator */ "./src/main/Validator.js");
// Copyright (c) 2015-2016 Yuya Ochiai
// Copyright (c) 2016-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.




class AppStateManager extends _common_JsonFileManager__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor(file) {
    super(file);

    // ensure data loaded from file is valid
    const validatedJSON = _Validator__WEBPACK_IMPORTED_MODULE_1__["validateAppState"](this.json);
    if (!validatedJSON) {
      this.setJson({});
    }
  }
  set lastAppVersion(version) {
    this.setValue('lastAppVersion', version);
  }

  get lastAppVersion() {
    return this.getValue('lastAppVersion');
  }

  set skippedVersion(version) {
    this.setValue('skippedVersion', version);
  }

  get skippedVersion() {
    return this.getValue('skippedVersion');
  }

  set updateCheckedDate(date) {
    this.setValue('updateCheckedDate', date.toISOString());
  }

  get updateCheckedDate() {
    const date = this.getValue('updateCheckedDate');
    if (date) {
      return new Date(date);
    }
    return null;
  }
}


/***/ }),

/***/ "./src/main/AutoLauncher.js":
/*!**********************************!*\
  !*** ./src/main/AutoLauncher.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AutoLauncher; });
/* harmony import */ var auto_launch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! auto-launch */ "./src/node_modules/auto-launch/dist/index.js");
/* harmony import */ var auto_launch__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(auto_launch__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! electron */ "electron");
/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(electron__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var electron_is_dev__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! electron-is-dev */ "./src/node_modules/electron-is-dev/index.js");
/* harmony import */ var electron_is_dev__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(electron_is_dev__WEBPACK_IMPORTED_MODULE_2__);
// Copyright (c) 2015-2016 Yuya Ochiai
// Copyright (c) 2016-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.





class AutoLauncher {
  constructor() {
    this.appLauncher = new auto_launch__WEBPACK_IMPORTED_MODULE_0___default.a({
      name: electron__WEBPACK_IMPORTED_MODULE_1__["app"].getName(),
      isHidden: true,
    });
  }

  isEnabled() {
    return this.appLauncher.isEnabled();
  }

  async blankPromise() {
    return null;
  }

  async enable() {
    if (electron_is_dev__WEBPACK_IMPORTED_MODULE_2___default.a) {
      console.log('In development mode, autostart config never effects');
      return this.blankPromise();
    }
    const enabled = await this.isEnabled();
    if (!enabled) {
      return this.appLauncher.enable();
    }
    return this.blankPromise();
  }

  async disable() {
    if (electron_is_dev__WEBPACK_IMPORTED_MODULE_2___default.a) {
      console.log('In development mode, autostart config never effects');
      return this.blankPromise();
    }
    const enabled = await this.isEnabled();
    if (enabled) {
      return this.appLauncher.disable();
    }
    return this.blankPromise();
  }
}


/***/ }),

/***/ "./src/main/CriticalErrorHandler.js":
/*!******************************************!*\
  !*** ./src/main/CriticalErrorHandler.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CriticalErrorHandler; });
/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! child_process */ "child_process");
/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(child_process__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! fs */ "fs");
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! os */ "os");
/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(os__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! path */ "path");
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! electron */ "electron");
/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(electron__WEBPACK_IMPORTED_MODULE_4__);
// Copyright (c) 2015-2016 Yuya Ochiai
// Copyright (c) 2016-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.







const BUTTON_OK = 'OK';
const BUTTON_SHOW_DETAILS = 'Show Details';
const BUTTON_REOPEN = 'Reopen';

function createErrorReport(err) {
  return `Application: ${electron__WEBPACK_IMPORTED_MODULE_4__["app"].getName()} ${electron__WEBPACK_IMPORTED_MODULE_4__["app"].getVersion()}\n` +
         `Platform: ${os__WEBPACK_IMPORTED_MODULE_2___default.a.type()} ${os__WEBPACK_IMPORTED_MODULE_2___default.a.release()} ${os__WEBPACK_IMPORTED_MODULE_2___default.a.arch()}\n` +
         `${err.stack}`;
}

function openDetachedExternal(url) {
  const spawnOption = {detached: true, stdio: 'ignore'};
  switch (process.platform) {
  case 'win32':
    return Object(child_process__WEBPACK_IMPORTED_MODULE_0__["spawn"])('cmd', ['/C', 'start', url], spawnOption);
  case 'darwin':
    return Object(child_process__WEBPACK_IMPORTED_MODULE_0__["spawn"])('open', [url], spawnOption);
  case 'linux':
    return Object(child_process__WEBPACK_IMPORTED_MODULE_0__["spawn"])('xdg-open', [url], spawnOption);
  default:
    return null;
  }
}

function bindWindowToShowMessageBox(win) {
  if (win && win.isVisible()) {
    return electron__WEBPACK_IMPORTED_MODULE_4__["dialog"].showMessageBox.bind(null, win);
  }
  return electron__WEBPACK_IMPORTED_MODULE_4__["dialog"].showMessageBox;
}

class CriticalErrorHandler {
  constructor() {
    this.mainWindow = null;
  }

  setMainWindow(mainWindow) {
    this.mainWindow = mainWindow;
  }

  windowUnresponsiveHandler() {
    const result = electron__WEBPACK_IMPORTED_MODULE_4__["dialog"].showMessageBox(this.mainWindow, {
      type: 'warning',
      title: electron__WEBPACK_IMPORTED_MODULE_4__["app"].getName(),
      message: 'The window is no longer responsive.\nDo you wait until the window becomes responsive again?',
      buttons: ['No', 'Yes'],
      defaultId: 0,
    });
    if (result === 0) {
      throw new Error('BrowserWindow \'unresponsive\' event has been emitted');
    }
  }

  processUncaughtExceptionHandler(err) {
    const file = path__WEBPACK_IMPORTED_MODULE_3___default.a.join(electron__WEBPACK_IMPORTED_MODULE_4__["app"].getPath('userData'), `uncaughtException-${Date.now()}.txt`);
    const report = createErrorReport(err);
    fs__WEBPACK_IMPORTED_MODULE_1___default.a.writeFileSync(file, report.replace(new RegExp('\\n', 'g'), os__WEBPACK_IMPORTED_MODULE_2___default.a.EOL));

    if (electron__WEBPACK_IMPORTED_MODULE_4__["app"].isReady()) {
      const buttons = [BUTTON_SHOW_DETAILS, BUTTON_OK, BUTTON_REOPEN];
      if (process.platform === 'darwin') {
        buttons.reverse();
      }
      const showMessageBox = bindWindowToShowMessageBox(this.mainWindow);
      const result = showMessageBox({
        type: 'error',
        title: electron__WEBPACK_IMPORTED_MODULE_4__["app"].getName(),
        message: `The ${electron__WEBPACK_IMPORTED_MODULE_4__["app"].getName()} app quit unexpectedly. Click "Show Details" to learn more or "Reopen" to open the application again.\n\nInternal error: ${err.message}`,
        buttons,
        defaultId: buttons.indexOf(BUTTON_REOPEN),
        noLink: true,
      });
      switch (result) {
      case buttons.indexOf(BUTTON_SHOW_DETAILS):
        {
          const child = openDetachedExternal(file);
          if (child) {
            child.on('error', (spawnError) => {
              console.log(spawnError);
            });
            child.unref();
          }
        }
        break;
      case buttons.indexOf(BUTTON_REOPEN):
        electron__WEBPACK_IMPORTED_MODULE_4__["app"].relaunch();
        break;
      }
    }
    throw err;
  }
}


/***/ }),

/***/ "./src/main/ParseArgs.js":
/*!*******************************!*\
  !*** ./src/main/ParseArgs.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return parse; });
/* harmony import */ var yargs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! yargs */ "./src/node_modules/yargs/index.js");
/* harmony import */ var yargs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(yargs__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _electron_builder_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../electron-builder.json */ "./electron-builder.json");
var _electron_builder_json__WEBPACK_IMPORTED_MODULE_1___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../electron-builder.json */ "./electron-builder.json", 1);
/* harmony import */ var _Validator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Validator */ "./src/main/Validator.js");
// Copyright (c) 2016-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.







function parse(args) {
  return validateArgs(parseArgs(triageArgs(args)));
}

function triageArgs(args) {
  // ensure any args following a possible deeplink are discarded
  if (_electron_builder_json__WEBPACK_IMPORTED_MODULE_1__["protocols"] && _electron_builder_json__WEBPACK_IMPORTED_MODULE_1__["protocols"][0] && _electron_builder_json__WEBPACK_IMPORTED_MODULE_1__["protocols"][0].schemes && _electron_builder_json__WEBPACK_IMPORTED_MODULE_1__["protocols"][0].schemes[0]) {
    const scheme = _electron_builder_json__WEBPACK_IMPORTED_MODULE_1__["protocols"][0].schemes[0].toLowerCase();
    const deeplinkIndex = args.findIndex((arg) => arg.toLowerCase().includes(`${scheme}:`));
    if (deeplinkIndex !== -1) {
      return args.slice(0, deeplinkIndex + 1);
    }
  }
  return args;
}

function parseArgs(args) {
  return yargs__WEBPACK_IMPORTED_MODULE_0___default.a.
    boolean('hidden').describe('hidden', 'Launch the app in hidden mode.').
    alias('disable-dev-mode', 'disableDevMode').boolean('disable-dev-mode').describe('disable-dev-mode', 'Disable dev mode.').
    alias('data-dir', 'dataDir').string('data-dir').describe('data-dir', 'Set the path to where user data is stored.').
    alias('v', 'version').boolean('v').describe('version', 'Prints the application version.').
    parse(args);
}

function validateArgs(args) {
  return _Validator__WEBPACK_IMPORTED_MODULE_2__["validateArgs"](args) || {};
}


/***/ }),

/***/ "./src/main/SpellChecker.js":
/*!**********************************!*\
  !*** ./src/main/SpellChecker.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return SpellChecker; });
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events */ "events");
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var simple_spellchecker__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! simple-spellchecker */ "./src/node_modules/simple-spellchecker/index.js");
/* harmony import */ var simple_spellchecker__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(simple_spellchecker__WEBPACK_IMPORTED_MODULE_1__);
// Copyright (c) 2015-2016 Yuya Ochiai
// Copyright (c) 2016-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.






/// Following approach for contractions is derived from electron-spellchecker.

// NB: This is to work around electron/electron#1005, where contractions
// are incorrectly marked as spelling errors. This lets people get away with
// incorrectly spelled contracted words, but it's the best we can do for now.
const contractions = [
  "ain't", "aren't", "can't", "could've", "couldn't", "couldn't've", "didn't", "doesn't", "don't", "hadn't",
  "hadn't've", "hasn't", "haven't", "he'd", "he'd've", "he'll", "he's", "how'd", "how'll", "how's", "I'd",
  "I'd've", "I'll", "I'm", "I've", "isn't", "it'd", "it'd've", "it'll", "it's", "let's", "ma'am", "mightn't",
  "mightn't've", "might've", "mustn't", "must've", "needn't", "not've", "o'clock", "shan't", "she'd", "she'd've",
  "she'll", "she's", "should've", "shouldn't", "shouldn't've", "that'll", "that's", "there'd", "there'd've",
  "there're", "there's", "they'd", "they'd've", "they'll", "they're", "they've", "wasn't", "we'd", "we'd've",
  "we'll", "we're", "we've", "weren't", "what'll", "what're", "what's", "what've", "when's", "where'd",
  "where's", "where've", "who'd", "who'll", "who're", "who's", "who've", "why'll", "why're", "why's", "won't",
  "would've", "wouldn't", "wouldn't've", "y'all", "y'all'd've", "you'd", "you'd've", "you'll", "you're", "you've",
];

const contractionMap = contractions.reduce((acc, word) => {
  acc[word.replace(/'.*/, '')] = true;
  return acc;
}, {});

/// End: derived from electron-spellchecker.

class SpellChecker extends events__WEBPACK_IMPORTED_MODULE_0___default.a {
  constructor(locale, dictDir, callback) {
    super();
    this.dict = null;
    this.locale = locale;
    simple_spellchecker__WEBPACK_IMPORTED_MODULE_1___default.a.getDictionary(locale, dictDir, (err, dict) => {
      if (err) {
        this.emit('error', err);
        if (callback) {
          callback(err);
        }
      } else {
        this.dict = dict;
        this.emit('ready');
        if (callback) {
          callback(null, this);
        }
      }
    });
  }

  isReady() {
    return this.dict !== null;
  }

  spellCheck(word) {
    if (word.toLowerCase() === 'mattermost') {
      return true;
    }
    if (isFinite(word)) { // Numerals are not included in the dictionary
      return true;
    }
    if (this.locale.match(/^en-?/) && contractionMap[word]) {
      return true;
    }
    return this.dict.spellCheck(word);
  }

  getSuggestions(word, maxSuggestions) {
    const suggestions = this.dict.getSuggestions(word, maxSuggestions);

    const firstCharWord = word.charAt(0);
    let i;
    for (i = 0; i < suggestions.length; i++) {
      if (suggestions[i].charAt(0).toUpperCase() === firstCharWord.toUpperCase()) {
        suggestions[i] = firstCharWord + suggestions[i].slice(1);
      }
    }

    const uniqueSuggestions = suggestions.reduce((a, b) => {
      if (a.indexOf(b) < 0) {
        a.push(b);
      }
      return a;
    }, []);

    return uniqueSuggestions;
  }
}

SpellChecker.getSpellCheckerLocale = (electronLocale) => {
  if (electronLocale.match(/^en-?/)) {
    return 'en-US';
  }
  if (electronLocale.match(/^fr-?/)) {
    return 'fr-FR';
  }
  if (electronLocale.match(/^de-?/)) {
    return 'de-DE';
  }
  if (electronLocale.match(/^es-?/)) {
    return 'es-ES';
  }
  if (electronLocale.match(/^nl-?/)) {
    return 'nl-NL';
  }
  if (electronLocale.match(/^pt-?/)) {
    return 'pt-BR';
  }
  return 'en-US';
};


/***/ }),

/***/ "./src/main/UserActivityMonitor.js":
/*!*****************************************!*\
  !*** ./src/main/UserActivityMonitor.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return UserActivityMonitor; });
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events */ "events");
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! electron */ "electron");
/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(electron__WEBPACK_IMPORTED_MODULE_1__);
// Copyright (c) 2016-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.





const {app} = electron__WEBPACK_IMPORTED_MODULE_1___default.a;

/**
 * Monitors system idle time, listens for system events and fires status updates as needed
 */
class UserActivityMonitor extends events__WEBPACK_IMPORTED_MODULE_0___default.a {
  constructor() {
    super();

    this.isActive = true;
    this.idleTime = 0;
    this.lastSetActive = null;
    this.systemIdleTimeIntervalID = -1;

    this.config = {
      updateFrequencyMs: 1 * 1000, // eslint-disable-line no-magic-numbers
      inactiveThresholdMs: 60 * 1000, // eslint-disable-line no-magic-numbers
      statusUpdateThresholdMs: 60 * 1000, // eslint-disable-line no-magic-numbers
    };
  }

  get userIsActive() {
    return this.isActive;
  }

  get userIdleTime() {
    return this.idleTime;
  }

  /**
   * Begin monitoring system events and idle time at defined frequency
   *
   * @param {Object} config - overide internal configuration defaults
   * @param {number} config.updateFrequencyMs - internal update clock frequency for monitoring idleTime
   * @param {number} config.inactiveThresholdMs - the number of milliseconds that idleTime needs to reach to internally be considered inactive
   * @param {number} config.statusUpdateThresholdMs - minimum amount of time before sending a new status update
   * @emits {error} emitted when method is called before the app is ready
   * @emits {error} emitted when this method has previously been called but not subsequently stopped
   */
  startMonitoring(config = {}) {
    if (!app.isReady()) {
      this.emit('error', new Error('UserActivityMonitor.startMonitoring can only be called after app is ready'));
      return;
    }

    if (this.systemIdleTimeIntervalID >= 0) {
      this.emit('error', new Error('User activity monitoring is already in progress'));
      return;
    }

    this.config = Object.assign({}, this.config, config);

    this.systemIdleTimeIntervalID = setInterval(() => {
      try {
        electron__WEBPACK_IMPORTED_MODULE_1___default.a.powerMonitor.querySystemIdleTime((idleTime) => {
          this.updateIdleTime(idleTime);
        });
      } catch (err) {
        console.log('Error getting system idle time:', err);
      }
    }, this.config.updateFrequencyMs);
  }

  /**
   * Stop monitoring system events and idle time
   */
  stopMonitoring() {
    clearInterval(this.systemIdleTimeIntervalID);
  }

  /**
   * Updates internal idle time and sets internal user activity state
   *
   * @param {integer} idleTime
   * @private
   */
  updateIdleTime(idleTime) {
    this.idleTime = idleTime;
    if (idleTime * 1000 > this.config.inactiveThresholdMs) { // eslint-disable-line no-magic-numbers
      this.setActivityState(false);
    } else {
      this.setActivityState(true);
    }
  }

  /**
   * Updates user active state and conditionally triggers a status update
   *
   * @param {boolean} isActive
   * @param {boolean} isSystemEvent – indicates whether the update was triggered by a system event (log in/out, screesaver on/off etc)
   * @private
   */
  setActivityState(isActive = false, isSystemEvent = false) {
    this.isActive = isActive;

    if (isSystemEvent) {
      this.sendStatusUpdate(true);
      return;
    }

    const now = Date.now();

    if (isActive && (this.lastSetActive == null || now - this.lastSetActive >= this.config.statusUpdateThresholdMs)) {
      this.sendStatusUpdate(false);
      this.lastSetActive = now;
    } else if (!isActive) {
      this.lastSetActive = null;
    }
  }

  /**
   * Sends an update with user activity status and current system idle time
   *
   * @emits {status} emitted at regular, definable intervals providing an update on user active status and idle time
   * @private
   */
  sendStatusUpdate(isSystemEvent = false) {
    this.emit('status', {
      userIsActive: this.isActive,
      idleTime: this.idleTime,
      isSystemEvent,
    });
  }
}


/***/ }),

/***/ "./src/main/Validator.js":
/*!*******************************!*\
  !*** ./src/main/Validator.js ***!
  \*******************************/
/*! exports provided: validateArgs, validateBoundsInfo, validateAppState, validateV0ConfigData, validateV1ConfigData, validateCertificateStore, validateAllowedProtocols */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "validateArgs", function() { return validateArgs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "validateBoundsInfo", function() { return validateBoundsInfo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "validateAppState", function() { return validateAppState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "validateV0ConfigData", function() { return validateV0ConfigData; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "validateV1ConfigData", function() { return validateV1ConfigData; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "validateCertificateStore", function() { return validateCertificateStore; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "validateAllowedProtocols", function() { return validateAllowedProtocols; });
/* harmony import */ var _hapi_joi__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hapi/joi */ "./src/node_modules/@hapi/joi/lib/index.js");
/* harmony import */ var _hapi_joi__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_hapi_joi__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _utils_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/util */ "./src/utils/util.js");
// Copyright (c) 2016-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.




const defaultOptions = {
  stripUnknown: true,
};
const defaultWindowWidth = 1000;
const defaultWindowHeight = 700;
const minWindowWidth = 400;
const minWindowHeight = 240;

const argsSchema = _hapi_joi__WEBPACK_IMPORTED_MODULE_0___default.a.object({
  hidden: _hapi_joi__WEBPACK_IMPORTED_MODULE_0___default.a.boolean(),
  'disable-dev-mode': _hapi_joi__WEBPACK_IMPORTED_MODULE_0___default.a.boolean(),
  disableDevMode: _hapi_joi__WEBPACK_IMPORTED_MODULE_0___default.a.boolean(),
  'data-dir': _hapi_joi__WEBPACK_IMPORTED_MODULE_0___default.a.string(),
  dataDir: _hapi_joi__WEBPACK_IMPORTED_MODULE_0___default.a.array().items(_hapi_joi__WEBPACK_IMPORTED_MODULE_0___default.a.string()),
  version: _hapi_joi__WEBPACK_IMPORTED_MODULE_0___default.a.boolean(),
});

const boundsInfoSchema = _hapi_joi__WEBPACK_IMPORTED_MODULE_0___default.a.object({
  x: _hapi_joi__WEBPACK_IMPORTED_MODULE_0___default.a.number().integer().default(0),
  y: _hapi_joi__WEBPACK_IMPORTED_MODULE_0___default.a.number().integer().default(0),
  width: _hapi_joi__WEBPACK_IMPORTED_MODULE_0___default.a.number().integer().min(minWindowWidth).required().default(defaultWindowWidth),
  height: _hapi_joi__WEBPACK_IMPORTED_MODULE_0___default.a.number().integer().min(minWindowHeight).required().default(defaultWindowHeight),
  maximized: _hapi_joi__WEBPACK_IMPORTED_MODULE_0___default.a.boolean().default(false),
  fullscreen: _hapi_joi__WEBPACK_IMPORTED_MODULE_0___default.a.boolean().default(false),
});

const appStateSchema = _hapi_joi__WEBPACK_IMPORTED_MODULE_0___default.a.object({
  lastAppVersion: _hapi_joi__WEBPACK_IMPORTED_MODULE_0___default.a.string(),
  skippedVersion: _hapi_joi__WEBPACK_IMPORTED_MODULE_0___default.a.string(),
  updateCheckedDate: _hapi_joi__WEBPACK_IMPORTED_MODULE_0___default.a.string(),
});

const configDataSchemaV0 = _hapi_joi__WEBPACK_IMPORTED_MODULE_0___default.a.object({
  url: _hapi_joi__WEBPACK_IMPORTED_MODULE_0___default.a.string().required(),
});

const configDataSchemaV1 = _hapi_joi__WEBPACK_IMPORTED_MODULE_0___default.a.object({
  version: _hapi_joi__WEBPACK_IMPORTED_MODULE_0___default.a.number().min(1).default(1),
  teams: _hapi_joi__WEBPACK_IMPORTED_MODULE_0___default.a.array().items(_hapi_joi__WEBPACK_IMPORTED_MODULE_0___default.a.object({
    name: _hapi_joi__WEBPACK_IMPORTED_MODULE_0___default.a.string().required(),
    url: _hapi_joi__WEBPACK_IMPORTED_MODULE_0___default.a.string().required(),
  })).default([]),
  showTrayIcon: _hapi_joi__WEBPACK_IMPORTED_MODULE_0___default.a.boolean().default(false),
  trayIconTheme: _hapi_joi__WEBPACK_IMPORTED_MODULE_0___default.a.any().allow('').valid('light', 'dark').default('light'),
  minimizeToTray: _hapi_joi__WEBPACK_IMPORTED_MODULE_0___default.a.boolean().default(false),
  notifications: _hapi_joi__WEBPACK_IMPORTED_MODULE_0___default.a.object({
    flashWindow: _hapi_joi__WEBPACK_IMPORTED_MODULE_0___default.a.any().valid(0, 2).default(0),
    bounceIcon: _hapi_joi__WEBPACK_IMPORTED_MODULE_0___default.a.boolean().default(false),
    bounceIconType: _hapi_joi__WEBPACK_IMPORTED_MODULE_0___default.a.any().allow('').valid('informational', 'critical').default('informational'),
  }),
  showUnreadBadge: _hapi_joi__WEBPACK_IMPORTED_MODULE_0___default.a.boolean().default(true),
  useSpellChecker: _hapi_joi__WEBPACK_IMPORTED_MODULE_0___default.a.boolean().default(true),
  enableHardwareAcceleration: _hapi_joi__WEBPACK_IMPORTED_MODULE_0___default.a.boolean().default(true),
  autostart: _hapi_joi__WEBPACK_IMPORTED_MODULE_0___default.a.boolean().default(true),
  spellCheckerLocale: _hapi_joi__WEBPACK_IMPORTED_MODULE_0___default.a.string().regex(/^[a-z]{2}-[A-Z]{2}$/).default('en-US'),
});

// eg. data['community.mattermost.com'] = { data: 'certificate data', issuerName: 'COMODO RSA Domain Validation Secure Server CA'};
const certificateStoreSchema = _hapi_joi__WEBPACK_IMPORTED_MODULE_0___default.a.object().pattern(
  _hapi_joi__WEBPACK_IMPORTED_MODULE_0___default.a.string().uri(),
  _hapi_joi__WEBPACK_IMPORTED_MODULE_0___default.a.object({
    data: _hapi_joi__WEBPACK_IMPORTED_MODULE_0___default.a.string(),
    issuerName: _hapi_joi__WEBPACK_IMPORTED_MODULE_0___default.a.string(),
  })
);

const allowedProtocolsSchema = _hapi_joi__WEBPACK_IMPORTED_MODULE_0___default.a.array().items(_hapi_joi__WEBPACK_IMPORTED_MODULE_0___default.a.string().regex(/^[a-z-]+:$/i));

// validate bounds_info.json
function validateArgs(data) {
  return validateAgainstSchema(data, argsSchema);
}

// validate bounds_info.json
function validateBoundsInfo(data) {
  return validateAgainstSchema(data, boundsInfoSchema);
}

// validate app_state.json
function validateAppState(data) {
  return validateAgainstSchema(data, appStateSchema);
}

// validate v.0 config.json
function validateV0ConfigData(data) {
  return validateAgainstSchema(data, configDataSchemaV0);
}

// validate v.1 config.json
function validateV1ConfigData(data) {
  if (Array.isArray(data.teams) && data.teams.length) {
    // first replace possible backslashes with forward slashes
    let teams = data.teams.map(({name, url}) => {
      let updatedURL = url;
      if (updatedURL.includes('\\')) {
        updatedURL = updatedURL.toLowerCase().replace(/\\/gi, '/');
      }
      return {name, url: updatedURL};
    });

    // next filter out urls that are still invalid so all is not lost
    teams = teams.filter(({url}) => _utils_util__WEBPACK_IMPORTED_MODULE_1__["default"].isValidURL(url));

    // replace original teams
    data.teams = teams;
  }
  return validateAgainstSchema(data, configDataSchemaV1);
}

// validate certificate.json
function validateCertificateStore(data) {
  return validateAgainstSchema(data, certificateStoreSchema);
}

// validate allowedProtocols.json
function validateAllowedProtocols(data) {
  return validateAgainstSchema(data, allowedProtocolsSchema);
}

function validateAgainstSchema(data, schema) {
  if (typeof data !== 'object' || !schema) {
    return false;
  }
  const {error, value} = _hapi_joi__WEBPACK_IMPORTED_MODULE_0___default.a.validate(data, schema, defaultOptions);
  if (error) {
    return false;
  }
  return value;
}


/***/ }),

/***/ "./src/main/allowProtocolDialog.js":
/*!*****************************************!*\
  !*** ./src/main/allowProtocolDialog.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! path */ "path");
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! fs */ "fs");
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! electron */ "electron");
/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(electron__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _Validator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Validator */ "./src/main/Validator.js");
// Copyright (c) 2015-2016 Yuya Ochiai
// Copyright (c) 2016-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.









const allowedProtocolFile = path__WEBPACK_IMPORTED_MODULE_0___default.a.resolve(electron__WEBPACK_IMPORTED_MODULE_2__["app"].getPath('userData'), 'allowedProtocols.json');
let allowedProtocols = [];

function init(mainWindow) {
  fs__WEBPACK_IMPORTED_MODULE_1___default.a.readFile(allowedProtocolFile, 'utf-8', (err, data) => {
    if (!err) {
      allowedProtocols = JSON.parse(data);
      allowedProtocols = _Validator__WEBPACK_IMPORTED_MODULE_3__["validateAllowedProtocols"](allowedProtocols) || [];
    }
    initDialogEvent(mainWindow);
  });
}

function initDialogEvent(mainWindow) {
  electron__WEBPACK_IMPORTED_MODULE_2__["ipcMain"].on('confirm-protocol', (event, protocol, URL) => {
    if (allowedProtocols.indexOf(protocol) !== -1) {
      electron__WEBPACK_IMPORTED_MODULE_2__["shell"].openExternal(URL);
      return;
    }
    electron__WEBPACK_IMPORTED_MODULE_2__["dialog"].showMessageBox(mainWindow, {
      title: 'Non http(s) protocol',
      message: `${protocol} link requires an external application.`,
      detail: `The requested link is ${URL} . Do you want to continue?`,
      type: 'warning',
      buttons: [
        'Yes',
        `Yes (Save ${protocol} as allowed)`,
        'No',
      ],
      cancelId: 2,
      noLink: true,
    }, (response) => {
      switch (response) {
      case 1: {
        allowedProtocols.push(protocol);
        function handleError(err) {
          if (err) {
            console.error(err);
          }
        }
        fs__WEBPACK_IMPORTED_MODULE_1___default.a.writeFile(allowedProtocolFile, JSON.stringify(allowedProtocols), handleError);
        electron__WEBPACK_IMPORTED_MODULE_2__["shell"].openExternal(URL);
        break;
      }
      case 0:
        electron__WEBPACK_IMPORTED_MODULE_2__["shell"].openExternal(URL);
        break;
      default:
        break;
      }
    });
  });
}

/* harmony default export */ __webpack_exports__["default"] = ({
  init,
});


/***/ }),

/***/ "./src/main/autoLaunch.js":
/*!********************************!*\
  !*** ./src/main/autoLaunch.js ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var auto_launch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! auto-launch */ "./src/node_modules/auto-launch/dist/index.js");
/* harmony import */ var auto_launch__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(auto_launch__WEBPACK_IMPORTED_MODULE_0__);
// Copyright (c) 2015-2016 Yuya Ochiai
// Copyright (c) 2016-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.


async function upgradeAutoLaunch() {
  if (process.platform === 'darwin') {
    return;
  }
  const appLauncher = new auto_launch__WEBPACK_IMPORTED_MODULE_0___default.a({
    name: 'Mattermost',
    isHidden: true,
  });
  const enabled = await appLauncher.isEnabled();
  if (enabled) {
    await appLauncher.enable();
  }
}

/* harmony default export */ __webpack_exports__["default"] = (upgradeAutoLaunch);


/***/ }),

/***/ "./src/main/certificateStore.js":
/*!**************************************!*\
  !*** ./src/main/certificateStore.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ "fs");
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! url */ "url");
/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(url__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _Validator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Validator */ "./src/main/Validator.js");
// Copyright (c) 2015-2016 Yuya Ochiai
// Copyright (c) 2016-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.







function comparableCertificate(certificate) {
  return {
    data: certificate.data.toString(),
    issuerName: certificate.issuerName,
  };
}

function areEqual(certificate0, certificate1) {
  if (certificate0.data !== certificate1.data) {
    return false;
  }
  if (certificate0.issuerName !== certificate1.issuerName) {
    return false;
  }
  return true;
}

function getHost(targetURL) {
  return url__WEBPACK_IMPORTED_MODULE_1___default.a.parse(targetURL).host;
}

function CertificateStore(storeFile) {
  this.storeFile = storeFile;
  let storeStr;
  try {
    storeStr = fs__WEBPACK_IMPORTED_MODULE_0___default.a.readFileSync(storeFile, 'utf-8');
    storeStr = _Validator__WEBPACK_IMPORTED_MODULE_2__["validateCertificateStore"](storeStr);
    if (!storeStr) {
      throw new Error('Provided certificate store file does not validate, using defaults instead.');
    }
  } catch (e) {
    storeStr = '{}';
  }
  try {
    this.data = JSON.parse(storeStr);
  } catch (e) {
    console.log('Error when parsing', storeFile, ':', e);
    this.data = {};
  }
}

CertificateStore.prototype.save = function save() {
  fs__WEBPACK_IMPORTED_MODULE_0___default.a.writeFileSync(this.storeFile, JSON.stringify(this.data, null, '  '));
};

CertificateStore.prototype.add = function add(targetURL, certificate) {
  this.data[getHost(targetURL)] = comparableCertificate(certificate);
};

CertificateStore.prototype.isExisting = function isExisting(targetURL) {
  return this.data.hasOwnProperty(getHost(targetURL));
};

CertificateStore.prototype.isTrusted = function isTrusted(targetURL, certificate) {
  const host = getHost(targetURL);
  if (!this.isExisting(targetURL)) {
    return false;
  }
  return areEqual(this.data[host], comparableCertificate(certificate));
};

/* harmony default export */ __webpack_exports__["default"] = ({
  load(storeFile) {
    return new CertificateStore(storeFile);
  },
});


/***/ }),

/***/ "./src/main/cookieManager.js":
/*!***********************************!*\
  !*** ./src/main/cookieManager.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return initCookieManager; });
/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! electron */ "electron");
/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(electron__WEBPACK_IMPORTED_MODULE_0__);
// Copyright (c) 2015-2016 Yuya Ochiai
// Copyright (c) 2016-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.


function flushCookiesStore(session) {
  session.cookies.flushStore((err) => {
    if (err) {
      console.log(err);
    }
  });
}

function initCookieManager(session) {
  // Somehow cookies are not immediately saved to disk.
  // So manually flush cookie store to disk on closing the app.
  // https://github.com/electron/electron/issues/8416
  electron__WEBPACK_IMPORTED_MODULE_0__["app"].on('before-quit', () => {
    flushCookiesStore(session);
  });

  electron__WEBPACK_IMPORTED_MODULE_0__["app"].on('browser-window-blur', () => {
    flushCookiesStore(session);
  });
}


/***/ }),

/***/ "./src/main/downloadURL.js":
/*!*********************************!*\
  !*** ./src/main/downloadURL.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return downloadURL; });
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ "fs");
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ "path");
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var zlib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zlib */ "zlib");
/* harmony import */ var zlib__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(zlib__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! electron */ "electron");
/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(electron__WEBPACK_IMPORTED_MODULE_3__);
// Copyright (c) 2015-2016 Yuya Ochiai
// Copyright (c) 2016-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.





const {app, dialog} = electron__WEBPACK_IMPORTED_MODULE_3___default.a;

function downloadURL(browserWindow, URL, callback) {
  const {net} = electron__WEBPACK_IMPORTED_MODULE_3___default.a;
  const request = net.request(URL);
  request.setHeader('Accept-Encoding', 'gzip,deflate');
  request.on('response', (response) => {
    const file = getAttachmentName(response.headers);
    const dialogOptions = {
      defaultPath: path__WEBPACK_IMPORTED_MODULE_1___default.a.join(app.getPath('downloads'), file),
    };
    dialog.showSaveDialog(browserWindow, dialogOptions, (filename) => {
      if (filename) {
        saveResponseBody(response, filename, callback);
      }
    });
  }).on('error', callback);
  request.end();
}

function getAttachmentName(headers) {
  if (headers['content-disposition']) {
    const contentDisposition = headers['content-disposition'][0];
    const matched = contentDisposition.match(/filename="(.*)"/);
    if (matched) {
      return path__WEBPACK_IMPORTED_MODULE_1___default.a.basename(matched[1]);
    }
  }
  return '';
}

function saveResponseBody(response, filename, callback) {
  const output = fs__WEBPACK_IMPORTED_MODULE_0___default.a.createWriteStream(filename);
  output.on('close', callback);
  switch (response.headers['content-encoding']) {
  case 'gzip':
    response.pipe(zlib__WEBPACK_IMPORTED_MODULE_2___default.a.createGunzip()).pipe(output).on('error', callback);
    break;
  case 'deflate':
    response.pipe(zlib__WEBPACK_IMPORTED_MODULE_2___default.a.createInflate()).pipe(output).on('error', callback);
    break;
  default:
    response.pipe(output).on('error', callback);
    break;
  }
}


/***/ }),

/***/ "./src/main/mainWindow.js":
/*!********************************!*\
  !*** ./src/main/mainWindow.js ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ "fs");
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ "path");
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! electron */ "electron");
/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(electron__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _Validator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Validator */ "./src/main/Validator.js");
// Copyright (c) 2015-2016 Yuya Ochiai
// Copyright (c) 2016-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.







function saveWindowState(file, window) {
  const windowState = window.getBounds();
  windowState.maximized = window.isMaximized();
  try {
    fs__WEBPACK_IMPORTED_MODULE_0___default.a.writeFileSync(file, JSON.stringify(windowState));
  } catch (e) {
    // [Linux] error happens only when the window state is changed before the config dir is created.
    console.log(e);
  }
}

function createMainWindow(config, options) {
  const defaultWindowWidth = 1000;
  const defaultWindowHeight = 700;
  const minimumWindowWidth = 400;
  const minimumWindowHeight = 240;

  // Create the browser window.
  const boundsInfoPath = path__WEBPACK_IMPORTED_MODULE_1___default.a.join(electron__WEBPACK_IMPORTED_MODULE_2__["app"].getPath('userData'), 'bounds-info.json');
  let windowOptions;
  try {
    windowOptions = JSON.parse(fs__WEBPACK_IMPORTED_MODULE_0___default.a.readFileSync(boundsInfoPath, 'utf-8'));
    windowOptions = _Validator__WEBPACK_IMPORTED_MODULE_3__["validateBoundsInfo"](windowOptions);
    if (!windowOptions) {
      throw new Error('Provided bounds info file does not validate, using defaults instead.');
    }
  } catch (e) {
    // Follow Electron's defaults, except for window dimensions which targets 1024x768 screen resolution.
    windowOptions = {width: defaultWindowWidth, height: defaultWindowHeight};
  }

  const {hideOnStartup, trayIconShown} = options;
  const {maximized: windowIsMaximized} = windowOptions;

  if (process.platform === 'linux') {
    windowOptions.icon = options.linuxAppIcon;
  }
  Object.assign(windowOptions, {
    title: electron__WEBPACK_IMPORTED_MODULE_2__["app"].getName(),
    fullscreenable: true,
    show: hideOnStartup || false,
    minWidth: minimumWindowWidth,
    minHeight: minimumWindowHeight,
    fullscreen: false,
    backgroundColor: '#fff', // prevents blurry text: https://electronjs.org/docs/faq#the-font-looks-blurry-what-is-this-and-what-can-i-do
    webPreferences: {
      nodeIntegration: true,
      contextIsolation: false,
      webviewTag: true,
      disableBlinkFeatures: 'Auxclick',
    },
  });

  const mainWindow = new electron__WEBPACK_IMPORTED_MODULE_2__["BrowserWindow"](windowOptions);
  mainWindow.deeplinkingUrl = options.deeplinkingUrl;

  const indexURL = global.isDev ? 'http://localhost:8080/browser/index.html' : `file://${electron__WEBPACK_IMPORTED_MODULE_2__["app"].getAppPath()}/browser/index.html`;
  mainWindow.loadURL(indexURL);

  // handle hiding the app when launched by auto-start
  if (hideOnStartup) {
    if (trayIconShown && process.platform !== 'darwin') {
      mainWindow.hide();
    } else {
      mainWindow.minimize();
    }
  }

  mainWindow.once('ready-to-show', () => {
    mainWindow.webContents.setZoomLevel(0);

    // handle showing the window when not launched by auto-start
    // - when not configured to auto-start, immediately show contents and optionally maximize as needed
    if (!hideOnStartup) {
      mainWindow.show();
      if (windowIsMaximized) {
        mainWindow.maximize();
      }
    }
  });

  mainWindow.once('show', () => {
    // handle showing the app when hidden to the tray icon by auto-start
    // - optionally maximize the window as needed
    if (hideOnStartup && windowIsMaximized) {
      mainWindow.maximize();
    }
  });

  mainWindow.once('restore', () => {
    // handle restoring the window when minimized to the app icon by auto-start
    // - optionally maximize the window as needed
    if (hideOnStartup && windowIsMaximized) {
      mainWindow.maximize();
    }
  });

  mainWindow.webContents.on('will-attach-webview', (event, webPreferences) => {
    webPreferences.nodeIntegration = false;
    webPreferences.contextIsolation = true;
  });

  // App should save bounds when a window is closed.
  // However, 'close' is not fired in some situations(shutdown, ctrl+c)
  // because main process is killed in such situations.
  // 'blur' event was effective in order to avoid this.
  // Ideally, app should detect that OS is shutting down.
  mainWindow.on('blur', () => {
    saveWindowState(boundsInfoPath, mainWindow);
    mainWindow.blurWebView();
  });

  mainWindow.on('close', (event) => {
    if (global.willAppQuit) { // when [Ctrl|Cmd]+Q
      saveWindowState(boundsInfoPath, mainWindow);
    } else { // Minimize or hide the window for close button.
      event.preventDefault();
      function hideWindow(window) {
        window.blur(); // To move focus to the next top-level window in Windows
        window.hide();
      }
      switch (process.platform) {
      case 'win32':
        hideWindow(mainWindow);
        break;
      case 'linux':
        if (config.minimizeToTray) {
          hideWindow(mainWindow);
        } else {
          mainWindow.minimize();
        }
        break;
      case 'darwin':
        // need to leave fullscreen first, then hide the window
        if (mainWindow.isFullScreen()) {
          mainWindow.once('leave-full-screen', () => {
            hideWindow(mainWindow);
          });
          mainWindow.setFullScreen(false);
        } else {
          hideWindow(mainWindow);
        }
        break;
      default:
      }
    }
  });

  mainWindow.on('sheet-end', () => {
    mainWindow.webContents.send('focus-on-webview');
  });

  // Register keyboard shortcuts
  mainWindow.webContents.on('before-input-event', (event, input) => {
    // Add Alt+Cmd+(Right|Left) as alternative to switch between servers
    if (process.platform === 'darwin') {
      if (input.alt && input.meta) {
        if (input.key === 'ArrowRight') {
          mainWindow.webContents.send('select-next-tab');
        }
        if (input.key === 'ArrowLeft') {
          mainWindow.webContents.send('select-previous-tab');
        }
      }
    }
  });

  return mainWindow;
}

/* harmony default export */ __webpack_exports__["default"] = (createMainWindow);


/***/ }),

/***/ "./src/main/menus/app.js":
/*!*******************************!*\
  !*** ./src/main/menus/app.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! electron */ "electron");
/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(electron__WEBPACK_IMPORTED_MODULE_0__);
// Copyright (c) 2015-2016 Yuya Ochiai
// Copyright (c) 2016-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.




function createTemplate(mainWindow, config, isDev) {
  const settingsURL = isDev ? 'http://localhost:8080/browser/settings.html' : `file://${electron__WEBPACK_IMPORTED_MODULE_0__["app"].getAppPath()}/browser/settings.html`;

  const separatorItem = {
    type: 'separator',
  };

  const appName = electron__WEBPACK_IMPORTED_MODULE_0__["app"].getName();
  const firstMenuName = (process.platform === 'darwin') ? appName : 'File';
  const template = [];

  let platformAppMenu = process.platform === 'darwin' ? [{
    label: 'About ' + appName,
    role: 'about',
    click() {
      electron__WEBPACK_IMPORTED_MODULE_0__["dialog"].showMessageBox(mainWindow, {
        buttons: ['OK'],
        message: `${appName} Desktop ${electron__WEBPACK_IMPORTED_MODULE_0__["app"].getVersion()}`,
      });
    },
  }, separatorItem, {
    label: 'Preferences...',
    accelerator: 'CmdOrCtrl+,',
    click() {
      mainWindow.loadURL(settingsURL);
    },
  }] : [{
    label: 'Settings...',
    accelerator: 'CmdOrCtrl+,',
    click() {
      mainWindow.loadURL(settingsURL);
    },
  }];

  if (config.enableServerManagement === true) {
    platformAppMenu.push({
      label: 'Sign in to Another Server',
      click() {
        mainWindow.webContents.send('add-server');
      },
    });
  }

  platformAppMenu = platformAppMenu.concat(process.platform === 'darwin' ? [
    separatorItem, {
      role: 'hide',
    }, {
      role: 'hideothers',
    }, {
      role: 'unhide',
    }, separatorItem, {
      role: 'quit',
    }] : [
    separatorItem, {
      role: 'quit',
      accelerator: 'CmdOrCtrl+Q',
      click() {
        electron__WEBPACK_IMPORTED_MODULE_0__["app"].quit();
      },
    }]
  );

  template.push({
    label: '&' + firstMenuName,
    submenu: [
      ...platformAppMenu,
    ],
  });
  template.push({
    label: '&编辑',
    submenu: [{
      label: '撤回',
      accelerator: 'CmdOrCtrl+Z',
      click() {
        mainWindow.webContents.send('undo');
      },
    }, {
      label: '撤回',
      accelerator: 'CmdOrCtrl+SHIFT+Z',
      click() {
        mainWindow.webContents.send('redo');
      },
    }, separatorItem, {
      label: '剪切',
      accelerator: 'CmdOrCtrl+X',
      click() {
        mainWindow.webContents.send('cut');
      },
    }, {
      label: '复制',
      accelerator: 'CmdOrCtrl+C',
      click() {
        mainWindow.webContents.send('copy');
      },
    }, {
      label: '粘贴',
      accelerator: 'CmdOrCtrl+V',
      click() {
        mainWindow.webContents.send('paste');
      },
    }, {
      label: '粘贴并匹配',
      accelerator: 'CmdOrCtrl+SHIFT+V',
      visible: process.platform === 'darwin',
      click() {
        mainWindow.webContents.send('paste-and-match');
      },
    }, {
      role: 'selectall',
    }],
  });
  template.push({
    label: '&浏览',
    submenu: [{
      label: '查找..',
      accelerator: 'CmdOrCtrl+F',
      click(item, focusedWindow) {
        focusedWindow.webContents.send('toggle-find');
      },
    }, {
      label: '刷新',
      accelerator: 'CmdOrCtrl+R',
      click(item, focusedWindow) {
        if (focusedWindow) {
          if (focusedWindow === mainWindow) {
            mainWindow.webContents.send('reload-tab');
          } else {
            focusedWindow.reload();
          }
        }
      },
    }, {
      label: '清除缓存',
      accelerator: 'Shift+CmdOrCtrl+R',
      click(item, focusedWindow) {
        if (focusedWindow) {
          if (focusedWindow === mainWindow) {
            mainWindow.webContents.send('clear-cache-and-reload-tab');
          } else {
            focusedWindow.webContents.session.clearCache(() => {
              focusedWindow.reload();
            });
          }
        }
      },
    }, {
      role: 'togglefullscreen',
    }, separatorItem, {
      label: '实际大小',
      accelerator: 'CmdOrCtrl+0',
      click() {
        mainWindow.webContents.send('zoom-reset');
      },
    }, {
      label: '缩小',
      accelerator: 'CmdOrCtrl+SHIFT+=',
      click() {
        mainWindow.webContents.send('zoom-in');
      },
    }, {
      label: '放大',
      accelerator: 'CmdOrCtrl+-',
      click() {
        mainWindow.webContents.send('zoom-out');
      },
    }, separatorItem, {
      label: '应用开发者工具',
      accelerator: (() => {
        if (process.platform === 'darwin') {
          return 'Alt+Command+I';
        }
        return 'Ctrl+Shift+I';
      })(),
      click(item, focusedWindow) {
        if (focusedWindow) {
          focusedWindow.toggleDevTools();
        }
      },
    }, {
      label: '服务器开发者工具',
      click() {
        mainWindow.webContents.send('open-devtool');
      },
    }],
  });
  template.push({
    label: '&历史',
    submenu: [{
      label: '后退',
      accelerator: process.platform === 'darwin' ? 'Cmd+[' : 'Alt+Left',
      click: (item, focusedWindow) => {
        if (focusedWindow === mainWindow) {
          mainWindow.webContents.send('go-back');
        } else if (focusedWindow.webContents.canGoBack()) {
          focusedWindow.goBack();
        }
      },
    }, {
      label: '前进',
      accelerator: process.platform === 'darwin' ? 'Cmd+]' : 'Alt+Right',
      click: (item, focusedWindow) => {
        if (focusedWindow === mainWindow) {
          mainWindow.webContents.send('go-forward');
        } else if (focusedWindow.webContents.canGoForward()) {
          focusedWindow.goForward();
        }
      },
    }],
  });

  const teams = config.teams;
  const windowMenu = {
    label: '&窗口',
    submenu: [{
      role: 'minimize',

      // empty string removes shortcut on Windows; null will default by OS
      accelerator: process.platform === 'win32' ? '' : null,
    }, {
      role: '关闭',
    }, separatorItem, ...teams.slice(0, 9).map((team, i) => {
      return {
        label: team.name,
        accelerator: `CmdOrCtrl+${i + 1}`,
        click() {
          mainWindow.show(); // for OS X
          mainWindow.webContents.send('switch-tab', i);
        },
      };
    }), separatorItem, {
      label: '选择下一个服务器',
      accelerator: 'Ctrl+Tab',
      click() {
        mainWindow.webContents.send('select-next-tab');
      },
      enabled: (teams.length > 1),
    }, {
      label: '选择上一个服务器',
      accelerator: 'Ctrl+Shift+Tab',
      click() {
        mainWindow.webContents.send('select-previous-tab');
      },
      enabled: (teams.length > 1),
    }],
  };
  template.push(windowMenu);
  const submenu = [];
  if (config.helpLink) {
    submenu.push({
      label: '详情...',
      click() {
        electron__WEBPACK_IMPORTED_MODULE_0__["shell"].openExternal(config.helpLink);
      },
    });
    submenu.push(separatorItem);
  }
  submenu.push({
    label: `版本 ${electron__WEBPACK_IMPORTED_MODULE_0__["app"].getVersion()}`,
    enabled: false,
  });

  template.push({label: '帮助', submenu});
  return template;
}

function createMenu(mainWindow, config, isDev) {
  return electron__WEBPACK_IMPORTED_MODULE_0__["Menu"].buildFromTemplate(createTemplate(mainWindow, config, isDev));
}

/* harmony default export */ __webpack_exports__["default"] = ({
  createMenu,
});


/***/ }),

/***/ "./src/main/menus/tray.js":
/*!********************************!*\
  !*** ./src/main/menus/tray.js ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! electron */ "electron");
/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(electron__WEBPACK_IMPORTED_MODULE_0__);
// Copyright (c) 2015-2016 Yuya Ochiai
// Copyright (c) 2016-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.




function createTemplate(mainWindow, config, isDev) {
  const settingsURL = isDev ? 'http://localhost:8080/browser/settings.html' : `file://${electron__WEBPACK_IMPORTED_MODULE_0__["app"].getAppPath()}/browser/settings.html`;
  const teams = config.teams;
  const template = [
    ...teams.slice(0, 9).map((team, i) => {
      return {
        label: team.name,
        click: () => {
          showOrRestore(mainWindow);
          mainWindow.webContents.send('switch-tab', i);

          if (process.platform === 'darwin') {
            electron__WEBPACK_IMPORTED_MODULE_0__["app"].dock.show();
            mainWindow.focus();
          }
        },
      };
    }), {
      type: 'separator',
    }, {
      label: process.platform === 'darwin' ? 'Preferences...' : 'Settings',
      click: () => {
        mainWindow.loadURL(settingsURL);
        showOrRestore(mainWindow);

        if (process.platform === 'darwin') {
          electron__WEBPACK_IMPORTED_MODULE_0__["app"].dock.show();
          mainWindow.focus();
        }
      },
    }, {
      type: 'separator',
    }, {
      role: 'quit',
    },
  ];
  return template;
}

function createMenu(mainWindow, config, isDev) {
  return electron__WEBPACK_IMPORTED_MODULE_0__["Menu"].buildFromTemplate(createTemplate(mainWindow, config, isDev));
}

function showOrRestore(window) {
  if (window.isMinimized()) {
    window.restore();
  } else {
    window.show();
  }
}

/* harmony default export */ __webpack_exports__["default"] = ({
  createMenu,
});


/***/ }),

/***/ "./src/main/utils.js":
/*!***************************!*\
  !*** ./src/main/utils.js ***!
  \***************************/
/*! exports provided: shouldBeHiddenOnStartup */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "shouldBeHiddenOnStartup", function() { return shouldBeHiddenOnStartup; });
/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! electron */ "electron");
/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(electron__WEBPACK_IMPORTED_MODULE_0__);
// Copyright (c) 2015-2016 Yuya Ochiai
// Copyright (c) 2016-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.



function shouldBeHiddenOnStartup(parsedArgv) {
  if (parsedArgv.hidden) {
    return true;
  }
  if (process.platform === 'darwin') {
    if (electron__WEBPACK_IMPORTED_MODULE_0__["app"].getLoginItemSettings().wasOpenedAsHidden) {
      return true;
    }
  }
  return false;
}


/***/ }),

/***/ "./src/node_modules/7zip/index.js":
/*!****************************************!*\
  !*** ./src/node_modules/7zip/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(__dirname) {var resolve = __webpack_require__(/*! path */ "path").resolve
var bin = __webpack_require__(/*! ./package */ "./src/node_modules/7zip/package.json").bin

module.exports = map_obj(bin, function(v){
  return resolve(__dirname, v)
})

function map_obj(obj, fn){
  return Object.keys(obj).reduce(function(m, k){
    m[k] = fn(obj[k])
    return m
  }, {})
}

/* WEBPACK VAR INJECTION */}.call(this, "src/node_modules/7zip"))

/***/ }),

/***/ "./src/node_modules/7zip/package.json":
/*!********************************************!*\
  !*** ./src/node_modules/7zip/package.json ***!
  \********************************************/
/*! exports provided: _args, _from, _id, _inBundle, _integrity, _location, _phantomChildren, _requested, _requiredBy, _resolved, _spec, _where, bin, bugs, description, homepage, keywords, license, main, name, repository, scripts, version, default */
/***/ (function(module) {

module.exports = {"_args":[["7zip@0.0.6","/Users/justinjia/work/desktop/src"]],"_from":"7zip@0.0.6","_id":"7zip@0.0.6","_inBundle":false,"_integrity":"sha1-nK+xca+CMpSQNTtIFvAzR6oVCjA=","_location":"/7zip","_phantomChildren":{},"_requested":{"type":"version","registry":true,"raw":"7zip@0.0.6","name":"7zip","escapedName":"7zip","rawSpec":"0.0.6","saveSpec":null,"fetchSpec":"0.0.6"},"_requiredBy":["/electron-devtools-installer"],"_resolved":"https://registry.npmjs.org/7zip/-/7zip-0.0.6.tgz","_spec":"0.0.6","_where":"/Users/justinjia/work/desktop/src","bin":{"7z":"7zip-lite/7z.exe"},"bugs":{"url":"https://github.com/fritx/win-7zip/issues"},"description":"7zip Windows Package via Node.js","homepage":"https://github.com/fritx/win-7zip#readme","keywords":["7z","7zip","7-zip","windows","install"],"license":"GNU LGPL","main":"index.js","name":"7zip","repository":{"type":"git","url":"git+ssh://git@github.com/fritx/win-7zip.git"},"scripts":{"test":"mocha"},"version":"0.0.6"};

/***/ }),

/***/ "./src/node_modules/@hapi/address/lib/abnf.js":
/*!****************************************************!*\
  !*** ./src/node_modules/@hapi/address/lib/abnf.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const internals = {};


/*
    From RFC 5321:

        Mailbox         =   Local-part "@" ( Domain / address-literal )

        Local-part      =   Dot-string / Quoted-string
        Dot-string      =   Atom *("."  Atom)
        Atom            =   1*atext
        atext           =   ALPHA / DIGIT / "!" / "#" / "$" / "%" / "&" / "'" / "*" / "+" / "-" / "/" / "=" / "?" / "^" / "_" / "`" / "{" / "|" / "}" / "~"

        Domain          =   sub-domain *("." sub-domain)
        sub-domain      =   Let-dig [Ldh-str]
        Let-dig         =   ALPHA / DIGIT
        Ldh-str         =   *( ALPHA / DIGIT / "-" ) Let-dig

        ALPHA           =   %x41-5A / %x61-7A        ; a-z, A-Z
        DIGIT           =   %x30-39                  ; 0-9

    From RFC 6531:

        sub-domain      =/  U-label
        atext           =/  UTF8-non-ascii

        UTF8-non-ascii  =   UTF8-2 / UTF8-3 / UTF8-4

        UTF8-2          =   %xC2-DF UTF8-tail
        UTF8-3          =   %xE0 %xA0-BF UTF8-tail /
                            %xE1-EC 2( UTF8-tail ) /
                            %xED %x80-9F UTF8-tail /
                            %xEE-EF 2( UTF8-tail )
        UTF8-4          =   %xF0 %x90-BF 2( UTF8-tail ) /
                            %xF1-F3 3( UTF8-tail ) /
                            %xF4 %x80-8F 2( UTF8-tail )

        UTF8-tail       =   %x80-BF

    Note: The following are not supported:

        RFC 5321: address-literal, Quoted-string
        RFC 5322: obs-*, CFWS
*/


internals.atext = '[\\w!#\\$%&\'\\*\\+\\-/=\\?\\^`\\{\\|\\}~]';                 // _ included in \w


exports.atextRx = new RegExp(`^${internals.atext}+$`);


exports.atomRx = new RegExp([

    internals.atext,

    //  %xC2-DF UTF8-tail
    '(?:[\\xc2-\\xdf][\\x80-\\xbf])',

    //  %xE0 %xA0-BF UTF8-tail              %xE1-EC 2( UTF8-tail )            %xED %x80-9F UTF8-tail              %xEE-EF 2( UTF8-tail )
    '(?:\\xe0[\\xa0-\\xbf][\\x80-\\xbf])|(?:[\\xe1-\\xec][\\x80-\\xbf]{2})|(?:\\xed[\\x80-\\x9f][\\x80-\\xbf])|(?:[\\xee-\\xef][\\x80-\\xbf]{2})',

    //  %xF0 %x90-BF 2( UTF8-tail )            %xF1-F3 3( UTF8-tail )            %xF4 %x80-8F 2( UTF8-tail )
    '(?:\\xf0[\\x90-\\xbf][\\x80-\\xbf]{2})|(?:[\\xf1-\\xf3][\\x80-\\xbf]{3})|(?:\\xf4[\\x80-\\x8f][\\x80-\\xbf]{2})'

].join('|'));


/***/ }),

/***/ "./src/node_modules/@hapi/address/lib/index.js":
/*!*****************************************************!*\
  !*** ./src/node_modules/@hapi/address/lib/index.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Punycode = __webpack_require__(/*! punycode */ "punycode");

const Abnf = __webpack_require__(/*! ./abnf */ "./src/node_modules/@hapi/address/lib/abnf.js");
const Tlds = __webpack_require__(/*! ./tlds */ "./src/node_modules/@hapi/address/lib/tlds.js");


const internals = {
    nonAsciiRx: /[^\x00-\x7f]/,
    minDomainSegments: 2,
    defaultTlds: { allow: Tlds, deny: null }
};


module.exports = {
    email: {
        analyze: function (email, options) {

            return internals.email(email, options);
        },
        isValid: function (email, options) {

            return !internals.email(email, options);
        }
    },
    domain: {
        analyze: function (domain, options = {}) {

            internals.options(domain, options);

            if (!domain) {
                return internals.error('Domain must be a non-empty string');
            }

            if (domain.length > 256) {
                return internals.error('Domain too long');
            }

            const ascii = !internals.nonAsciiRx.test(domain);
            if (!ascii) {
                if (options.allowUnicode === false) {                                           // Defaults to true
                    return internals.error('Domain contains forbidden Unicode characters');
                }

                const normalized = domain.normalize('NFC');
                domain = Punycode.toASCII(normalized);
            }

            return internals.domain(domain, options);
        },
        isValid: function (domain, options) {

            return !module.exports.domain.analyze(domain, options);
        }
    }
};


internals.email = function (email, options = {}) {

    internals.options(email, options);

    if (!email) {
        return internals.error('Address must be a non-empty string');
    }

    // Unicode

    const ascii = !internals.nonAsciiRx.test(email);
    if (!ascii) {
        if (options.allowUnicode === false) {                                                   // Defaults to true
            return internals.error('Address contains forbidden Unicode characters');
        }

        const normalized = email.normalize('NFC');
        email = Punycode.toASCII(normalized);
    }

    // Basic structure

    const parts = email.split('@');
    if (parts.length !== 2) {
        return internals.error(parts.length > 2 ? 'Address cannot contain more than one @ character' : 'Address must contain one @ character');
    }

    const local = parts[0];
    const domain = parts[1];

    if (!local) {
        return internals.error('Address local part cannot be empty');
    }

    if (!domain) {
        return internals.error('Domain cannot be empty');
    }

    if (email.length > 254) {                                                   // http://tools.ietf.org/html/rfc5321#section-4.5.3.1.3
        return internals.error('Address too long');
    }

    if (Buffer.byteLength(local, 'utf-8') > 64) {                               // http://tools.ietf.org/html/rfc5321#section-4.5.3.1.1
        return internals.error('Address local part too long');
    }

    // Validate parts

    return internals.local(local, ascii) || internals.domain(domain, options);
};


internals.options = function (value, options) {

    // Options validation

    if (options.tlds &&
        options.tlds !== true) {

        if (typeof options.tlds !== 'object') {
            throw new Error('Invalid options: tlds must be a boolean or an object');
        }

        if (options.tlds.allow !== undefined &&
            options.tlds.allow !== true &&
            options.tlds.allow instanceof Set === false) {

            throw new Error('Invalid options: tlds.allow must be a Set object or true');
        }

        if (options.tlds.deny) {
            if (options.tlds.deny instanceof Set === false) {
                throw new Error('Invalid options: tlds.deny must be a Set object');
            }

            if (options.tlds.allow instanceof Set) {
                throw new Error('Invalid options: cannot specify both tlds.allow and tlds.deny lists');
            }
        }
    }

    // Input validation

    if (typeof value !== 'string') {
        throw new Error('Invalid input: value must be a string');
    }
};


internals.local = function (local, ascii) {

    const segments = local.split('.');
    for (const segment of segments) {
        if (!segment.length) {
            return internals.error('Address local part contains empty dot-separated segment');
        }

        if (ascii) {
            if (!Abnf.atextRx.test(segment)) {
                return internals.error('Address local part contains invalid character');
            }
        }
        else {
            for (const char of segment) {
                const binary = Buffer.from(char).toString('binary');
                if (!Abnf.atomRx.test(binary)) {
                    return internals.error('Address local part contains invalid character');
                }
            }
        }
    }
};


internals.tldSegmentRx = /^[a-zA-Z](?:[a-zA-Z0-9\-]*[a-zA-Z0-9])?$/;


internals.domainSegmentRx = /^[a-zA-Z0-9](?:[a-zA-Z0-9\-]*[a-zA-Z0-9])?$/;


internals.domain = function (domain, options) {

    // https://tools.ietf.org/html/rfc1035 section 2.3.1

    const minDomainSegments = (options.minDomainSegments || internals.minDomainSegments);

    const segments = domain.split('.');
    if (segments.length < minDomainSegments) {
        return internals.error('Domain lacks the minimum required number of segments');
    }

    const tlds = internals.tlds(options);
    if (tlds) {
        const tld = segments[segments.length - 1].toLowerCase();
        if (tlds.deny && tlds.deny.has(tld) ||
            tlds.allow && !tlds.allow.has(tld)) {

            return internals.error('Domain uses forbidden TLD');
        }
    }

    for (let i = 0; i < segments.length; ++i) {
        const segment = segments[i];

        if (!segment.length) {
            return internals.error('Domain contains empty dot-separated segment');
        }

        if (segment.length > 63) {
            return internals.error('Domain contains dot-separated segment that is too long');
        }

        if (i < segments.length - 1) {
            if (!internals.domainSegmentRx.test(segment)) {
                return internals.error('Domain contains invalid character');
            }
        }
        else {
            if (!internals.tldSegmentRx.test(segment)) {
                return internals.error('Domain contains invalid tld character');
            }
        }
    }
};


internals.tlds = function (options) {

    if (options.tlds === false) {                // Defaults to true
        return null;
    }

    if (!options.tlds ||
        options.tlds === true) {

        return internals.defaultTlds;
    }

    return {
        allow: options.tlds.allow === true ? null : options.tlds.allow || Tlds,
        deny: options.tlds.deny || null
    };
};


internals.error = function (reason) {

    return { error: reason };
};


/***/ }),

/***/ "./src/node_modules/@hapi/address/lib/tlds.js":
/*!****************************************************!*\
  !*** ./src/node_modules/@hapi/address/lib/tlds.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const internals = {};


// http://data.iana.org/TLD/tlds-alpha-by-domain.txt
// # Version 2019032300, Last Updated Sat Mar 23 07:07:02 2019 UTC


internals.tlds = [
    'AAA',
    'AARP',
    'ABARTH',
    'ABB',
    'ABBOTT',
    'ABBVIE',
    'ABC',
    'ABLE',
    'ABOGADO',
    'ABUDHABI',
    'AC',
    'ACADEMY',
    'ACCENTURE',
    'ACCOUNTANT',
    'ACCOUNTANTS',
    'ACO',
    'ACTOR',
    'AD',
    'ADAC',
    'ADS',
    'ADULT',
    'AE',
    'AEG',
    'AERO',
    'AETNA',
    'AF',
    'AFAMILYCOMPANY',
    'AFL',
    'AFRICA',
    'AG',
    'AGAKHAN',
    'AGENCY',
    'AI',
    'AIG',
    'AIGO',
    'AIRBUS',
    'AIRFORCE',
    'AIRTEL',
    'AKDN',
    'AL',
    'ALFAROMEO',
    'ALIBABA',
    'ALIPAY',
    'ALLFINANZ',
    'ALLSTATE',
    'ALLY',
    'ALSACE',
    'ALSTOM',
    'AM',
    'AMERICANEXPRESS',
    'AMERICANFAMILY',
    'AMEX',
    'AMFAM',
    'AMICA',
    'AMSTERDAM',
    'ANALYTICS',
    'ANDROID',
    'ANQUAN',
    'ANZ',
    'AO',
    'AOL',
    'APARTMENTS',
    'APP',
    'APPLE',
    'AQ',
    'AQUARELLE',
    'AR',
    'ARAB',
    'ARAMCO',
    'ARCHI',
    'ARMY',
    'ARPA',
    'ART',
    'ARTE',
    'AS',
    'ASDA',
    'ASIA',
    'ASSOCIATES',
    'AT',
    'ATHLETA',
    'ATTORNEY',
    'AU',
    'AUCTION',
    'AUDI',
    'AUDIBLE',
    'AUDIO',
    'AUSPOST',
    'AUTHOR',
    'AUTO',
    'AUTOS',
    'AVIANCA',
    'AW',
    'AWS',
    'AX',
    'AXA',
    'AZ',
    'AZURE',
    'BA',
    'BABY',
    'BAIDU',
    'BANAMEX',
    'BANANAREPUBLIC',
    'BAND',
    'BANK',
    'BAR',
    'BARCELONA',
    'BARCLAYCARD',
    'BARCLAYS',
    'BAREFOOT',
    'BARGAINS',
    'BASEBALL',
    'BASKETBALL',
    'BAUHAUS',
    'BAYERN',
    'BB',
    'BBC',
    'BBT',
    'BBVA',
    'BCG',
    'BCN',
    'BD',
    'BE',
    'BEATS',
    'BEAUTY',
    'BEER',
    'BENTLEY',
    'BERLIN',
    'BEST',
    'BESTBUY',
    'BET',
    'BF',
    'BG',
    'BH',
    'BHARTI',
    'BI',
    'BIBLE',
    'BID',
    'BIKE',
    'BING',
    'BINGO',
    'BIO',
    'BIZ',
    'BJ',
    'BLACK',
    'BLACKFRIDAY',
    'BLOCKBUSTER',
    'BLOG',
    'BLOOMBERG',
    'BLUE',
    'BM',
    'BMS',
    'BMW',
    'BN',
    'BNL',
    'BNPPARIBAS',
    'BO',
    'BOATS',
    'BOEHRINGER',
    'BOFA',
    'BOM',
    'BOND',
    'BOO',
    'BOOK',
    'BOOKING',
    'BOSCH',
    'BOSTIK',
    'BOSTON',
    'BOT',
    'BOUTIQUE',
    'BOX',
    'BR',
    'BRADESCO',
    'BRIDGESTONE',
    'BROADWAY',
    'BROKER',
    'BROTHER',
    'BRUSSELS',
    'BS',
    'BT',
    'BUDAPEST',
    'BUGATTI',
    'BUILD',
    'BUILDERS',
    'BUSINESS',
    'BUY',
    'BUZZ',
    'BV',
    'BW',
    'BY',
    'BZ',
    'BZH',
    'CA',
    'CAB',
    'CAFE',
    'CAL',
    'CALL',
    'CALVINKLEIN',
    'CAM',
    'CAMERA',
    'CAMP',
    'CANCERRESEARCH',
    'CANON',
    'CAPETOWN',
    'CAPITAL',
    'CAPITALONE',
    'CAR',
    'CARAVAN',
    'CARDS',
    'CARE',
    'CAREER',
    'CAREERS',
    'CARS',
    'CARTIER',
    'CASA',
    'CASE',
    'CASEIH',
    'CASH',
    'CASINO',
    'CAT',
    'CATERING',
    'CATHOLIC',
    'CBA',
    'CBN',
    'CBRE',
    'CBS',
    'CC',
    'CD',
    'CEB',
    'CENTER',
    'CEO',
    'CERN',
    'CF',
    'CFA',
    'CFD',
    'CG',
    'CH',
    'CHANEL',
    'CHANNEL',
    'CHARITY',
    'CHASE',
    'CHAT',
    'CHEAP',
    'CHINTAI',
    'CHRISTMAS',
    'CHROME',
    'CHRYSLER',
    'CHURCH',
    'CI',
    'CIPRIANI',
    'CIRCLE',
    'CISCO',
    'CITADEL',
    'CITI',
    'CITIC',
    'CITY',
    'CITYEATS',
    'CK',
    'CL',
    'CLAIMS',
    'CLEANING',
    'CLICK',
    'CLINIC',
    'CLINIQUE',
    'CLOTHING',
    'CLOUD',
    'CLUB',
    'CLUBMED',
    'CM',
    'CN',
    'CO',
    'COACH',
    'CODES',
    'COFFEE',
    'COLLEGE',
    'COLOGNE',
    'COM',
    'COMCAST',
    'COMMBANK',
    'COMMUNITY',
    'COMPANY',
    'COMPARE',
    'COMPUTER',
    'COMSEC',
    'CONDOS',
    'CONSTRUCTION',
    'CONSULTING',
    'CONTACT',
    'CONTRACTORS',
    'COOKING',
    'COOKINGCHANNEL',
    'COOL',
    'COOP',
    'CORSICA',
    'COUNTRY',
    'COUPON',
    'COUPONS',
    'COURSES',
    'CR',
    'CREDIT',
    'CREDITCARD',
    'CREDITUNION',
    'CRICKET',
    'CROWN',
    'CRS',
    'CRUISE',
    'CRUISES',
    'CSC',
    'CU',
    'CUISINELLA',
    'CV',
    'CW',
    'CX',
    'CY',
    'CYMRU',
    'CYOU',
    'CZ',
    'DABUR',
    'DAD',
    'DANCE',
    'DATA',
    'DATE',
    'DATING',
    'DATSUN',
    'DAY',
    'DCLK',
    'DDS',
    'DE',
    'DEAL',
    'DEALER',
    'DEALS',
    'DEGREE',
    'DELIVERY',
    'DELL',
    'DELOITTE',
    'DELTA',
    'DEMOCRAT',
    'DENTAL',
    'DENTIST',
    'DESI',
    'DESIGN',
    'DEV',
    'DHL',
    'DIAMONDS',
    'DIET',
    'DIGITAL',
    'DIRECT',
    'DIRECTORY',
    'DISCOUNT',
    'DISCOVER',
    'DISH',
    'DIY',
    'DJ',
    'DK',
    'DM',
    'DNP',
    'DO',
    'DOCS',
    'DOCTOR',
    'DODGE',
    'DOG',
    'DOHA',
    'DOMAINS',
    'DOT',
    'DOWNLOAD',
    'DRIVE',
    'DTV',
    'DUBAI',
    'DUCK',
    'DUNLOP',
    'DUNS',
    'DUPONT',
    'DURBAN',
    'DVAG',
    'DVR',
    'DZ',
    'EARTH',
    'EAT',
    'EC',
    'ECO',
    'EDEKA',
    'EDU',
    'EDUCATION',
    'EE',
    'EG',
    'EMAIL',
    'EMERCK',
    'ENERGY',
    'ENGINEER',
    'ENGINEERING',
    'ENTERPRISES',
    'EPSON',
    'EQUIPMENT',
    'ER',
    'ERICSSON',
    'ERNI',
    'ES',
    'ESQ',
    'ESTATE',
    'ESURANCE',
    'ET',
    'ETISALAT',
    'EU',
    'EUROVISION',
    'EUS',
    'EVENTS',
    'EVERBANK',
    'EXCHANGE',
    'EXPERT',
    'EXPOSED',
    'EXPRESS',
    'EXTRASPACE',
    'FAGE',
    'FAIL',
    'FAIRWINDS',
    'FAITH',
    'FAMILY',
    'FAN',
    'FANS',
    'FARM',
    'FARMERS',
    'FASHION',
    'FAST',
    'FEDEX',
    'FEEDBACK',
    'FERRARI',
    'FERRERO',
    'FI',
    'FIAT',
    'FIDELITY',
    'FIDO',
    'FILM',
    'FINAL',
    'FINANCE',
    'FINANCIAL',
    'FIRE',
    'FIRESTONE',
    'FIRMDALE',
    'FISH',
    'FISHING',
    'FIT',
    'FITNESS',
    'FJ',
    'FK',
    'FLICKR',
    'FLIGHTS',
    'FLIR',
    'FLORIST',
    'FLOWERS',
    'FLY',
    'FM',
    'FO',
    'FOO',
    'FOOD',
    'FOODNETWORK',
    'FOOTBALL',
    'FORD',
    'FOREX',
    'FORSALE',
    'FORUM',
    'FOUNDATION',
    'FOX',
    'FR',
    'FREE',
    'FRESENIUS',
    'FRL',
    'FROGANS',
    'FRONTDOOR',
    'FRONTIER',
    'FTR',
    'FUJITSU',
    'FUJIXEROX',
    'FUN',
    'FUND',
    'FURNITURE',
    'FUTBOL',
    'FYI',
    'GA',
    'GAL',
    'GALLERY',
    'GALLO',
    'GALLUP',
    'GAME',
    'GAMES',
    'GAP',
    'GARDEN',
    'GB',
    'GBIZ',
    'GD',
    'GDN',
    'GE',
    'GEA',
    'GENT',
    'GENTING',
    'GEORGE',
    'GF',
    'GG',
    'GGEE',
    'GH',
    'GI',
    'GIFT',
    'GIFTS',
    'GIVES',
    'GIVING',
    'GL',
    'GLADE',
    'GLASS',
    'GLE',
    'GLOBAL',
    'GLOBO',
    'GM',
    'GMAIL',
    'GMBH',
    'GMO',
    'GMX',
    'GN',
    'GODADDY',
    'GOLD',
    'GOLDPOINT',
    'GOLF',
    'GOO',
    'GOODYEAR',
    'GOOG',
    'GOOGLE',
    'GOP',
    'GOT',
    'GOV',
    'GP',
    'GQ',
    'GR',
    'GRAINGER',
    'GRAPHICS',
    'GRATIS',
    'GREEN',
    'GRIPE',
    'GROCERY',
    'GROUP',
    'GS',
    'GT',
    'GU',
    'GUARDIAN',
    'GUCCI',
    'GUGE',
    'GUIDE',
    'GUITARS',
    'GURU',
    'GW',
    'GY',
    'HAIR',
    'HAMBURG',
    'HANGOUT',
    'HAUS',
    'HBO',
    'HDFC',
    'HDFCBANK',
    'HEALTH',
    'HEALTHCARE',
    'HELP',
    'HELSINKI',
    'HERE',
    'HERMES',
    'HGTV',
    'HIPHOP',
    'HISAMITSU',
    'HITACHI',
    'HIV',
    'HK',
    'HKT',
    'HM',
    'HN',
    'HOCKEY',
    'HOLDINGS',
    'HOLIDAY',
    'HOMEDEPOT',
    'HOMEGOODS',
    'HOMES',
    'HOMESENSE',
    'HONDA',
    'HONEYWELL',
    'HORSE',
    'HOSPITAL',
    'HOST',
    'HOSTING',
    'HOT',
    'HOTELES',
    'HOTELS',
    'HOTMAIL',
    'HOUSE',
    'HOW',
    'HR',
    'HSBC',
    'HT',
    'HU',
    'HUGHES',
    'HYATT',
    'HYUNDAI',
    'IBM',
    'ICBC',
    'ICE',
    'ICU',
    'ID',
    'IE',
    'IEEE',
    'IFM',
    'IKANO',
    'IL',
    'IM',
    'IMAMAT',
    'IMDB',
    'IMMO',
    'IMMOBILIEN',
    'IN',
    'INC',
    'INDUSTRIES',
    'INFINITI',
    'INFO',
    'ING',
    'INK',
    'INSTITUTE',
    'INSURANCE',
    'INSURE',
    'INT',
    'INTEL',
    'INTERNATIONAL',
    'INTUIT',
    'INVESTMENTS',
    'IO',
    'IPIRANGA',
    'IQ',
    'IR',
    'IRISH',
    'IS',
    'ISELECT',
    'ISMAILI',
    'IST',
    'ISTANBUL',
    'IT',
    'ITAU',
    'ITV',
    'IVECO',
    'JAGUAR',
    'JAVA',
    'JCB',
    'JCP',
    'JE',
    'JEEP',
    'JETZT',
    'JEWELRY',
    'JIO',
    'JLL',
    'JM',
    'JMP',
    'JNJ',
    'JO',
    'JOBS',
    'JOBURG',
    'JOT',
    'JOY',
    'JP',
    'JPMORGAN',
    'JPRS',
    'JUEGOS',
    'JUNIPER',
    'KAUFEN',
    'KDDI',
    'KE',
    'KERRYHOTELS',
    'KERRYLOGISTICS',
    'KERRYPROPERTIES',
    'KFH',
    'KG',
    'KH',
    'KI',
    'KIA',
    'KIM',
    'KINDER',
    'KINDLE',
    'KITCHEN',
    'KIWI',
    'KM',
    'KN',
    'KOELN',
    'KOMATSU',
    'KOSHER',
    'KP',
    'KPMG',
    'KPN',
    'KR',
    'KRD',
    'KRED',
    'KUOKGROUP',
    'KW',
    'KY',
    'KYOTO',
    'KZ',
    'LA',
    'LACAIXA',
    'LADBROKES',
    'LAMBORGHINI',
    'LAMER',
    'LANCASTER',
    'LANCIA',
    'LANCOME',
    'LAND',
    'LANDROVER',
    'LANXESS',
    'LASALLE',
    'LAT',
    'LATINO',
    'LATROBE',
    'LAW',
    'LAWYER',
    'LB',
    'LC',
    'LDS',
    'LEASE',
    'LECLERC',
    'LEFRAK',
    'LEGAL',
    'LEGO',
    'LEXUS',
    'LGBT',
    'LI',
    'LIAISON',
    'LIDL',
    'LIFE',
    'LIFEINSURANCE',
    'LIFESTYLE',
    'LIGHTING',
    'LIKE',
    'LILLY',
    'LIMITED',
    'LIMO',
    'LINCOLN',
    'LINDE',
    'LINK',
    'LIPSY',
    'LIVE',
    'LIVING',
    'LIXIL',
    'LK',
    'LLC',
    'LOAN',
    'LOANS',
    'LOCKER',
    'LOCUS',
    'LOFT',
    'LOL',
    'LONDON',
    'LOTTE',
    'LOTTO',
    'LOVE',
    'LPL',
    'LPLFINANCIAL',
    'LR',
    'LS',
    'LT',
    'LTD',
    'LTDA',
    'LU',
    'LUNDBECK',
    'LUPIN',
    'LUXE',
    'LUXURY',
    'LV',
    'LY',
    'MA',
    'MACYS',
    'MADRID',
    'MAIF',
    'MAISON',
    'MAKEUP',
    'MAN',
    'MANAGEMENT',
    'MANGO',
    'MAP',
    'MARKET',
    'MARKETING',
    'MARKETS',
    'MARRIOTT',
    'MARSHALLS',
    'MASERATI',
    'MATTEL',
    'MBA',
    'MC',
    'MCKINSEY',
    'MD',
    'ME',
    'MED',
    'MEDIA',
    'MEET',
    'MELBOURNE',
    'MEME',
    'MEMORIAL',
    'MEN',
    'MENU',
    'MERCKMSD',
    'METLIFE',
    'MG',
    'MH',
    'MIAMI',
    'MICROSOFT',
    'MIL',
    'MINI',
    'MINT',
    'MIT',
    'MITSUBISHI',
    'MK',
    'ML',
    'MLB',
    'MLS',
    'MM',
    'MMA',
    'MN',
    'MO',
    'MOBI',
    'MOBILE',
    'MOBILY',
    'MODA',
    'MOE',
    'MOI',
    'MOM',
    'MONASH',
    'MONEY',
    'MONSTER',
    'MOPAR',
    'MORMON',
    'MORTGAGE',
    'MOSCOW',
    'MOTO',
    'MOTORCYCLES',
    'MOV',
    'MOVIE',
    'MOVISTAR',
    'MP',
    'MQ',
    'MR',
    'MS',
    'MSD',
    'MT',
    'MTN',
    'MTR',
    'MU',
    'MUSEUM',
    'MUTUAL',
    'MV',
    'MW',
    'MX',
    'MY',
    'MZ',
    'NA',
    'NAB',
    'NADEX',
    'NAGOYA',
    'NAME',
    'NATIONWIDE',
    'NATURA',
    'NAVY',
    'NBA',
    'NC',
    'NE',
    'NEC',
    'NET',
    'NETBANK',
    'NETFLIX',
    'NETWORK',
    'NEUSTAR',
    'NEW',
    'NEWHOLLAND',
    'NEWS',
    'NEXT',
    'NEXTDIRECT',
    'NEXUS',
    'NF',
    'NFL',
    'NG',
    'NGO',
    'NHK',
    'NI',
    'NICO',
    'NIKE',
    'NIKON',
    'NINJA',
    'NISSAN',
    'NISSAY',
    'NL',
    'NO',
    'NOKIA',
    'NORTHWESTERNMUTUAL',
    'NORTON',
    'NOW',
    'NOWRUZ',
    'NOWTV',
    'NP',
    'NR',
    'NRA',
    'NRW',
    'NTT',
    'NU',
    'NYC',
    'NZ',
    'OBI',
    'OBSERVER',
    'OFF',
    'OFFICE',
    'OKINAWA',
    'OLAYAN',
    'OLAYANGROUP',
    'OLDNAVY',
    'OLLO',
    'OM',
    'OMEGA',
    'ONE',
    'ONG',
    'ONL',
    'ONLINE',
    'ONYOURSIDE',
    'OOO',
    'OPEN',
    'ORACLE',
    'ORANGE',
    'ORG',
    'ORGANIC',
    'ORIGINS',
    'OSAKA',
    'OTSUKA',
    'OTT',
    'OVH',
    'PA',
    'PAGE',
    'PANASONIC',
    'PARIS',
    'PARS',
    'PARTNERS',
    'PARTS',
    'PARTY',
    'PASSAGENS',
    'PAY',
    'PCCW',
    'PE',
    'PET',
    'PF',
    'PFIZER',
    'PG',
    'PH',
    'PHARMACY',
    'PHD',
    'PHILIPS',
    'PHONE',
    'PHOTO',
    'PHOTOGRAPHY',
    'PHOTOS',
    'PHYSIO',
    'PIAGET',
    'PICS',
    'PICTET',
    'PICTURES',
    'PID',
    'PIN',
    'PING',
    'PINK',
    'PIONEER',
    'PIZZA',
    'PK',
    'PL',
    'PLACE',
    'PLAY',
    'PLAYSTATION',
    'PLUMBING',
    'PLUS',
    'PM',
    'PN',
    'PNC',
    'POHL',
    'POKER',
    'POLITIE',
    'PORN',
    'POST',
    'PR',
    'PRAMERICA',
    'PRAXI',
    'PRESS',
    'PRIME',
    'PRO',
    'PROD',
    'PRODUCTIONS',
    'PROF',
    'PROGRESSIVE',
    'PROMO',
    'PROPERTIES',
    'PROPERTY',
    'PROTECTION',
    'PRU',
    'PRUDENTIAL',
    'PS',
    'PT',
    'PUB',
    'PW',
    'PWC',
    'PY',
    'QA',
    'QPON',
    'QUEBEC',
    'QUEST',
    'QVC',
    'RACING',
    'RADIO',
    'RAID',
    'RE',
    'READ',
    'REALESTATE',
    'REALTOR',
    'REALTY',
    'RECIPES',
    'RED',
    'REDSTONE',
    'REDUMBRELLA',
    'REHAB',
    'REISE',
    'REISEN',
    'REIT',
    'RELIANCE',
    'REN',
    'RENT',
    'RENTALS',
    'REPAIR',
    'REPORT',
    'REPUBLICAN',
    'REST',
    'RESTAURANT',
    'REVIEW',
    'REVIEWS',
    'REXROTH',
    'RICH',
    'RICHARDLI',
    'RICOH',
    'RIGHTATHOME',
    'RIL',
    'RIO',
    'RIP',
    'RMIT',
    'RO',
    'ROCHER',
    'ROCKS',
    'RODEO',
    'ROGERS',
    'ROOM',
    'RS',
    'RSVP',
    'RU',
    'RUGBY',
    'RUHR',
    'RUN',
    'RW',
    'RWE',
    'RYUKYU',
    'SA',
    'SAARLAND',
    'SAFE',
    'SAFETY',
    'SAKURA',
    'SALE',
    'SALON',
    'SAMSCLUB',
    'SAMSUNG',
    'SANDVIK',
    'SANDVIKCOROMANT',
    'SANOFI',
    'SAP',
    'SARL',
    'SAS',
    'SAVE',
    'SAXO',
    'SB',
    'SBI',
    'SBS',
    'SC',
    'SCA',
    'SCB',
    'SCHAEFFLER',
    'SCHMIDT',
    'SCHOLARSHIPS',
    'SCHOOL',
    'SCHULE',
    'SCHWARZ',
    'SCIENCE',
    'SCJOHNSON',
    'SCOR',
    'SCOT',
    'SD',
    'SE',
    'SEARCH',
    'SEAT',
    'SECURE',
    'SECURITY',
    'SEEK',
    'SELECT',
    'SENER',
    'SERVICES',
    'SES',
    'SEVEN',
    'SEW',
    'SEX',
    'SEXY',
    'SFR',
    'SG',
    'SH',
    'SHANGRILA',
    'SHARP',
    'SHAW',
    'SHELL',
    'SHIA',
    'SHIKSHA',
    'SHOES',
    'SHOP',
    'SHOPPING',
    'SHOUJI',
    'SHOW',
    'SHOWTIME',
    'SHRIRAM',
    'SI',
    'SILK',
    'SINA',
    'SINGLES',
    'SITE',
    'SJ',
    'SK',
    'SKI',
    'SKIN',
    'SKY',
    'SKYPE',
    'SL',
    'SLING',
    'SM',
    'SMART',
    'SMILE',
    'SN',
    'SNCF',
    'SO',
    'SOCCER',
    'SOCIAL',
    'SOFTBANK',
    'SOFTWARE',
    'SOHU',
    'SOLAR',
    'SOLUTIONS',
    'SONG',
    'SONY',
    'SOY',
    'SPACE',
    'SPORT',
    'SPOT',
    'SPREADBETTING',
    'SR',
    'SRL',
    'SRT',
    'SS',
    'ST',
    'STADA',
    'STAPLES',
    'STAR',
    'STARHUB',
    'STATEBANK',
    'STATEFARM',
    'STC',
    'STCGROUP',
    'STOCKHOLM',
    'STORAGE',
    'STORE',
    'STREAM',
    'STUDIO',
    'STUDY',
    'STYLE',
    'SU',
    'SUCKS',
    'SUPPLIES',
    'SUPPLY',
    'SUPPORT',
    'SURF',
    'SURGERY',
    'SUZUKI',
    'SV',
    'SWATCH',
    'SWIFTCOVER',
    'SWISS',
    'SX',
    'SY',
    'SYDNEY',
    'SYMANTEC',
    'SYSTEMS',
    'SZ',
    'TAB',
    'TAIPEI',
    'TALK',
    'TAOBAO',
    'TARGET',
    'TATAMOTORS',
    'TATAR',
    'TATTOO',
    'TAX',
    'TAXI',
    'TC',
    'TCI',
    'TD',
    'TDK',
    'TEAM',
    'TECH',
    'TECHNOLOGY',
    'TEL',
    'TELEFONICA',
    'TEMASEK',
    'TENNIS',
    'TEVA',
    'TF',
    'TG',
    'TH',
    'THD',
    'THEATER',
    'THEATRE',
    'TIAA',
    'TICKETS',
    'TIENDA',
    'TIFFANY',
    'TIPS',
    'TIRES',
    'TIROL',
    'TJ',
    'TJMAXX',
    'TJX',
    'TK',
    'TKMAXX',
    'TL',
    'TM',
    'TMALL',
    'TN',
    'TO',
    'TODAY',
    'TOKYO',
    'TOOLS',
    'TOP',
    'TORAY',
    'TOSHIBA',
    'TOTAL',
    'TOURS',
    'TOWN',
    'TOYOTA',
    'TOYS',
    'TR',
    'TRADE',
    'TRADING',
    'TRAINING',
    'TRAVEL',
    'TRAVELCHANNEL',
    'TRAVELERS',
    'TRAVELERSINSURANCE',
    'TRUST',
    'TRV',
    'TT',
    'TUBE',
    'TUI',
    'TUNES',
    'TUSHU',
    'TV',
    'TVS',
    'TW',
    'TZ',
    'UA',
    'UBANK',
    'UBS',
    'UCONNECT',
    'UG',
    'UK',
    'UNICOM',
    'UNIVERSITY',
    'UNO',
    'UOL',
    'UPS',
    'US',
    'UY',
    'UZ',
    'VA',
    'VACATIONS',
    'VANA',
    'VANGUARD',
    'VC',
    'VE',
    'VEGAS',
    'VENTURES',
    'VERISIGN',
    'VERSICHERUNG',
    'VET',
    'VG',
    'VI',
    'VIAJES',
    'VIDEO',
    'VIG',
    'VIKING',
    'VILLAS',
    'VIN',
    'VIP',
    'VIRGIN',
    'VISA',
    'VISION',
    'VISTAPRINT',
    'VIVA',
    'VIVO',
    'VLAANDEREN',
    'VN',
    'VODKA',
    'VOLKSWAGEN',
    'VOLVO',
    'VOTE',
    'VOTING',
    'VOTO',
    'VOYAGE',
    'VU',
    'VUELOS',
    'WALES',
    'WALMART',
    'WALTER',
    'WANG',
    'WANGGOU',
    'WARMAN',
    'WATCH',
    'WATCHES',
    'WEATHER',
    'WEATHERCHANNEL',
    'WEBCAM',
    'WEBER',
    'WEBSITE',
    'WED',
    'WEDDING',
    'WEIBO',
    'WEIR',
    'WF',
    'WHOSWHO',
    'WIEN',
    'WIKI',
    'WILLIAMHILL',
    'WIN',
    'WINDOWS',
    'WINE',
    'WINNERS',
    'WME',
    'WOLTERSKLUWER',
    'WOODSIDE',
    'WORK',
    'WORKS',
    'WORLD',
    'WOW',
    'WS',
    'WTC',
    'WTF',
    'XBOX',
    'XEROX',
    'XFINITY',
    'XIHUAN',
    'XIN',
    'XN--11B4C3D',
    'XN--1CK2E1B',
    'XN--1QQW23A',
    'XN--2SCRJ9C',
    'XN--30RR7Y',
    'XN--3BST00M',
    'XN--3DS443G',
    'XN--3E0B707E',
    'XN--3HCRJ9C',
    'XN--3OQ18VL8PN36A',
    'XN--3PXU8K',
    'XN--42C2D9A',
    'XN--45BR5CYL',
    'XN--45BRJ9C',
    'XN--45Q11C',
    'XN--4GBRIM',
    'XN--54B7FTA0CC',
    'XN--55QW42G',
    'XN--55QX5D',
    'XN--5SU34J936BGSG',
    'XN--5TZM5G',
    'XN--6FRZ82G',
    'XN--6QQ986B3XL',
    'XN--80ADXHKS',
    'XN--80AO21A',
    'XN--80AQECDR1A',
    'XN--80ASEHDB',
    'XN--80ASWG',
    'XN--8Y0A063A',
    'XN--90A3AC',
    'XN--90AE',
    'XN--90AIS',
    'XN--9DBQ2A',
    'XN--9ET52U',
    'XN--9KRT00A',
    'XN--B4W605FERD',
    'XN--BCK1B9A5DRE4C',
    'XN--C1AVG',
    'XN--C2BR7G',
    'XN--CCK2B3B',
    'XN--CG4BKI',
    'XN--CLCHC0EA0B2G2A9GCD',
    'XN--CZR694B',
    'XN--CZRS0T',
    'XN--CZRU2D',
    'XN--D1ACJ3B',
    'XN--D1ALF',
    'XN--E1A4C',
    'XN--ECKVDTC9D',
    'XN--EFVY88H',
    'XN--ESTV75G',
    'XN--FCT429K',
    'XN--FHBEI',
    'XN--FIQ228C5HS',
    'XN--FIQ64B',
    'XN--FIQS8S',
    'XN--FIQZ9S',
    'XN--FJQ720A',
    'XN--FLW351E',
    'XN--FPCRJ9C3D',
    'XN--FZC2C9E2C',
    'XN--FZYS8D69UVGM',
    'XN--G2XX48C',
    'XN--GCKR3F0F',
    'XN--GECRJ9C',
    'XN--GK3AT1E',
    'XN--H2BREG3EVE',
    'XN--H2BRJ9C',
    'XN--H2BRJ9C8C',
    'XN--HXT814E',
    'XN--I1B6B1A6A2E',
    'XN--IMR513N',
    'XN--IO0A7I',
    'XN--J1AEF',
    'XN--J1AMH',
    'XN--J6W193G',
    'XN--JLQ61U9W7B',
    'XN--JVR189M',
    'XN--KCRX77D1X4A',
    'XN--KPRW13D',
    'XN--KPRY57D',
    'XN--KPU716F',
    'XN--KPUT3I',
    'XN--L1ACC',
    'XN--LGBBAT1AD8J',
    'XN--MGB9AWBF',
    'XN--MGBA3A3EJT',
    'XN--MGBA3A4F16A',
    'XN--MGBA7C0BBN0A',
    'XN--MGBAAKC7DVF',
    'XN--MGBAAM7A8H',
    'XN--MGBAB2BD',
    'XN--MGBAH1A3HJKRD',
    'XN--MGBAI9AZGQP6J',
    'XN--MGBAYH7GPA',
    'XN--MGBB9FBPOB',
    'XN--MGBBH1A',
    'XN--MGBBH1A71E',
    'XN--MGBC0A9AZCG',
    'XN--MGBCA7DZDO',
    'XN--MGBERP4A5D4AR',
    'XN--MGBGU82A',
    'XN--MGBI4ECEXP',
    'XN--MGBPL2FH',
    'XN--MGBT3DHD',
    'XN--MGBTX2B',
    'XN--MGBX4CD0AB',
    'XN--MIX891F',
    'XN--MK1BU44C',
    'XN--MXTQ1M',
    'XN--NGBC5AZD',
    'XN--NGBE9E0A',
    'XN--NGBRX',
    'XN--NODE',
    'XN--NQV7F',
    'XN--NQV7FS00EMA',
    'XN--NYQY26A',
    'XN--O3CW4H',
    'XN--OGBPF8FL',
    'XN--OTU796D',
    'XN--P1ACF',
    'XN--P1AI',
    'XN--PBT977C',
    'XN--PGBS0DH',
    'XN--PSSY2U',
    'XN--Q9JYB4C',
    'XN--QCKA1PMC',
    'XN--QXAM',
    'XN--RHQV96G',
    'XN--ROVU88B',
    'XN--RVC1E0AM3E',
    'XN--S9BRJ9C',
    'XN--SES554G',
    'XN--T60B56A',
    'XN--TCKWE',
    'XN--TIQ49XQYJ',
    'XN--UNUP4Y',
    'XN--VERMGENSBERATER-CTB',
    'XN--VERMGENSBERATUNG-PWB',
    'XN--VHQUV',
    'XN--VUQ861B',
    'XN--W4R85EL8FHU5DNRA',
    'XN--W4RS40L',
    'XN--WGBH1C',
    'XN--WGBL6A',
    'XN--XHQ521B',
    'XN--XKC2AL3HYE2A',
    'XN--XKC2DL3A5EE0H',
    'XN--Y9A3AQ',
    'XN--YFRO4I67O',
    'XN--YGBI2AMMX',
    'XN--ZFR164B',
    'XXX',
    'XYZ',
    'YACHTS',
    'YAHOO',
    'YAMAXUN',
    'YANDEX',
    'YE',
    'YODOBASHI',
    'YOGA',
    'YOKOHAMA',
    'YOU',
    'YOUTUBE',
    'YT',
    'YUN',
    'ZA',
    'ZAPPOS',
    'ZARA',
    'ZERO',
    'ZIP',
    'ZM',
    'ZONE',
    'ZUERICH',
    'ZW'
];


// Keep as upper-case to make updating from source easier

module.exports = new Set(internals.tlds.map((tld) => tld.toLowerCase()));


/***/ }),

/***/ "./src/node_modules/@hapi/hoek/lib/deep-equal.js":
/*!*******************************************************!*\
  !*** ./src/node_modules/@hapi/hoek/lib/deep-equal.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// Load modules

const Types = __webpack_require__(/*! ./types */ "./src/node_modules/@hapi/hoek/lib/types.js");


// Declare internals

const internals = {
    mismatched: null
};


module.exports = function (obj, ref, options) {

    options = { prototype: true, ...options };

    return !!internals.isDeepEqual(obj, ref, options, []);
};


internals.isDeepEqual = function (obj, ref, options, seen) {

    if (obj === ref) {                                      // Copied from Deep-eql, copyright(c) 2013 Jake Luer, jake@alogicalparadox.com, MIT Licensed, https://github.com/chaijs/deep-eql
        return obj !== 0 || 1 / obj === 1 / ref;
    }

    const type = typeof obj;

    if (type !== typeof ref) {
        return false;
    }

    if (type !== 'object' ||
        obj === null ||
        ref === null) {

        return obj !== obj && ref !== ref;                  // NaN
    }

    const instanceType = internals.getSharedType(obj, ref, !!options.prototype);
    switch (instanceType) {
        case Types.buffer:
            return Buffer.prototype.equals.call(obj, ref);
        case Types.promise:
            return obj === ref;
        case Types.regex:
            return obj.toString() === ref.toString();
        case internals.mismatched:
            return false;
    }

    for (let i = seen.length - 1; i >= 0; --i) {
        if (seen[i].isSame(obj, ref)) {
            return true;                                    // If previous comparison failed, it would have stopped execution
        }
    }

    seen.push(new internals.SeenEntry(obj, ref));

    try {
        return !!internals.isDeepEqualObj(instanceType, obj, ref, options, seen);
    }
    finally {
        seen.pop();
    }
};


internals.getSharedType = function (obj, ref, checkPrototype) {

    if (checkPrototype) {
        if (Object.getPrototypeOf(obj) !== Object.getPrototypeOf(ref)) {
            return internals.mismatched;
        }

        return Types.getInternalProto(obj);
    }

    const type = Types.getInternalProto(obj);
    if (type !== Types.getInternalProto(ref)) {
        return internals.mismatched;
    }

    return type;
};


internals.valueOf = function (obj) {

    const objValueOf = obj.valueOf;
    if (objValueOf === undefined) {
        return obj;
    }

    try {
        return objValueOf.call(obj);
    }
    catch (err) {
        return err;
    }
};


internals.hasOwnEnumerableProperty = function (obj, key) {

    return Object.prototype.propertyIsEnumerable.call(obj, key);
};


internals.isSetSimpleEqual = function (obj, ref) {

    for (const entry of obj) {
        if (!ref.has(entry)) {
            return false;
        }
    }

    return true;
};


internals.isDeepEqualObj = function (instanceType, obj, ref, options, seen) {

    const { isDeepEqual, valueOf, hasOwnEnumerableProperty } = internals;
    const { keys, getOwnPropertySymbols } = Object;

    if (instanceType === Types.array) {
        if (options.part) {
            // Check if any index match any other index

            for (let i = 0; i < obj.length; ++i) {
                const objValue = obj[i];
                for (let j = 0; j < ref.length; ++j) {
                    if (isDeepEqual(objValue, ref[j], options, seen)) {
                        return true;
                    }
                }
            }
        }
        else {
            if (obj.length !== ref.length) {
                return false;
            }

            for (let i = 0; i < obj.length; ++i) {
                if (!isDeepEqual(obj[i], ref[i], options, seen)) {
                    return false;
                }
            }

            return true;
        }
    }
    else if (instanceType === Types.set) {
        if (obj.size !== ref.size) {
            return false;
        }

        if (!internals.isSetSimpleEqual(obj, ref)) {

            // Check for deep equality

            const ref2 = new Set(ref);
            for (const objEntry of obj) {
                if (ref2.delete(objEntry)) {
                    continue;
                }

                let found = false;
                for (const refEntry of ref2) {
                    if (isDeepEqual(objEntry, refEntry, options, seen)) {
                        ref2.delete(refEntry);
                        found = true;
                        break;
                    }
                }

                if (!found) {
                    return false;
                }
            }
        }
    }
    else if (instanceType === Types.map) {
        if (obj.size !== ref.size) {
            return false;
        }

        for (const [key, value] of obj) {
            if (value === undefined && !ref.has(key)) {
                return false;
            }

            if (!isDeepEqual(value, ref.get(key), options, seen)) {
                return false;
            }
        }
    }
    else if (instanceType === Types.error) {
        // Always check name and message

        if (obj.name !== ref.name || obj.message !== ref.message) {
            return false;
        }
    }

    // Check .valueOf()

    const valueOfObj = valueOf(obj);
    const valueOfRef = valueOf(ref);
    if (!(obj === valueOfObj && ref === valueOfRef) &&
        !isDeepEqual(valueOfObj, valueOfRef, options, seen)) {
        return false;
    }

    // Check properties

    const objKeys = keys(obj);
    if (!options.part &&
        objKeys.length !== keys(ref).length) {

        return false;
    }

    for (let i = 0; i < objKeys.length; ++i) {
        const key = objKeys[i];

        if (!hasOwnEnumerableProperty(ref, key)) {
            return false;
        }

        if (!isDeepEqual(obj[key], ref[key], options, seen)) {
            return false;
        }
    }

    // Check symbols

    if (options.symbols) {
        const objSymbols = getOwnPropertySymbols(obj);
        const refSymbols = new Set(getOwnPropertySymbols(ref));

        for (let i = 0; i < objSymbols.length; ++i) {
            const key = objSymbols[i];

            if (hasOwnEnumerableProperty(obj, key)) {
                if (!hasOwnEnumerableProperty(ref, key)) {
                    return false;
                }

                if (!isDeepEqual(obj[key], ref[key], options, seen)) {
                    return false;
                }
            }
            else if (hasOwnEnumerableProperty(ref, key)) {
                return false;
            }

            refSymbols.delete(key);
        }

        for (const key of refSymbols) {
            if (hasOwnEnumerableProperty(ref, key)) {
                return false;
            }
        }
    }

    return true;
};


internals.SeenEntry = class {

    constructor(obj, ref) {

        this.obj = obj;
        this.ref = ref;
    }

    isSame(obj, ref) {

        return this.obj === obj && this.ref === ref;
    }
};


/***/ }),

/***/ "./src/node_modules/@hapi/hoek/lib/escape.js":
/*!***************************************************!*\
  !*** ./src/node_modules/@hapi/hoek/lib/escape.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// Declare internals

const internals = {};


exports.escapeHtml = function (input) {

    if (!input) {
        return '';
    }

    let escaped = '';

    for (let i = 0; i < input.length; ++i) {

        const charCode = input.charCodeAt(i);

        if (internals.isSafe(charCode)) {
            escaped += input[i];
        }
        else {
            escaped += internals.escapeHtmlChar(charCode);
        }
    }

    return escaped;
};


exports.escapeJson = function (input) {

    if (!input) {
        return '';
    }

    const lessThan = 0x3C;
    const greaterThan = 0x3E;
    const andSymbol = 0x26;
    const lineSeperator = 0x2028;

    // replace method
    let charCode;
    return input.replace(/[<>&\u2028\u2029]/g, (match) => {

        charCode = match.charCodeAt(0);

        if (charCode === lessThan) {
            return '\\u003c';
        }

        if (charCode === greaterThan) {
            return '\\u003e';
        }

        if (charCode === andSymbol) {
            return '\\u0026';
        }

        if (charCode === lineSeperator) {
            return '\\u2028';
        }

        return '\\u2029';
    });
};


internals.escapeHtmlChar = function (charCode) {

    const namedEscape = internals.namedHtml[charCode];
    if (typeof namedEscape !== 'undefined') {
        return namedEscape;
    }

    if (charCode >= 256) {
        return '&#' + charCode + ';';
    }

    const hexValue = Buffer.from(String.fromCharCode(charCode), 'ascii').toString('hex');
    return `&#x${hexValue};`;
};


internals.isSafe = function (charCode) {

    return (typeof internals.safeCharCodes[charCode] !== 'undefined');
};


internals.namedHtml = {
    '38': '&amp;',
    '60': '&lt;',
    '62': '&gt;',
    '34': '&quot;',
    '160': '&nbsp;',
    '162': '&cent;',
    '163': '&pound;',
    '164': '&curren;',
    '169': '&copy;',
    '174': '&reg;'
};


internals.safeCharCodes = (function () {

    const safe = {};

    for (let i = 32; i < 123; ++i) {

        if ((i >= 97) ||                    // a-z
            (i >= 65 && i <= 90) ||         // A-Z
            (i >= 48 && i <= 57) ||         // 0-9
            i === 32 ||                     // space
            i === 46 ||                     // .
            i === 44 ||                     // ,
            i === 45 ||                     // -
            i === 58 ||                     // :
            i === 95) {                     // _

            safe[i] = null;
        }
    }

    return safe;
}());


/***/ }),

/***/ "./src/node_modules/@hapi/hoek/lib/index.js":
/*!**************************************************!*\
  !*** ./src/node_modules/@hapi/hoek/lib/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// Load modules

const Assert = __webpack_require__(/*! assert */ "assert");
const Crypto = __webpack_require__(/*! crypto */ "crypto");
const Path = __webpack_require__(/*! path */ "path");

const DeepEqual = __webpack_require__(/*! ./deep-equal */ "./src/node_modules/@hapi/hoek/lib/deep-equal.js");
const Escape = __webpack_require__(/*! ./escape */ "./src/node_modules/@hapi/hoek/lib/escape.js");
const Types = __webpack_require__(/*! ./types */ "./src/node_modules/@hapi/hoek/lib/types.js");


// Declare internals

const internals = {
    needsProtoHack: new Set([Types.set, Types.map, Types.weakSet, Types.weakMap])
};


// Deep object or array comparison

exports.deepEqual = DeepEqual;


// Clone object or array

exports.clone = function (obj, options = {}, _seen = null) {

    if (typeof obj !== 'object' ||
        obj === null) {

        return obj;
    }

    const seen = _seen || new Map();

    const lookup = seen.get(obj);
    if (lookup) {
        return lookup;
    }

    const baseProto = Types.getInternalProto(obj);
    let newObj;

    switch (baseProto) {
        case Types.buffer:
            return Buffer.from(obj);

        case Types.date:
            return new Date(obj.getTime());

        case Types.regex:
            return new RegExp(obj);

        case Types.array:
            newObj = [];
            break;

        default:
            if (options.prototype !== false) {              // Defaults to true
                const proto = Object.getPrototypeOf(obj);
                if (proto &&
                    proto.isImmutable) {

                    return obj;
                }

                if (internals.needsProtoHack.has(baseProto)) {
                    newObj = new proto.constructor();
                    if (proto !== baseProto) {
                        Object.setPrototypeOf(newObj, proto);
                    }
                }
                else {
                    newObj = Object.create(proto);
                }
            }
            else if (internals.needsProtoHack.has(baseProto)) {
                newObj = new baseProto.constructor();
            }
            else {
                newObj = {};
            }
    }

    seen.set(obj, newObj);                                  // Set seen, since obj could recurse

    if (baseProto === Types.set) {
        for (const value of obj) {
            newObj.add(exports.clone(value, options, seen));
        }
    }
    else if (baseProto === Types.map) {
        for (const [key, value] of obj) {
            newObj.set(key, exports.clone(value, options, seen));
        }
    }

    const keys = internals.keys(obj, options);
    for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];

        if (baseProto === Types.array &&
            key === 'length') {

            continue;
        }

        const descriptor = Object.getOwnPropertyDescriptor(obj, key);
        if (descriptor &&
            (descriptor.get ||
                descriptor.set)) {

            Object.defineProperty(newObj, key, descriptor);
        }
        else {
            Object.defineProperty(newObj, key, {
                enumerable: descriptor ? descriptor.enumerable : true,
                writable: true,
                configurable: true,
                value: exports.clone(obj[key], options, seen)
            });
        }
    }

    if (baseProto === Types.array) {
        newObj.length = obj.length;
    }

    return newObj;
};


internals.keys = function (obj, options = {}) {

    return options.symbols ? Reflect.ownKeys(obj) : Object.getOwnPropertyNames(obj);
};


// Merge all the properties of source into target, source wins in conflict, and by default null and undefined from source are applied

exports.merge = function (target, source, isNullOverride = true, isMergeArrays = true) {

    exports.assert(target && typeof target === 'object', 'Invalid target value: must be an object');
    exports.assert(source === null || source === undefined || typeof source === 'object', 'Invalid source value: must be null, undefined, or an object');

    if (!source) {
        return target;
    }

    if (Array.isArray(source)) {
        exports.assert(Array.isArray(target), 'Cannot merge array onto an object');
        if (!isMergeArrays) {
            target.length = 0;                                                          // Must not change target assignment
        }

        for (let i = 0; i < source.length; ++i) {
            target.push(exports.clone(source[i]));
        }

        return target;
    }

    const keys = internals.keys(source);
    for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        if (key === '__proto__' ||
            !Object.prototype.propertyIsEnumerable.call(source, key)) {

            continue;
        }

        const value = source[key];
        if (value &&
            typeof value === 'object') {

            if (!target[key] ||
                typeof target[key] !== 'object' ||
                (Array.isArray(target[key]) !== Array.isArray(value)) ||
                value instanceof Date ||
                Buffer.isBuffer(value) ||
                value instanceof RegExp) {

                target[key] = exports.clone(value);
            }
            else {
                exports.merge(target[key], value, isNullOverride, isMergeArrays);
            }
        }
        else {
            if (value !== null &&
                value !== undefined) {                              // Explicit to preserve empty strings

                target[key] = value;
            }
            else if (isNullOverride) {
                target[key] = value;
            }
        }
    }

    return target;
};


// Apply options to a copy of the defaults

exports.applyToDefaults = function (defaults, options, isNullOverride = false) {

    exports.assert(defaults && typeof defaults === 'object', 'Invalid defaults value: must be an object');
    exports.assert(!options || options === true || typeof options === 'object', 'Invalid options value: must be true, falsy or an object');

    if (!options) {                                                 // If no options, return null
        return null;
    }

    const copy = exports.clone(defaults);

    if (options === true) {                                         // If options is set to true, use defaults
        return copy;
    }

    return exports.merge(copy, options, isNullOverride, false);
};


// Clone an object except for the listed keys which are shallow copied

exports.cloneWithShallow = function (source, keys, options) {

    if (!source ||
        typeof source !== 'object') {

        return source;
    }

    const storage = internals.store(source, keys);    // Move shallow copy items to storage
    const copy = exports.clone(source, options);      // Deep copy the rest
    internals.restore(copy, source, storage);         // Shallow copy the stored items and restore
    return copy;
};


internals.store = function (source, keys) {

    const storage = new Map();
    for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        const value = exports.reach(source, key);
        if (typeof value === 'object' ||
            typeof value === 'function') {

            storage.set(key, value);
            internals.reachSet(source, key, undefined);
        }
    }

    return storage;
};


internals.restore = function (copy, source, storage) {

    for (const [key, value] of storage) {
        internals.reachSet(copy, key, value);
        internals.reachSet(source, key, value);
    }
};


internals.reachSet = function (obj, key, value) {

    const path = Array.isArray(key) ? key : key.split('.');
    let ref = obj;
    for (let i = 0; i < path.length; ++i) {
        const segment = path[i];
        if (i + 1 === path.length) {
            ref[segment] = value;
        }

        ref = ref[segment];
    }
};


// Apply options to defaults except for the listed keys which are shallow copied from option without merging

exports.applyToDefaultsWithShallow = function (defaults, options, keys) {

    exports.assert(defaults && typeof defaults === 'object', 'Invalid defaults value: must be an object');
    exports.assert(!options || options === true || typeof options === 'object', 'Invalid options value: must be true, falsy or an object');
    exports.assert(keys && Array.isArray(keys), 'Invalid keys');

    if (!options) {                                                 // If no options, return null
        return null;
    }

    const copy = exports.cloneWithShallow(defaults, keys);

    if (options === true) {                                         // If options is set to true, use defaults
        return copy;
    }

    const storage = internals.store(options, keys);     // Move shallow copy items to storage
    exports.merge(copy, options, false, false);         // Deep copy the rest
    internals.restore(copy, options, storage);          // Shallow copy the stored items and restore
    return copy;
};


// Find the common unique items in two arrays

exports.intersect = function (array1, array2, justFirst = false) {

    if (!array1 ||
        !array2) {

        return (justFirst ? null : []);
    }

    const common = [];
    const hash = (Array.isArray(array1) ? new Set(array1) : array1);
    const found = new Set();
    for (const value of array2) {
        if (internals.has(hash, value) &&
            !found.has(value)) {

            if (justFirst) {
                return value;
            }

            common.push(value);
            found.add(value);
        }
    }

    return (justFirst ? null : common);
};


internals.has = function (ref, key) {

    if (typeof ref.has === 'function') {
        return ref.has(key);
    }

    return ref[key] !== undefined;
};


// Test if the reference contains the values

exports.contain = function (ref, values, options = {}) {        // options: { deep, once, only, part, symbols }

    /*
        string -> string(s)
        array -> item(s)
        object -> key(s)
        object -> object (key:value)
    */

    let valuePairs = null;
    if (typeof ref === 'object' &&
        typeof values === 'object' &&
        !Array.isArray(ref) &&
        !Array.isArray(values)) {

        valuePairs = values;
        const symbols = Object.getOwnPropertySymbols(values).filter(Object.prototype.propertyIsEnumerable.bind(values));
        values = [...Object.keys(values), ...symbols];
    }
    else {
        values = [].concat(values);
    }

    exports.assert(typeof ref === 'string' || typeof ref === 'object', 'Reference must be string or an object');
    exports.assert(values.length, 'Values array cannot be empty');

    let compare;
    let compareFlags;
    if (options.deep) {
        compare = exports.deepEqual;

        const hasOnly = options.only !== undefined;
        const hasPart = options.part !== undefined;

        compareFlags = {
            prototype: hasOnly ? options.only : hasPart ? !options.part : false,
            part: hasOnly ? !options.only : hasPart ? options.part : false
        };
    }
    else {
        compare = (a, b) => a === b;
    }

    let misses = false;
    const matches = new Array(values.length);
    for (let i = 0; i < matches.length; ++i) {
        matches[i] = 0;
    }

    if (typeof ref === 'string') {
        let pattern = '(';
        for (let i = 0; i < values.length; ++i) {
            const value = values[i];
            exports.assert(typeof value === 'string', 'Cannot compare string reference to non-string value');
            pattern += (i ? '|' : '') + exports.escapeRegex(value);
        }

        const regex = new RegExp(pattern + ')', 'g');
        const leftovers = ref.replace(regex, ($0, $1) => {

            const index = values.indexOf($1);
            ++matches[index];
            return '';          // Remove from string
        });

        misses = !!leftovers;
    }
    else if (Array.isArray(ref)) {
        const onlyOnce = !!(options.only && options.once);
        if (onlyOnce && ref.length !== values.length) {
            return false;
        }

        for (let i = 0; i < ref.length; ++i) {
            let matched = false;
            for (let j = 0; j < values.length && matched === false; ++j) {
                if (!onlyOnce || matches[j] === 0) {
                    matched = compare(values[j], ref[i], compareFlags) && j;
                }
            }

            if (matched !== false) {
                ++matches[matched];
            }
            else {
                misses = true;
            }
        }
    }
    else {
        const keys = internals.keys(ref, options);
        for (let i = 0; i < keys.length; ++i) {
            const key = keys[i];
            const pos = values.indexOf(key);
            if (pos !== -1) {
                if (valuePairs &&
                    !compare(valuePairs[key], ref[key], compareFlags)) {

                    return false;
                }

                ++matches[pos];
            }
            else {
                misses = true;
            }
        }
    }

    if (options.only) {
        if (misses || !options.once) {
            return !misses;
        }
    }

    let result = false;
    for (let i = 0; i < matches.length; ++i) {
        result = result || !!matches[i];
        if ((options.once && matches[i] > 1) ||
            (!options.part && !matches[i])) {

            return false;
        }
    }

    return result;
};


// Flatten array

exports.flatten = function (array, target) {

    const result = target || [];

    for (let i = 0; i < array.length; ++i) {
        if (Array.isArray(array[i])) {
            exports.flatten(array[i], result);
        }
        else {
            result.push(array[i]);
        }
    }

    return result;
};


// Convert an object key chain string ('a.b.c') to reference (object[a][b][c])

exports.reach = function (obj, chain, options) {

    if (chain === false ||
        chain === null ||
        chain === undefined) {

        return obj;
    }

    options = options || {};
    if (typeof options === 'string') {
        options = { separator: options };
    }

    const isChainArray = Array.isArray(chain);

    exports.assert(!isChainArray || !options.separator, 'Separator option no valid for array-based chain');

    const path = isChainArray ? chain : chain.split(options.separator || '.');
    let ref = obj;
    for (let i = 0; i < path.length; ++i) {
        let key = path[i];

        if (Array.isArray(ref)) {
            const number = Number(key);

            if (Number.isInteger(number) && number < 0) {
                key = ref.length + number;
            }
        }

        if (!ref ||
            !((typeof ref === 'object' || typeof ref === 'function') && key in ref) ||
            (typeof ref !== 'object' && options.functions === false)) {         // Only object and function can have properties

            exports.assert(!options.strict || i + 1 === path.length, 'Missing segment', key, 'in reach path ', chain);
            exports.assert(typeof ref === 'object' || options.functions === true || typeof ref !== 'function', 'Invalid segment', key, 'in reach path ', chain);
            ref = options.default;
            break;
        }

        ref = ref[key];
    }

    return ref;
};


exports.reachTemplate = function (obj, template, options) {

    return template.replace(/{([^}]+)}/g, ($0, chain) => {

        const value = exports.reach(obj, chain, options);
        return (value === undefined || value === null ? '' : value);
    });
};


exports.assert = function (condition, ...args) {

    if (condition) {
        return;
    }

    if (args.length === 1 && args[0] instanceof Error) {
        throw args[0];
    }

    const msgs = args
        .filter((arg) => arg !== '')
        .map((arg) => {

            return typeof arg === 'string' ? arg : arg instanceof Error ? arg.message : exports.stringify(arg);
        });

    throw new Assert.AssertionError({
        message: msgs.join(' ') || 'Unknown error',
        actual: false,
        expected: true,
        operator: '==',
        stackStartFunction: exports.assert
    });
};


exports.Bench = class {

    constructor() {

        this.ts = 0;
        this.reset();
    }

    reset() {

        this.ts = exports.Bench.now();
    }

    elapsed() {

        return exports.Bench.now() - this.ts;
    }

    static now() {

        const ts = process.hrtime();
        return (ts[0] * 1e3) + (ts[1] / 1e6);
    }
};


// Escape string for Regex construction

exports.escapeRegex = function (string) {

    // Escape ^$.*+-?=!:|\/()[]{},
    return string.replace(/[\^\$\.\*\+\-\?\=\!\:\|\\\/\(\)\[\]\{\}\,]/g, '\\$&');
};


// Escape attribute value for use in HTTP header

exports.escapeHeaderAttribute = function (attribute) {

    // Allowed value characters: !#$%&'()*+,-./:;<=>?@[]^_`{|}~ and space, a-z, A-Z, 0-9, \, "

    exports.assert(/^[ \w\!#\$%&'\(\)\*\+,\-\.\/\:;<\=>\?@\[\]\^`\{\|\}~\"\\]*$/.test(attribute), 'Bad attribute value (' + attribute + ')');

    return attribute.replace(/\\/g, '\\\\').replace(/\"/g, '\\"');                             // Escape quotes and slash
};


exports.escapeHtml = function (string) {

    return Escape.escapeHtml(string);
};


exports.escapeJson = function (string) {

    return Escape.escapeJson(string);
};


exports.once = function (method) {

    if (method._hoekOnce) {
        return method;
    }

    let once = false;
    const wrapped = function (...args) {

        if (!once) {
            once = true;
            method(...args);
        }
    };

    wrapped._hoekOnce = true;
    return wrapped;
};


exports.ignore = function () { };


exports.uniqueFilename = function (path, extension) {

    if (extension) {
        extension = extension[0] !== '.' ? '.' + extension : extension;
    }
    else {
        extension = '';
    }

    path = Path.resolve(path);
    const name = [Date.now(), process.pid, Crypto.randomBytes(8).toString('hex')].join('-') + extension;
    return Path.join(path, name);
};


exports.stringify = function (...args) {

    try {
        return JSON.stringify.apply(null, args);
    }
    catch (err) {
        return '[Cannot display object: ' + err.message + ']';
    }
};


exports.wait = function (timeout) {

    return new Promise((resolve) => setTimeout(resolve, timeout));
};


exports.block = function () {

    return new Promise(exports.ignore);
};


/***/ }),

/***/ "./src/node_modules/@hapi/hoek/lib/types.js":
/*!**************************************************!*\
  !*** ./src/node_modules/@hapi/hoek/lib/types.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const internals = {};


exports = module.exports = {
    array: Array.prototype,
    buffer: Buffer.prototype,
    date: Date.prototype,
    error: Error.prototype,
    generic: Object.prototype,
    map: Map.prototype,
    promise: Promise.prototype,
    regex: RegExp.prototype,
    set: Set.prototype,
    weakMap: WeakMap.prototype,
    weakSet: WeakSet.prototype
};


internals.typeMap = new Map([
    ['[object Error]', exports.error],
    ['[object Map]', exports.map],
    ['[object Promise]', exports.promise],
    ['[object Set]', exports.set],
    ['[object WeakMap]', exports.weakMap],
    ['[object WeakSet]', exports.weakSet]
]);


exports.getInternalProto = function (obj) {

    if (Array.isArray(obj)) {
        return exports.array;
    }

    if (obj instanceof Buffer) {
        return exports.buffer;
    }

    if (obj instanceof Date) {
        return exports.date;
    }

    if (obj instanceof RegExp) {
        return exports.regex;
    }

    const objName = Object.prototype.toString.call(obj);
    return internals.typeMap.get(objName) || exports.generic;
};


/***/ }),

/***/ "./src/node_modules/@hapi/joi/lib/cast.js":
/*!************************************************!*\
  !*** ./src/node_modules/@hapi/joi/lib/cast.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Hoek = __webpack_require__(/*! @hapi/hoek */ "./src/node_modules/@hapi/hoek/lib/index.js");

const Ref = __webpack_require__(/*! ./ref */ "./src/node_modules/@hapi/joi/lib/ref.js");


const internals = {};


exports.schema = function (Joi, config) {

    if (config !== undefined && config !== null && typeof config === 'object') {

        if (config.isJoi) {
            return config;
        }

        if (Array.isArray(config)) {
            return Joi.alternatives().try(config);
        }

        if (config instanceof RegExp) {
            return Joi.string().regex(config);
        }

        if (config instanceof Date) {
            return Joi.date().valid(config);
        }

        return Joi.object().keys(config);
    }

    if (typeof config === 'string') {
        return Joi.string().valid(config);
    }

    if (typeof config === 'number') {
        return Joi.number().valid(config);
    }

    if (typeof config === 'boolean') {
        return Joi.boolean().valid(config);
    }

    if (Ref.isRef(config)) {
        return Joi.valid(config);
    }

    Hoek.assert(config === null, 'Invalid schema content:', config);

    return Joi.valid(null);
};


exports.ref = function (id) {

    return Ref.isRef(id) ? id : Ref.create(id);
};


/***/ }),

/***/ "./src/node_modules/@hapi/joi/lib/errors.js":
/*!**************************************************!*\
  !*** ./src/node_modules/@hapi/joi/lib/errors.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Hoek = __webpack_require__(/*! @hapi/hoek */ "./src/node_modules/@hapi/hoek/lib/index.js");

const Language = __webpack_require__(/*! ./language */ "./src/node_modules/@hapi/joi/lib/language.js");


const internals = {
    annotations: Symbol('joi-annotations')
};


internals.stringify = function (value, wrapArrays) {

    const type = typeof value;

    if (value === null) {
        return 'null';
    }

    if (type === 'string') {
        return value;
    }

    if (value instanceof exports.Err || type === 'function' || type === 'symbol') {
        return value.toString();
    }

    if (type === 'object') {
        if (Array.isArray(value)) {
            let partial = '';

            for (let i = 0; i < value.length; ++i) {
                partial = partial + (partial.length ? ', ' : '') + internals.stringify(value[i], wrapArrays);
            }

            return wrapArrays ? '[' + partial + ']' : partial;
        }

        return value.toString();
    }

    return JSON.stringify(value);
};


exports.Err = class {

    constructor(type, context, state, options, flags, message, template) {

        this.isJoi = true;
        this.type = type;
        this.context = context || {};
        this.context.key = state.path[state.path.length - 1];
        this.context.label = state.key;
        this.path = state.path;
        this.options = options;
        this.flags = flags;
        this.message = message;
        this.template = template;

        const localized = this.options.language;

        if (this.flags.label) {
            this.context.label = this.flags.label;
        }
        else if (localized &&                   // language can be null for arrays exclusion check
            (this.context.label === '' ||
            this.context.label === null)) {
            this.context.label = localized.root || Language.errors.root;
        }
    }

    toString() {

        if (this.message) {
            return this.message;
        }

        let format;

        if (this.template) {
            format = this.template;
        }

        const localized = this.options.language;

        format = format || Hoek.reach(localized, this.type) || Hoek.reach(Language.errors, this.type);

        if (format === undefined) {
            return `Error code "${this.type}" is not defined, your custom type is missing the correct language definition`;
        }

        let wrapArrays = Hoek.reach(localized, 'messages.wrapArrays');
        if (typeof wrapArrays !== 'boolean') {
            wrapArrays = Language.errors.messages.wrapArrays;
        }

        if (format === null) {
            const childrenString = internals.stringify(this.context.reason, wrapArrays);
            if (wrapArrays) {
                return childrenString.slice(1, -1);
            }

            return childrenString;
        }

        const hasKey = /{{!?label}}/.test(format);
        const skipKey = format.length > 2 && format[0] === '!' && format[1] === '!';

        if (skipKey) {
            format = format.slice(2);
        }

        if (!hasKey && !skipKey) {
            const localizedKey = Hoek.reach(localized, 'key');
            if (typeof localizedKey === 'string') {
                format = localizedKey + format;
            }
            else {
                format = Hoek.reach(Language.errors, 'key') + format;
            }
        }

        const message =  format.replace(/{{(!?)([^}]+)}}/g, ($0, isSecure, name) => {

            const value = Hoek.reach(this.context, name);
            const normalized = internals.stringify(value, wrapArrays);
            return (isSecure && this.options.escapeHtml ? Hoek.escapeHtml(normalized) : normalized);
        });

        this.toString = () => message;  // Persist result of last toString call, it won't change

        return message;
    }

};


exports.create = function (type, context, state, options, flags, message, template) {

    return new exports.Err(type, context, state, options, flags, message, template);
};


exports.process = function (errors, object) {

    if (!errors) {
        return null;
    }

    // Construct error

    let message = '';
    const details = [];

    const processErrors = function (localErrors, parent, overrideMessage) {

        for (let i = 0; i < localErrors.length; ++i) {
            const item = localErrors[i];

            if (item instanceof Error) {
                return item;
            }

            if (item.flags.error && typeof item.flags.error !== 'function') {
                if (!item.flags.selfError || !item.context.reason) {
                    return item.flags.error;
                }
            }

            let itemMessage;
            if (parent === undefined) {
                itemMessage = item.toString();
                message = message + (message ? '. ' : '') + itemMessage;
            }

            // Do not push intermediate errors, we're only interested in leafs

            if (item.context.reason) {
                const override = processErrors(item.context.reason, item.path, item.type === 'override' ? item.message : null);
                if (override) {
                    return override;
                }
            }
            else {
                details.push({
                    message: overrideMessage || itemMessage || item.toString(),
                    path: item.path,
                    type: item.type,
                    context: item.context
                });
            }
        }
    };

    const override = processErrors(errors);
    if (override) {
        return override;
    }

    const error = new Error(message);
    error.isJoi = true;
    error.name = 'ValidationError';
    error.details = details;
    error._object = object;
    error.annotate = internals.annotate;
    return error;
};


// Inspired by json-stringify-safe

internals.safeStringify = function (obj, spaces) {

    return JSON.stringify(obj, internals.serializer(), spaces);
};


internals.serializer = function () {

    const keys = [];
    const stack = [];

    const cycleReplacer = (key, value) => {

        if (stack[0] === value) {
            return '[Circular ~]';
        }

        return '[Circular ~.' + keys.slice(0, stack.indexOf(value)).join('.') + ']';
    };

    return function (key, value) {

        if (stack.length > 0) {
            const thisPos = stack.indexOf(this);
            if (~thisPos) {
                stack.length = thisPos + 1;
                keys.length = thisPos + 1;
                keys[thisPos] = key;
            }
            else {
                stack.push(this);
                keys.push(key);
            }

            if (~stack.indexOf(value)) {
                value = cycleReplacer.call(this, key, value);
            }
        }
        else {
            stack.push(value);
        }

        if (value) {
            const annotations = value[internals.annotations];
            if (annotations) {
                if (Array.isArray(value)) {
                    const annotated = [];

                    for (let i = 0; i < value.length; ++i) {
                        if (annotations.errors[i]) {
                            annotated.push(`_$idx$_${annotations.errors[i].sort().join(', ')}_$end$_`);
                        }

                        annotated.push(value[i]);
                    }

                    value = annotated;
                }
                else {
                    const errorKeys = Object.keys(annotations.errors);
                    for (let i = 0; i < errorKeys.length; ++i) {
                        const errorKey = errorKeys[i];
                        value[`${errorKey}_$key$_${annotations.errors[errorKey].sort().join(', ')}_$end$_`] = value[errorKey];
                        value[errorKey] = undefined;
                    }

                    const missingKeys = Object.keys(annotations.missing);
                    for (let i = 0; i < missingKeys.length; ++i) {
                        const missingKey = missingKeys[i];
                        value[`_$miss$_${missingKey}|${annotations.missing[missingKey]}_$end$_`] = '__missing__';
                    }
                }

                return value;
            }
        }

        if (value === Infinity || value === -Infinity || Number.isNaN(value) ||
            typeof value === 'function' || typeof value === 'symbol') {
            return '[' + value.toString() + ']';
        }

        return value;
    };
};


internals.annotate = function (stripColorCodes) {

    const redFgEscape = stripColorCodes ? '' : '\u001b[31m';
    const redBgEscape = stripColorCodes ? '' : '\u001b[41m';
    const endColor = stripColorCodes ? '' : '\u001b[0m';

    if (typeof this._object !== 'object') {
        return this.details[0].message;
    }

    const obj = Hoek.clone(this._object || {});

    for (let i = this.details.length - 1; i >= 0; --i) {        // Reverse order to process deepest child first
        const pos = i + 1;
        const error = this.details[i];
        const path = error.path;
        let ref = obj;
        for (let j = 0; ; ++j) {
            const seg = path[j];

            if (ref.isImmutable) {
                ref = ref.clone();                              // joi schemas are not cloned by hoek, we have to take this extra step
            }

            if (j + 1 < path.length &&
                ref[seg] &&
                typeof ref[seg] !== 'string') {

                ref = ref[seg];
            }
            else {
                const refAnnotations = ref[internals.annotations] = ref[internals.annotations] || { errors: {}, missing: {} };
                const value = ref[seg];
                const cacheKey = seg || error.context.label;

                if (value !== undefined) {
                    refAnnotations.errors[cacheKey] = refAnnotations.errors[cacheKey] || [];
                    refAnnotations.errors[cacheKey].push(pos);
                }
                else {
                    refAnnotations.missing[cacheKey] = pos;
                }

                break;
            }
        }
    }

    const replacers = {
        key: /_\$key\$_([, \d]+)_\$end\$_"/g,
        missing: /"_\$miss\$_([^|]+)\|(\d+)_\$end\$_": "__missing__"/g,
        arrayIndex: /\s*"_\$idx\$_([, \d]+)_\$end\$_",?\n(.*)/g,
        specials: /"\[(NaN|Symbol.*|-?Infinity|function.*|\(.*)]"/g
    };

    let message = internals.safeStringify(obj, 2)
        .replace(replacers.key, ($0, $1) => `" ${redFgEscape}[${$1}]${endColor}`)
        .replace(replacers.missing, ($0, $1, $2) => `${redBgEscape}"${$1}"${endColor}${redFgEscape} [${$2}]: -- missing --${endColor}`)
        .replace(replacers.arrayIndex, ($0, $1, $2) => `\n${$2} ${redFgEscape}[${$1}]${endColor}`)
        .replace(replacers.specials, ($0, $1) => $1);

    message = `${message}\n${redFgEscape}`;

    for (let i = 0; i < this.details.length; ++i) {
        const pos = i + 1;
        message = `${message}\n[${pos}] ${this.details[i].message}`;
    }

    message = message + endColor;

    return message;
};


/***/ }),

/***/ "./src/node_modules/@hapi/joi/lib/index.js":
/*!*************************************************!*\
  !*** ./src/node_modules/@hapi/joi/lib/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Hoek = __webpack_require__(/*! @hapi/hoek */ "./src/node_modules/@hapi/hoek/lib/index.js");

const Any = __webpack_require__(/*! ./types/any */ "./src/node_modules/@hapi/joi/lib/types/any/index.js");
const Cast = __webpack_require__(/*! ./cast */ "./src/node_modules/@hapi/joi/lib/cast.js");
const Errors = __webpack_require__(/*! ./errors */ "./src/node_modules/@hapi/joi/lib/errors.js");
const Lazy = __webpack_require__(/*! ./types/lazy */ "./src/node_modules/@hapi/joi/lib/types/lazy/index.js");
const Ref = __webpack_require__(/*! ./ref */ "./src/node_modules/@hapi/joi/lib/ref.js");


const internals = {
    alternatives: __webpack_require__(/*! ./types/alternatives */ "./src/node_modules/@hapi/joi/lib/types/alternatives/index.js"),
    array: __webpack_require__(/*! ./types/array */ "./src/node_modules/@hapi/joi/lib/types/array/index.js"),
    boolean: __webpack_require__(/*! ./types/boolean */ "./src/node_modules/@hapi/joi/lib/types/boolean/index.js"),
    binary: __webpack_require__(/*! ./types/binary */ "./src/node_modules/@hapi/joi/lib/types/binary/index.js"),
    date: __webpack_require__(/*! ./types/date */ "./src/node_modules/@hapi/joi/lib/types/date/index.js"),
    func: __webpack_require__(/*! ./types/func */ "./src/node_modules/@hapi/joi/lib/types/func/index.js"),
    number: __webpack_require__(/*! ./types/number */ "./src/node_modules/@hapi/joi/lib/types/number/index.js"),
    object: __webpack_require__(/*! ./types/object */ "./src/node_modules/@hapi/joi/lib/types/object/index.js"),
    string: __webpack_require__(/*! ./types/string */ "./src/node_modules/@hapi/joi/lib/types/string/index.js"),
    symbol: __webpack_require__(/*! ./types/symbol */ "./src/node_modules/@hapi/joi/lib/types/symbol/index.js")
};


internals.callWithDefaults = function (schema, args) {

    Hoek.assert(this, 'Must be invoked on a Joi instance.');

    if (this._defaults) {
        schema = this._defaults(schema);
    }

    schema._currentJoi = this;

    return schema._init(...args);
};


internals.root = function () {

    const any = new Any();

    const root = any.clone();
    Any.prototype._currentJoi = root;
    root._currentJoi = root;
    root._binds = new Set(['any', 'alternatives', 'alt', 'array', 'bool', 'boolean', 'binary', 'date', 'func', 'number', 'object', 'string', 'symbol', 'validate', 'describe', 'compile', 'assert', 'attempt', 'lazy', 'defaults', 'extend', 'allow', 'valid', 'only', 'equal', 'invalid', 'disallow', 'not', 'required', 'exist', 'optional', 'forbidden', 'strip', 'when', 'empty', 'default']);

    root.any = function (...args) {

        Hoek.assert(args.length === 0, 'Joi.any() does not allow arguments.');

        return internals.callWithDefaults.call(this, any, args);
    };

    root.alternatives = root.alt = function (...args) {

        return internals.callWithDefaults.call(this, internals.alternatives, args);
    };

    root.array = function (...args) {

        Hoek.assert(args.length === 0, 'Joi.array() does not allow arguments.');

        return internals.callWithDefaults.call(this, internals.array, args);
    };

    root.boolean = root.bool = function (...args) {

        Hoek.assert(args.length === 0, 'Joi.boolean() does not allow arguments.');

        return internals.callWithDefaults.call(this, internals.boolean, args);
    };

    root.binary = function (...args) {

        Hoek.assert(args.length === 0, 'Joi.binary() does not allow arguments.');

        return internals.callWithDefaults.call(this, internals.binary, args);
    };

    root.date = function (...args) {

        Hoek.assert(args.length === 0, 'Joi.date() does not allow arguments.');

        return internals.callWithDefaults.call(this, internals.date, args);
    };

    root.func = function (...args) {

        Hoek.assert(args.length === 0, 'Joi.func() does not allow arguments.');

        return internals.callWithDefaults.call(this, internals.func, args);
    };

    root.number = function (...args) {

        Hoek.assert(args.length === 0, 'Joi.number() does not allow arguments.');

        return internals.callWithDefaults.call(this, internals.number, args);
    };

    root.object = function (...args) {

        return internals.callWithDefaults.call(this, internals.object, args);
    };

    root.string = function (...args) {

        Hoek.assert(args.length === 0, 'Joi.string() does not allow arguments.');

        return internals.callWithDefaults.call(this, internals.string, args);
    };

    root.symbol = function (...args) {

        Hoek.assert(args.length === 0, 'Joi.symbol() does not allow arguments.');

        return internals.callWithDefaults.call(this, internals.symbol, args);
    };

    root.ref = function (...args) {

        return Ref.create(...args);
    };

    root.isRef = function (ref) {

        return Ref.isRef(ref);
    };

    root.validate = function (value, ...args /*, [schema], [options], callback */) {

        const last = args[args.length - 1];
        const callback = typeof last === 'function' ? last : null;

        const count = args.length - (callback ? 1 : 0);
        if (count === 0) {
            return any.validate(value, callback);
        }

        const options = count === 2 ? args[1] : undefined;
        const schema = this.compile(args[0]);

        return schema._validateWithOptions(value, options, callback);
    };

    root.describe = function (...args) {

        const schema = args.length ? this.compile(args[0]) : any;
        return schema.describe();
    };

    root.compile = function (schema) {

        try {
            return Cast.schema(this, schema);
        }
        catch (err) {
            if (err.hasOwnProperty('path')) {
                err.message = err.message + '(' + err.path + ')';
            }

            throw err;
        }
    };

    root.assert = function (value, schema, message) {

        this.attempt(value, schema, message);
    };

    root.attempt = function (value, schema, message) {

        const result = this.validate(value, schema);
        const error = result.error;
        if (error) {
            if (!message) {
                if (typeof error.annotate === 'function') {
                    error.message = error.annotate();
                }

                throw error;
            }

            if (!(message instanceof Error)) {
                if (typeof error.annotate === 'function') {
                    error.message = `${message} ${error.annotate()}`;
                }

                throw error;
            }

            throw message;
        }

        return result.value;
    };

    root.reach = function (schema, path) {

        Hoek.assert(schema && schema instanceof Any, 'you must provide a joi schema');
        Hoek.assert(Array.isArray(path) || typeof path === 'string', 'path must be a string or an array of strings');

        const reach = (sourceSchema, schemaPath) => {

            if (!schemaPath.length) {
                return sourceSchema;
            }

            const children = sourceSchema._inner.children;
            if (!children) {
                return;
            }

            const key = schemaPath.shift();
            for (let i = 0; i < children.length; ++i) {
                const child = children[i];
                if (child.key === key) {
                    return reach(child.schema, schemaPath);
                }
            }
        };

        const schemaPath = typeof path === 'string' ? (path ? path.split('.') : []) : path.slice();

        return reach(schema, schemaPath);
    };

    root.lazy = function (...args) {

        return internals.callWithDefaults.call(this, Lazy, args);
    };

    root.defaults = function (fn) {

        Hoek.assert(typeof fn === 'function', 'Defaults must be a function');

        let joi = Object.create(this.any());
        joi = fn(joi);

        Hoek.assert(joi && joi instanceof this.constructor, 'defaults() must return a schema');

        Object.assign(joi, this, joi.clone()); // Re-add the types from `this` but also keep the settings from joi's potential new defaults

        joi._defaults = (schema) => {

            if (this._defaults) {
                schema = this._defaults(schema);
                Hoek.assert(schema instanceof this.constructor, 'defaults() must return a schema');
            }

            schema = fn(schema);
            Hoek.assert(schema instanceof this.constructor, 'defaults() must return a schema');
            return schema;
        };

        return joi;
    };

    root.bind = function () {

        const joi = Object.create(this);

        joi._binds.forEach((bind) => {

            joi[bind] = joi[bind].bind(joi);
        });

        return joi;
    };

    root.extend = function (...args) {

        const extensions = Hoek.flatten(args);
        Hoek.assert(extensions.length > 0, 'You need to provide at least one extension');

        this.assert(extensions, root.extensionsSchema);

        const joi = Object.create(this.any());
        Object.assign(joi, this);
        joi._currentJoi = joi;
        joi._binds = new Set(joi._binds);

        for (let i = 0; i < extensions.length; ++i) {
            let extension = extensions[i];

            if (typeof extension === 'function') {
                extension = extension(joi);
            }

            this.assert(extension, root.extensionSchema);

            const base = (extension.base || this.any()).clone(); // Cloning because we're going to override language afterwards
            const ctor = base.constructor;
            const type = class extends ctor { // eslint-disable-line no-loop-func

                constructor() {

                    super();
                    if (extension.base) {
                        Object.assign(this, base);
                    }

                    this._type = extension.name;
                }

            };

            if (extension.language) {
                const lang = {
                    [extension.name]: extension.language
                };
                type.prototype._language = Hoek.applyToDefaults(type.prototype._language || (base._settings && base._settings.language) || {}, lang);
            }


            if (extension.coerce) {
                type.prototype._coerce = function (value, state, options) {

                    if (ctor.prototype._coerce) {
                        const baseRet = ctor.prototype._coerce.call(this, value, state, options);

                        if (baseRet.errors) {
                            return baseRet;
                        }

                        value = baseRet.value;
                    }

                    const ret = extension.coerce.call(this, value, state, options);
                    if (ret instanceof Errors.Err) {
                        return { value, errors: ret };
                    }

                    return { value: ret };
                };
            }

            if (extension.pre) {
                type.prototype._base = function (value, state, options) {

                    if (ctor.prototype._base) {
                        const baseRet = ctor.prototype._base.call(this, value, state, options);

                        if (baseRet.errors) {
                            return baseRet;
                        }

                        value = baseRet.value;
                    }

                    const ret = extension.pre.call(this, value, state, options);
                    if (ret instanceof Errors.Err) {
                        return { value, errors: ret };
                    }

                    return { value: ret };
                };
            }

            if (extension.rules) {
                for (let j = 0; j < extension.rules.length; ++j) {
                    const rule = extension.rules[j];
                    const ruleArgs = rule.params ?
                        (rule.params instanceof Any ? rule.params._inner.children.map((k) => k.key) : Object.keys(rule.params)) :
                        [];
                    const validateArgs = rule.params ? Cast.schema(this, rule.params) : null;

                    type.prototype[rule.name] = function (...rArgs) { // eslint-disable-line no-loop-func

                        if (rArgs.length > ruleArgs.length) {
                            throw new Error('Unexpected number of arguments');
                        }

                        let hasRef = false;
                        let arg = {};

                        for (let k = 0; k < ruleArgs.length; ++k) {
                            arg[ruleArgs[k]] = rArgs[k];
                            if (!hasRef && Ref.isRef(rArgs[k])) {
                                hasRef = true;
                            }
                        }

                        if (validateArgs) {
                            arg = joi.attempt(arg, validateArgs);
                        }

                        let schema;
                        if (rule.validate && !rule.setup) {
                            const validate = function (value, state, options) {

                                return rule.validate.call(this, arg, value, state, options);
                            };

                            schema = this._test(rule.name, arg, validate, {
                                description: rule.description,
                                hasRef
                            });
                        }
                        else {
                            schema = this.clone();
                        }

                        if (rule.setup) {
                            const newSchema = rule.setup.call(schema, arg);
                            if (newSchema !== undefined) {
                                Hoek.assert(newSchema instanceof Any, `Setup of extension Joi.${this._type}().${rule.name}() must return undefined or a Joi object`);
                                schema = newSchema;
                            }

                            if (rule.validate) {
                                const validate = function (value, state, options) {

                                    return rule.validate.call(this, arg, value, state, options);
                                };

                                schema = schema._test(rule.name, arg, validate, {
                                    description: rule.description,
                                    hasRef
                                });
                            }
                        }

                        return schema;
                    };
                }
            }

            if (extension.describe) {
                type.prototype.describe = function () {

                    const description = ctor.prototype.describe.call(this);
                    return extension.describe.call(this, description);
                };
            }

            const instance = new type();
            joi[extension.name] = function (...extArgs) {

                return internals.callWithDefaults.call(this, instance, extArgs);
            };

            joi._binds.add(extension.name);
        }

        return joi;
    };

    root.extensionSchema = internals.object.keys({
        base: internals.object.type(Any, 'Joi object'),
        name: internals.string.required(),
        coerce: internals.func.arity(3),
        pre: internals.func.arity(3),
        language: internals.object,
        describe: internals.func.arity(1),
        rules: internals.array.items(internals.object.keys({
            name: internals.string.required(),
            setup: internals.func.arity(1),
            validate: internals.func.arity(4),
            params: [
                internals.object.pattern(/.*/, internals.object.type(Any, 'Joi object')),
                internals.object.type(internals.object.constructor, 'Joi object')
            ],
            description: [internals.string, internals.func.arity(1)]
        }).or('setup', 'validate'))
    }).strict();

    root.extensionsSchema = internals.array.items([internals.object, internals.func.arity(1)]).strict();

    root.version = __webpack_require__(/*! ../package.json */ "./src/node_modules/@hapi/joi/package.json").version;

    return root;
};


module.exports = internals.root();


/***/ }),

/***/ "./src/node_modules/@hapi/joi/lib/language.js":
/*!****************************************************!*\
  !*** ./src/node_modules/@hapi/joi/lib/language.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const internals = {};


exports.errors = {
    root: 'value',
    key: '"{{!label}}" ',
    messages: {
        wrapArrays: true
    },
    any: {
        unknown: 'is not allowed',
        invalid: 'contains an invalid value',
        empty: 'is not allowed to be empty',
        required: 'is required',
        allowOnly: 'must be one of {{valids}}',
        default: 'threw an error when running default method'
    },
    alternatives: {
        base: 'not matching any of the allowed alternatives',
        child: null
    },
    array: {
        base: 'must be an array',
        includes: 'at position {{pos}} does not match any of the allowed types',
        includesSingle: 'single value of "{{!label}}" does not match any of the allowed types',
        includesOne: 'at position {{pos}} fails because {{reason}}',
        includesOneSingle: 'single value of "{{!label}}" fails because {{reason}}',
        includesRequiredUnknowns: 'does not contain {{unknownMisses}} required value(s)',
        includesRequiredKnowns: 'does not contain {{knownMisses}}',
        includesRequiredBoth: 'does not contain {{knownMisses}} and {{unknownMisses}} other required value(s)',
        excludes: 'at position {{pos}} contains an excluded value',
        excludesSingle: 'single value of "{{!label}}" contains an excluded value',
        hasKnown: 'does not contain at least one required match for type "{{!patternLabel}}"',
        hasUnknown: 'does not contain at least one required match',
        min: 'must contain at least {{limit}} items',
        max: 'must contain less than or equal to {{limit}} items',
        length: 'must contain {{limit}} items',
        ordered: 'at position {{pos}} fails because {{reason}}',
        orderedLength: 'at position {{pos}} fails because array must contain at most {{limit}} items',
        ref: 'references "{{ref}}" which is not a positive integer',
        sparse: 'must not be a sparse array',
        unique: 'position {{pos}} contains a duplicate value'
    },
    boolean: {
        base: 'must be a boolean'
    },
    binary: {
        base: 'must be a buffer or a string',
        min: 'must be at least {{limit}} bytes',
        max: 'must be less than or equal to {{limit}} bytes',
        length: 'must be {{limit}} bytes'
    },
    date: {
        base: 'must be a number of milliseconds or valid date string',
        strict: 'must be a valid date',
        min: 'must be larger than or equal to "{{limit}}"',
        max: 'must be less than or equal to "{{limit}}"',
        less: 'must be less than "{{limit}}"',
        greater: 'must be greater than "{{limit}}"',
        isoDate: 'must be a valid ISO 8601 date',
        timestamp: {
            javascript: 'must be a valid timestamp or number of milliseconds',
            unix: 'must be a valid timestamp or number of seconds'
        },
        ref: 'references "{{ref}}" which is not a date'
    },
    function: {
        base: 'must be a Function',
        arity: 'must have an arity of {{n}}',
        minArity: 'must have an arity greater or equal to {{n}}',
        maxArity: 'must have an arity lesser or equal to {{n}}',
        ref: 'must be a Joi reference',
        class: 'must be a class'
    },
    lazy: {
        base: '!!schema error: lazy schema must be set',
        schema: '!!schema error: lazy schema function must return a schema'
    },
    object: {
        base: 'must be an object',
        child: '!!child "{{!child}}" fails because {{reason}}',
        min: 'must have at least {{limit}} children',
        max: 'must have less than or equal to {{limit}} children',
        length: 'must have {{limit}} children',
        allowUnknown: '!!"{{!child}}" is not allowed',
        with: '!!"{{mainWithLabel}}" missing required peer "{{peerWithLabel}}"',
        without: '!!"{{mainWithLabel}}" conflict with forbidden peer "{{peerWithLabel}}"',
        missing: 'must contain at least one of {{peersWithLabels}}',
        xor: 'contains a conflict between exclusive peers {{peersWithLabels}}',
        oxor: 'contains a conflict between optional exclusive peers {{peersWithLabels}}',
        and: 'contains {{presentWithLabels}} without its required peers {{missingWithLabels}}',
        nand: '!!"{{mainWithLabel}}" must not exist simultaneously with {{peersWithLabels}}',
        assert: '!!"{{ref}}" validation failed because "{{ref}}" failed to {{message}}',
        rename: {
            multiple: 'cannot rename child "{{from}}" because multiple renames are disabled and another key was already renamed to "{{to}}"',
            override: 'cannot rename child "{{from}}" because override is disabled and target "{{to}}" exists',
            regex: {
                multiple: 'cannot rename children {{from}} because multiple renames are disabled and another key was already renamed to "{{to}}"',
                override: 'cannot rename children {{from}} because override is disabled and target "{{to}}" exists'
            }
        },
        type: 'must be an instance of "{{type}}"',
        schema: 'must be a Joi instance'
    },
    number: {
        base: 'must be a number',
        unsafe: 'must be a safe number',
        min: 'must be larger than or equal to {{limit}}',
        max: 'must be less than or equal to {{limit}}',
        less: 'must be less than {{limit}}',
        greater: 'must be greater than {{limit}}',
        integer: 'must be an integer',
        negative: 'must be a negative number',
        positive: 'must be a positive number',
        precision: 'must have no more than {{limit}} decimal places',
        ref: 'references "{{ref}}" which is not a number',
        multiple: 'must be a multiple of {{multiple}}',
        port: 'must be a valid port'
    },
    string: {
        base: 'must be a string',
        min: 'length must be at least {{limit}} characters long',
        max: 'length must be less than or equal to {{limit}} characters long',
        length: 'length must be {{limit}} characters long',
        alphanum: 'must only contain alpha-numeric characters',
        token: 'must only contain alpha-numeric and underscore characters',
        regex: {
            base: 'with value "{{!value}}" fails to match the required pattern: {{pattern}}',
            name: 'with value "{{!value}}" fails to match the {{name}} pattern',
            invert: {
                base: 'with value "{{!value}}" matches the inverted pattern: {{pattern}}',
                name: 'with value "{{!value}}" matches the inverted {{name}} pattern'
            }
        },
        email: 'must be a valid email',
        uri: 'must be a valid uri',
        uriRelativeOnly: 'must be a valid relative uri',
        uriCustomScheme: 'must be a valid uri with a scheme matching the {{scheme}} pattern',
        isoDate: 'must be a valid ISO 8601 date',
        guid: 'must be a valid GUID',
        hex: 'must only contain hexadecimal characters',
        hexAlign: 'hex decoded representation must be byte aligned',
        base64: 'must be a valid base64 string',
        dataUri: 'must be a valid dataUri string',
        hostname: 'must be a valid hostname',
        normalize: 'must be unicode normalized in the {{form}} form',
        lowercase: 'must only contain lowercase characters',
        uppercase: 'must only contain uppercase characters',
        trim: 'must not have leading or trailing whitespace',
        creditCard: 'must be a credit card',
        ref: 'references "{{ref}}" which is not a number',
        ip: 'must be a valid ip address with a {{cidr}} CIDR',
        ipVersion: 'must be a valid ip address of one of the following versions {{version}} with a {{cidr}} CIDR'
    },
    symbol: {
        base: 'must be a symbol',
        map: 'must be one of {{map}}'
    }
};


/***/ }),

/***/ "./src/node_modules/@hapi/joi/lib/ref.js":
/*!***********************************************!*\
  !*** ./src/node_modules/@hapi/joi/lib/ref.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Hoek = __webpack_require__(/*! @hapi/hoek */ "./src/node_modules/@hapi/hoek/lib/index.js");


const internals = {};


exports.create = function (key, options) {

    Hoek.assert(typeof key === 'string', 'Invalid reference key:', key);

    const settings = Hoek.clone(options);         // options can be reused and modified

    const ref = function (value, validationOptions) {

        return Hoek.reach(ref.isContext ? validationOptions.context : value, ref.key, settings);
    };

    ref.isContext = (key[0] === ((settings && settings.contextPrefix) || '$'));
    ref.key = (ref.isContext ? key.slice(1) : key);
    ref.path = ref.key.split((settings && settings.separator) || '.');
    ref.depth = ref.path.length;
    ref.root = ref.path[0];
    ref.isJoi = true;

    ref.toString = function () {

        return (ref.isContext ? 'context:' : 'ref:') + ref.key;
    };

    return ref;
};


exports.isRef = function (ref) {

    return typeof ref === 'function' && ref.isJoi;
};


exports.push = function (array, ref) {

    if (exports.isRef(ref) &&
        !ref.isContext) {

        array.push(ref.root);
    }
};


/***/ }),

/***/ "./src/node_modules/@hapi/joi/lib/schemas.js":
/*!***************************************************!*\
  !*** ./src/node_modules/@hapi/joi/lib/schemas.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Joi = __webpack_require__(/*! ./index */ "./src/node_modules/@hapi/joi/lib/index.js");


const internals = {};


exports.options = Joi.object({
    abortEarly: Joi.boolean(),
    convert: Joi.boolean(),
    allowUnknown: Joi.boolean(),
    skipFunctions: Joi.boolean(),
    stripUnknown: [Joi.boolean(), Joi.object({ arrays: Joi.boolean(), objects: Joi.boolean() }).or('arrays', 'objects')],
    language: Joi.object(),
    presence: Joi.string().only('required', 'optional', 'forbidden', 'ignore'),
    context: Joi.object(),
    noDefaults: Joi.boolean(),
    escapeHtml: Joi.boolean()
}).strict();


/***/ }),

/***/ "./src/node_modules/@hapi/joi/lib/set.js":
/*!***********************************************!*\
  !*** ./src/node_modules/@hapi/joi/lib/set.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Ref = __webpack_require__(/*! ./ref */ "./src/node_modules/@hapi/joi/lib/ref.js");


const internals = {};


internals.extendedCheckForValue = function (value, insensitive) {

    const valueType = typeof value;

    if (valueType === 'object') {
        if (value instanceof Date) {
            return (item) => {

                return item instanceof Date && value.getTime() === item.getTime();
            };
        }

        if (Buffer.isBuffer(value)) {
            return (item) => {

                return Buffer.isBuffer(item) && value.length === item.length && value.toString('binary') === item.toString('binary');
            };
        }
    }
    else if (insensitive && valueType === 'string') {
        const lowercaseValue = value.toLowerCase();
        return (item) => {

            return typeof item === 'string' && lowercaseValue === item.toLowerCase();
        };
    }

    return null;
};


module.exports = class InternalSet {

    constructor(from) {

        this._set = new Set(from);
        this._hasRef = false;
    }

    add(value, refs) {

        const isRef = Ref.isRef(value);
        if (!isRef && this.has(value, null, null, false)) {

            return this;
        }

        if (refs !== undefined) { // If it's a merge, we don't have any refs
            Ref.push(refs, value);
        }

        this._set.add(value);

        this._hasRef |= isRef;

        return this;
    }

    merge(add, remove) {

        for (const item of add._set) {
            this.add(item);
        }

        for (const item of remove._set) {
            this.remove(item);
        }

        return this;
    }

    remove(value) {

        this._set.delete(value);
        return this;
    }

    has(value, state, options, insensitive) {

        return !!this.get(value, state, options, insensitive);
    }

    get(value, state, options, insensitive) {

        if (!this._set.size) {
            return false;
        }

        const hasValue = this._set.has(value);
        if (hasValue) {
            return { value };
        }

        const extendedCheck = internals.extendedCheckForValue(value, insensitive);
        if (!extendedCheck) {
            if (state && this._hasRef) {
                for (let item of this._set) {
                    if (Ref.isRef(item)) {
                        item = [].concat(item(state.reference || state.parent, options));
                        const found = item.indexOf(value);
                        if (found >= 0) {
                            return { value: item[found] };
                        }
                    }
                }
            }

            return false;
        }

        return this._has(value, state, options, extendedCheck);
    }

    _has(value, state, options, check) {

        const checkRef = !!(state && this._hasRef);

        const isReallyEqual = function (item) {

            if (value === item) {
                return true;
            }

            return check(item);
        };

        for (let item of this._set) {
            if (checkRef && Ref.isRef(item)) { // Only resolve references if there is a state, otherwise it's a merge
                item = item(state.reference || state.parent, options);

                if (Array.isArray(item)) {
                    const found = item.findIndex(isReallyEqual);
                    if (found >= 0) {
                        return {
                            value: item[found]
                        };
                    }

                    continue;
                }
            }

            if (isReallyEqual(item)) {
                return {
                    value: item
                };
            }
        }

        return false;
    }

    values(options) {

        if (options && options.stripUndefined) {
            const values = [];

            for (const item of this._set) {
                if (item !== undefined) {
                    values.push(item);
                }
            }

            return values;
        }

        return Array.from(this._set);
    }

    slice() {

        const set = new InternalSet(this._set);
        set._hasRef = this._hasRef;
        return set;
    }

    concat(source) {

        const set = new InternalSet([...this._set, ...source._set]);
        set._hasRef = !!(this._hasRef | source._hasRef);
        return set;
    }
};


/***/ }),

/***/ "./src/node_modules/@hapi/joi/lib/types/alternatives/index.js":
/*!********************************************************************!*\
  !*** ./src/node_modules/@hapi/joi/lib/types/alternatives/index.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Hoek = __webpack_require__(/*! @hapi/hoek */ "./src/node_modules/@hapi/hoek/lib/index.js");

const Any = __webpack_require__(/*! ../any */ "./src/node_modules/@hapi/joi/lib/types/any/index.js");
const Cast = __webpack_require__(/*! ../../cast */ "./src/node_modules/@hapi/joi/lib/cast.js");
const Ref = __webpack_require__(/*! ../../ref */ "./src/node_modules/@hapi/joi/lib/ref.js");


const internals = {};


internals.Alternatives = class extends Any {

    constructor() {

        super();
        this._type = 'alternatives';
        this._invalids.remove(null);
        this._inner.matches = [];
    }

    _init(...args) {

        return args.length ? this.try(...args) : this;
    }

    _base(value, state, options) {

        const errors = [];
        const il = this._inner.matches.length;
        const baseType = this._baseType;

        for (let i = 0; i < il; ++i) {
            const item = this._inner.matches[i];
            if (!item.schema) {
                const schema = item.peek || item.is;
                const input = item.is ? item.ref(state.reference || state.parent, options) : value;
                const failed = schema._validate(input, null, options, state.parent).errors;

                if (failed) {
                    if (item.otherwise) {
                        return item.otherwise._validate(value, state, options);
                    }
                }
                else if (item.then) {
                    return item.then._validate(value, state, options);
                }

                if (i === (il - 1) && baseType) {
                    return baseType._validate(value, state, options);
                }

                continue;
            }

            const result = item.schema._validate(value, state, options);
            if (!result.errors) {     // Found a valid match
                return result;
            }

            errors.push(...result.errors);
        }

        if (errors.length) {
            return { errors: this.createError('alternatives.child', { reason: errors }, state, options) };
        }

        return { errors: this.createError('alternatives.base', null, state, options) };
    }

    try(...schemas) {

        schemas = Hoek.flatten(schemas);
        Hoek.assert(schemas.length, 'Cannot add other alternatives without at least one schema');

        const obj = this.clone();

        for (let i = 0; i < schemas.length; ++i) {
            const cast = Cast.schema(this._currentJoi, schemas[i]);
            if (cast._refs.length) {
                obj._refs.push(...cast._refs);
            }

            obj._inner.matches.push({ schema: cast });
        }

        return obj;
    }

    when(condition, options) {

        let schemaCondition = false;
        Hoek.assert(Ref.isRef(condition) || typeof condition === 'string' || (schemaCondition = condition instanceof Any), 'Invalid condition:', condition);
        Hoek.assert(options, 'Missing options');
        Hoek.assert(typeof options === 'object', 'Invalid options');
        if (schemaCondition) {
            Hoek.assert(!options.hasOwnProperty('is'), '"is" can not be used with a schema condition');
        }
        else {
            Hoek.assert(options.hasOwnProperty('is'), 'Missing "is" directive');
        }

        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of "then" or "otherwise"');

        const obj = this.clone();
        let is;
        if (!schemaCondition) {
            is = Cast.schema(this._currentJoi, options.is);

            if (options.is === null || !(Ref.isRef(options.is) || options.is instanceof Any)) {

                // Only apply required if this wasn't already a schema or a ref, we'll suppose people know what they're doing
                is = is.required();
            }
        }

        const item = {
            ref: schemaCondition ? null : Cast.ref(condition),
            peek: schemaCondition ? condition : null,
            is,
            then: options.then !== undefined ? Cast.schema(this._currentJoi, options.then) : undefined,
            otherwise: options.otherwise !== undefined ? Cast.schema(this._currentJoi, options.otherwise) : undefined
        };

        if (obj._baseType) {

            item.then = item.then && obj._baseType.concat(item.then);
            item.otherwise = item.otherwise && obj._baseType.concat(item.otherwise);
        }

        if (!schemaCondition) {
            Ref.push(obj._refs, item.ref);
            obj._refs.push(...item.is._refs);
        }

        if (item.then && item.then._refs.length) {
            obj._refs.push(...item.then._refs);
        }

        if (item.otherwise && item.otherwise._refs.length) {
            obj._refs.push(...item.otherwise._refs);
        }

        obj._inner.matches.push(item);

        return obj;
    }

    label(name) {

        const obj = super.label(name);
        obj._inner.matches = obj._inner.matches.map((match) => {

            if (match.schema) {
                return { schema: match.schema.label(name) };
            }

            match = Object.assign({}, match);
            if (match.then) {
                match.then = match.then.label(name);
            }

            if (match.otherwise) {
                match.otherwise = match.otherwise.label(name);
            }

            return match;
        });
        return obj;
    }

    describe() {

        const description = super.describe();
        const alternatives = [];
        for (let i = 0; i < this._inner.matches.length; ++i) {
            const item = this._inner.matches[i];
            if (item.schema) {

                // try()

                alternatives.push(item.schema.describe());
            }
            else {

                // when()

                const when = item.is ? {
                    ref: item.ref.toString(),
                    is: item.is.describe()
                } : {
                    peek: item.peek.describe()
                };

                if (item.then) {
                    when.then = item.then.describe();
                }

                if (item.otherwise) {
                    when.otherwise = item.otherwise.describe();
                }

                alternatives.push(when);
            }
        }

        description.alternatives = alternatives;
        return description;
    }

};


module.exports = new internals.Alternatives();


/***/ }),

/***/ "./src/node_modules/@hapi/joi/lib/types/any/index.js":
/*!***********************************************************!*\
  !*** ./src/node_modules/@hapi/joi/lib/types/any/index.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Hoek = __webpack_require__(/*! @hapi/hoek */ "./src/node_modules/@hapi/hoek/lib/index.js");
const Marker = __webpack_require__(/*! @hapi/marker */ "./src/node_modules/@hapi/marker/lib/index.js");

const Cast = __webpack_require__(/*! ../../cast */ "./src/node_modules/@hapi/joi/lib/cast.js");
const Settings = __webpack_require__(/*! ./settings */ "./src/node_modules/@hapi/joi/lib/types/any/settings.js");
const Ref = __webpack_require__(/*! ../../ref */ "./src/node_modules/@hapi/joi/lib/ref.js");
const Errors = __webpack_require__(/*! ../../errors */ "./src/node_modules/@hapi/joi/lib/errors.js");
const State = __webpack_require__(/*! ../state */ "./src/node_modules/@hapi/joi/lib/types/state.js");
const Symbols = __webpack_require__(/*! ../symbols */ "./src/node_modules/@hapi/joi/lib/types/symbols.js");

const Pkg = __webpack_require__(/*! ../../../package.json */ "./src/node_modules/@hapi/joi/package.json");

let Alternatives = null;                            // Delay-loaded to prevent circular dependencies
let Schemas = null;


const internals = {
    Set: __webpack_require__(/*! ../../set */ "./src/node_modules/@hapi/joi/lib/set.js"),
    symbol: Marker('joi-any-base')
};


internals.defaults = {
    abortEarly: true,
    convert: true,
    allowUnknown: false,
    skipFunctions: false,
    stripUnknown: false,
    language: {},
    presence: 'optional',
    noDefaults: false,
    escapeHtml: false

    // context: null
};


module.exports = internals.Any = class {

    constructor() {

        this.isJoi = true;
        this._type = 'any';
        this._settings = null;
        this._valids = new internals.Set();
        this._invalids = new internals.Set();
        this._tests = [];
        this._refs = [];
        this._flags = {
            /*
             presence: 'optional',                   // optional, required, forbidden, ignore
             allowOnly: false,
             allowUnknown: undefined,
             default: undefined,
             forbidden: false,
             encoding: undefined,
             insensitive: false,
             trim: false,
             normalize: undefined,                   // NFC, NFD, NFKC, NFKD
             case: undefined,                        // upper, lower
             empty: undefined,
             func: false,
             raw: false
             */
        };

        this._description = null;
        this._unit = null;
        this._notes = [];
        this._tags = [];
        this._examples = [];
        this._meta = [];

        this._inner = {};                           // Hash of arrays of immutable objects
    }

    _init() {

        return this;
    }

    get schemaType() {

        return this._type;
    }

    createError(type, context, state, options, flags = this._flags) {

        return Errors.create(type, context, state, options, flags);
    }

    createOverrideError(type, context, state, options, message, template) {

        return Errors.create(type, context, state, options, this._flags, message, template);
    }

    checkOptions(options) {

        Schemas = Schemas || __webpack_require__(/*! ../../schemas */ "./src/node_modules/@hapi/joi/lib/schemas.js");

        const result = Schemas.options.validate(options);

        if (result.error) {
            throw new Error(result.error.details[0].message);
        }
    }

    clone() {

        const obj = Object.create(Object.getPrototypeOf(this));

        obj.isJoi = true;
        obj._currentJoi = this._currentJoi;
        obj._type = this._type;
        obj._settings = this._settings;
        obj._baseType = this._baseType;
        obj._valids = this._valids.slice();
        obj._invalids = this._invalids.slice();
        obj._tests = this._tests.slice();
        obj._refs = this._refs.slice();
        obj._flags = Hoek.clone(this._flags);

        obj._description = this._description;
        obj._unit = this._unit;
        obj._notes = this._notes.slice();
        obj._tags = this._tags.slice();
        obj._examples = this._examples.slice();
        obj._meta = this._meta.slice();

        obj._inner = {};
        const inners = Object.keys(this._inner);
        for (let i = 0; i < inners.length; ++i) {
            const key = inners[i];
            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;
        }

        return obj;
    }

    concat(schema) {

        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');
        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);

        let obj = this.clone();

        if (this._type === 'any' && schema._type !== 'any') {

            // Reset values as if we were "this"
            const tmpObj = schema.clone();
            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',
                '_notes', '_tags', '_examples', '_meta', '_inner'];

            for (let i = 0; i < keysToRestore.length; ++i) {
                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];
            }

            obj = tmpObj;
        }

        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;
        obj._valids.merge(schema._valids, schema._invalids);
        obj._invalids.merge(schema._invalids, schema._valids);
        obj._tests.push(...schema._tests);
        obj._refs.push(...schema._refs);
        if (obj._flags.empty && schema._flags.empty) {
            obj._flags.empty = obj._flags.empty.concat(schema._flags.empty);
            const flags = Object.assign({}, schema._flags);
            delete flags.empty;
            Hoek.merge(obj._flags, flags);
        }
        else if (schema._flags.empty) {
            obj._flags.empty = schema._flags.empty;
            const flags = Object.assign({}, schema._flags);
            delete flags.empty;
            Hoek.merge(obj._flags, flags);
        }
        else {
            Hoek.merge(obj._flags, schema._flags);
        }

        obj._description = schema._description || obj._description;
        obj._unit = schema._unit || obj._unit;
        obj._notes.push(...schema._notes);
        obj._tags.push(...schema._tags);
        obj._examples.push(...schema._examples);
        obj._meta.push(...schema._meta);

        const inners = Object.keys(schema._inner);
        const isObject = obj._type === 'object';
        for (let i = 0; i < inners.length; ++i) {
            const key = inners[i];
            const source = schema._inner[key];
            if (source) {
                const target = obj._inner[key];
                if (target) {
                    if (isObject && key === 'children') {
                        const keys = {};

                        for (let j = 0; j < target.length; ++j) {
                            keys[target[j].key] = j;
                        }

                        for (let j = 0; j < source.length; ++j) {
                            const sourceKey = source[j].key;
                            if (keys[sourceKey] >= 0) {
                                target[keys[sourceKey]] = {
                                    key: sourceKey,
                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)
                                };
                            }
                            else {
                                target.push(source[j]);
                            }
                        }
                    }
                    else {
                        obj._inner[key] = obj._inner[key].concat(source);
                    }
                }
                else {
                    obj._inner[key] = source.slice();
                }
            }
        }

        return obj;
    }

    _test(name, arg, func, options) {

        const obj = this.clone();
        obj._tests.push({ func, name, arg, options });
        return obj;
    }

    _testUnique(name, arg, func, options) {

        const obj = this.clone();
        obj._tests = obj._tests.filter((test) => test.name !== name);
        obj._tests.push({ func, name, arg, options });
        return obj;
    }

    options(options) {

        Hoek.assert(!options.context, 'Cannot override context');
        this.checkOptions(options);

        const obj = this.clone();
        obj._settings = Settings.concat(obj._settings, options);
        return obj;
    }

    strict(isStrict) {

        const obj = this.clone();

        const convert = isStrict === undefined ? false : !isStrict;
        obj._settings = Settings.concat(obj._settings, { convert });
        return obj;
    }

    raw(isRaw) {

        const value = isRaw === undefined ? true : isRaw;

        if (this._flags.raw === value) {
            return this;
        }

        const obj = this.clone();
        obj._flags.raw = value;
        return obj;
    }

    error(err, options = { self: false }) {

        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');

        const unknownKeys = Object.keys(options).filter((k) => !['self'].includes(k));
        Hoek.assert(unknownKeys.length === 0, `Options ${unknownKeys} are unknown`);

        const obj = this.clone();
        obj._flags.error = err;

        if (options.self) {
            obj._flags.selfError = true;
        }

        return obj;
    }

    allow(...values) {

        const obj = this.clone();
        values = Hoek.flatten(values);
        for (let i = 0; i < values.length; ++i) {
            const value = values[i];

            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');
            obj._invalids.remove(value);
            obj._valids.add(value, obj._refs);
        }

        return obj;
    }

    valid(...values) {

        const obj = this.allow(...values);
        obj._flags.allowOnly = true;
        return obj;
    }

    invalid(...values) {

        const obj = this.clone();
        values = Hoek.flatten(values);
        for (let i = 0; i < values.length; ++i) {
            const value = values[i];

            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');
            obj._valids.remove(value);
            obj._invalids.add(value, obj._refs);
        }

        return obj;
    }

    required() {

        if (this._flags.presence === 'required') {
            return this;
        }

        const obj = this.clone();
        obj._flags.presence = 'required';
        return obj;
    }

    optional() {

        if (this._flags.presence === 'optional') {
            return this;
        }

        const obj = this.clone();
        obj._flags.presence = 'optional';
        return obj;
    }


    forbidden() {

        if (this._flags.presence === 'forbidden') {
            return this;
        }

        const obj = this.clone();
        obj._flags.presence = 'forbidden';
        return obj;
    }


    strip() {

        if (this._flags.strip) {
            return this;
        }

        const obj = this.clone();
        obj._flags.strip = true;
        return obj;
    }

    applyFunctionToChildren(children, fn, args = [], root) {

        children = [].concat(children);

        if (children.length !== 1 || children[0] !== '') {
            root = root ? (root + '.') : '';

            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {

                return root + child;
            });

            throw new Error('unknown key(s) ' + extraChildren.join(', '));
        }

        return this[fn](...args);
    }

    default(value, description) {

        if (typeof value === 'function' &&
            !Ref.isRef(value)) {

            if (!value.description &&
                description) {

                value.description = description;
            }

            if (!this._flags.func) {
                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');
            }
        }

        const obj = this.clone();
        obj._flags.default = value;
        Ref.push(obj._refs, value);
        return obj;
    }

    empty(schema) {

        const obj = this.clone();
        if (schema === undefined) {
            delete obj._flags.empty;
        }
        else {
            obj._flags.empty = Cast.schema(this._currentJoi, schema);
        }

        return obj;
    }

    when(condition, options) {

        Hoek.assert(options && typeof options === 'object', 'Invalid options');
        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of "then" or "otherwise"');

        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;
        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;

        Alternatives = Alternatives || __webpack_require__(/*! ../alternatives */ "./src/node_modules/@hapi/joi/lib/types/alternatives/index.js");

        const alternativeOptions = { then, otherwise };
        if (Object.prototype.hasOwnProperty.call(options, 'is')) {
            alternativeOptions.is = options.is;
        }

        const obj = Alternatives.when(condition, alternativeOptions);
        obj._flags.presence = 'ignore';
        obj._baseType = this;

        return obj;
    }

    description(desc) {

        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');

        const obj = this.clone();
        obj._description = desc;
        return obj;
    }

    notes(notes) {

        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');

        const obj = this.clone();
        obj._notes = obj._notes.concat(notes);
        return obj;
    }

    tags(tags) {

        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');

        const obj = this.clone();
        obj._tags = obj._tags.concat(tags);
        return obj;
    }

    meta(meta) {

        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');

        const obj = this.clone();
        obj._meta = obj._meta.concat(meta);
        return obj;
    }

    example(...examples) {

        Hoek.assert(examples.length > 0, 'Missing examples');

        const processed = [];
        for (let i = 0; i < examples.length; ++i) {
            const example = [].concat(examples[i]);
            Hoek.assert(example.length <= 2, `Bad example format at index ${i}`);

            const value = example[0];
            let options = example[1];
            if (options !== undefined) {
                Hoek.assert(options && typeof options === 'object', `Options for example at index ${i} must be an object`);
                const unknownOptions = Object.keys(options).filter((option) => !['parent', 'context'].includes(option));
                Hoek.assert(unknownOptions.length === 0, `Unknown example options ${unknownOptions} at index ${i}`);
            }
            else {
                options = {};
            }

            const localState = new State('', [], options.parent || null);
            const result = this._validate(value, localState, Settings.concat(internals.defaults, options.context ? { context: options.context } : null));
            Hoek.assert(!result.errors, `Bad example at index ${i}:`, result.errors && Errors.process(result.errors, value));

            const ex = { value };
            if (Object.keys(options).length) {
                ex.options = options;
            }

            processed.push(ex);
        }

        const obj = this.clone();
        obj._examples = processed;
        return obj;
    }

    unit(name) {

        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');

        const obj = this.clone();
        obj._unit = name;
        return obj;
    }

    _prepareEmptyValue(value) {

        if (typeof value === 'string' && this._flags.trim) {
            return value.trim();
        }

        return value;
    }

    _validate(value, state, options, reference) {

        const originalValue = value;

        // Setup state and settings

        state = state || new State('', [], null, reference);

        if (this._settings) {
            const isDefaultOptions = options === internals.defaults;
            if (isDefaultOptions && this._settings[Symbols.settingsCache]) {
                options = this._settings[Symbols.settingsCache];
            }
            else {
                options = Settings.concat(this._language ? Settings.concat({ language: this._language }, options) : options, this._settings);
                if (isDefaultOptions) {
                    this._settings[Symbols.settingsCache] = options;
                }
            }
        }
        else if (this._language) {
            options = Settings.concat({ language: this._language }, options);
        }

        let errors = [];

        if (this._coerce) {
            const coerced = this._coerce(value, state, options);
            if (coerced.errors) {
                value = coerced.value;
                errors = errors.concat(coerced.errors);
                return this._finalizeValue(value, originalValue, errors, state, options);                            // Coerced error always aborts early
            }

            value = coerced.value;
        }

        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {
            value = undefined;
        }

        // Check presence requirements

        const presence = this._flags.presence || options.presence;
        if (presence === 'optional') {
            if (value === undefined) {
                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;
                if (isDeepDefault && this._type === 'object') {
                    value = {};
                }
                else {
                    return this._finalizeValue(value, originalValue, errors, state, options);
                }
            }
        }
        else if (presence === 'required' &&
            value === undefined) {

            errors.push(this.createError('any.required', null, state, options));
            return this._finalizeValue(value, originalValue, errors, state, options);
        }
        else if (presence === 'forbidden') {
            if (value === undefined) {
                return this._finalizeValue(value, originalValue, errors, state, options);
            }

            errors.push(this.createError('any.unknown', null, state, options));
            return this._finalizeValue(value, originalValue, errors, state, options);
        }

        // Check allowed and denied values using the original value

        let match = this._valids.get(value, state, options, this._flags.insensitive);
        if (match) {
            if (options.convert) {
                value = match.value;
            }

            return this._finalizeValue(value, originalValue, errors, state, options);
        }

        if (this._invalids.has(value, state, options, this._flags.insensitive)) {
            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));
            if (options.abortEarly) {

                return this._finalizeValue(value, originalValue, errors, state, options);
            }
        }

        // Convert value and validate type

        if (this._base) {
            const base = this._base(value, state, options);
            if (base.errors) {
                value = base.value;
                errors = errors.concat(base.errors);
                return this._finalizeValue(value, originalValue, errors, state, options);                            // Base error always aborts early
            }

            if (base.value !== value) {
                value = base.value;

                // Check allowed and denied values using the converted value

                match = this._valids.get(value, state, options, this._flags.insensitive);
                if (match) {
                    value = match.value;
                    return this._finalizeValue(value, originalValue, errors, state, options);
                }

                if (this._invalids.has(value, state, options, this._flags.insensitive)) {
                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));
                    if (options.abortEarly) {
                        return this._finalizeValue(value, originalValue, errors, state, options);
                    }
                }
            }
        }

        // Required values did not match

        if (this._flags.allowOnly) {
            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));
            if (options.abortEarly) {
                return this._finalizeValue(value, originalValue, errors, state, options);
            }
        }

        // Validate tests

        for (let i = 0; i < this._tests.length; ++i) {
            const test = this._tests[i];
            const ret = test.func.call(this, value, state, options);
            if (ret instanceof Errors.Err) {
                errors.push(ret);
                if (options.abortEarly) {
                    return this._finalizeValue(value, originalValue, errors, state, options);
                }
            }
            else {
                value = ret;
            }
        }

        return this._finalizeValue(value, originalValue, errors, state, options);
    }

    _finalizeValue(value, originalValue, errors, state, options) {

        let finalValue;

        if (value !== undefined) {
            finalValue = this._flags.raw ? originalValue : value;
        }
        else if (options.noDefaults) {
            finalValue = value;
        }
        else if (Ref.isRef(this._flags.default)) {
            finalValue = this._flags.default(state.parent, options);
        }
        else if (typeof this._flags.default === 'function' &&
            !(this._flags.func && !this._flags.default.description)) {

            let args;

            if (state.parent !== null &&
                this._flags.default.length > 0) {

                args = [Hoek.clone(state.parent), options];
            }

            const defaultValue = internals._try(this._flags.default, args);
            finalValue = defaultValue.value;
            if (defaultValue.error) {
                errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));
            }
        }
        else {
            finalValue = Hoek.clone(this._flags.default);
        }

        if (errors.length &&
            typeof this._flags.error === 'function' &&
            (
                !this._flags.selfError ||
                errors.some((e) => state.path.length === e.path.length)
            )
        ) {
            const change = this._flags.error.call(this, errors);

            if (typeof change === 'string') {
                errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];
            }
            else {
                errors = [].concat(change)
                    .map((err) => {

                        return err instanceof Error ?
                            err :
                            this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);
                    });
            }
        }

        return {
            value: this._flags.strip ? undefined : finalValue,
            finalValue,
            errors: errors.length ? errors : null
        };
    }

    _validateWithOptions(value, options, callback) {

        if (options) {
            this.checkOptions(options);
        }

        const settings = Settings.concat(internals.defaults, options);
        const result = this._validate(value, null, settings);
        const errors = Errors.process(result.errors, value);

        if (callback) {
            return callback(errors, result.value);
        }

        return {
            error: errors,
            value: result.value,
            then(resolve, reject) {

                if (errors) {
                    return Promise.reject(errors).catch(reject);
                }

                return Promise.resolve(result.value).then(resolve);
            },
            catch(reject) {

                if (errors) {
                    return Promise.reject(errors).catch(reject);
                }

                return Promise.resolve(result.value);
            }
        };
    }

    validate(value, options, callback) {

        if (typeof options === 'function') {
            return this._validateWithOptions(value, null, options);
        }

        return this._validateWithOptions(value, options, callback);
    }

    describe() {

        const description = {
            type: this._type
        };

        const flags = Object.keys(this._flags);
        if (flags.length) {
            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {
                description.flags = {};
                for (let i = 0; i < flags.length; ++i) {
                    const flag = flags[i];
                    if (flag === 'empty') {
                        description.flags[flag] = this._flags[flag].describe();
                    }
                    else if (flag === 'default') {
                        if (Ref.isRef(this._flags[flag])) {
                            description.flags[flag] = this._flags[flag].toString();
                        }
                        else if (typeof this._flags[flag] === 'function') {
                            description.flags[flag] = {
                                description: this._flags[flag].description,
                                function   : this._flags[flag]
                            };
                        }
                        else {
                            description.flags[flag] = this._flags[flag];
                        }
                    }
                    else if (flag === 'lazy' || flag === 'label') {
                        // We don't want it in the description
                    }
                    else {
                        description.flags[flag] = this._flags[flag];
                    }
                }
            }
            else {
                description.flags = this._flags;
            }
        }

        if (this._settings) {
            description.options = Hoek.clone(this._settings);
        }

        if (this._baseType) {
            description.base = this._baseType.describe();
        }

        if (this._description) {
            description.description = this._description;
        }

        if (this._notes.length) {
            description.notes = this._notes;
        }

        if (this._tags.length) {
            description.tags = this._tags;
        }

        if (this._meta.length) {
            description.meta = this._meta;
        }

        if (this._examples.length) {
            description.examples = this._examples;
        }

        if (this._unit) {
            description.unit = this._unit;
        }

        const valids = this._valids.values();
        if (valids.length) {
            description.valids = valids.map((v) => {

                return Ref.isRef(v) ? v.toString() : v;
            });
        }

        const invalids = this._invalids.values();
        if (invalids.length) {
            description.invalids = invalids.map((v) => {

                return Ref.isRef(v) ? v.toString() : v;
            });
        }

        description.rules = [];

        for (let i = 0; i < this._tests.length; ++i) {
            const validator = this._tests[i];
            const item = { name: validator.name };

            if (validator.arg !== void 0) {
                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;
            }

            const options = validator.options;
            if (options) {
                if (options.hasRef) {
                    item.arg = {};
                    const keys = Object.keys(validator.arg);
                    for (let j = 0; j < keys.length; ++j) {
                        const key = keys[j];
                        const value = validator.arg[key];
                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;
                    }
                }

                if (typeof options.description === 'string') {
                    item.description = options.description;
                }
                else if (typeof options.description === 'function') {
                    item.description = options.description(item.arg);
                }
            }

            description.rules.push(item);
        }

        if (!description.rules.length) {
            delete description.rules;
        }

        const label = this._getLabel();
        if (label) {
            description.label = label;
        }

        return description;
    }

    label(name) {

        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');

        const obj = this.clone();
        obj._flags.label = name;
        return obj;
    }

    _getLabel(def) {

        return this._flags.label || def;
    }

};


internals.Any.prototype.isImmutable = true;     // Prevents Hoek from deep cloning schema objects

// Aliases

internals.Any.prototype.only = internals.Any.prototype.equal = internals.Any.prototype.valid;
internals.Any.prototype.disallow = internals.Any.prototype.not = internals.Any.prototype.invalid;
internals.Any.prototype.exist = internals.Any.prototype.required;


internals.Any.prototype[internals.symbol] = {
    version: Pkg.version,
    compile: Cast.schema,
    root: '_currentJoi'
};


internals._try = function (fn, args = []) {

    let err;
    let result;

    try {
        result = fn(...args);
    }
    catch (e) {
        err = e;
    }

    return {
        value: result,
        error: err
    };
};


/***/ }),

/***/ "./src/node_modules/@hapi/joi/lib/types/any/settings.js":
/*!**************************************************************!*\
  !*** ./src/node_modules/@hapi/joi/lib/types/any/settings.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Hoek = __webpack_require__(/*! @hapi/hoek */ "./src/node_modules/@hapi/hoek/lib/index.js");

const Symbols = __webpack_require__(/*! ../symbols */ "./src/node_modules/@hapi/joi/lib/types/symbols.js");


const internals = {};


exports.concat = function (target, source) {

    if (!source) {
        return target;
    }

    const obj = Object.assign({}, target);

    const language = source.language;

    Object.assign(obj, source);

    if (language && target && target.language) {
        obj.language = Hoek.applyToDefaults(target.language, language);
    }

    if (obj[Symbols.settingsCache]) {
        delete obj[Symbols.settingsCache];
    }

    return obj;
};


/***/ }),

/***/ "./src/node_modules/@hapi/joi/lib/types/array/index.js":
/*!*************************************************************!*\
  !*** ./src/node_modules/@hapi/joi/lib/types/array/index.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Hoek = __webpack_require__(/*! @hapi/hoek */ "./src/node_modules/@hapi/hoek/lib/index.js");

const Any = __webpack_require__(/*! ../any */ "./src/node_modules/@hapi/joi/lib/types/any/index.js");
const Cast = __webpack_require__(/*! ../../cast */ "./src/node_modules/@hapi/joi/lib/cast.js");
const Ref = __webpack_require__(/*! ../../ref */ "./src/node_modules/@hapi/joi/lib/ref.js");
const State = __webpack_require__(/*! ../state */ "./src/node_modules/@hapi/joi/lib/types/state.js");


const internals = {};


internals.fastSplice = function (arr, i) {

    let pos = i;
    while (pos < arr.length) {
        arr[pos++] = arr[pos];
    }

    --arr.length;
};


internals.Array = class extends Any {

    constructor() {

        super();
        this._type = 'array';
        this._inner.items = [];
        this._inner.ordereds = [];
        this._inner.inclusions = [];
        this._inner.exclusions = [];
        this._inner.requireds = [];
        this._flags.sparse = false;
    }

    _base(value, state, options) {

        const result = {
            value
        };

        if (typeof value === 'string' &&
            options.convert) {

            if (value.length > 1 &&
                (value[0] === '[' || /^\s*\[/.test(value))) {

                try {
                    result.value = JSON.parse(value);
                }
                catch (e) { }
            }
        }

        let isArray = Array.isArray(result.value);
        const wasArray = isArray;
        if (options.convert && this._flags.single && !isArray) {
            result.value = [result.value];
            isArray = true;
        }

        if (!isArray) {
            result.errors = this.createError('array.base', null, state, options);
            return result;
        }

        if (this._inner.inclusions.length ||
            this._inner.exclusions.length ||
            this._inner.requireds.length ||
            this._inner.ordereds.length ||
            !this._flags.sparse) {

            // Clone the array so that we don't modify the original
            if (wasArray) {
                result.value = result.value.slice(0);
            }

            result.errors = this._checkItems(result.value, wasArray, state, options);

            if (result.errors && wasArray && options.convert && this._flags.single) {

                // Attempt a 2nd pass by putting the array inside one.
                const previousErrors = result.errors;

                result.value = [result.value];
                result.errors = this._checkItems(result.value, wasArray, state, options);

                if (result.errors) {

                    // Restore previous errors and value since this didn't validate either.
                    result.errors = previousErrors;
                    result.value = result.value[0];
                }
            }
        }

        return result;
    }

    _checkItems(items, wasArray, state, options) {

        const errors = [];
        let errored;

        const requireds = this._inner.requireds.slice();
        const ordereds = this._inner.ordereds.slice();
        const inclusions = [...this._inner.inclusions, ...requireds];

        let il = items.length;
        for (let i = 0; i < il; ++i) {
            errored = false;
            const item = items[i];
            let isValid = false;
            const key = wasArray ? i : state.key;
            const path = wasArray ? [...state.path, i] : state.path;
            const localState = new State(key, path, state.parent, state.reference);
            let res;

            // Sparse

            if (!this._flags.sparse && item === undefined) {
                errors.push(this.createError('array.sparse', null, { key: state.key, path: localState.path, pos: i }, options));

                if (options.abortEarly) {
                    return errors;
                }

                ordereds.shift();

                continue;
            }

            // Exclusions

            for (let j = 0; j < this._inner.exclusions.length; ++j) {
                res = this._inner.exclusions[j]._validate(item, localState, {});                // Not passing options to use defaults

                if (!res.errors) {
                    errors.push(this.createError(wasArray ? 'array.excludes' : 'array.excludesSingle', { pos: i, value: item }, { key: state.key, path: localState.path }, options));
                    errored = true;

                    if (options.abortEarly) {
                        return errors;
                    }

                    ordereds.shift();

                    break;
                }
            }

            if (errored) {
                continue;
            }

            // Ordered
            if (this._inner.ordereds.length) {
                if (ordereds.length > 0) {
                    const ordered = ordereds.shift();
                    res = ordered._validate(item, localState, options);
                    if (!res.errors) {
                        if (ordered._flags.strip) {
                            internals.fastSplice(items, i);
                            --i;
                            --il;
                        }
                        else if (!this._flags.sparse && res.value === undefined) {
                            errors.push(this.createError('array.sparse', null, { key: state.key, path: localState.path, pos: i }, options));

                            if (options.abortEarly) {
                                return errors;
                            }

                            continue;
                        }
                        else {
                            items[i] = res.value;
                        }
                    }
                    else {
                        errors.push(this.createError('array.ordered', { pos: i, reason: res.errors, value: item }, { key: state.key, path: localState.path }, options));
                        if (options.abortEarly) {
                            return errors;
                        }
                    }

                    continue;
                }
                else if (!this._inner.items.length) {
                    errors.push(this.createError('array.orderedLength', { pos: i, limit: this._inner.ordereds.length }, { key: state.key, path: localState.path }, options));
                    if (options.abortEarly) {
                        return errors;
                    }

                    continue;
                }
            }

            // Requireds

            const requiredChecks = [];
            let jl = requireds.length;
            for (let j = 0; j < jl; ++j) {
                res = requiredChecks[j] = requireds[j]._validate(item, localState, options);
                if (!res.errors) {
                    items[i] = res.value;
                    isValid = true;
                    internals.fastSplice(requireds, j);
                    --j;
                    --jl;

                    if (!this._flags.sparse && res.value === undefined) {
                        errors.push(this.createError('array.sparse', null, { key: state.key, path: localState.path, pos: i }, options));

                        if (options.abortEarly) {
                            return errors;
                        }
                    }

                    break;
                }
            }

            if (isValid) {
                continue;
            }

            // Inclusions

            const stripUnknown = options.stripUnknown && !!options.stripUnknown.arrays || false;

            jl = inclusions.length;
            for (let j = 0; j < jl; ++j) {
                const inclusion = inclusions[j];

                // Avoid re-running requireds that already didn't match in the previous loop
                const previousCheck = requireds.indexOf(inclusion);
                if (previousCheck !== -1) {
                    res = requiredChecks[previousCheck];
                }
                else {
                    res = inclusion._validate(item, localState, options);

                    if (!res.errors) {
                        if (inclusion._flags.strip) {
                            internals.fastSplice(items, i);
                            --i;
                            --il;
                        }
                        else if (!this._flags.sparse && res.value === undefined) {
                            errors.push(this.createError('array.sparse', null, { key: state.key, path: localState.path, pos: i }, options));
                            errored = true;
                        }
                        else {
                            items[i] = res.value;
                        }

                        isValid = true;
                        break;
                    }
                }

                // Return the actual error if only one inclusion defined
                if (jl === 1) {
                    if (stripUnknown) {
                        internals.fastSplice(items, i);
                        --i;
                        --il;
                        isValid = true;
                        break;
                    }

                    errors.push(this.createError(wasArray ? 'array.includesOne' : 'array.includesOneSingle', { pos: i, reason: res.errors, value: item }, { key: state.key, path: localState.path }, options));
                    errored = true;

                    if (options.abortEarly) {
                        return errors;
                    }

                    break;
                }
            }

            if (errored) {
                continue;
            }

            if (this._inner.inclusions.length && !isValid) {
                if (stripUnknown) {
                    internals.fastSplice(items, i);
                    --i;
                    --il;
                    continue;
                }

                errors.push(this.createError(wasArray ? 'array.includes' : 'array.includesSingle', { pos: i, value: item }, { key: state.key, path: localState.path }, options));

                if (options.abortEarly) {
                    return errors;
                }
            }
        }

        if (requireds.length) {
            this._fillMissedErrors(errors, requireds, state, options);
        }

        if (ordereds.length) {
            this._fillOrderedErrors(errors, ordereds, state, options);
        }

        return errors.length ? errors : null;
    }

    describe() {

        const description = super.describe();

        if (this._inner.ordereds.length) {
            description.orderedItems = [];

            for (let i = 0; i < this._inner.ordereds.length; ++i) {
                description.orderedItems.push(this._inner.ordereds[i].describe());
            }
        }

        if (this._inner.items.length) {
            description.items = [];

            for (let i = 0; i < this._inner.items.length; ++i) {
                description.items.push(this._inner.items[i].describe());
            }
        }

        if (description.rules) {
            for (let i = 0; i < description.rules.length; ++i) {
                const rule = description.rules[i];
                if (rule.name === 'has') {
                    rule.arg = rule.arg.describe();
                }
            }
        }

        return description;
    }

    items(...schemas) {

        const obj = this.clone();

        Hoek.flatten(schemas).forEach((type, index) => {

            try {
                type = Cast.schema(this._currentJoi, type);
            }
            catch (castErr) {
                if (castErr.hasOwnProperty('path')) {
                    castErr.path = index + '.' + castErr.path;
                }
                else {
                    castErr.path = index;
                }

                castErr.message = `${castErr.message}(${castErr.path})`;
                throw castErr;
            }

            obj._inner.items.push(type);

            if (type._flags.presence === 'required') {
                obj._inner.requireds.push(type);
            }
            else if (type._flags.presence === 'forbidden') {
                obj._inner.exclusions.push(type.optional());
            }
            else {
                obj._inner.inclusions.push(type);
            }
        });

        return obj;
    }

    ordered(...schemas) {

        const obj = this.clone();

        Hoek.flatten(schemas).forEach((type, index) => {

            try {
                type = Cast.schema(this._currentJoi, type);
            }
            catch (castErr) {
                if (castErr.hasOwnProperty('path')) {
                    castErr.path = index + '.' + castErr.path;
                }
                else {
                    castErr.path = index;
                }

                castErr.message = `${castErr.message}(${castErr.path})`;
                throw castErr;
            }

            obj._inner.ordereds.push(type);
        });

        return obj;
    }

    min(limit) {

        const isRef = Ref.isRef(limit);

        Hoek.assert((Number.isSafeInteger(limit) && limit >= 0) || isRef, 'limit must be a positive integer or reference');

        return this._testUnique('min', limit, function (value, state, options) {

            let compareTo;
            if (isRef) {
                compareTo = limit(state.reference || state.parent, options);

                if (!(Number.isSafeInteger(compareTo) && compareTo >= 0)) {
                    return this.createError('array.ref', { ref: limit, value: compareTo }, state, options);
                }
            }
            else {
                compareTo = limit;
            }

            if (value.length >= compareTo) {
                return value;
            }

            return this.createError('array.min', { limit, value }, state, options);
        });
    }

    max(limit) {

        const isRef = Ref.isRef(limit);

        Hoek.assert((Number.isSafeInteger(limit) && limit >= 0) || isRef, 'limit must be a positive integer or reference');

        return this._testUnique('max', limit, function (value, state, options) {

            let compareTo;
            if (isRef) {
                compareTo = limit(state.reference || state.parent, options);

                if (!(Number.isSafeInteger(compareTo) && compareTo >= 0)) {
                    return this.createError('array.ref', { ref: limit.key }, state, options);
                }
            }
            else {
                compareTo = limit;
            }

            if (value.length <= compareTo) {
                return value;
            }

            return this.createError('array.max', { limit, value }, state, options);
        });
    }

    length(limit) {

        const isRef = Ref.isRef(limit);

        Hoek.assert((Number.isSafeInteger(limit) && limit >= 0) || isRef, 'limit must be a positive integer or reference');

        return this._testUnique('length', limit, function (value, state, options) {

            let compareTo;
            if (isRef) {
                compareTo = limit(state.reference || state.parent, options);

                if (!(Number.isSafeInteger(compareTo) && compareTo >= 0)) {
                    return this.createError('array.ref', { ref: limit.key }, state, options);
                }
            }
            else {
                compareTo = limit;
            }

            if (value.length === compareTo) {
                return value;
            }

            return this.createError('array.length', { limit, value }, state, options);
        });
    }

    has(schema) {

        try {
            schema = Cast.schema(this._currentJoi, schema);
        }
        catch (castErr) {
            if (castErr.hasOwnProperty('path')) {
                castErr.message = `${castErr.message}(${castErr.path})`;
            }

            throw castErr;
        }

        return this._test('has', schema, function (value, state, options) {

            const isValid = value.some((item, idx) => {

                const localState = new State(idx, [...state.path, idx], state.key, state.reference);
                return !schema._validate(item, localState, options).errors;
            });

            if (isValid) {
                return value;
            }

            const patternLabel = schema._getLabel();
            if (patternLabel) {
                return this.createError('array.hasKnown', { patternLabel }, state, options);
            }

            return this.createError('array.hasUnknown', null, state, options);
        });
    }

    unique(comparator, configs) {

        Hoek.assert(comparator === undefined ||
            typeof comparator === 'function' ||
            typeof comparator === 'string', 'comparator must be a function or a string');

        Hoek.assert(configs === undefined ||
            typeof configs === 'object', 'configs must be an object');

        const settings = {
            ignoreUndefined: (configs && configs.ignoreUndefined) || false
        };


        if (typeof comparator === 'string') {
            settings.path = comparator;
        }
        else if (typeof comparator === 'function') {
            settings.comparator = comparator;
        }

        return this._test('unique', settings, function (value, state, options) {

            const found = {
                string: Object.create(null),
                number: Object.create(null),
                undefined: Object.create(null),
                boolean: Object.create(null),
                object: new Map(),
                function: new Map(),
                custom: new Map()
            };

            const compare = settings.comparator || Hoek.deepEqual;
            const ignoreUndefined = settings.ignoreUndefined;

            for (let i = 0; i < value.length; ++i) {
                const item = settings.path ? Hoek.reach(value[i], settings.path) : value[i];
                const records = settings.comparator ? found.custom : found[typeof item];

                // All available types are supported, so it's not possible to reach 100% coverage without ignoring this line.
                // I still want to keep the test for future js versions with new types (eg. Symbol).
                if (/* $lab:coverage:off$ */ records /* $lab:coverage:on$ */) {
                    if (records instanceof Map) {
                        const entries = records.entries();
                        let current;
                        while (!(current = entries.next()).done) {
                            if (compare(current.value[0], item)) {
                                const localState = new State(state.key, [...state.path, i], state.parent, state.reference);
                                const context = {
                                    pos: i,
                                    value: value[i],
                                    dupePos: current.value[1],
                                    dupeValue: value[current.value[1]]
                                };

                                if (settings.path) {
                                    context.path = settings.path;
                                }

                                return this.createError('array.unique', context, localState, options);
                            }
                        }

                        records.set(item, i);
                    }
                    else {
                        if ((!ignoreUndefined || item !== undefined) && records[item] !== undefined) {
                            const localState = new State(state.key, [...state.path, i], state.parent, state.reference);

                            const context = {
                                pos: i,
                                value: value[i],
                                dupePos: records[item],
                                dupeValue: value[records[item]]
                            };

                            if (settings.path) {
                                context.path = settings.path;
                            }

                            return this.createError('array.unique', context, localState, options);
                        }

                        records[item] = i;
                    }
                }
            }

            return value;
        });
    }

    sparse(enabled) {

        const value = enabled === undefined ? true : !!enabled;

        if (this._flags.sparse === value) {
            return this;
        }

        const obj = this.clone();
        obj._flags.sparse = value;
        return obj;
    }

    single(enabled) {

        const value = enabled === undefined ? true : !!enabled;

        if (this._flags.single === value) {
            return this;
        }

        const obj = this.clone();
        obj._flags.single = value;
        return obj;
    }

    _fillMissedErrors(errors, requireds, state, options) {

        const knownMisses = [];
        let unknownMisses = 0;
        for (let i = 0; i < requireds.length; ++i) {
            const label = requireds[i]._getLabel();
            if (label) {
                knownMisses.push(label);
            }
            else {
                ++unknownMisses;
            }
        }

        if (knownMisses.length) {
            if (unknownMisses) {
                errors.push(this.createError('array.includesRequiredBoth', { knownMisses, unknownMisses }, { key: state.key, path: state.path }, options));
            }
            else {
                errors.push(this.createError('array.includesRequiredKnowns', { knownMisses }, { key: state.key, path: state.path }, options));
            }
        }
        else {
            errors.push(this.createError('array.includesRequiredUnknowns', { unknownMisses }, { key: state.key, path: state.path }, options));
        }
    }


    _fillOrderedErrors(errors, ordereds, state, options) {

        const requiredOrdereds = [];

        for (let i = 0; i < ordereds.length; ++i) {
            const presence = Hoek.reach(ordereds[i], '_flags.presence');
            if (presence === 'required') {
                requiredOrdereds.push(ordereds[i]);
            }
        }

        if (requiredOrdereds.length) {
            this._fillMissedErrors(errors, requiredOrdereds, state, options);
        }
    }

};


module.exports = new internals.Array();


/***/ }),

/***/ "./src/node_modules/@hapi/joi/lib/types/binary/index.js":
/*!**************************************************************!*\
  !*** ./src/node_modules/@hapi/joi/lib/types/binary/index.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Hoek = __webpack_require__(/*! @hapi/hoek */ "./src/node_modules/@hapi/hoek/lib/index.js");

const Any = __webpack_require__(/*! ../any */ "./src/node_modules/@hapi/joi/lib/types/any/index.js");


const internals = {};


internals.Binary = class extends Any {

    constructor() {

        super();
        this._type = 'binary';
    }

    _base(value, state, options) {

        const result = {
            value
        };

        if (typeof value === 'string' &&
            options.convert) {

            try {
                result.value = Buffer.from(value, this._flags.encoding);
            }
            catch (e) { }
        }

        result.errors = Buffer.isBuffer(result.value) ? null : this.createError('binary.base', null, state, options);
        return result;
    }

    encoding(encoding) {

        Hoek.assert(Buffer.isEncoding(encoding), 'Invalid encoding:', encoding);

        if (this._flags.encoding === encoding) {
            return this;
        }

        const obj = this.clone();
        obj._flags.encoding = encoding;
        return obj;
    }

    min(limit) {

        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');

        return this._test('min', limit, function (value, state, options) {

            if (value.length >= limit) {
                return value;
            }

            return this.createError('binary.min', { limit, value }, state, options);
        });
    }

    max(limit) {

        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');

        return this._test('max', limit, function (value, state, options) {

            if (value.length <= limit) {
                return value;
            }

            return this.createError('binary.max', { limit, value }, state, options);
        });
    }

    length(limit) {

        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');

        return this._test('length', limit, function (value, state, options) {

            if (value.length === limit) {
                return value;
            }

            return this.createError('binary.length', { limit, value }, state, options);
        });
    }

};


module.exports = new internals.Binary();


/***/ }),

/***/ "./src/node_modules/@hapi/joi/lib/types/boolean/index.js":
/*!***************************************************************!*\
  !*** ./src/node_modules/@hapi/joi/lib/types/boolean/index.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Hoek = __webpack_require__(/*! @hapi/hoek */ "./src/node_modules/@hapi/hoek/lib/index.js");

const Any = __webpack_require__(/*! ../any */ "./src/node_modules/@hapi/joi/lib/types/any/index.js");


const internals = {
    Set: __webpack_require__(/*! ../../set */ "./src/node_modules/@hapi/joi/lib/set.js")
};


internals.Boolean = class extends Any {
    constructor() {

        super();
        this._type = 'boolean';
        this._flags.insensitive = true;
        this._inner.truthySet = new internals.Set();
        this._inner.falsySet = new internals.Set();
    }

    _base(value, state, options) {

        const result = {
            value
        };

        if (typeof value === 'string' &&
            options.convert) {

            const normalized = this._flags.insensitive ? value.toLowerCase() : value;
            result.value = (normalized === 'true' ? true
                : (normalized === 'false' ? false : value));
        }

        if (typeof result.value !== 'boolean') {
            result.value = (this._inner.truthySet.has(value, null, null, this._flags.insensitive) ? true
                : (this._inner.falsySet.has(value, null, null, this._flags.insensitive) ? false : value));
        }

        result.errors = (typeof result.value === 'boolean') ? null : this.createError('boolean.base', { value }, state, options);
        return result;
    }

    truthy(...values) {

        const obj = this.clone();
        values = Hoek.flatten(values);
        for (let i = 0; i < values.length; ++i) {
            const value = values[i];

            Hoek.assert(value !== undefined, 'Cannot call truthy with undefined');
            obj._inner.truthySet.add(value);
        }

        return obj;
    }

    falsy(...values) {

        const obj = this.clone();
        values = Hoek.flatten(values);
        for (let i = 0; i < values.length; ++i) {
            const value = values[i];

            Hoek.assert(value !== undefined, 'Cannot call falsy with undefined');
            obj._inner.falsySet.add(value);
        }

        return obj;
    }

    insensitive(enabled) {

        const insensitive = enabled === undefined ? true : !!enabled;

        if (this._flags.insensitive === insensitive) {
            return this;
        }

        const obj = this.clone();
        obj._flags.insensitive = insensitive;
        return obj;
    }

    describe() {

        const description = super.describe();
        description.truthy = [true, ...this._inner.truthySet.values()];
        description.falsy = [false, ...this._inner.falsySet.values()];
        return description;
    }
};


module.exports = new internals.Boolean();


/***/ }),

/***/ "./src/node_modules/@hapi/joi/lib/types/date/index.js":
/*!************************************************************!*\
  !*** ./src/node_modules/@hapi/joi/lib/types/date/index.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Hoek = __webpack_require__(/*! @hapi/hoek */ "./src/node_modules/@hapi/hoek/lib/index.js");

const Any = __webpack_require__(/*! ../any */ "./src/node_modules/@hapi/joi/lib/types/any/index.js");
const Ref = __webpack_require__(/*! ../../ref */ "./src/node_modules/@hapi/joi/lib/ref.js");


const internals = {};

internals.isoDate = /^(?:[-+]\d{2})?(?:\d{4}(?!\d{2}\b))(?:(-?)(?:(?:0[1-9]|1[0-2])(?:\1(?:[12]\d|0[1-9]|3[01]))?|W(?:[0-4]\d|5[0-2])(?:-?[1-7])?|(?:00[1-9]|0[1-9]\d|[12]\d{2}|3(?:[0-5]\d|6[1-6])))(?![T]$|[T][\d]+Z$)(?:[T\s](?:(?:(?:[01]\d|2[0-3])(?:(:?)[0-5]\d)?|24\:?00)(?:[.,]\d+(?!:))?)(?:\2[0-5]\d(?:[.,]\d+)?)?(?:[Z]|(?:[+-])(?:[01]\d|2[0-3])(?::?[0-5]\d)?)?)?)?$/;
internals.invalidDate = new Date('');
internals.isIsoDate = (() => {

    const isoString = internals.isoDate.toString();

    return (date) => {

        return date && (date.toString() === isoString);
    };
})();

internals.Date = class extends Any {

    constructor() {

        super();
        this._type = 'date';
    }

    _base(value, state, options) {

        const result = {
            value: (options.convert && internals.Date.toDate(value, this._flags.format, this._flags.timestamp, this._flags.multiplier)) || value
        };

        if (result.value instanceof Date && !isNaN(result.value.getTime())) {
            result.errors = null;
        }
        else if (!options.convert) {
            result.errors = this.createError('date.strict', { value }, state, options);
        }
        else {
            let type;
            if (internals.isIsoDate(this._flags.format)) {
                type = 'isoDate';
            }
            else if (this._flags.timestamp) {
                type = `timestamp.${this._flags.timestamp}`;
            }
            else {
                type = 'base';
            }

            result.errors = this.createError(`date.${type}`, { value }, state, options);
        }

        return result;
    }

    static toDate(value, format, timestamp, multiplier) {

        if (value instanceof Date) {
            return value;
        }

        if (typeof value === 'string' ||
            (typeof value === 'number' && !isNaN(value) && isFinite(value))) {

            const isIsoDate = format && internals.isIsoDate(format);
            if (!isIsoDate &&
                typeof value === 'string' &&
                /^[+-]?\d+(\.\d+)?$/.test(value)) {

                value = parseFloat(value);
            }

            let date;
            if (isIsoDate) {
                date = format.test(value) ? new Date(value.toString()) : internals.invalidDate;
            }
            else if (timestamp) {
                date = /^\s*$/.test(value) ? internals.invalidDate : new Date(value * multiplier);
            }
            else {
                date = new Date(value);
            }

            if (!isNaN(date.getTime())) {
                return date;
            }
        }

        return null;
    }

    iso() {

        if (this._flags.format === internals.isoDate) {
            return this;
        }

        const obj = this.clone();
        obj._flags.format = internals.isoDate;
        return obj;
    }

    timestamp(type = 'javascript') {

        const allowed = ['javascript', 'unix'];
        Hoek.assert(allowed.includes(type), '"type" must be one of "' + allowed.join('", "') + '"');

        if (this._flags.timestamp === type) {
            return this;
        }

        const obj = this.clone();
        obj._flags.timestamp = type;
        obj._flags.multiplier = type === 'unix' ? 1000 : 1;
        return obj;
    }

    _isIsoDate(value) {

        return internals.isoDate.test(value);
    }

};

internals.compare = function (type, compare) {

    return function (date) {

        const isNow = date === 'now';
        const isRef = Ref.isRef(date);

        if (!isNow && !isRef) {
            date = internals.Date.toDate(date);
        }

        Hoek.assert(date, 'Invalid date format');

        return this._test(type, date, function (value, state, options) {

            let compareTo;
            if (isNow) {
                compareTo = Date.now();
            }
            else if (isRef) {
                const refValue = date(state.reference || state.parent, options);
                compareTo = internals.Date.toDate(refValue);

                if (!compareTo) {
                    return this.createError('date.ref', { ref: date, value: refValue }, state, options);
                }

                compareTo = compareTo.getTime();
            }
            else {
                compareTo = date.getTime();
            }

            if (compare(value.getTime(), compareTo)) {
                return value;
            }

            return this.createError('date.' + type, { limit: new Date(compareTo), value }, state, options);
        });
    };
};


internals.Date.prototype.min = internals.compare('min', (value, date) => value >= date);
internals.Date.prototype.max = internals.compare('max', (value, date) => value <= date);
internals.Date.prototype.greater = internals.compare('greater', (value, date) => value > date);
internals.Date.prototype.less = internals.compare('less', (value, date) => value < date);


module.exports = new internals.Date();


/***/ }),

/***/ "./src/node_modules/@hapi/joi/lib/types/func/index.js":
/*!************************************************************!*\
  !*** ./src/node_modules/@hapi/joi/lib/types/func/index.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Hoek = __webpack_require__(/*! @hapi/hoek */ "./src/node_modules/@hapi/hoek/lib/index.js");

const ObjectType = __webpack_require__(/*! ../object */ "./src/node_modules/@hapi/joi/lib/types/object/index.js");
const Ref = __webpack_require__(/*! ../../ref */ "./src/node_modules/@hapi/joi/lib/ref.js");


const internals = {};


internals.Func = class extends ObjectType.constructor {

    constructor() {

        super();
        this._flags.func = true;
    }

    arity(n) {

        Hoek.assert(Number.isSafeInteger(n) && n >= 0, 'n must be a positive integer');

        return this._test('arity', n, function (value, state, options) {

            if (value.length === n) {
                return value;
            }

            return this.createError('function.arity', { n }, state, options);
        });
    }

    minArity(n) {

        Hoek.assert(Number.isSafeInteger(n) && n > 0, 'n must be a strict positive integer');

        return this._test('minArity', n, function (value, state, options) {

            if (value.length >= n) {
                return value;
            }

            return this.createError('function.minArity', { n }, state, options);
        });
    }

    maxArity(n) {

        Hoek.assert(Number.isSafeInteger(n) && n >= 0, 'n must be a positive integer');

        return this._test('maxArity', n, function (value, state, options) {

            if (value.length <= n) {
                return value;
            }

            return this.createError('function.maxArity', { n }, state, options);
        });
    }

    ref() {

        return this._test('ref', null, function (value, state, options) {

            if (Ref.isRef(value)) {
                return value;
            }

            return this.createError('function.ref', { value }, state, options);
        });
    }

    class() {

        return this._test('class', null, function (value, state, options) {

            if ((/^\s*class\s/).test(value.toString())) {
                return value;
            }

            return this.createError('function.class', { value }, state, options);
        });
    }
};

module.exports = new internals.Func();


/***/ }),

/***/ "./src/node_modules/@hapi/joi/lib/types/lazy/index.js":
/*!************************************************************!*\
  !*** ./src/node_modules/@hapi/joi/lib/types/lazy/index.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Hoek = __webpack_require__(/*! @hapi/hoek */ "./src/node_modules/@hapi/hoek/lib/index.js");

const Any = __webpack_require__(/*! ../any */ "./src/node_modules/@hapi/joi/lib/types/any/index.js");


const internals = {};


internals.Lazy = class extends Any {

    constructor() {

        super();
        this._type = 'lazy';
        this._flags.once = true;
        this._cache = null;
    }

    _init(fn, options) {

        return this.set(fn, options);
    }

    _base(value, state, options) {

        let schema;
        if (this._cache) {
            schema = this._cache;
        }
        else {
            const result = { value };
            const lazy = this._flags.lazy;

            if (!lazy) {
                result.errors = this.createError('lazy.base', null, state, options);
                return result;
            }

            schema = lazy();

            if (!(schema instanceof Any)) {
                result.errors = this.createError('lazy.schema', { schema }, state, options);
                return result;
            }

            if (this._flags.once) {
                this._cache = schema;
            }
        }

        return schema._validate(value, state, options);
    }

    set(fn, options) {

        Hoek.assert(typeof fn === 'function', 'You must provide a function as first argument');
        Hoek.assert(options === undefined || (options && typeof options === 'object' && !Array.isArray(options)), `Options must be an object`);

        if (options) {
            const unknownOptions = Object.keys(options).filter((key) => !['once'].includes(key));
            Hoek.assert(unknownOptions.length === 0, `Options contain unknown keys: ${unknownOptions}`);
            Hoek.assert(options.once === undefined || typeof options.once === 'boolean', 'Option "once" must be a boolean');
        }

        const obj = this.clone();
        obj._flags.lazy = fn;

        if (options && options.once !== obj._flags.once) {
            obj._flags.once = options.once;
        }

        return obj;
    }

};

module.exports = new internals.Lazy();


/***/ }),

/***/ "./src/node_modules/@hapi/joi/lib/types/number/index.js":
/*!**************************************************************!*\
  !*** ./src/node_modules/@hapi/joi/lib/types/number/index.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Hoek = __webpack_require__(/*! @hapi/hoek */ "./src/node_modules/@hapi/hoek/lib/index.js");

const Any = __webpack_require__(/*! ../any */ "./src/node_modules/@hapi/joi/lib/types/any/index.js");
const Ref = __webpack_require__(/*! ../../ref */ "./src/node_modules/@hapi/joi/lib/ref.js");


const internals = {
    precisionRx: /(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/,
    normalizeExponent(str) {

        return str
            .replace(/\.?0+e/, 'e')
            .replace(/e\+/, 'e')
            .replace(/^\+/, '')
            .replace(/^(-?)0+([1-9])/, '$1$2');
    },
    normalizeDecimal(str) {

        str = str
            .replace(/^\+/, '')
            .replace(/\.0+$/, '')
            .replace(/^(-?)0+([1-9])/, '$1$2');

        if (str.includes('.') && str.endsWith('0')) {
            str = str.replace(/0+$/, '');
        }

        return str;
    }
};


internals.Number = class extends Any {

    constructor() {

        super();
        this._type = 'number';
        this._flags.unsafe = false;
        this._invalids.add(Infinity);
        this._invalids.add(-Infinity);
    }

    _base(value, state, options) {

        const result = {
            errors: null,
            value
        };

        if (typeof value === 'string' &&
            options.convert) {

            const matches = value.match(/^\s*[+-]?\d+(?:\.\d+)?(?:e([+-]?\d+))?\s*$/i);
            if (matches) {

                value = value.trim();
                result.value = parseFloat(value);

                if (!this._flags.unsafe) {
                    if (value.includes('e')) {
                        if (internals.normalizeExponent(`${result.value / Math.pow(10, matches[1])}e${matches[1]}`) !== internals.normalizeExponent(value)) {
                            result.errors = this.createError('number.unsafe', { value }, state, options);
                            return result;
                        }
                    }
                    else {
                        if (result.value.toString() !== internals.normalizeDecimal(value)) {
                            result.errors = this.createError('number.unsafe', { value }, state, options);
                            return result;
                        }
                    }
                }
            }
        }

        const isNumber = typeof result.value === 'number' && !isNaN(result.value);

        if (options.convert && 'precision' in this._flags && isNumber) {

            // This is conceptually equivalent to using toFixed but it should be much faster
            const precision = Math.pow(10, this._flags.precision);
            result.value = Math.round(result.value * precision) / precision;
        }

        if (isNumber) {
            if (!this._flags.unsafe &&
                (value > Number.MAX_SAFE_INTEGER || value < Number.MIN_SAFE_INTEGER)) {
                result.errors = this.createError('number.unsafe', { value }, state, options);
            }
        }
        else {
            result.errors = this.createError('number.base', { value }, state, options);
        }

        return result;
    }

    multiple(base) {

        const isRef = Ref.isRef(base);

        if (!isRef) {
            Hoek.assert(typeof base === 'number' && isFinite(base), 'multiple must be a number');
            Hoek.assert(base > 0, 'multiple must be greater than 0');
        }

        return this._test('multiple', base, function (value, state, options) {

            const divisor = isRef ? base(state.reference || state.parent, options) : base;

            if (isRef && (typeof divisor !== 'number' || !isFinite(divisor))) {
                return this.createError('number.ref', { ref: base.key }, state, options);
            }

            if (value % divisor === 0) {
                return value;
            }

            return this.createError('number.multiple', { multiple: base, value }, state, options);
        });
    }

    integer() {

        return this._test('integer', undefined, function (value, state, options) {

            return Math.trunc(value) - value === 0 ? value : this.createError('number.integer', { value }, state, options);
        });
    }

    unsafe(enabled = true) {

        Hoek.assert(typeof enabled === 'boolean', 'enabled must be a boolean');

        if (this._flags.unsafe === enabled) {
            return this;
        }

        const obj = this.clone();
        obj._flags.unsafe = enabled;
        return obj;
    }

    negative() {

        return this._test('negative', undefined, function (value, state, options) {

            if (value < 0) {
                return value;
            }

            return this.createError('number.negative', { value }, state, options);
        });
    }

    positive() {

        return this._test('positive', undefined, function (value, state, options) {

            if (value > 0) {
                return value;
            }

            return this.createError('number.positive', { value }, state, options);
        });
    }

    precision(limit) {

        Hoek.assert(Number.isSafeInteger(limit), 'limit must be an integer');
        Hoek.assert(!('precision' in this._flags), 'precision already set');

        const obj = this._test('precision', limit, function (value, state, options) {

            const places = value.toString().match(internals.precisionRx);
            const decimals = Math.max((places[1] ? places[1].length : 0) - (places[2] ? parseInt(places[2], 10) : 0), 0);
            if (decimals <= limit) {
                return value;
            }

            return this.createError('number.precision', { limit, value }, state, options);
        });

        obj._flags.precision = limit;
        return obj;
    }

    port() {

        return this._test('port', undefined, function (value, state, options) {

            if (!Number.isSafeInteger(value) || value < 0 || value > 65535) {
                return this.createError('number.port', { value }, state, options);
            }

            return value;
        });
    }

};


internals.compare = function (type, compare) {

    return function (limit) {

        const isRef = Ref.isRef(limit);
        const isNumber = typeof limit === 'number' && !isNaN(limit);

        Hoek.assert(isNumber || isRef, 'limit must be a number or reference');

        return this._test(type, limit, function (value, state, options) {

            let compareTo;
            if (isRef) {
                compareTo = limit(state.reference || state.parent, options);

                if (!(typeof compareTo === 'number' && !isNaN(compareTo))) {
                    return this.createError('number.ref', { ref: limit.key }, state, options);
                }
            }
            else {
                compareTo = limit;
            }

            if (compare(value, compareTo)) {
                return value;
            }

            return this.createError('number.' + type, { limit: compareTo, value }, state, options);
        });
    };
};


internals.Number.prototype.min = internals.compare('min', (value, limit) => value >= limit);
internals.Number.prototype.max = internals.compare('max', (value, limit) => value <= limit);
internals.Number.prototype.greater = internals.compare('greater', (value, limit) => value > limit);
internals.Number.prototype.less = internals.compare('less', (value, limit) => value < limit);


module.exports = new internals.Number();


/***/ }),

/***/ "./src/node_modules/@hapi/joi/lib/types/object/index.js":
/*!**************************************************************!*\
  !*** ./src/node_modules/@hapi/joi/lib/types/object/index.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Hoek = __webpack_require__(/*! @hapi/hoek */ "./src/node_modules/@hapi/hoek/lib/index.js");
const Topo = __webpack_require__(/*! @hapi/topo */ "./src/node_modules/@hapi/topo/lib/index.js");

const Any = __webpack_require__(/*! ../any */ "./src/node_modules/@hapi/joi/lib/types/any/index.js");
const Errors = __webpack_require__(/*! ../../errors */ "./src/node_modules/@hapi/joi/lib/errors.js");
const Cast = __webpack_require__(/*! ../../cast */ "./src/node_modules/@hapi/joi/lib/cast.js");
const State = __webpack_require__(/*! ../state */ "./src/node_modules/@hapi/joi/lib/types/state.js");


const internals = {};


internals.Object = class extends Any {

    constructor() {

        super();
        this._type = 'object';
        this._inner.children = null;
        this._inner.renames = [];
        this._inner.dependencies = [];
        this._inner.patterns = [];
    }

    _init(...args) {

        return args.length ? this.keys(...args) : this;
    }

    _base(value, state, options) {

        let target = value;
        const errors = [];
        const finish = () => {

            return {
                value: target,
                errors: errors.length ? errors : null
            };
        };

        if (typeof value === 'string' &&
            options.convert) {

            if (value.length > 1 &&
                (value[0] === '{' || /^\s*\{/.test(value))) {

                try {
                    value = JSON.parse(value);
                }
                catch (e) { }
            }
        }

        const type = this._flags.func ? 'function' : 'object';
        if (!value ||
            typeof value !== type ||
            Array.isArray(value)) {

            errors.push(this.createError(type + '.base', { value }, state, options));
            return finish();
        }

        // Skip if there are no other rules to test

        if (!this._inner.renames.length &&
            !this._inner.dependencies.length &&
            !this._inner.children &&                    // null allows any keys
            !this._inner.patterns.length) {

            target = value;
            return finish();
        }

        // Ensure target is a local copy (parsed) or shallow copy

        if (target === value) {
            if (type === 'object') {
                target = Object.create(Object.getPrototypeOf(value));
            }
            else {
                target = function (...args) {

                    return value.apply(this, args);
                };

                target.prototype = Hoek.clone(value.prototype);
            }

            const valueKeys = Object.keys(value);
            for (let i = 0; i < valueKeys.length; ++i) {
                target[valueKeys[i]] = value[valueKeys[i]];
            }
        }
        else {
            target = value;
        }

        // Rename keys

        const renamed = {};
        for (let i = 0; i < this._inner.renames.length; ++i) {
            const rename = this._inner.renames[i];

            if (rename.isRegExp) {
                const targetKeys = Object.keys(target);
                const matchedTargetKeys = [];

                for (let j = 0; j < targetKeys.length; ++j) {
                    if (rename.from.test(targetKeys[j])) {
                        matchedTargetKeys.push(targetKeys[j]);
                    }
                }

                const allUndefined = matchedTargetKeys.every((key) => target[key] === undefined);
                if (rename.options.ignoreUndefined && allUndefined) {
                    continue;
                }

                if (!rename.options.multiple &&
                    renamed[rename.to]) {

                    errors.push(this.createError('object.rename.regex.multiple', { from: matchedTargetKeys, to: rename.to }, state, options));
                    if (options.abortEarly) {
                        return finish();
                    }
                }

                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&
                    !rename.options.override &&
                    !renamed[rename.to]) {

                    errors.push(this.createError('object.rename.regex.override', { from: matchedTargetKeys, to: rename.to }, state, options));
                    if (options.abortEarly) {
                        return finish();
                    }
                }

                if (allUndefined) {
                    delete target[rename.to];
                }
                else {
                    target[rename.to] = target[matchedTargetKeys[matchedTargetKeys.length - 1]];
                }

                renamed[rename.to] = true;

                if (!rename.options.alias) {
                    for (let j = 0; j < matchedTargetKeys.length; ++j) {
                        delete target[matchedTargetKeys[j]];
                    }
                }
            }
            else {
                if (rename.options.ignoreUndefined && target[rename.from] === undefined) {
                    continue;
                }

                if (!rename.options.multiple &&
                    renamed[rename.to]) {

                    errors.push(this.createError('object.rename.multiple', { from: rename.from, to: rename.to }, state, options));
                    if (options.abortEarly) {
                        return finish();
                    }
                }

                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&
                    !rename.options.override &&
                    !renamed[rename.to]) {

                    errors.push(this.createError('object.rename.override', { from: rename.from, to: rename.to }, state, options));
                    if (options.abortEarly) {
                        return finish();
                    }
                }

                if (target[rename.from] === undefined) {
                    delete target[rename.to];
                }
                else {
                    target[rename.to] = target[rename.from];
                }

                renamed[rename.to] = true;

                if (!rename.options.alias) {
                    delete target[rename.from];
                }
            }
        }

        // Validate schema

        if (!this._inner.children &&            // null allows any keys
            !this._inner.patterns.length &&
            !this._inner.dependencies.length) {

            return finish();
        }

        const unprocessed = new Set(Object.keys(target));

        if (this._inner.children) {
            const stripProps = [];

            for (let i = 0; i < this._inner.children.length; ++i) {
                const child = this._inner.children[i];
                const key = child.key;
                const item = target[key];

                unprocessed.delete(key);

                const localState = new State(key, [...state.path, key], target, state.reference);
                const result = child.schema._validate(item, localState, options);
                if (result.errors) {
                    errors.push(this.createError('object.child', { key, child: child.schema._getLabel(key), reason: result.errors }, localState, options));

                    if (options.abortEarly) {
                        return finish();
                    }
                }
                else {
                    if (child.schema._flags.strip || (result.value === undefined && result.value !== item)) {
                        stripProps.push(key);
                        target[key] = result.finalValue;
                    }
                    else if (result.value !== undefined) {
                        target[key] = result.value;
                    }
                }
            }

            for (let i = 0; i < stripProps.length; ++i) {
                delete target[stripProps[i]];
            }
        }

        // Unknown keys

        if (unprocessed.size && this._inner.patterns.length) {

            for (const key of unprocessed) {
                const localState = new State(key, [...state.path, key], target, state.reference);
                const item = target[key];

                for (let i = 0; i < this._inner.patterns.length; ++i) {
                    const pattern = this._inner.patterns[i];

                    if (pattern.regex ?
                        pattern.regex.test(key) :
                        !pattern.schema._validate(key, state, { ...options, abortEarly:true }).errors) {

                        unprocessed.delete(key);

                        const result = pattern.rule._validate(item, localState, options);
                        if (result.errors) {
                            errors.push(this.createError('object.child', {
                                key,
                                child: pattern.rule._getLabel(key),
                                reason: result.errors
                            }, localState, options));

                            if (options.abortEarly) {
                                return finish();
                            }
                        }

                        target[key] = result.value;
                    }
                }
            }
        }

        if (unprocessed.size && (this._inner.children || this._inner.patterns.length)) {
            if ((options.stripUnknown && this._flags.allowUnknown !== true) ||
                options.skipFunctions) {

                const stripUnknown = options.stripUnknown
                    ? (options.stripUnknown === true ? true : !!options.stripUnknown.objects)
                    : false;


                for (const key of unprocessed) {
                    if (stripUnknown) {
                        delete target[key];
                        unprocessed.delete(key);
                    }
                    else if (typeof target[key] === 'function') {
                        unprocessed.delete(key);
                    }
                }
            }

            if ((this._flags.allowUnknown !== undefined ? !this._flags.allowUnknown : !options.allowUnknown)) {

                for (const unprocessedKey of unprocessed) {
                    errors.push(this.createError('object.allowUnknown', { child: unprocessedKey, value: target[unprocessedKey] }, {
                        key: unprocessedKey,
                        path: [...state.path, unprocessedKey]
                    }, options, {}));
                }
            }
        }

        // Validate dependencies

        for (let i = 0; i < this._inner.dependencies.length; ++i) {
            const dep = this._inner.dependencies[i];
            const hasKey = dep.key !== null;
            const splitKey = hasKey && dep.key.split('.');
            const localState = hasKey ? new State(splitKey[splitKey.length - 1], [...state.path, ...splitKey]) : new State(null, state.path);
            const err = internals[dep.type].call(this, dep.key, hasKey && Hoek.reach(target, dep.key, { functions: true }), dep.peers, target, localState, options);
            if (err instanceof Errors.Err) {
                errors.push(err);
                if (options.abortEarly) {
                    return finish();
                }
            }
        }

        return finish();
    }

    keys(schema) {

        Hoek.assert(schema === null || schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');
        Hoek.assert(!schema || !(schema instanceof Any), 'Object schema cannot be a joi schema');

        const obj = this.clone();

        if (!schema) {
            obj._inner.children = null;
            return obj;
        }

        const children = Object.keys(schema);

        if (!children.length) {
            obj._inner.children = [];
            return obj;
        }

        const topo = new Topo();
        if (obj._inner.children) {
            for (let i = 0; i < obj._inner.children.length; ++i) {
                const child = obj._inner.children[i];

                // Only add the key if we are not going to replace it later
                if (!children.includes(child.key)) {
                    topo.add(child, { after: child._refs, group: child.key });
                }
            }
        }

        for (let i = 0; i < children.length; ++i) {
            const key = children[i];
            const child = schema[key];
            try {
                const cast = Cast.schema(this._currentJoi, child);
                topo.add({ key, schema: cast }, { after: cast._refs, group: key });
            }
            catch (castErr) {
                if (castErr.hasOwnProperty('path')) {
                    castErr.path = key + '.' + castErr.path;
                }
                else {
                    castErr.path = key;
                }

                throw castErr;
            }
        }

        obj._inner.children = topo.nodes;

        return obj;
    }

    append(schema) {
        // Skip any changes
        if (schema === null || schema === undefined || Object.keys(schema).length === 0) {
            return this;
        }

        return this.keys(schema);
    }

    unknown(allow) {

        const value = allow !== false;

        if (this._flags.allowUnknown === value) {
            return this;
        }

        const obj = this.clone();
        obj._flags.allowUnknown = value;
        return obj;
    }

    length(limit) {

        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');

        return this._test('length', limit, function (value, state, options) {

            if (Object.keys(value).length === limit) {
                return value;
            }

            return this.createError('object.length', { limit, value }, state, options);
        });
    }

    min(limit) {

        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');

        return this._test('min', limit, function (value, state, options) {

            if (Object.keys(value).length >= limit) {
                return value;
            }

            return this.createError('object.min', { limit, value }, state, options);
        });
    }

    max(limit) {

        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');

        return this._test('max', limit, function (value, state, options) {

            if (Object.keys(value).length <= limit) {
                return value;
            }

            return this.createError('object.max', { limit, value }, state, options);
        });
    }

    pattern(pattern, schema) {

        const isRegExp = pattern instanceof RegExp;
        Hoek.assert(isRegExp || pattern instanceof Any, 'pattern must be a regex or schema');
        Hoek.assert(schema !== undefined, 'Invalid rule');

        if (isRegExp) {
            Hoek.assert(!pattern.flags.includes('g') && !pattern.flags.includes('y'), 'pattern should not use global or sticky mode');
        }

        try {
            schema = Cast.schema(this._currentJoi, schema);
        }
        catch (castErr) {
            if (castErr.hasOwnProperty('path')) {
                castErr.message = `${castErr.message}(${castErr.path})`;
            }

            throw castErr;
        }

        const obj = this.clone();
        if (isRegExp) {
            obj._inner.patterns.push({ regex: pattern, rule: schema });
        }
        else {
            obj._inner.patterns.push({ schema: pattern, rule: schema });
        }

        return obj;
    }

    schema() {

        return this._test('schema', null, function (value, state, options) {

            if (value instanceof Any) {
                return value;
            }

            return this.createError('object.schema', null, state, options);
        });
    }

    with(key, peers) {

        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');

        return this._dependency('with', key, peers);
    }

    without(key, peers) {

        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');

        return this._dependency('without', key, peers);
    }

    xor(...peers) {

        peers = Hoek.flatten(peers);
        return this._dependency('xor', null, peers);
    }

    oxor(...peers) {

        return this._dependency('oxor', null, peers);
    }

    or(...peers) {

        peers = Hoek.flatten(peers);
        return this._dependency('or', null, peers);
    }

    and(...peers) {

        peers = Hoek.flatten(peers);
        return this._dependency('and', null, peers);
    }

    nand(...peers) {

        peers = Hoek.flatten(peers);
        return this._dependency('nand', null, peers);
    }

    requiredKeys(...children) {

        children = Hoek.flatten(children);
        return this.applyFunctionToChildren(children, 'required');
    }

    optionalKeys(...children) {

        children = Hoek.flatten(children);
        return this.applyFunctionToChildren(children, 'optional');
    }

    forbiddenKeys(...children) {

        children = Hoek.flatten(children);
        return this.applyFunctionToChildren(children, 'forbidden');
    }

    rename(from, to, options) {

        Hoek.assert(typeof from === 'string' || from instanceof RegExp, 'Rename missing the from argument');
        Hoek.assert(typeof to === 'string', 'Rename missing the to argument');
        Hoek.assert(to !== from, 'Cannot rename key to same name:', from);

        for (let i = 0; i < this._inner.renames.length; ++i) {
            Hoek.assert(this._inner.renames[i].from !== from, 'Cannot rename the same key multiple times');
        }

        const obj = this.clone();

        obj._inner.renames.push({
            from,
            to,
            options: Hoek.applyToDefaults(internals.renameDefaults, options || {}),
            isRegExp: from instanceof RegExp
        });

        return obj;
    }

    applyFunctionToChildren(children, fn, args = [], root) {

        children = [].concat(children);
        Hoek.assert(children.length > 0, 'expected at least one children');

        const groupedChildren = internals.groupChildren(children);
        let obj;

        if ('' in groupedChildren) {
            obj = this[fn](...args);
            delete groupedChildren[''];
        }
        else {
            obj = this.clone();
        }

        if (obj._inner.children) {
            root = root ? (root + '.') : '';

            for (let i = 0; i < obj._inner.children.length; ++i) {
                const child = obj._inner.children[i];
                const group = groupedChildren[child.key];

                if (group) {
                    obj._inner.children[i] = {
                        key: child.key,
                        _refs: child._refs,
                        schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)
                    };

                    delete groupedChildren[child.key];
                }
            }
        }

        const remaining = Object.keys(groupedChildren);
        Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));

        return obj;
    }

    _dependency(type, key, peers) {

        peers = [].concat(peers);
        for (let i = 0; i < peers.length; ++i) {
            Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');
        }

        const obj = this.clone();
        obj._inner.dependencies.push({ type, key, peers });
        return obj;
    }

    describe(shallow) {

        const description = super.describe();

        if (description.rules) {
            for (let i = 0; i < description.rules.length; ++i) {
                const rule = description.rules[i];
                // Coverage off for future-proof descriptions, only object().assert() is use right now
                if (/* $lab:coverage:off$ */rule.arg &&
                    typeof rule.arg === 'object' &&
                    rule.arg.schema &&
                    rule.arg.ref /* $lab:coverage:on$ */) {
                    rule.arg = {
                        schema: rule.arg.schema.describe(),
                        ref: rule.arg.ref.toString()
                    };
                }
            }
        }

        if (this._inner.children &&
            !shallow) {

            description.children = {};
            for (let i = 0; i < this._inner.children.length; ++i) {
                const child = this._inner.children[i];
                description.children[child.key] = child.schema.describe();
            }
        }

        if (this._inner.dependencies.length) {
            description.dependencies = Hoek.clone(this._inner.dependencies);
        }

        if (this._inner.patterns.length) {
            description.patterns = [];

            for (let i = 0; i < this._inner.patterns.length; ++i) {
                const pattern = this._inner.patterns[i];
                if (pattern.regex) {
                    description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });
                }
                else {
                    description.patterns.push({ schema: pattern.schema.describe(), rule: pattern.rule.describe() });
                }
            }
        }

        if (this._inner.renames.length > 0) {
            description.renames = Hoek.clone(this._inner.renames);
        }

        return description;
    }

    assert(ref, schema, message) {

        ref = Cast.ref(ref);
        Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');
        message = message || 'pass the assertion test';
        Hoek.assert(typeof message === 'string', 'Message must be a string');

        try {
            schema = Cast.schema(this._currentJoi, schema);
        }
        catch (castErr) {
            if (castErr.hasOwnProperty('path')) {
                castErr.message = `${castErr.message}(${castErr.path})`;
            }

            throw castErr;
        }

        const key = ref.path[ref.path.length - 1];
        const path = ref.path.join('.');

        return this._test('assert', { schema, ref }, function (value, state, options) {

            const result = schema._validate(ref(value), null, options, value);
            if (!result.errors) {
                return value;
            }

            const localState = new State(key, ref.path, state.parent, state.reference);
            return this.createError('object.assert', { ref: path, message }, localState, options);
        });
    }

    type(constructor, name = constructor.name) {

        Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');
        const typeData = {
            name,
            ctor: constructor
        };

        return this._test('type', typeData, function (value, state, options) {

            if (value instanceof constructor) {
                return value;
            }

            return this.createError('object.type', { type: typeData.name, value }, state, options);
        });
    }
};


internals.renameDefaults = {
    alias: false,                   // Keep old value in place
    multiple: false,                // Allow renaming multiple keys into the same target
    override: false                 // Overrides an existing key
};


internals.groupChildren = function (children) {

    children.sort();

    const grouped = {};

    for (let i = 0; i < children.length; ++i) {
        const child = children[i];
        Hoek.assert(typeof child === 'string', 'children must be strings');
        const group = child.split('.')[0];
        const childGroup = grouped[group] = (grouped[group] || []);
        childGroup.push(child.substring(group.length + 1));
    }

    return grouped;
};


internals.keysToLabels = function (schema, keys) {

    const children = schema._inner.children;

    if (!children) {
        return keys;
    }

    const findLabel = function (key) {

        const matchingChild = schema._currentJoi.reach(schema, key);
        return matchingChild ? matchingChild._getLabel(key) : key;
    };

    if (Array.isArray(keys)) {
        return keys.map(findLabel);
    }

    return findLabel(keys);
};


internals.with = function (key, value, peers, parent, state, options) {

    if (value === undefined) {
        return;
    }

    for (let i = 0; i < peers.length; ++i) {

        const peer = peers[i];
        const keysExist = Hoek.reach(parent, peer, { functions: true });
        if (keysExist === undefined) {

            return this.createError('object.with', {
                main: key,
                mainWithLabel: internals.keysToLabels(this, key),
                peer,
                peerWithLabel: internals.keysToLabels(this, peer)
            }, state, options);
        }
    }
};


internals.without = function (key, value, peers, parent, state, options) {

    if (value === undefined) {
        return;
    }

    for (let i = 0; i < peers.length; ++i) {
        const peer = peers[i];
        const keysExist = Hoek.reach(parent, peer, { functions: true });
        if (keysExist !== undefined) {

            return this.createError('object.without', {
                main: key,
                mainWithLabel: internals.keysToLabels(this, key),
                peer,
                peerWithLabel: internals.keysToLabels(this, peer)
            }, state, options);
        }
    }
};


internals.xor = function (key, value, peers, parent, state, options) {

    const present = [];
    for (let i = 0; i < peers.length; ++i) {
        const peer = peers[i];
        const keysExist = Hoek.reach(parent, peer, { functions: true });
        if (keysExist !== undefined) {
            present.push(peer);
        }
    }

    if (present.length === 1) {
        return;
    }

    const context = { peers, peersWithLabels: internals.keysToLabels(this, peers) };

    if (present.length === 0) {
        return this.createError('object.missing', context, state, options);
    }

    context.present = present;
    context.presentWithLabels = internals.keysToLabels(this, present);

    return this.createError('object.xor', context, state, options);
};


internals.oxor = function (key, value, peers, parent, state, options) {

    const present = [];
    for (let i = 0; i < peers.length; ++i) {
        const peer = peers[i];
        const keysExist = Hoek.reach(parent, peer, { functions: true });
        if (keysExist !== undefined) {
            present.push(peer);
        }
    }

    if (!present.length ||
        present.length === 1) {

        return;
    }

    const context = { peers, peersWithLabels: internals.keysToLabels(this, peers) };
    context.present = present;
    context.presentWithLabels = internals.keysToLabels(this, present);

    return this.createError('object.oxor', context, state, options);
};


internals.or = function (key, value, peers, parent, state, options) {

    for (let i = 0; i < peers.length; ++i) {
        const peer = peers[i];
        const keysExist = Hoek.reach(parent, peer, { functions: true });
        if (keysExist !== undefined) {
            return;
        }
    }

    return this.createError('object.missing', {
        peers,
        peersWithLabels: internals.keysToLabels(this, peers)
    }, state, options);
};


internals.and = function (key, value, peers, parent, state, options) {

    const missing = [];
    const present = [];
    const count = peers.length;
    for (let i = 0; i < count; ++i) {
        const peer = peers[i];
        const keysExist = Hoek.reach(parent, peer, { functions: true });
        if (keysExist === undefined) {

            missing.push(peer);
        }
        else {
            present.push(peer);
        }
    }

    const aon = (missing.length === count || present.length === count);

    if (!aon) {

        return this.createError('object.and', {
            present,
            presentWithLabels: internals.keysToLabels(this, present),
            missing,
            missingWithLabels: internals.keysToLabels(this, missing)
        }, state, options);
    }
};


internals.nand = function (key, value, peers, parent, state, options) {

    const present = [];
    for (let i = 0; i < peers.length; ++i) {
        const peer = peers[i];
        const keysExist = Hoek.reach(parent, peer, { functions: true });
        if (keysExist !== undefined) {

            present.push(peer);
        }
    }

    const main = peers[0];
    const values = peers.slice(1);
    const allPresent = (present.length === peers.length);
    return allPresent ? this.createError('object.nand', {
        main,
        mainWithLabel: internals.keysToLabels(this, main),
        peers: values,
        peersWithLabels: internals.keysToLabels(this, values)
    }, state, options) : null;
};


module.exports = new internals.Object();


/***/ }),

/***/ "./src/node_modules/@hapi/joi/lib/types/state.js":
/*!*******************************************************!*\
  !*** ./src/node_modules/@hapi/joi/lib/types/state.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const internals = {};


module.exports = class {
    constructor(key, path, parent, reference) {

        this.key = key;
        this.path = path;
        this.parent = parent;
        this.reference = reference;
    }
};


/***/ }),

/***/ "./src/node_modules/@hapi/joi/lib/types/string/index.js":
/*!**************************************************************!*\
  !*** ./src/node_modules/@hapi/joi/lib/types/string/index.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Net = __webpack_require__(/*! net */ "net");

const Address = __webpack_require__(/*! @hapi/address */ "./src/node_modules/@hapi/address/lib/index.js");
const Hoek = __webpack_require__(/*! @hapi/hoek */ "./src/node_modules/@hapi/hoek/lib/index.js");

const Any = __webpack_require__(/*! ../any */ "./src/node_modules/@hapi/joi/lib/types/any/index.js");
const Ref = __webpack_require__(/*! ../../ref */ "./src/node_modules/@hapi/joi/lib/ref.js");
const JoiDate = __webpack_require__(/*! ../date */ "./src/node_modules/@hapi/joi/lib/types/date/index.js");

const Uri = __webpack_require__(/*! ./uri */ "./src/node_modules/@hapi/joi/lib/types/string/uri.js");
const Ip = __webpack_require__(/*! ./ip */ "./src/node_modules/@hapi/joi/lib/types/string/ip.js");


const internals = {
    uriRegex: Uri.createUriRegex(),
    ipRegex: Ip.createIpRegex(['ipv4', 'ipv6', 'ipvfuture'], 'optional'),
    guidBrackets: {
        '{': '}', '[': ']', '(': ')', '': ''
    },
    guidVersions: {
        uuidv1: '1',
        uuidv2: '2',
        uuidv3: '3',
        uuidv4: '4',
        uuidv5: '5'
    },
    cidrPresences: ['required', 'optional', 'forbidden'],
    normalizationForms: ['NFC', 'NFD', 'NFKC', 'NFKD']
};


internals.String = class extends Any {

    constructor() {

        super();
        this._type = 'string';
        this._invalids.add('');
    }

    _base(value, state, options) {

        if (typeof value === 'string' &&
            options.convert) {

            if (this._flags.normalize) {
                value = value.normalize(this._flags.normalize);
            }

            if (this._flags.case) {
                value = (this._flags.case === 'upper' ? value.toLocaleUpperCase() : value.toLocaleLowerCase());
            }

            if (this._flags.trim) {
                value = value.trim();
            }

            if (this._inner.replacements) {

                for (let i = 0; i < this._inner.replacements.length; ++i) {
                    const replacement = this._inner.replacements[i];
                    value = value.replace(replacement.pattern, replacement.replacement);
                }
            }

            if (this._flags.truncate) {
                for (let i = 0; i < this._tests.length; ++i) {
                    const test = this._tests[i];
                    if (test.name === 'max') {
                        value = value.slice(0, test.arg);
                        break;
                    }
                }
            }

            if (this._flags.byteAligned && value.length % 2 !== 0) {
                value = `0${value}`;
            }
        }

        return {
            value,
            errors: (typeof value === 'string') ? null : this.createError('string.base', { value }, state, options)
        };
    }

    insensitive() {

        if (this._flags.insensitive) {
            return this;
        }

        const obj = this.clone();
        obj._flags.insensitive = true;
        return obj;
    }

    creditCard() {

        return this._test('creditCard', undefined, function (value, state, options) {

            let i = value.length;
            let sum = 0;
            let mul = 1;

            while (i--) {
                const char = value.charAt(i) * mul;
                sum = sum + (char - (char > 9) * 9);
                mul = mul ^ 3;
            }

            const check = (sum % 10 === 0) && (sum > 0);
            return check ? value : this.createError('string.creditCard', { value }, state, options);
        });
    }

    regex(pattern, patternOptions) {

        Hoek.assert(pattern instanceof RegExp, 'pattern must be a RegExp');
        Hoek.assert(!pattern.flags.includes('g') && !pattern.flags.includes('y'), 'pattern should not use global or sticky mode');

        const patternObject = { pattern };

        if (typeof patternOptions === 'string') {
            patternObject.name = patternOptions;
        }
        else if (typeof patternOptions === 'object') {
            patternObject.invert = !!patternOptions.invert;

            if (patternOptions.name) {
                patternObject.name = patternOptions.name;
            }
        }

        const errorCode = ['string.regex', patternObject.invert ? '.invert' : '', patternObject.name ? '.name' : '.base'].join('');

        return this._test('regex', patternObject, function (value, state, options) {

            const patternMatch = patternObject.pattern.test(value);

            if (patternMatch ^ patternObject.invert) {
                return value;
            }

            return this.createError(errorCode, { name: patternObject.name, pattern: patternObject.pattern, value }, state, options);
        });
    }

    alphanum() {

        return this._test('alphanum', undefined, function (value, state, options) {

            if (/^[a-zA-Z0-9]+$/.test(value)) {
                return value;
            }

            return this.createError('string.alphanum', { value }, state, options);
        });
    }

    token() {

        return this._test('token', undefined, function (value, state, options) {

            if (/^\w+$/.test(value)) {
                return value;
            }

            return this.createError('string.token', { value }, state, options);
        });
    }

    email(validationOptions) {

        if (validationOptions) {
            Hoek.assert(typeof validationOptions === 'object', 'email options must be an object');

            // Migration validation for unsupported options

            Hoek.assert(validationOptions.checkDNS === undefined, 'checkDNS option is not supported');
            Hoek.assert(validationOptions.errorLevel === undefined, 'errorLevel option is not supported');
            Hoek.assert(validationOptions.minDomainAtoms === undefined, 'minDomainAtoms option is not supported, use minDomainSegments instead');
            Hoek.assert(validationOptions.tldBlacklist === undefined, 'tldBlacklist option is not supported, use tlds.deny instead');
            Hoek.assert(validationOptions.tldWhitelist === undefined, 'tldWhitelist option is not supported, use tlds.allow instead');

            // Validate options

            if (validationOptions.tlds &&
                typeof validationOptions.tlds === 'object') {

                Hoek.assert(validationOptions.tlds.allow === undefined ||
                    validationOptions.tlds.allow === false ||
                    validationOptions.tlds.allow === true ||
                    Array.isArray(validationOptions.tlds.allow) ||
                    validationOptions.tlds.allow instanceof Set, 'tlds.allow must be an array, Set, or boolean');

                Hoek.assert(validationOptions.tlds.deny === undefined ||
                    Array.isArray(validationOptions.tlds.deny) ||
                    validationOptions.tlds.deny instanceof Set, 'tlds.deny must be an array or Set');

                const normalizeTable = (table) => {

                    if (table === undefined ||
                        typeof table === 'boolean' ||
                        table instanceof Set) {

                        return table;
                    }

                    return new Set(table);
                };

                validationOptions = Object.assign({}, validationOptions);       // Shallow cloned
                validationOptions.tlds = {
                    allow: normalizeTable(validationOptions.tlds.allow),
                    deny: normalizeTable(validationOptions.tlds.deny)
                };
            }

            Hoek.assert(validationOptions.minDomainSegments === undefined ||
                Number.isSafeInteger(validationOptions.minDomainSegments) && validationOptions.minDomainSegments > 0, 'minDomainSegments must be a positive integer');
        }

        return this._test('email', validationOptions, function (value, state, options) {

            if (Address.email.isValid(value, validationOptions)) {
                return value;
            }

            return this.createError('string.email', { value }, state, options);
        });
    }

    ip(ipOptions = {}) {

        let regex = internals.ipRegex;
        Hoek.assert(typeof ipOptions === 'object', 'options must be an object');

        if (ipOptions.cidr) {
            Hoek.assert(typeof ipOptions.cidr === 'string', 'cidr must be a string');
            ipOptions.cidr = ipOptions.cidr.toLowerCase();

            Hoek.assert(Hoek.contain(internals.cidrPresences, ipOptions.cidr), 'cidr must be one of ' + internals.cidrPresences.join(', '));

            // If we only received a `cidr` setting, create a regex for it. But we don't need to create one if `cidr` is "optional" since that is the default
            if (!ipOptions.version && ipOptions.cidr !== 'optional') {
                regex = Ip.createIpRegex(['ipv4', 'ipv6', 'ipvfuture'], ipOptions.cidr);
            }
        }
        else {

            // Set our default cidr strategy
            ipOptions.cidr = 'optional';
        }

        let versions;
        if (ipOptions.version) {
            if (!Array.isArray(ipOptions.version)) {
                ipOptions.version = [ipOptions.version];
            }

            Hoek.assert(ipOptions.version.length >= 1, 'version must have at least 1 version specified');

            versions = [];
            for (let i = 0; i < ipOptions.version.length; ++i) {
                let version = ipOptions.version[i];
                Hoek.assert(typeof version === 'string', 'version at position ' + i + ' must be a string');
                version = version.toLowerCase();
                Hoek.assert(Ip.versions[version], 'version at position ' + i + ' must be one of ' + Object.keys(Ip.versions).join(', '));
                versions.push(version);
            }

            // Make sure we have a set of versions
            versions = Array.from(new Set(versions));

            regex = Ip.createIpRegex(versions, ipOptions.cidr);
        }

        return this._test('ip', ipOptions, function (value, state, options) {

            if (regex.test(value)) {
                return value;
            }

            if (versions) {
                return this.createError('string.ipVersion', { value, cidr: ipOptions.cidr, version: versions }, state, options);
            }

            return this.createError('string.ip', { value, cidr: ipOptions.cidr }, state, options);
        });
    }

    uri(uriOptions) {

        let customScheme = '';
        let allowRelative = false;
        let relativeOnly = false;
        let allowQuerySquareBrackets = false;
        let regex = internals.uriRegex;

        if (uriOptions) {
            Hoek.assert(typeof uriOptions === 'object', 'options must be an object');

            const unknownOptions = Object.keys(uriOptions).filter((key) => !['scheme', 'allowRelative', 'relativeOnly', 'allowQuerySquareBrackets'].includes(key));
            Hoek.assert(unknownOptions.length === 0, `options contain unknown keys: ${unknownOptions}`);

            if (uriOptions.scheme) {
                Hoek.assert(uriOptions.scheme instanceof RegExp || typeof uriOptions.scheme === 'string' || Array.isArray(uriOptions.scheme), 'scheme must be a RegExp, String, or Array');

                if (!Array.isArray(uriOptions.scheme)) {
                    uriOptions.scheme = [uriOptions.scheme];
                }

                Hoek.assert(uriOptions.scheme.length >= 1, 'scheme must have at least 1 scheme specified');

                // Flatten the array into a string to be used to match the schemes.
                for (let i = 0; i < uriOptions.scheme.length; ++i) {
                    const scheme = uriOptions.scheme[i];
                    Hoek.assert(scheme instanceof RegExp || typeof scheme === 'string', 'scheme at position ' + i + ' must be a RegExp or String');

                    // Add OR separators if a value already exists
                    customScheme = customScheme + (customScheme ? '|' : '');

                    // If someone wants to match HTTP or HTTPS for example then we need to support both RegExp and String so we don't escape their pattern unknowingly.
                    if (scheme instanceof RegExp) {
                        customScheme = customScheme + scheme.source;
                    }
                    else {
                        Hoek.assert(/[a-zA-Z][a-zA-Z0-9+-\.]*/.test(scheme), 'scheme at position ' + i + ' must be a valid scheme');
                        customScheme = customScheme + Hoek.escapeRegex(scheme);
                    }
                }
            }

            if (uriOptions.allowRelative) {
                allowRelative = true;
            }

            if (uriOptions.relativeOnly) {
                relativeOnly = true;
            }

            if (uriOptions.allowQuerySquareBrackets) {
                allowQuerySquareBrackets = true;
            }
        }

        if (customScheme || allowRelative || relativeOnly || allowQuerySquareBrackets) {
            regex = Uri.createUriRegex(customScheme, allowRelative, relativeOnly, allowQuerySquareBrackets);
        }

        return this._test('uri', uriOptions, function (value, state, options) {

            if (regex.test(value)) {
                return value;
            }

            if (relativeOnly) {
                return this.createError('string.uriRelativeOnly', { value }, state, options);
            }

            if (customScheme) {
                return this.createError('string.uriCustomScheme', { scheme: customScheme, value }, state, options);
            }

            return this.createError('string.uri', { value }, state, options);
        });
    }

    isoDate() {

        return this._test('isoDate', undefined, function (value, state, options) {

            if (JoiDate._isIsoDate(value)) {
                if (!options.convert) {
                    return value;
                }

                const d = new Date(value);
                if (!isNaN(d.getTime())) {
                    return d.toISOString();
                }
            }

            return this.createError('string.isoDate', { value }, state, options);
        });
    }

    guid(guidOptions) {

        let versionNumbers = '';

        if (guidOptions && guidOptions.version) {
            if (!Array.isArray(guidOptions.version)) {
                guidOptions.version = [guidOptions.version];
            }

            Hoek.assert(guidOptions.version.length >= 1, 'version must have at least 1 valid version specified');
            const versions = new Set();

            for (let i = 0; i < guidOptions.version.length; ++i) {
                let version = guidOptions.version[i];
                Hoek.assert(typeof version === 'string', 'version at position ' + i + ' must be a string');
                version = version.toLowerCase();
                const versionNumber = internals.guidVersions[version];
                Hoek.assert(versionNumber, 'version at position ' + i + ' must be one of ' + Object.keys(internals.guidVersions).join(', '));
                Hoek.assert(!(versions.has(versionNumber)), 'version at position ' + i + ' must not be a duplicate.');

                versionNumbers += versionNumber;
                versions.add(versionNumber);
            }
        }

        const guidRegex = new RegExp(`^([\\[{\\(]?)[0-9A-F]{8}([:-]?)[0-9A-F]{4}\\2?[${versionNumbers || '0-9A-F'}][0-9A-F]{3}\\2?[${versionNumbers ? '89AB' : '0-9A-F'}][0-9A-F]{3}\\2?[0-9A-F]{12}([\\]}\\)]?)$`, 'i');

        return this._test('guid', guidOptions, function (value, state, options) {

            const results = guidRegex.exec(value);

            if (!results) {
                return this.createError('string.guid', { value }, state, options);
            }

            // Matching braces
            if (internals.guidBrackets[results[1]] !== results[results.length - 1]) {
                return this.createError('string.guid', { value }, state, options);
            }

            return value;
        });
    }

    hex(hexOptions = {}) {

        Hoek.assert(typeof hexOptions === 'object', 'hex options must be an object');
        Hoek.assert(typeof hexOptions.byteAligned === 'undefined' || typeof hexOptions.byteAligned === 'boolean',
            'byteAligned must be boolean');

        const byteAligned = hexOptions.byteAligned === true;
        const regex = /^[a-f0-9]+$/i;

        const obj = this._test('hex', regex, function (value, state, options) {

            if (regex.test(value)) {
                if (byteAligned && value.length % 2 !== 0) {
                    return this.createError('string.hexAlign', { value }, state, options);
                }

                return value;
            }

            return this.createError('string.hex', { value }, state, options);
        });

        if (byteAligned) {
            obj._flags.byteAligned = true;
        }

        return obj;
    }

    base64(base64Options = {}) {

        // Validation.
        Hoek.assert(typeof base64Options === 'object', 'base64 options must be an object');
        Hoek.assert(typeof base64Options.paddingRequired === 'undefined' || typeof base64Options.paddingRequired === 'boolean',
            'paddingRequired must be boolean');

        // Determine if padding is required.
        const paddingRequired = base64Options.paddingRequired === false ?
            base64Options.paddingRequired
            : base64Options.paddingRequired || true;

        // Set validation based on preference.
        const regex = paddingRequired ?
            // Padding is required.
            /^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/
            // Padding is optional.
            : /^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}(==)?|[A-Za-z0-9+\/]{3}=?)?$/;

        return this._test('base64', regex, function (value, state, options) {

            if (regex.test(value)) {
                return value;
            }

            return this.createError('string.base64', { value }, state, options);
        });
    }

    dataUri(dataUriOptions = {}) {

        const regex = /^data:[\w+.-]+\/[\w+.-]+;((charset=[\w-]+|base64),)?(.*)$/;

        // Determine if padding is required.
        const paddingRequired = dataUriOptions.paddingRequired === false ?
            dataUriOptions.paddingRequired
            : dataUriOptions.paddingRequired || true;

        const base64regex = paddingRequired ?
            /^(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/
            : /^(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}(==)?|[A-Za-z0-9+\/]{3}=?)?$/;

        return this._test('dataUri', regex, function (value, state, options) {

            const matches = value.match(regex);

            if (matches) {
                if (!matches[2]) {
                    return value;
                }

                if (matches[2] !== 'base64') {
                    return value;
                }

                if (base64regex.test(matches[3])) {
                    return value;
                }
            }

            return this.createError('string.dataUri', { value }, state, options);
        });
    }

    hostname() {

        const regex = /^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\-]*[a-zA-Z0-9])\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\-]*[A-Za-z0-9])$/;

        return this._test('hostname', undefined, function (value, state, options) {

            if ((value.length <= 255 && regex.test(value)) ||
                Net.isIPv6(value)) {

                return value;
            }

            return this.createError('string.hostname', { value }, state, options);
        });
    }

    normalize(form = 'NFC') {

        Hoek.assert(Hoek.contain(internals.normalizationForms, form), 'normalization form must be one of ' + internals.normalizationForms.join(', '));

        const obj = this._test('normalize', form, function (value, state, options) {

            if (options.convert ||
                value === value.normalize(form)) {

                return value;
            }

            return this.createError('string.normalize', { value, form }, state, options);
        });

        obj._flags.normalize = form;
        return obj;
    }

    lowercase() {

        const obj = this._test('lowercase', undefined, function (value, state, options) {

            if (options.convert ||
                value === value.toLocaleLowerCase()) {

                return value;
            }

            return this.createError('string.lowercase', { value }, state, options);
        });

        obj._flags.case = 'lower';
        return obj;
    }

    uppercase() {

        const obj = this._test('uppercase', undefined, function (value, state, options) {

            if (options.convert ||
                value === value.toLocaleUpperCase()) {

                return value;
            }

            return this.createError('string.uppercase', { value }, state, options);
        });

        obj._flags.case = 'upper';
        return obj;
    }

    trim(enabled = true) {

        Hoek.assert(typeof enabled === 'boolean', 'option must be a boolean');

        if ((this._flags.trim && enabled) || (!this._flags.trim && !enabled)) {
            return this;
        }

        let obj;
        if (enabled) {
            obj = this._test('trim', undefined, function (value, state, options) {

                if (options.convert ||
                    value === value.trim()) {

                    return value;
                }

                return this.createError('string.trim', { value }, state, options);
            });
        }
        else {
            obj = this.clone();
            obj._tests = obj._tests.filter((test) => test.name !== 'trim');
        }

        obj._flags.trim = enabled;
        return obj;
    }

    replace(pattern, replacement) {

        if (typeof pattern === 'string') {
            pattern = new RegExp(Hoek.escapeRegex(pattern), 'g');
        }

        Hoek.assert(pattern instanceof RegExp, 'pattern must be a RegExp');
        Hoek.assert(typeof replacement === 'string', 'replacement must be a String');

        // This can not be considere a test like trim, we can't "reject"
        // anything from this rule, so just clone the current object
        const obj = this.clone();

        if (!obj._inner.replacements) {
            obj._inner.replacements = [];
        }

        obj._inner.replacements.push({
            pattern,
            replacement
        });

        return obj;
    }

    truncate(enabled) {

        const value = enabled === undefined ? true : !!enabled;

        if (this._flags.truncate === value) {
            return this;
        }

        const obj = this.clone();
        obj._flags.truncate = value;
        return obj;
    }

};

internals.compare = function (type, compare) {

    return function (limit, encoding) {

        const isRef = Ref.isRef(limit);

        Hoek.assert((Number.isSafeInteger(limit) && limit >= 0) || isRef, 'limit must be a positive integer or reference');
        Hoek.assert(!encoding || Buffer.isEncoding(encoding), 'Invalid encoding:', encoding);

        return this._test(type, limit, function (value, state, options) {

            let compareTo;
            if (isRef) {
                compareTo = limit(state.reference || state.parent, options);

                if (!Number.isSafeInteger(compareTo)) {
                    return this.createError('string.ref', { ref: limit, value: compareTo }, state, options);
                }
            }
            else {
                compareTo = limit;
            }

            if (compare(value, compareTo, encoding)) {
                return value;
            }

            return this.createError('string.' + type, { limit: compareTo, value, encoding }, state, options);
        });
    };
};


internals.String.prototype.min = internals.compare('min', (value, limit, encoding) => {

    const length = encoding ? Buffer.byteLength(value, encoding) : value.length;
    return length >= limit;
});


internals.String.prototype.max = internals.compare('max', (value, limit, encoding) => {

    const length = encoding ? Buffer.byteLength(value, encoding) : value.length;
    return length <= limit;
});


internals.String.prototype.length = internals.compare('length', (value, limit, encoding) => {

    const length = encoding ? Buffer.byteLength(value, encoding) : value.length;
    return length === limit;
});

// Aliases

internals.String.prototype.uuid = internals.String.prototype.guid;

module.exports = new internals.String();


/***/ }),

/***/ "./src/node_modules/@hapi/joi/lib/types/string/ip.js":
/*!***********************************************************!*\
  !*** ./src/node_modules/@hapi/joi/lib/types/string/ip.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const RFC3986 = __webpack_require__(/*! ./rfc3986 */ "./src/node_modules/@hapi/joi/lib/types/string/rfc3986.js");


const internals = {
    Ip: {
        cidrs: {
            ipv4: {
                required: '\\/(?:' + RFC3986.ipv4Cidr + ')',
                optional: '(?:\\/(?:' + RFC3986.ipv4Cidr + '))?',
                forbidden: ''
            },
            ipv6: {
                required: '\\/' + RFC3986.ipv6Cidr,
                optional: '(?:\\/' + RFC3986.ipv6Cidr + ')?',
                forbidden: ''
            },
            ipvfuture: {
                required: '\\/' + RFC3986.ipv6Cidr,
                optional: '(?:\\/' + RFC3986.ipv6Cidr + ')?',
                forbidden: ''
            }
        },
        versions: {
            ipv4: RFC3986.IPv4address,
            ipv6: RFC3986.IPv6address,
            ipvfuture: RFC3986.IPvFuture
        }
    }
};


internals.Ip.createIpRegex = function (versions, cidr) {

    let regex;
    for (let i = 0; i < versions.length; ++i) {
        const version = versions[i];
        if (!regex) {
            regex = '^(?:' + internals.Ip.versions[version] + internals.Ip.cidrs[version][cidr];
        }
        else {
            regex += '|' + internals.Ip.versions[version] + internals.Ip.cidrs[version][cidr];
        }
    }

    return new RegExp(regex + ')$');
};

module.exports = internals.Ip;


/***/ }),

/***/ "./src/node_modules/@hapi/joi/lib/types/string/rfc3986.js":
/*!****************************************************************!*\
  !*** ./src/node_modules/@hapi/joi/lib/types/string/rfc3986.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const internals = {
    rfc3986: {}
};


internals.generate = function () {

    /**
     * elements separated by forward slash ("/") are alternatives.
     */
    const or = '|';

    /**
     * Rule to support zero-padded addresses.
     */
    const zeroPad = '0?';

    /**
     * DIGIT = %x30-39 ; 0-9
     */
    const digit = '0-9';
    const digitOnly = '[' + digit + ']';

    /**
     * ALPHA = %x41-5A / %x61-7A   ; A-Z / a-z
     */
    const alpha = 'a-zA-Z';
    const alphaOnly = '[' + alpha + ']';

    /**
     * IPv4
     * cidr       = DIGIT                ; 0-9
     *            / %x31-32 DIGIT         ; 10-29
     *            / "3" %x30-32           ; 30-32
     */
    internals.rfc3986.ipv4Cidr = digitOnly + or + '[1-2]' + digitOnly + or + '3' + '[0-2]';

    /**
     * IPv6
     * cidr       = DIGIT                 ; 0-9
     *            / %x31-39 DIGIT         ; 10-99
     *            / "1" %x0-1 DIGIT       ; 100-119
     *            / "12" %x0-8            ; 120-128
     */
    internals.rfc3986.ipv6Cidr = '(?:' + zeroPad + zeroPad + digitOnly + or + zeroPad + '[1-9]' + digitOnly + or + '1' + '[01]' + digitOnly + or + '12[0-8])';

    /**
     * HEXDIG = DIGIT / "A" / "B" / "C" / "D" / "E" / "F"
     */
    const hexDigit = digit + 'A-Fa-f';
    const hexDigitOnly = '[' + hexDigit + ']';

    /**
     * unreserved = ALPHA / DIGIT / "-" / "." / "_" / "~"
     */
    const unreserved = alpha + digit + '-\\._~';

    /**
     * sub-delims = "!" / "$" / "&" / "'" / "(" / ")" / "*" / "+" / "," / ";" / "="
     */
    const subDelims = '!\\$&\'\\(\\)\\*\\+,;=';

    /**
     * pct-encoded = "%" HEXDIG HEXDIG
     */
    const pctEncoded = '%' + hexDigit;

    /**
     * pchar = unreserved / pct-encoded / sub-delims / ":" / "@"
     */
    const pchar = unreserved + pctEncoded + subDelims + ':@';
    const pcharOnly = '[' + pchar + ']';

    /**
     * squareBrackets example: []
     */
    const squareBrackets = '\\[\\]';

    /**
     * dec-octet   = DIGIT                 ; 0-9
     *            / %x31-39 DIGIT         ; 10-99
     *            / "1" 2DIGIT            ; 100-199
     *            / "2" %x30-34 DIGIT     ; 200-249
     *            / "25" %x30-35          ; 250-255
     */
    const decOctect = '(?:' + zeroPad + zeroPad + digitOnly + or + zeroPad + '[1-9]' + digitOnly + or + '1' + digitOnly + digitOnly + or + '2' + '[0-4]' + digitOnly + or + '25' + '[0-5])';

    /**
     * IPv4address = dec-octet "." dec-octet "." dec-octet "." dec-octet
     */
    internals.rfc3986.IPv4address = '(?:' + decOctect + '\\.){3}' + decOctect;

    /**
     * h16 = 1*4HEXDIG ; 16 bits of address represented in hexadecimal
     * ls32 = ( h16 ":" h16 ) / IPv4address ; least-significant 32 bits of address
     * IPv6address =                            6( h16 ":" ) ls32
     *             /                       "::" 5( h16 ":" ) ls32
     *             / [               h16 ] "::" 4( h16 ":" ) ls32
     *             / [ *1( h16 ":" ) h16 ] "::" 3( h16 ":" ) ls32
     *             / [ *2( h16 ":" ) h16 ] "::" 2( h16 ":" ) ls32
     *             / [ *3( h16 ":" ) h16 ] "::"    h16 ":"   ls32
     *             / [ *4( h16 ":" ) h16 ] "::"              ls32
     *             / [ *5( h16 ":" ) h16 ] "::"              h16
     *             / [ *6( h16 ":" ) h16 ] "::"
     */
    const h16 = hexDigitOnly + '{1,4}';
    const ls32 = '(?:' + h16 + ':' + h16 + '|' + internals.rfc3986.IPv4address + ')';
    const IPv6SixHex = '(?:' + h16 + ':){6}' + ls32;
    const IPv6FiveHex = '::(?:' + h16 + ':){5}' + ls32;
    const IPv6FourHex = '(?:' + h16 + ')?::(?:' + h16 + ':){4}' + ls32;
    const IPv6ThreeHex = '(?:(?:' + h16 + ':){0,1}' + h16 + ')?::(?:' + h16 + ':){3}' + ls32;
    const IPv6TwoHex = '(?:(?:' + h16 + ':){0,2}' + h16 + ')?::(?:' + h16 + ':){2}' + ls32;
    const IPv6OneHex = '(?:(?:' + h16 + ':){0,3}' + h16 + ')?::' + h16 + ':' + ls32;
    const IPv6NoneHex = '(?:(?:' + h16 + ':){0,4}' + h16 + ')?::' + ls32;
    const IPv6NoneHex2 = '(?:(?:' + h16 + ':){0,5}' + h16 + ')?::' + h16;
    const IPv6NoneHex3 = '(?:(?:' + h16 + ':){0,6}' + h16 + ')?::';
    internals.rfc3986.IPv6address = '(?:' + IPv6SixHex + or + IPv6FiveHex + or + IPv6FourHex + or + IPv6ThreeHex + or + IPv6TwoHex + or + IPv6OneHex + or + IPv6NoneHex + or + IPv6NoneHex2 + or + IPv6NoneHex3 + ')';

    /**
     * IPvFuture = "v" 1*HEXDIG "." 1*( unreserved / sub-delims / ":" )
     */
    internals.rfc3986.IPvFuture = 'v' + hexDigitOnly + '+\\.[' + unreserved + subDelims + ':]+';

    /**
     * scheme = ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )
     */
    internals.rfc3986.scheme = alphaOnly + '[' + alpha + digit + '+-\\.]*';

    /**
     * userinfo = *( unreserved / pct-encoded / sub-delims / ":" )
     */
    const userinfo = '[' + unreserved + pctEncoded + subDelims + ':]*';

    /**
     * IP-literal = "[" ( IPv6address / IPvFuture  ) "]"
     */
    const IPLiteral = '\\[(?:' + internals.rfc3986.IPv6address + or + internals.rfc3986.IPvFuture + ')\\]';

    /**
     * reg-name = *( unreserved / pct-encoded / sub-delims )
     */
    const regName = '[' + unreserved + pctEncoded + subDelims + ']{0,255}';

    /**
     * host = IP-literal / IPv4address / reg-name
     */
    const host = '(?:' + IPLiteral + or + internals.rfc3986.IPv4address + or + regName + ')';

    /**
     * port = *DIGIT
     */
    const port = digitOnly + '*';

    /**
     * authority   = [ userinfo "@" ] host [ ":" port ]
     */
    const authority = '(?:' + userinfo + '@)?' + host + '(?::' + port + ')?';

    /**
     * segment       = *pchar
     * segment-nz    = 1*pchar
     * path          = path-abempty    ; begins with "/" or is empty
     *               / path-absolute   ; begins with "/" but not "//"
     *               / path-noscheme   ; begins with a non-colon segment
     *               / path-rootless   ; begins with a segment
     *               / path-empty      ; zero characters
     * path-abempty  = *( "/" segment )
     * path-absolute = "/" [ segment-nz *( "/" segment ) ]
     * path-rootless = segment-nz *( "/" segment )
     */
    const segment = pcharOnly + '*';
    const segmentNz = pcharOnly + '+';
    const segmentNzNc = '[' + unreserved + pctEncoded + subDelims + '@' + ']+';
    const pathEmpty = '';
    const pathAbEmpty = '(?:\\/' + segment + ')*';
    const pathAbsolute = '\\/(?:' + segmentNz + pathAbEmpty + ')?';
    const pathRootless = segmentNz + pathAbEmpty;
    const pathNoScheme = segmentNzNc + pathAbEmpty;

    /**
     * hier-part = "//" authority path
     */
    internals.rfc3986.hierPart = '(?:' + '(?:\\/\\/' + authority + pathAbEmpty + ')' + or + pathAbsolute + or + pathRootless + ')';

    /**
     * relative-part = "//" authority path-abempty
     *                 / path-absolute
     *                 / path-noscheme
     *                 / path-empty
     */
    internals.rfc3986.relativeRef = '(?:' + '(?:\\/\\/' + authority + pathAbEmpty  + ')' + or + pathAbsolute + or + pathNoScheme + or + pathEmpty + ')';

    /**
     * query = *( pchar / "/" / "?" )
     */
    internals.rfc3986.query = '[' + pchar + '\\/\\?]*(?=#|$)'; //Finish matching either at the fragment part or end of the line.

    /**
     * query = *( pchar / "[" / "]" / "/" / "?" )
     */
    internals.rfc3986.queryWithSquareBrackets = '[' + pchar + squareBrackets + '\\/\\?]*(?=#|$)'; //Finish matching either at the fragment part or end of the line.

    /**
     * fragment = *( pchar / "/" / "?" )
     */
    internals.rfc3986.fragment = '[' + pchar + '\\/\\?]*';
};


internals.generate();

module.exports = internals.rfc3986;


/***/ }),

/***/ "./src/node_modules/@hapi/joi/lib/types/string/uri.js":
/*!************************************************************!*\
  !*** ./src/node_modules/@hapi/joi/lib/types/string/uri.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const RFC3986 = __webpack_require__(/*! ./rfc3986 */ "./src/node_modules/@hapi/joi/lib/types/string/rfc3986.js");


const internals = {
    Uri: {
        createUriRegex: function (optionalScheme, allowRelative, relativeOnly, allowQuerySquareBrackets) {

            let scheme = RFC3986.scheme;
            let prefix;

            if (relativeOnly) {
                prefix = '(?:' + RFC3986.relativeRef + ')';
            }
            else {
                // If we were passed a scheme, use it instead of the generic one
                if (optionalScheme) {

                    // Have to put this in a non-capturing group to handle the OR statements
                    scheme = '(?:' + optionalScheme + ')';
                }

                const withScheme = '(?:' + scheme + ':' + RFC3986.hierPart + ')';

                prefix = allowRelative ? '(?:' + withScheme + '|' + RFC3986.relativeRef + ')' : withScheme;
            }

            /**
             * URI = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
             *
             * OR
             *
             * relative-ref = relative-part [ "?" query ] [ "#" fragment ]
             */
            return new RegExp('^' + prefix + '(?:\\?' + (allowQuerySquareBrackets ? RFC3986.queryWithSquareBrackets : RFC3986.query) + ')?' + '(?:#' + RFC3986.fragment + ')?$');
        }
    }
};

module.exports = internals.Uri;


/***/ }),

/***/ "./src/node_modules/@hapi/joi/lib/types/symbol/index.js":
/*!**************************************************************!*\
  !*** ./src/node_modules/@hapi/joi/lib/types/symbol/index.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Util = __webpack_require__(/*! util */ "util");

const Hoek = __webpack_require__(/*! @hapi/hoek */ "./src/node_modules/@hapi/hoek/lib/index.js");

const Any = __webpack_require__(/*! ../any */ "./src/node_modules/@hapi/joi/lib/types/any/index.js");


const internals = {};


internals.Map = class extends Map {

    slice() {

        return new internals.Map(this);
    }

    toString() {

        return Util.inspect(this);
    }
};


internals.Symbol = class extends Any {

    constructor() {

        super();
        this._type = 'symbol';
        this._inner.map = new internals.Map();
    }

    _base(value, state, options) {

        if (options.convert) {
            const lookup = this._inner.map.get(value);
            if (lookup) {
                value = lookup;
            }

            if (this._flags.allowOnly) {
                return {
                    value,
                    errors: (typeof value === 'symbol') ? null : this.createError('symbol.map', { value, map: this._inner.map }, state, options)
                };
            }
        }

        return {
            value,
            errors: (typeof value === 'symbol') ? null : this.createError('symbol.base', { value }, state, options)
        };
    }

    map(iterable) {

        if (iterable && !iterable[Symbol.iterator] && typeof iterable === 'object') {
            iterable = Object.entries(iterable);
        }

        Hoek.assert(iterable && iterable[Symbol.iterator], 'Iterable must be an iterable or object');
        const obj = this.clone();

        const symbols = [];
        for (const entry of iterable) {
            Hoek.assert(entry && entry[Symbol.iterator], 'Entry must be an iterable');
            const [key, value] = entry;

            Hoek.assert(typeof key !== 'object' && typeof key !== 'function' && typeof key !== 'symbol', 'Key must not be an object, function, or Symbol');
            Hoek.assert(typeof value === 'symbol', 'Value must be a Symbol');
            obj._inner.map.set(key, value);
            symbols.push(value);
        }

        return obj.valid(...symbols);
    }

    describe() {

        const description = super.describe();
        description.map = new Map(this._inner.map);
        return description;
    }
};


module.exports = new internals.Symbol();


/***/ }),

/***/ "./src/node_modules/@hapi/joi/lib/types/symbols.js":
/*!*********************************************************!*\
  !*** ./src/node_modules/@hapi/joi/lib/types/symbols.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const internals = {};


module.exports = {
    settingsCache: Symbol('settingsCache')
};


/***/ }),

/***/ "./src/node_modules/@hapi/joi/package.json":
/*!*************************************************!*\
  !*** ./src/node_modules/@hapi/joi/package.json ***!
  \*************************************************/
/*! exports provided: _args, _from, _id, _inBundle, _integrity, _location, _phantomChildren, _requested, _requiredBy, _resolved, _spec, _where, bugs, dependencies, description, devDependencies, homepage, keywords, license, main, name, repository, scripts, version, default */
/***/ (function(module) {

module.exports = {"_args":[["@hapi/joi@15.1.0","/Users/justinjia/work/desktop/src"]],"_from":"@hapi/joi@15.1.0","_id":"@hapi/joi@15.1.0","_inBundle":false,"_integrity":"sha512-n6kaRQO8S+kepUTbXL9O/UOL788Odqs38/VOfoCrATDtTvyfiO3fgjlSRaNkHabpTLgM7qru9ifqXlXbXk8SeQ==","_location":"/@hapi/joi","_phantomChildren":{},"_requested":{"type":"version","registry":true,"raw":"@hapi/joi@15.1.0","name":"@hapi/joi","escapedName":"@hapi%2fjoi","scope":"@hapi","rawSpec":"15.1.0","saveSpec":null,"fetchSpec":"15.1.0"},"_requiredBy":["/"],"_resolved":"https://registry.npmjs.org/@hapi/joi/-/joi-15.1.0.tgz","_spec":"15.1.0","_where":"/Users/justinjia/work/desktop/src","bugs":{"url":"https://github.com/hapijs/joi/issues"},"dependencies":{"@hapi/address":"2.x.x","@hapi/hoek":"6.x.x","@hapi/marker":"1.x.x","@hapi/topo":"3.x.x"},"description":"Object schema validation","devDependencies":{"@hapi/code":"5.x.x","@hapi/lab":"18.x.x","hapitoc":"1.x.x"},"homepage":"https://github.com/hapijs/joi","keywords":["schema","validation"],"license":"BSD-3-Clause","main":"lib/index.js","name":"@hapi/joi","repository":{"type":"git","url":"git://github.com/hapijs/joi.git"},"scripts":{"test":"lab -t 100 -a @hapi/code -L","test-cov-html":"lab -r html -o coverage.html -a @hapi/code","toc":"hapitoc && node docs/check-errors-list.js","version":"npm run toc && git add API.md README.md"},"version":"15.1.0"};

/***/ }),

/***/ "./src/node_modules/@hapi/marker/lib/index.js":
/*!****************************************************!*\
  !*** ./src/node_modules/@hapi/marker/lib/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const internals = {
    symbols: new Map()
};


module.exports = exports = function (subject) {

    let symbol = internals.symbols.get(subject);
    if (symbol) {
        return symbol;
    }

    symbol = Symbol(subject);
    internals.symbols.set(subject, symbol);

    return symbol;
};


/***/ }),

/***/ "./src/node_modules/@hapi/topo/lib/index.js":
/*!**************************************************!*\
  !*** ./src/node_modules/@hapi/topo/lib/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Hoek = __webpack_require__(/*! @hapi/hoek */ "./src/node_modules/@hapi/topo/node_modules/@hapi/hoek/lib/index.js");


const internals = {};


module.exports = class Topo {

    constructor() {

        this._items = [];
        this.nodes = [];
    }

    add(nodes, options) {

        options = options || {};

        // Validate rules

        const before = [].concat(options.before || []);
        const after = [].concat(options.after || []);
        const group = options.group || '?';
        const sort = options.sort || 0;                   // Used for merging only

        Hoek.assert(!before.includes(group), `Item cannot come before itself: ${group}`);
        Hoek.assert(!before.includes('?'), 'Item cannot come before unassociated items');
        Hoek.assert(!after.includes(group), `Item cannot come after itself: ${group}`);
        Hoek.assert(!after.includes('?'), 'Item cannot come after unassociated items');

        ([].concat(nodes)).forEach((node, i) => {

            const item = {
                seq: this._items.length,
                sort,
                before,
                after,
                group,
                node
            };

            this._items.push(item);
        });

        // Insert event

        const error = this._sort();
        Hoek.assert(!error, 'item', (group !== '?' ? `added into group ${group}` : ''), 'created a dependencies error');

        return this.nodes;
    }

    merge(others) {

        others = [].concat(others);
        for (let i = 0; i < others.length; ++i) {
            const other = others[i];
            if (other) {
                for (let j = 0; j < other._items.length; ++j) {
                    const item = Object.assign({}, other._items[j]);        // Shallow cloned
                    this._items.push(item);
                }
            }
        }

        // Sort items

        this._items.sort(internals.mergeSort);
        for (let i = 0; i < this._items.length; ++i) {
            this._items[i].seq = i;
        }

        const error = this._sort();
        Hoek.assert(!error, 'merge created a dependencies error');

        return this.nodes;
    }

    _sort() {

        // Construct graph

        const graph = {};
        const graphAfters = Object.create(null); // A prototype can bungle lookups w/ false positives
        const groups = Object.create(null);

        for (let i = 0; i < this._items.length; ++i) {
            const item = this._items[i];
            const seq = item.seq;                         // Unique across all items
            const group = item.group;

            // Determine Groups

            groups[group] = groups[group] || [];
            groups[group].push(seq);

            // Build intermediary graph using 'before'

            graph[seq] = item.before;

            // Build second intermediary graph with 'after'

            const after = item.after;
            for (let j = 0; j < after.length; ++j) {
                graphAfters[after[j]] = (graphAfters[after[j]] || []).concat(seq);
            }
        }

        // Expand intermediary graph

        let graphNodes = Object.keys(graph);
        for (let i = 0; i < graphNodes.length; ++i) {
            const node = graphNodes[i];
            const expandedGroups = [];

            const graphNodeItems = Object.keys(graph[node]);
            for (let j = 0; j < graphNodeItems.length; ++j) {
                const group = graph[node][graphNodeItems[j]];
                groups[group] = groups[group] || [];

                for (let k = 0; k < groups[group].length; ++k) {
                    expandedGroups.push(groups[group][k]);
                }
            }

            graph[node] = expandedGroups;
        }

        // Merge intermediary graph using graphAfters into final graph

        const afterNodes = Object.keys(graphAfters);
        for (let i = 0; i < afterNodes.length; ++i) {
            const group = afterNodes[i];

            if (groups[group]) {
                for (let j = 0; j < groups[group].length; ++j) {
                    const node = groups[group][j];
                    graph[node] = graph[node].concat(graphAfters[group]);
                }
            }
        }

        // Compile ancestors

        let children;
        const ancestors = {};
        graphNodes = Object.keys(graph);
        for (let i = 0; i < graphNodes.length; ++i) {
            const node = graphNodes[i];
            children = graph[node];

            for (let j = 0; j < children.length; ++j) {
                ancestors[children[j]] = (ancestors[children[j]] || []).concat(node);
            }
        }

        // Topo sort

        const visited = {};
        const sorted = [];

        for (let i = 0; i < this._items.length; ++i) {          // Really looping thru item.seq values out of order
            let next = i;

            if (ancestors[i]) {
                next = null;
                for (let j = 0; j < this._items.length; ++j) {  // As above, these are item.seq values
                    if (visited[j] === true) {
                        continue;
                    }

                    if (!ancestors[j]) {
                        ancestors[j] = [];
                    }

                    const shouldSeeCount = ancestors[j].length;
                    let seenCount = 0;
                    for (let k = 0; k < shouldSeeCount; ++k) {
                        if (visited[ancestors[j][k]]) {
                            ++seenCount;
                        }
                    }

                    if (seenCount === shouldSeeCount) {
                        next = j;
                        break;
                    }
                }
            }

            if (next !== null) {
                visited[next] = true;
                sorted.push(next);
            }
        }

        if (sorted.length !== this._items.length) {
            return new Error('Invalid dependencies');
        }

        const seqIndex = {};
        for (let i = 0; i < this._items.length; ++i) {
            const item = this._items[i];
            seqIndex[item.seq] = item;
        }

        const sortedNodes = [];
        this._items = sorted.map((value) => {

            const sortedItem = seqIndex[value];
            sortedNodes.push(sortedItem.node);
            return sortedItem;
        });

        this.nodes = sortedNodes;
    }
};

internals.mergeSort = (a, b) => {

    return a.sort === b.sort ? 0 : (a.sort < b.sort ? -1 : 1);
};


/***/ }),

/***/ "./src/node_modules/@hapi/topo/node_modules/@hapi/hoek/lib/deep-equal.js":
/*!*******************************************************************************!*\
  !*** ./src/node_modules/@hapi/topo/node_modules/@hapi/hoek/lib/deep-equal.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Types = __webpack_require__(/*! ./types */ "./src/node_modules/@hapi/topo/node_modules/@hapi/hoek/lib/types.js");


const internals = {
    mismatched: null
};


module.exports = function (obj, ref, options) {

    options = Object.assign({ prototype: true }, options);

    return !!internals.isDeepEqual(obj, ref, options, []);
};


internals.isDeepEqual = function (obj, ref, options, seen) {

    if (obj === ref) {                                      // Copied from Deep-eql, copyright(c) 2013 Jake Luer, jake@alogicalparadox.com, MIT Licensed, https://github.com/chaijs/deep-eql
        return obj !== 0 || 1 / obj === 1 / ref;
    }

    const type = typeof obj;

    if (type !== typeof ref) {
        return false;
    }

    if (type !== 'object' ||
        obj === null ||
        ref === null) {

        return obj !== obj && ref !== ref;                  // NaN
    }

    const instanceType = internals.getSharedType(obj, ref, !!options.prototype);
    switch (instanceType) {
        case Types.buffer:
            return Buffer.prototype.equals.call(obj, ref);
        case Types.promise:
            return obj === ref;
        case Types.regex:
            return obj.toString() === ref.toString();
        case internals.mismatched:
            return false;
    }

    for (let i = seen.length - 1; i >= 0; --i) {
        if (seen[i].isSame(obj, ref)) {
            return true;                                    // If previous comparison failed, it would have stopped execution
        }
    }

    seen.push(new internals.SeenEntry(obj, ref));

    try {
        return !!internals.isDeepEqualObj(instanceType, obj, ref, options, seen);
    }
    finally {
        seen.pop();
    }
};


internals.getSharedType = function (obj, ref, checkPrototype) {

    if (checkPrototype) {
        if (Object.getPrototypeOf(obj) !== Object.getPrototypeOf(ref)) {
            return internals.mismatched;
        }

        return Types.getInternalProto(obj);
    }

    const type = Types.getInternalProto(obj);
    if (type !== Types.getInternalProto(ref)) {
        return internals.mismatched;
    }

    return type;
};


internals.valueOf = function (obj) {

    const objValueOf = obj.valueOf;
    if (objValueOf === undefined) {
        return obj;
    }

    try {
        return objValueOf.call(obj);
    }
    catch (err) {
        return err;
    }
};


internals.hasOwnEnumerableProperty = function (obj, key) {

    return Object.prototype.propertyIsEnumerable.call(obj, key);
};


internals.isSetSimpleEqual = function (obj, ref) {

    for (const entry of obj) {
        if (!ref.has(entry)) {
            return false;
        }
    }

    return true;
};


internals.isDeepEqualObj = function (instanceType, obj, ref, options, seen) {

    const { isDeepEqual, valueOf, hasOwnEnumerableProperty } = internals;
    const { keys, getOwnPropertySymbols } = Object;

    if (instanceType === Types.array) {
        if (options.part) {
            // Check if any index match any other index

            for (let i = 0; i < obj.length; ++i) {
                const objValue = obj[i];
                for (let j = 0; j < ref.length; ++j) {
                    if (isDeepEqual(objValue, ref[j], options, seen)) {
                        return true;
                    }
                }
            }
        }
        else {
            if (obj.length !== ref.length) {
                return false;
            }

            for (let i = 0; i < obj.length; ++i) {
                if (!isDeepEqual(obj[i], ref[i], options, seen)) {
                    return false;
                }
            }

            return true;
        }
    }
    else if (instanceType === Types.set) {
        if (obj.size !== ref.size) {
            return false;
        }

        if (!internals.isSetSimpleEqual(obj, ref)) {

            // Check for deep equality

            const ref2 = new Set(ref);
            for (const objEntry of obj) {
                if (ref2.delete(objEntry)) {
                    continue;
                }

                let found = false;
                for (const refEntry of ref2) {
                    if (isDeepEqual(objEntry, refEntry, options, seen)) {
                        ref2.delete(refEntry);
                        found = true;
                        break;
                    }
                }

                if (!found) {
                    return false;
                }
            }
        }
    }
    else if (instanceType === Types.map) {
        if (obj.size !== ref.size) {
            return false;
        }

        for (const [key, value] of obj) {
            if (value === undefined && !ref.has(key)) {
                return false;
            }

            if (!isDeepEqual(value, ref.get(key), options, seen)) {
                return false;
            }
        }
    }
    else if (instanceType === Types.error) {
        // Always check name and message

        if (obj.name !== ref.name || obj.message !== ref.message) {
            return false;
        }
    }

    // Check .valueOf()

    const valueOfObj = valueOf(obj);
    const valueOfRef = valueOf(ref);
    if (!(obj === valueOfObj && ref === valueOfRef) &&
        !isDeepEqual(valueOfObj, valueOfRef, options, seen)) {
        return false;
    }

    // Check properties

    const objKeys = keys(obj);
    if (!options.part &&
        objKeys.length !== keys(ref).length) {

        return false;
    }

    for (let i = 0; i < objKeys.length; ++i) {
        const key = objKeys[i];

        if (!hasOwnEnumerableProperty(ref, key)) {
            return false;
        }

        if (!isDeepEqual(obj[key], ref[key], options, seen)) {
            return false;
        }
    }

    // Check symbols

    if (options.symbols !== false) {                                // Defaults to true
        const objSymbols = getOwnPropertySymbols(obj);
        const refSymbols = new Set(getOwnPropertySymbols(ref));

        for (let i = 0; i < objSymbols.length; ++i) {
            const key = objSymbols[i];

            if (hasOwnEnumerableProperty(obj, key)) {
                if (!hasOwnEnumerableProperty(ref, key)) {
                    return false;
                }

                if (!isDeepEqual(obj[key], ref[key], options, seen)) {
                    return false;
                }
            }
            else if (hasOwnEnumerableProperty(ref, key)) {
                return false;
            }

            refSymbols.delete(key);
        }

        for (const key of refSymbols) {
            if (hasOwnEnumerableProperty(ref, key)) {
                return false;
            }
        }
    }

    return true;
};


internals.SeenEntry = class {

    constructor(obj, ref) {

        this.obj = obj;
        this.ref = ref;
    }

    isSame(obj, ref) {

        return this.obj === obj && this.ref === ref;
    }
};


/***/ }),

/***/ "./src/node_modules/@hapi/topo/node_modules/@hapi/hoek/lib/escape.js":
/*!***************************************************************************!*\
  !*** ./src/node_modules/@hapi/topo/node_modules/@hapi/hoek/lib/escape.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const internals = {};


exports.escapeHtml = function (input) {

    if (!input) {
        return '';
    }

    let escaped = '';

    for (let i = 0; i < input.length; ++i) {

        const charCode = input.charCodeAt(i);

        if (internals.isSafe(charCode)) {
            escaped += input[i];
        }
        else {
            escaped += internals.escapeHtmlChar(charCode);
        }
    }

    return escaped;
};


exports.escapeJson = function (input) {

    if (!input) {
        return '';
    }

    const lessThan = 0x3C;
    const greaterThan = 0x3E;
    const andSymbol = 0x26;
    const lineSeperator = 0x2028;

    // replace method
    let charCode;
    return input.replace(/[<>&\u2028\u2029]/g, (match) => {

        charCode = match.charCodeAt(0);

        if (charCode === lessThan) {
            return '\\u003c';
        }

        if (charCode === greaterThan) {
            return '\\u003e';
        }

        if (charCode === andSymbol) {
            return '\\u0026';
        }

        if (charCode === lineSeperator) {
            return '\\u2028';
        }

        return '\\u2029';
    });
};


internals.escapeHtmlChar = function (charCode) {

    const namedEscape = internals.namedHtml[charCode];
    if (typeof namedEscape !== 'undefined') {
        return namedEscape;
    }

    if (charCode >= 256) {
        return '&#' + charCode + ';';
    }

    const hexValue = Buffer.from(String.fromCharCode(charCode), 'ascii').toString('hex');
    return `&#x${hexValue};`;
};


internals.isSafe = function (charCode) {

    return (typeof internals.safeCharCodes[charCode] !== 'undefined');
};


internals.namedHtml = {
    '38': '&amp;',
    '60': '&lt;',
    '62': '&gt;',
    '34': '&quot;',
    '160': '&nbsp;',
    '162': '&cent;',
    '163': '&pound;',
    '164': '&curren;',
    '169': '&copy;',
    '174': '&reg;'
};


internals.safeCharCodes = (function () {

    const safe = {};

    for (let i = 32; i < 123; ++i) {

        if ((i >= 97) ||                    // a-z
            (i >= 65 && i <= 90) ||         // A-Z
            (i >= 48 && i <= 57) ||         // 0-9
            i === 32 ||                     // space
            i === 46 ||                     // .
            i === 44 ||                     // ,
            i === 45 ||                     // -
            i === 58 ||                     // :
            i === 95) {                     // _

            safe[i] = null;
        }
    }

    return safe;
}());


/***/ }),

/***/ "./src/node_modules/@hapi/topo/node_modules/@hapi/hoek/lib/index.js":
/*!**************************************************************************!*\
  !*** ./src/node_modules/@hapi/topo/node_modules/@hapi/hoek/lib/index.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const DeepEqual = __webpack_require__(/*! ./deep-equal */ "./src/node_modules/@hapi/topo/node_modules/@hapi/hoek/lib/deep-equal.js");
const Escape = __webpack_require__(/*! ./escape */ "./src/node_modules/@hapi/topo/node_modules/@hapi/hoek/lib/escape.js");
const Types = __webpack_require__(/*! ./types */ "./src/node_modules/@hapi/topo/node_modules/@hapi/hoek/lib/types.js");


const internals = {
    needsProtoHack: new Set([Types.set, Types.map, Types.weakSet, Types.weakMap])
};


// Deep object or array comparison

exports.deepEqual = DeepEqual;


// Clone object or array

exports.clone = function (obj, options = {}, _seen = null) {

    if (typeof obj !== 'object' ||
        obj === null) {

        return obj;
    }

    let clone = exports.clone;
    let seen = _seen;

    if (options.shallow) {
        if (options.shallow !== true) {
            return internals.cloneWithShallow(obj, options);
        }

        clone = (value) => value;
    }
    else {
        seen = seen || new Map();

        const lookup = seen.get(obj);
        if (lookup) {
            return lookup;
        }
    }

    const baseProto = Types.getInternalProto(obj);
    let newObj;

    switch (baseProto) {
        case Types.buffer:
            return Buffer.from(obj);

        case Types.date:
            return new Date(obj.getTime());

        case Types.regex:
            return new RegExp(obj);

        case Types.array:
            newObj = [];
            break;

        default:
            if (options.prototype !== false) {              // Defaults to true
                const proto = Object.getPrototypeOf(obj);
                if (proto &&
                    proto.isImmutable) {

                    return obj;
                }

                if (internals.needsProtoHack.has(baseProto)) {
                    newObj = new proto.constructor();
                    if (proto !== baseProto) {
                        Object.setPrototypeOf(newObj, proto);
                    }
                }
                else {
                    newObj = Object.create(proto);
                }
            }
            else if (internals.needsProtoHack.has(baseProto)) {
                newObj = new baseProto.constructor();
            }
            else {
                newObj = {};
            }
    }

    if (seen) {
        seen.set(obj, newObj);                              // Set seen, since obj could recurse
    }

    if (baseProto === Types.set) {
        for (const value of obj) {
            newObj.add(clone(value, options, seen));
        }
    }
    else if (baseProto === Types.map) {
        for (const [key, value] of obj) {
            newObj.set(key, clone(value, options, seen));
        }
    }

    const keys = internals.keys(obj, options);
    for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];

        if (baseProto === Types.array &&
            key === 'length') {

            continue;
        }

        const descriptor = Object.getOwnPropertyDescriptor(obj, key);
        if (descriptor &&
            (descriptor.get || descriptor.set)) {

            Object.defineProperty(newObj, key, descriptor);
        }
        else {
            Object.defineProperty(newObj, key, {
                enumerable: descriptor ? descriptor.enumerable : true,
                writable: true,
                configurable: true,
                value: clone(obj[key], options, seen)
            });
        }
    }

    if (baseProto === Types.array) {
        newObj.length = obj.length;
    }

    return newObj;
};


internals.keys = function (obj, options = {}) {

    return options.symbols !== false ? Reflect.ownKeys(obj) : Object.getOwnPropertyNames(obj);  // Defaults to true
};


internals.cloneWithShallow = function (source, options) {

    const keys = options.shallow;
    options = Object.assign({}, options);
    options.shallow = false;

    const storage = internals.store(source, keys);    // Move shallow copy items to storage
    const copy = exports.clone(source, options);      // Deep copy the rest
    internals.restore(copy, source, storage);         // Shallow copy the stored items and restore
    return copy;
};


internals.store = function (source, keys) {

    const storage = new Map();
    for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        const value = exports.reach(source, key);
        if (typeof value === 'object' ||
            typeof value === 'function') {

            storage.set(key, value);
            internals.reachSet(source, key, undefined);
        }
    }

    return storage;
};


internals.restore = function (copy, source, storage) {

    for (const [key, value] of storage) {
        internals.reachSet(copy, key, value);
        internals.reachSet(source, key, value);
    }
};


internals.reachSet = function (obj, key, value) {

    const path = Array.isArray(key) ? key : key.split('.');
    let ref = obj;
    for (let i = 0; i < path.length; ++i) {
        const segment = path[i];
        if (i + 1 === path.length) {
            ref[segment] = value;
        }

        ref = ref[segment];
    }
};


// Merge all the properties of source into target, source wins in conflict, and by default null and undefined from source are applied

exports.merge = function (target, source, options) {

    exports.assert(target && typeof target === 'object', 'Invalid target value: must be an object');
    exports.assert(source === null || source === undefined || typeof source === 'object', 'Invalid source value: must be null, undefined, or an object');

    if (!source) {
        return target;
    }

    options = Object.assign({ nullOverride: true, mergeArrays: true }, options);

    if (Array.isArray(source)) {
        exports.assert(Array.isArray(target), 'Cannot merge array onto an object');
        if (!options.mergeArrays) {
            target.length = 0;                                                          // Must not change target assignment
        }

        for (let i = 0; i < source.length; ++i) {
            target.push(exports.clone(source[i], { symbols: options.symbols }));
        }

        return target;
    }

    const keys = internals.keys(source, options);
    for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        if (key === '__proto__' ||
            !Object.prototype.propertyIsEnumerable.call(source, key)) {

            continue;
        }

        const value = source[key];
        if (value &&
            typeof value === 'object') {

            if (!target[key] ||
                typeof target[key] !== 'object' ||
                (Array.isArray(target[key]) !== Array.isArray(value)) ||
                value instanceof Date ||
                Buffer.isBuffer(value) ||
                value instanceof RegExp) {

                target[key] = exports.clone(value, { symbols: options.symbols });
            }
            else {
                exports.merge(target[key], value, options);
            }
        }
        else {
            if (value !== null &&
                value !== undefined) {                              // Explicit to preserve empty strings

                target[key] = value;
            }
            else if (options.nullOverride) {
                target[key] = value;
            }
        }
    }

    return target;
};


// Apply source to a copy of the defaults

exports.applyToDefaults = function (defaults, source, options = {}) {

    exports.assert(defaults && typeof defaults === 'object', 'Invalid defaults value: must be an object');
    exports.assert(!source || source === true || typeof source === 'object', 'Invalid source value: must be true, falsy or an object');
    exports.assert(typeof options === 'object', 'Invalid options: must be an object');

    if (!source) {                                                  // If no source, return null
        return null;
    }

    if (options.shallow) {
        return internals.applyToDefaultsWithShallow(defaults, source, options);
    }

    const copy = exports.clone(defaults);

    if (source === true) {                                          // If source is set to true, use defaults
        return copy;
    }

    const nullOverride = options.nullOverride !== undefined ? options.nullOverride : false;
    return exports.merge(copy, source, { nullOverride, mergeArrays: false });
};


internals.applyToDefaultsWithShallow = function (defaults, source, options) {

    const keys = options.shallow;
    exports.assert(Array.isArray(keys), 'Invalid keys');

    options = Object.assign({}, options);
    options.shallow = false;

    const copy = exports.clone(defaults, { shallow: keys });

    if (source === true) {                                                      // If source is set to true, use defaults
        return copy;
    }

    const storage = internals.store(source, keys);                              // Move shallow copy items to storage
    exports.merge(copy, source, { mergeArrays: false, nullOverride: false });   // Deep copy the rest
    internals.restore(copy, source, storage);                                   // Shallow copy the stored items and restore
    return copy;
};


// Find the common unique items in two arrays

exports.intersect = function (array1, array2, options = {}) {

    if (!array1 ||
        !array2) {

        return (options.first ? null : []);
    }

    const common = [];
    const hash = (Array.isArray(array1) ? new Set(array1) : array1);
    const found = new Set();
    for (const value of array2) {
        if (internals.has(hash, value) &&
            !found.has(value)) {

            if (options.first) {
                return value;
            }

            common.push(value);
            found.add(value);
        }
    }

    return (options.first ? null : common);
};


internals.has = function (ref, key) {

    if (typeof ref.has === 'function') {
        return ref.has(key);
    }

    return ref[key] !== undefined;
};


// Test if the reference contains the values

exports.contain = function (ref, values, options = {}) {        // options: { deep, once, only, part, symbols }

    /*
        string -> string(s)
        array -> item(s)
        object -> key(s)
        object -> object (key:value)
    */

    let valuePairs = null;
    if (typeof ref === 'object' &&
        typeof values === 'object' &&
        !Array.isArray(ref) &&
        !Array.isArray(values)) {

        valuePairs = values;
        const symbols = Object.getOwnPropertySymbols(values).filter(Object.prototype.propertyIsEnumerable.bind(values));
        values = [...Object.keys(values), ...symbols];
    }
    else {
        values = [].concat(values);
    }

    exports.assert(typeof ref === 'string' || typeof ref === 'object', 'Reference must be string or an object');
    exports.assert(values.length, 'Values array cannot be empty');

    let compare;
    let compareFlags;
    if (options.deep) {
        compare = exports.deepEqual;

        const hasOnly = options.only !== undefined;
        const hasPart = options.part !== undefined;

        compareFlags = {
            prototype: hasOnly ? options.only : hasPart ? !options.part : false,
            part: hasOnly ? !options.only : hasPart ? options.part : false
        };
    }
    else {
        compare = (a, b) => a === b;
    }

    let misses = false;
    const matches = new Array(values.length);
    for (let i = 0; i < matches.length; ++i) {
        matches[i] = 0;
    }

    if (typeof ref === 'string') {
        let pattern = '(';
        for (let i = 0; i < values.length; ++i) {
            const value = values[i];
            exports.assert(typeof value === 'string', 'Cannot compare string reference to non-string value');
            pattern += (i ? '|' : '') + exports.escapeRegex(value);
        }

        const regex = new RegExp(pattern + ')', 'g');
        const leftovers = ref.replace(regex, ($0, $1) => {

            const index = values.indexOf($1);
            ++matches[index];
            return '';          // Remove from string
        });

        misses = !!leftovers;
    }
    else if (Array.isArray(ref)) {
        const onlyOnce = !!(options.only && options.once);
        if (onlyOnce && ref.length !== values.length) {
            return false;
        }

        for (let i = 0; i < ref.length; ++i) {
            let matched = false;
            for (let j = 0; j < values.length && matched === false; ++j) {
                if (!onlyOnce || matches[j] === 0) {
                    matched = compare(values[j], ref[i], compareFlags) && j;
                }
            }

            if (matched !== false) {
                ++matches[matched];
            }
            else {
                misses = true;
            }
        }
    }
    else {
        const keys = internals.keys(ref, options);
        for (let i = 0; i < keys.length; ++i) {
            const key = keys[i];
            const pos = values.indexOf(key);
            if (pos !== -1) {
                if (valuePairs &&
                    !compare(valuePairs[key], ref[key], compareFlags)) {

                    return false;
                }

                ++matches[pos];
            }
            else {
                misses = true;
            }
        }
    }

    if (options.only) {
        if (misses || !options.once) {
            return !misses;
        }
    }

    let result = false;
    for (let i = 0; i < matches.length; ++i) {
        result = result || !!matches[i];
        if ((options.once && matches[i] > 1) ||
            (!options.part && !matches[i])) {

            return false;
        }
    }

    return result;
};


// Flatten array

exports.flatten = function (array, target) {

    const result = target || [];

    for (let i = 0; i < array.length; ++i) {
        if (Array.isArray(array[i])) {
            exports.flatten(array[i], result);
        }
        else {
            result.push(array[i]);
        }
    }

    return result;
};


// Convert an object key chain string ('a.b.c') to reference (object[a][b][c])

exports.reach = function (obj, chain, options) {

    if (chain === false ||
        chain === null ||
        chain === undefined) {

        return obj;
    }

    options = options || {};
    if (typeof options === 'string') {
        options = { separator: options };
    }

    const isChainArray = Array.isArray(chain);

    exports.assert(!isChainArray || !options.separator, 'Separator option no valid for array-based chain');

    const path = isChainArray ? chain : chain.split(options.separator || '.');
    let ref = obj;
    for (let i = 0; i < path.length; ++i) {
        let key = path[i];
        const type = options.iterables && internals.iterables(ref);

        if (Array.isArray(ref) ||
            type === 'set') {

            const number = Number(key);
            if (Number.isInteger(number)) {
                key = number < 0 ? ref.length + number : number;
            }
        }

        if (!ref ||
            typeof ref === 'function' && options.functions === false ||         // Defaults to true
            !type && ref[key] === undefined) {

            exports.assert(!options.strict || i + 1 === path.length, 'Missing segment', key, 'in reach path ', chain);
            exports.assert(typeof ref === 'object' || options.functions === true || typeof ref !== 'function', 'Invalid segment', key, 'in reach path ', chain);
            ref = options.default;
            break;
        }

        if (!type) {
            ref = ref[key];
        }
        else if (type === 'set') {
            ref = [...ref][key];
        }
        else {  // type === 'map'
            ref = ref.get(key);
        }
    }

    return ref;
};


internals.iterables = function (ref) {

    if (ref instanceof Set) {
        return 'set';
    }

    if (ref instanceof Map) {
        return 'map';
    }
};


exports.reachTemplate = function (obj, template, options) {

    return template.replace(/{([^}]+)}/g, ($0, chain) => {

        const value = exports.reach(obj, chain, options);
        return (value === undefined || value === null ? '' : value);
    });
};


exports.assert = function (condition, ...args) {

    if (condition) {
        return;
    }

    if (args.length === 1 &&
        args[0] instanceof Error) {

        throw args[0];
    }

    throw new exports.Error(args);
};


exports.Error = class extends Error {

    constructor(args) {

        const msgs = args
            .filter((arg) => arg !== '')
            .map((arg) => {

                return typeof arg === 'string' ? arg : arg instanceof Error ? arg.message : exports.stringify(arg);
            });

        super(msgs.join(' ') || 'Unknown error');
        Error.captureStackTrace(this, exports.assert);
    }
};


exports.Bench = class {

    constructor() {

        this.ts = 0;
        this.reset();
    }

    reset() {

        this.ts = exports.Bench.now();
    }

    elapsed() {

        return exports.Bench.now() - this.ts;
    }

    static now() {

        const ts = process.hrtime();
        return (ts[0] * 1e3) + (ts[1] / 1e6);
    }
};


// Escape string for Regex construction

exports.escapeRegex = function (string) {

    // Escape ^$.*+-?=!:|\/()[]{},
    return string.replace(/[\^\$\.\*\+\-\?\=\!\:\|\\\/\(\)\[\]\{\}\,]/g, '\\$&');
};


// Escape attribute value for use in HTTP header

exports.escapeHeaderAttribute = function (attribute) {

    // Allowed value characters: !#$%&'()*+,-./:;<=>?@[]^_`{|}~ and space, a-z, A-Z, 0-9, \, "

    exports.assert(/^[ \w\!#\$%&'\(\)\*\+,\-\.\/\:;<\=>\?@\[\]\^`\{\|\}~\"\\]*$/.test(attribute), 'Bad attribute value (' + attribute + ')');

    return attribute.replace(/\\/g, '\\\\').replace(/\"/g, '\\"');                             // Escape quotes and slash
};


exports.escapeHtml = function (string) {

    return Escape.escapeHtml(string);
};


exports.escapeJson = function (string) {

    return Escape.escapeJson(string);
};


exports.once = function (method) {

    if (method._hoekOnce) {
        return method;
    }

    let once = false;
    const wrapped = function (...args) {

        if (!once) {
            once = true;
            method(...args);
        }
    };

    wrapped._hoekOnce = true;
    return wrapped;
};


exports.ignore = function () { };


exports.stringify = function (...args) {

    try {
        return JSON.stringify.apply(null, args);
    }
    catch (err) {
        return '[Cannot display object: ' + err.message + ']';
    }
};


exports.wait = function (timeout) {

    return new Promise((resolve) => setTimeout(resolve, timeout));
};


exports.block = function () {

    return new Promise(exports.ignore);
};


/***/ }),

/***/ "./src/node_modules/@hapi/topo/node_modules/@hapi/hoek/lib/types.js":
/*!**************************************************************************!*\
  !*** ./src/node_modules/@hapi/topo/node_modules/@hapi/hoek/lib/types.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const internals = {};


exports = module.exports = {
    array: Array.prototype,
    buffer: Buffer.prototype,
    date: Date.prototype,
    error: Error.prototype,
    generic: Object.prototype,
    map: Map.prototype,
    promise: Promise.prototype,
    regex: RegExp.prototype,
    set: Set.prototype,
    weakMap: WeakMap.prototype,
    weakSet: WeakSet.prototype
};


internals.typeMap = new Map([
    ['[object Error]', exports.error],
    ['[object Map]', exports.map],
    ['[object Promise]', exports.promise],
    ['[object Set]', exports.set],
    ['[object WeakMap]', exports.weakMap],
    ['[object WeakSet]', exports.weakSet]
]);


exports.getInternalProto = function (obj) {

    if (Array.isArray(obj)) {
        return exports.array;
    }

    if (obj instanceof Buffer) {
        return exports.buffer;
    }

    if (obj instanceof Date) {
        return exports.date;
    }

    if (obj instanceof RegExp) {
        return exports.regex;
    }

    const objName = Object.prototype.toString.call(obj);
    return internals.typeMap.get(objName) || exports.generic;
};


/***/ }),

/***/ "./src/node_modules/ansi-regex/index.js":
/*!**********************************************!*\
  !*** ./src/node_modules/ansi-regex/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function () {
	return /[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-PRZcf-nqry=><]/g;
};


/***/ }),

/***/ "./src/node_modules/applescript/lib/applescript-parser.js":
/*!****************************************************************!*\
  !*** ./src/node_modules/applescript/lib/applescript-parser.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {


// 'parse' accepts a string that is expected to be the stdout stream of an
// osascript invocation. It reads the fist char of the string to determine
// the data-type of the result, and creates the appropriate type parser.
exports.parse = function(str) {
  if (str.length == 0) {
    return;
  }

  var rtn = parseFromFirstRemaining.call({
    value: str,
    index: 0
  });
  return rtn;
}

// Attemps to determine the data type of the next part of the String to
// parse. The 'this' value has a Object with 'value' as the AppleScript
// string to parse, and 'index' as the pointer to the current position
// of parsing in the String. This Function does not need to be exported???
function parseFromFirstRemaining() {
  var cur = this.value[this.index];
  switch(cur) {
    case '{':
      return exports.ArrayParser.call(this);
      break;
    case '"':
      return exports.StringParser.call(this);
      break;
    case 'a':
      if (this.value.substring(this.index, this.index+5) == 'alias') {
        return exports.AliasParser.call(this);
      }
      break;
    case '«':
      if (this.value.substring(this.index, this.index+5) == '«data') {
        return exports.DataParser.call(this);
      }
      break;
  }
  if (!isNaN(cur)) {
    return exports.NumberParser.call(this);
  }
  return exports.UndefinedParser.call(this);
}

// Parses an AppleScript "alias", which is really just a reference to a
// location on the filesystem, but formatted kinda weirdly.
exports.AliasParser = function() {
  this.index += 6;
  return "/Volumes/" + exports.StringParser.call(this).replace(/:/g, "/");
}

// Parses an AppleScript Array. Which looks like {}, instead of JavaScript's [].
exports.ArrayParser = function() {
  var rtn = [],
    cur = this.value[++this.index];
  while (cur != '}') {
    rtn.push(parseFromFirstRemaining.call(this));
    if (this.value[this.index] == ',') this.index += 2;
    cur = this.value[this.index];
  }
  this.index++;
  return rtn;
}

// Parses «data » results into native Buffer instances.
exports.DataParser = function() {
  var body = exports.UndefinedParser.call(this);
  body = body.substring(6, body.length-1);
  var type = body.substring(0,4);
  body = body.substring(4, body.length);
  var buf = new Buffer(body.length/2);
  var count = 0;
  for (var i=0, l=body.length; i<l; i += 2) {
    buf[count++] = parseInt(body[i]+body[i+1], 16);
  }
  buf.type = type;
  return buf;
}

// Parses an AppleScript Number into a native JavaScript Number instance.
exports.NumberParser = function() {
  return Number(exports.UndefinedParser.call(this));
}

// Parses a standard AppleScript String. Which starts and ends with "" chars.
// The \ char is the escape character, so anything after that is a valid part
// of the resulting String.
exports.StringParser = function(str) {
  var rtn = "",
    end = ++this.index,
    cur = this.value[end++];
  while(cur != '"') {
    if (cur == '\\') {
      rtn += this.value.substring(this.index, end-1);
      this.index = end++;
    }
    cur = this.value[end++];
  }
  rtn += this.value.substring(this.index, end-1);
  this.index = end;
  return rtn;
}

// When the "parseFromFirstRemaining" function can't figure out the data type
// of "str", then the UndefinedParser is used. It crams everything it sees
// into a String, until it finds a ',' or a '}' or it reaches the end of data.
var END_OF_TOKEN = /}|,|\n/;
exports.UndefinedParser = function() {
  var end = this.index, cur = this.value[end++];
  while (!END_OF_TOKEN.test(cur)) {
    cur = this.value[end++];
  }
  var rtn = this.value.substring(this.index, end-1);
  this.index = end-1;
  return rtn;
}


/***/ }),

/***/ "./src/node_modules/applescript/lib/applescript.js":
/*!*********************************************************!*\
  !*** ./src/node_modules/applescript/lib/applescript.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var spawn = __webpack_require__(/*! child_process */ "child_process").spawn;
exports.Parsers = __webpack_require__(/*! ./applescript-parser */ "./src/node_modules/applescript/lib/applescript-parser.js");
var parse = exports.Parsers.parse;

// Path to 'osascript'. By default search PATH.
exports.osascript = "osascript";

// Execute a *.applescript file.
exports.execFile = function execFile(file, args, callback) {
  if (!Array.isArray(args)) {
    callback = args;
    args = [];
  }
  return runApplescript(file, args, callback);
}

// Execute a String as AppleScript.
exports.execString = function execString(str, callback) {
  return runApplescript(str, callback);
}



function runApplescript(strOrPath, args, callback) {
  var isString = false;
  if (!Array.isArray(args)) {
    callback = args;
    args = [];
    isString = true;
  }

  // args get added to the end of the args array
  args.push("-ss"); // To output machine-readable text.
  if (!isString) {
    // The name of the file is the final arg if 'execFile' was called.
    args.push(strOrPath);
  }
  var interpreter = spawn(exports.osascript, args);

  bufferBody(interpreter.stdout);
  bufferBody(interpreter.stderr);

  interpreter.on('exit', function(code) {
    var result = parse(interpreter.stdout.body);
    var err;
    if (code) {
      // If the exit code was something other than 0, we're gonna
      // return an Error object.
      err = new Error(interpreter.stderr.body);
      err.appleScript = strOrPath;
      err.exitCode = code;
    }
    if (callback) {
      callback(err, result, interpreter.stderr.body);
    }
  });

  if (isString) {
    // Write the given applescript String to stdin if 'execString' was called.
    interpreter.stdin.write(strOrPath);
    interpreter.stdin.end();
  }
}

function bufferBody(stream) {
  stream.body = "";
  stream.setEncoding("utf8");
  stream.on("data", function(chunk) { stream.body += chunk; });
}


/***/ }),

/***/ "./src/node_modules/auto-launch/dist/AutoLaunchLinux.js":
/*!**************************************************************!*\
  !*** ./src/node_modules/auto-launch/dist/AutoLaunchLinux.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var fileBasedUtilities, untildify;

untildify = __webpack_require__(/*! untildify */ "./src/node_modules/untildify/index.js");

fileBasedUtilities = __webpack_require__(/*! ./fileBasedUtilities */ "./src/node_modules/auto-launch/dist/fileBasedUtilities.js");

module.exports = {

  /* Public */
  enable: function(arg) {
    var appName, appPath, data, hiddenArg, isHiddenOnLaunch;
    appName = arg.appName, appPath = arg.appPath, isHiddenOnLaunch = arg.isHiddenOnLaunch;
    hiddenArg = isHiddenOnLaunch ? ' --hidden' : '';
    data = "[Desktop Entry]\nType=Application\nVersion=1.0\nName=" + appName + "\nComment=" + appName + "startup script\nExec=" + appPath + hiddenArg + "\nStartupNotify=false\nTerminal=false";
    return fileBasedUtilities.createFile({
      data: data,
      directory: this.getDirectory(),
      filePath: this.getFilePath(appName)
    });
  },
  disable: function(appName) {
    return fileBasedUtilities.removeFile(this.getFilePath(appName));
  },
  isEnabled: function(appName) {
    return fileBasedUtilities.isEnabled(this.getFilePath(appName));
  },

  /* Private */
  getDirectory: function() {
    return untildify('~/.config/autostart/');
  },
  getFilePath: function(appName) {
    return "" + (this.getDirectory()) + appName + ".desktop";
  }
};


/***/ }),

/***/ "./src/node_modules/auto-launch/dist/AutoLaunchMac.js":
/*!************************************************************!*\
  !*** ./src/node_modules/auto-launch/dist/AutoLaunchMac.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var applescript, fileBasedUtilities, untildify,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

applescript = __webpack_require__(/*! applescript */ "./src/node_modules/applescript/lib/applescript.js");

untildify = __webpack_require__(/*! untildify */ "./src/node_modules/untildify/index.js");

fileBasedUtilities = __webpack_require__(/*! ./fileBasedUtilities */ "./src/node_modules/auto-launch/dist/fileBasedUtilities.js");

module.exports = {

  /* Public */
  enable: function(arg) {
    var appName, appPath, data, isHiddenOnLaunch, isHiddenValue, mac, programArguments, programArgumentsSection, properties;
    appName = arg.appName, appPath = arg.appPath, isHiddenOnLaunch = arg.isHiddenOnLaunch, mac = arg.mac;
    if (mac.useLaunchAgent) {
      programArguments = [appPath];
      if (isHiddenOnLaunch) {
        programArguments.push('--hidden');
      }
      programArgumentsSection = programArguments.map(function(argument) {
        return "    <string>" + argument + "</string>";
      }).join('\n');
      data = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n  <key>Label</key>\n  <string>" + appName + "</string>\n  <key>ProgramArguments</key>\n  <array>\n  " + programArgumentsSection + "\n  </array>\n  <key>RunAtLoad</key>\n  <true/>\n</dict>\n</plist>";
      return fileBasedUtilities.createFile({
        data: data,
        directory: this.getDirectory(),
        filePath: this.getFilePath(appName)
      });
    }
    isHiddenValue = isHiddenOnLaunch ? 'true' : 'false';
    properties = "{path:\"" + appPath + "\", hidden:" + isHiddenValue + ", name:\"" + appName + "\"}";
    return this.execApplescriptCommand("make login item at end with properties " + properties);
  },
  disable: function(appName, mac) {
    if (mac.useLaunchAgent) {
      return fileBasedUtilities.removeFile(this.getFilePath(appName));
    }
    return this.execApplescriptCommand("delete login item \"" + appName + "\"");
  },
  isEnabled: function(appName, mac) {
    if (mac.useLaunchAgent) {
      return fileBasedUtilities.isEnabled(this.getFilePath(appName));
    }
    return this.execApplescriptCommand('get the name of every login item').then(function(loginItems) {
      return (loginItems != null) && indexOf.call(loginItems, appName) >= 0;
    });
  },

  /* Private */
  execApplescriptCommand: function(commandSuffix) {
    return new Promise(function(resolve, reject) {
      return applescript.execString("tell application \"System Events\" to " + commandSuffix, function(err, result) {
        if (err != null) {
          return reject(err);
        }
        return resolve(result);
      });
    });
  },
  getDirectory: function() {
    return untildify('~/Library/LaunchAgents/');
  },
  getFilePath: function(appName) {
    return "" + (this.getDirectory()) + appName + ".plist";
  }
};


/***/ }),

/***/ "./src/node_modules/auto-launch/dist/AutoLaunchWindows.js":
/*!****************************************************************!*\
  !*** ./src/node_modules/auto-launch/dist/AutoLaunchWindows.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Winreg, fs, path, regKey;

fs = __webpack_require__(/*! fs */ "fs");

path = __webpack_require__(/*! path */ "path");

Winreg = __webpack_require__(/*! winreg */ "./src/node_modules/winreg/lib/registry.js");

regKey = new Winreg({
  hive: Winreg.HKCU,
  key: '\\Software\\Microsoft\\Windows\\CurrentVersion\\Run'
});

module.exports = {

  /* Public */
  enable: function(arg) {
    var appName, appPath, isHiddenOnLaunch;
    appName = arg.appName, appPath = arg.appPath, isHiddenOnLaunch = arg.isHiddenOnLaunch;
    return new Promise(function(resolve, reject) {
      var args, pathToAutoLaunchedApp, ref, updateDotExe;
      pathToAutoLaunchedApp = appPath;
      args = '';
      updateDotExe = path.join(path.dirname(process.execPath), '..', 'update.exe');
      if ((((ref = process.versions) != null ? ref.electron : void 0) != null) && fs.existsSync(updateDotExe)) {
        pathToAutoLaunchedApp = updateDotExe;
        args = " --processStart \"" + (path.basename(process.execPath)) + "\"";
        if (isHiddenOnLaunch) {
          args += ' --process-start-args "--hidden"';
        }
      } else {
        if (isHiddenOnLaunch) {
          args += ' --hidden';
        }
      }
      return regKey.set(appName, Winreg.REG_SZ, "\"" + pathToAutoLaunchedApp + "\"" + args, function(err) {
        if (err != null) {
          return reject(err);
        }
        return resolve();
      });
    });
  },
  disable: function(appName) {
    return new Promise(function(resolve, reject) {
      return regKey.remove(appName, function(err) {
        if (err != null) {
          if (err.message.indexOf('The system was unable to find the specified registry key or value') !== -1) {
            return resolve(false);
          }
          return reject(err);
        }
        return resolve();
      });
    });
  },
  isEnabled: function(appName) {
    return new Promise(function(resolve, reject) {
      return regKey.get(appName, function(err, item) {
        if (err != null) {
          return resolve(false);
        }
        return resolve(item != null);
      });
    });
  }
};


/***/ }),

/***/ "./src/node_modules/auto-launch/dist/fileBasedUtilities.js":
/*!*****************************************************************!*\
  !*** ./src/node_modules/auto-launch/dist/fileBasedUtilities.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var fs, mkdirp;

fs = __webpack_require__(/*! fs */ "fs");

mkdirp = __webpack_require__(/*! mkdirp */ "./src/node_modules/mkdirp/index.js");

module.exports = {

  /* Public */
  createFile: function(arg) {
    var data, directory, filePath;
    directory = arg.directory, filePath = arg.filePath, data = arg.data;
    return new Promise(function(resolve, reject) {
      return mkdirp(directory, function(mkdirErr) {
        if (mkdirErr != null) {
          return reject(mkdirErr);
        }
        return fs.writeFile(filePath, data, function(writeErr) {
          if (writeErr != null) {
            return reject(writeErr);
          }
          return resolve();
        });
      });
    });
  },
  isEnabled: function(filePath) {
    return new Promise((function(_this) {
      return function(resolve, reject) {
        return fs.stat(filePath, function(err, stat) {
          if (err != null) {
            return resolve(false);
          }
          return resolve(stat != null);
        });
      };
    })(this));
  },
  removeFile: function(filePath) {
    return new Promise((function(_this) {
      return function(resolve, reject) {
        return fs.stat(filePath, function(statErr) {
          if (statErr != null) {
            return resolve();
          }
          return fs.unlink(filePath, function(unlinkErr) {
            if (unlinkErr != null) {
              return reject(unlinkErr);
            }
            return resolve();
          });
        });
      };
    })(this));
  }
};


/***/ }),

/***/ "./src/node_modules/auto-launch/dist/index.js":
/*!****************************************************!*\
  !*** ./src/node_modules/auto-launch/dist/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var AutoLaunch, isPathAbsolute,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

isPathAbsolute = __webpack_require__(/*! path-is-absolute */ "./src/node_modules/path-is-absolute/index.js");

module.exports = AutoLaunch = (function() {

  /* Public */
  function AutoLaunch(arg) {
    var isHidden, mac, name, path, versions;
    name = arg.name, isHidden = arg.isHidden, mac = arg.mac, path = arg.path;
    this.fixOpts = bind(this.fixOpts, this);
    this.isEnabled = bind(this.isEnabled, this);
    this.disable = bind(this.disable, this);
    this.enable = bind(this.enable, this);
    if (name == null) {
      throw new Error('You must specify a name');
    }
    this.opts = {
      appName: name,
      isHiddenOnLaunch: isHidden != null ? isHidden : false,
      mac: mac != null ? mac : {}
    };
    versions = typeof process !== "undefined" && process !== null ? process.versions : void 0;
    if (path != null) {
      if (!isPathAbsolute(path)) {
        throw new Error('path must be absolute');
      }
      this.opts.appPath = path;
    } else if ((versions != null) && ((versions.nw != null) || (versions['node-webkit'] != null) || (versions.electron != null))) {
      this.opts.appPath = process.execPath;
    } else {
      throw new Error('You must give a path (this is only auto-detected for NW.js and Electron apps)');
    }
    this.fixOpts();
    this.api = null;
    if (/^win/.test(process.platform)) {
      this.api = __webpack_require__(/*! ./AutoLaunchWindows */ "./src/node_modules/auto-launch/dist/AutoLaunchWindows.js");
    } else if (/darwin/.test(process.platform)) {
      this.api = __webpack_require__(/*! ./AutoLaunchMac */ "./src/node_modules/auto-launch/dist/AutoLaunchMac.js");
    } else if (/linux/.test(process.platform)) {
      this.api = __webpack_require__(/*! ./AutoLaunchLinux */ "./src/node_modules/auto-launch/dist/AutoLaunchLinux.js");
    } else {
      throw new Error('Unsupported platform');
    }
  }

  AutoLaunch.prototype.enable = function() {
    return this.api.enable(this.opts);
  };

  AutoLaunch.prototype.disable = function() {
    return this.api.disable(this.opts.appName, this.opts.mac);
  };

  AutoLaunch.prototype.isEnabled = function() {
    return this.api.isEnabled(this.opts.appName, this.opts.mac);
  };


  /* Private */

  AutoLaunch.prototype.fixMacExecPath = function(path, macOptions) {
    path = path.replace(/(^.+?[^\/]+?\.app)\/Contents\/(Frameworks\/((\1|[^\/]+?) Helper)\.app\/Contents\/MacOS\/\3|MacOS\/Electron)/, '$1');
    if (!macOptions.useLaunchAgent) {
      path = path.replace(/\.app\/Contents\/MacOS\/[^\/]*$/, '.app');
    }
    return path;
  };

  AutoLaunch.prototype.fixOpts = function() {
    var tempPath;
    this.opts.appPath = this.opts.appPath.replace(/\/$/, '');
    if (/darwin/.test(process.platform)) {
      this.opts.appPath = this.fixMacExecPath(this.opts.appPath, this.opts.mac);
    }
    if (this.opts.appPath.indexOf('/') !== -1) {
      tempPath = this.opts.appPath.split('/');
      this.opts.appName = tempPath[tempPath.length - 1];
    } else if (this.opts.appPath.indexOf('\\') !== -1) {
      tempPath = this.opts.appPath.split('\\');
      this.opts.appName = tempPath[tempPath.length - 1];
      this.opts.appName = this.opts.appName.substr(0, this.opts.appName.length - '.exe'.length);
    }
    if (/darwin/.test(process.platform)) {
      if (this.opts.appName.indexOf('.app', this.opts.appName.length - '.app'.length) !== -1) {
        return this.opts.appName = this.opts.appName.substr(0, this.opts.appName.length - '.app'.length);
      }
    }
  };

  return AutoLaunch;

})();


/***/ }),

/***/ "./src/node_modules/balanced-match/index.js":
/*!**************************************************!*\
  !*** ./src/node_modules/balanced-match/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = balanced;
function balanced(a, b, str) {
  if (a instanceof RegExp) a = maybeMatch(a, str);
  if (b instanceof RegExp) b = maybeMatch(b, str);

  var r = range(a, b, str);

  return r && {
    start: r[0],
    end: r[1],
    pre: str.slice(0, r[0]),
    body: str.slice(r[0] + a.length, r[1]),
    post: str.slice(r[1] + b.length)
  };
}

function maybeMatch(reg, str) {
  var m = str.match(reg);
  return m ? m[0] : null;
}

balanced.range = range;
function range(a, b, str) {
  var begs, beg, left, right, result;
  var ai = str.indexOf(a);
  var bi = str.indexOf(b, ai + 1);
  var i = ai;

  if (ai >= 0 && bi > 0) {
    begs = [];
    left = str.length;

    while (i >= 0 && !result) {
      if (i == ai) {
        begs.push(i);
        ai = str.indexOf(a, i + 1);
      } else if (begs.length == 1) {
        result = [ begs.pop(), bi ];
      } else {
        beg = begs.pop();
        if (beg < left) {
          left = beg;
          right = bi;
        }

        bi = str.indexOf(b, i + 1);
      }

      i = ai < bi && ai >= 0 ? ai : bi;
    }

    if (begs.length) {
      result = [ left, right ];
    }
  }

  return result;
}


/***/ }),

/***/ "./src/node_modules/binary/index.js":
/*!******************************************!*\
  !*** ./src/node_modules/binary/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Chainsaw = __webpack_require__(/*! chainsaw */ "./src/node_modules/chainsaw/index.js");
var EventEmitter = __webpack_require__(/*! events */ "events").EventEmitter;
var Buffers = __webpack_require__(/*! buffers */ "./src/node_modules/buffers/index.js");
var Vars = __webpack_require__(/*! ./lib/vars.js */ "./src/node_modules/binary/lib/vars.js");
var Stream = __webpack_require__(/*! stream */ "stream").Stream;

exports = module.exports = function (bufOrEm, eventName) {
    if (Buffer.isBuffer(bufOrEm)) {
        return exports.parse(bufOrEm);
    }

    var s = exports.stream();
    if (bufOrEm && bufOrEm.pipe) {
        bufOrEm.pipe(s);
    }
    else if (bufOrEm) {
        bufOrEm.on(eventName || 'data', function (buf) {
            s.write(buf);
        });

        bufOrEm.on('end', function () {
            s.end();
        });
    }
    return s;
};

exports.stream = function (input) {
    if (input) return exports.apply(null, arguments);

    var pending = null;
    function getBytes (bytes, cb, skip) {
        pending = {
            bytes : bytes,
            skip : skip,
            cb : function (buf) {
                pending = null;
                cb(buf);
            },
        };
        dispatch();
    }

    var offset = null;
    function dispatch () {
        if (!pending) {
            if (caughtEnd) done = true;
            return;
        }
        if (typeof pending === 'function') {
            pending();
        }
        else {
            var bytes = offset + pending.bytes;

            if (buffers.length >= bytes) {
                var buf;
                if (offset == null) {
                    buf = buffers.splice(0, bytes);
                    if (!pending.skip) {
                        buf = buf.slice();
                    }
                }
                else {
                    if (!pending.skip) {
                        buf = buffers.slice(offset, bytes);
                    }
                    offset = bytes;
                }

                if (pending.skip) {
                    pending.cb();
                }
                else {
                    pending.cb(buf);
                }
            }
        }
    }

    function builder (saw) {
        function next () { if (!done) saw.next() }

        var self = words(function (bytes, cb) {
            return function (name) {
                getBytes(bytes, function (buf) {
                    vars.set(name, cb(buf));
                    next();
                });
            };
        });

        self.tap = function (cb) {
            saw.nest(cb, vars.store);
        };

        self.into = function (key, cb) {
            if (!vars.get(key)) vars.set(key, {});
            var parent = vars;
            vars = Vars(parent.get(key));

            saw.nest(function () {
                cb.apply(this, arguments);
                this.tap(function () {
                    vars = parent;
                });
            }, vars.store);
        };

        self.flush = function () {
            vars.store = {};
            next();
        };

        self.loop = function (cb) {
            var end = false;

            saw.nest(false, function loop () {
                this.vars = vars.store;
                cb.call(this, function () {
                    end = true;
                    next();
                }, vars.store);
                this.tap(function () {
                    if (end) saw.next()
                    else loop.call(this)
                }.bind(this));
            }, vars.store);
        };

        self.buffer = function (name, bytes) {
            if (typeof bytes === 'string') {
                bytes = vars.get(bytes);
            }

            getBytes(bytes, function (buf) {
                vars.set(name, buf);
                next();
            });
        };

        self.skip = function (bytes) {
            if (typeof bytes === 'string') {
                bytes = vars.get(bytes);
            }

            getBytes(bytes, function () {
                next();
            });
        };

        self.scan = function find (name, search) {
            if (typeof search === 'string') {
                search = new Buffer(search);
            }
            else if (!Buffer.isBuffer(search)) {
                throw new Error('search must be a Buffer or a string');
            }

            var taken = 0;
            pending = function () {
                var pos = buffers.indexOf(search, offset + taken);
                var i = pos-offset-taken;
                if (pos !== -1) {
                    pending = null;
                    if (offset != null) {
                        vars.set(
                            name,
                            buffers.slice(offset, offset + taken + i)
                        );
                        offset += taken + i + search.length;
                    }
                    else {
                        vars.set(
                            name,
                            buffers.slice(0, taken + i)
                        );
                        buffers.splice(0, taken + i + search.length);
                    }
                    next();
                    dispatch();
                } else {
                    i = Math.max(buffers.length - search.length - offset - taken, 0);
				}
                taken += i;
            };
            dispatch();
        };

        self.peek = function (cb) {
            offset = 0;
            saw.nest(function () {
                cb.call(this, vars.store);
                this.tap(function () {
                    offset = null;
                });
            });
        };

        return self;
    };

    var stream = Chainsaw.light(builder);
    stream.writable = true;

    var buffers = Buffers();

    stream.write = function (buf) {
        buffers.push(buf);
        dispatch();
    };

    var vars = Vars();

    var done = false, caughtEnd = false;
    stream.end = function () {
        caughtEnd = true;
    };

    stream.pipe = Stream.prototype.pipe;
    Object.getOwnPropertyNames(EventEmitter.prototype).forEach(function (name) {
        stream[name] = EventEmitter.prototype[name];
    });

    return stream;
};

exports.parse = function parse (buffer) {
    var self = words(function (bytes, cb) {
        return function (name) {
            if (offset + bytes <= buffer.length) {
                var buf = buffer.slice(offset, offset + bytes);
                offset += bytes;
                vars.set(name, cb(buf));
            }
            else {
                vars.set(name, null);
            }
            return self;
        };
    });

    var offset = 0;
    var vars = Vars();
    self.vars = vars.store;

    self.tap = function (cb) {
        cb.call(self, vars.store);
        return self;
    };

    self.into = function (key, cb) {
        if (!vars.get(key)) {
            vars.set(key, {});
        }
        var parent = vars;
        vars = Vars(parent.get(key));
        cb.call(self, vars.store);
        vars = parent;
        return self;
    };

    self.loop = function (cb) {
        var end = false;
        var ender = function () { end = true };
        while (end === false) {
            cb.call(self, ender, vars.store);
        }
        return self;
    };

    self.buffer = function (name, size) {
        if (typeof size === 'string') {
            size = vars.get(size);
        }
        var buf = buffer.slice(offset, Math.min(buffer.length, offset + size));
        offset += size;
        vars.set(name, buf);

        return self;
    };

    self.skip = function (bytes) {
        if (typeof bytes === 'string') {
            bytes = vars.get(bytes);
        }
        offset += bytes;

        return self;
    };

    self.scan = function (name, search) {
        if (typeof search === 'string') {
            search = new Buffer(search);
        }
        else if (!Buffer.isBuffer(search)) {
            throw new Error('search must be a Buffer or a string');
        }
        vars.set(name, null);

        // simple but slow string search
        for (var i = 0; i + offset <= buffer.length - search.length + 1; i++) {
            for (
                var j = 0;
                j < search.length && buffer[offset+i+j] === search[j];
                j++
            );
            if (j === search.length) break;
        }

        vars.set(name, buffer.slice(offset, offset + i));
        offset += i + search.length;
        return self;
    };

    self.peek = function (cb) {
        var was = offset;
        cb.call(self, vars.store);
        offset = was;
        return self;
    };

    self.flush = function () {
        vars.store = {};
        return self;
    };

    self.eof = function () {
        return offset >= buffer.length;
    };

    return self;
};

// convert byte strings to unsigned little endian numbers
function decodeLEu (bytes) {
    var acc = 0;
    for (var i = 0; i < bytes.length; i++) {
        acc += Math.pow(256,i) * bytes[i];
    }
    return acc;
}

// convert byte strings to unsigned big endian numbers
function decodeBEu (bytes) {
    var acc = 0;
    for (var i = 0; i < bytes.length; i++) {
        acc += Math.pow(256, bytes.length - i - 1) * bytes[i];
    }
    return acc;
}

// convert byte strings to signed big endian numbers
function decodeBEs (bytes) {
    var val = decodeBEu(bytes);
    if ((bytes[0] & 0x80) == 0x80) {
        val -= Math.pow(256, bytes.length);
    }
    return val;
}

// convert byte strings to signed little endian numbers
function decodeLEs (bytes) {
    var val = decodeLEu(bytes);
    if ((bytes[bytes.length - 1] & 0x80) == 0x80) {
        val -= Math.pow(256, bytes.length);
    }
    return val;
}

function words (decode) {
    var self = {};

    [ 1, 2, 4, 8 ].forEach(function (bytes) {
        var bits = bytes * 8;

        self['word' + bits + 'le']
        = self['word' + bits + 'lu']
        = decode(bytes, decodeLEu);

        self['word' + bits + 'ls']
        = decode(bytes, decodeLEs);

        self['word' + bits + 'be']
        = self['word' + bits + 'bu']
        = decode(bytes, decodeBEu);

        self['word' + bits + 'bs']
        = decode(bytes, decodeBEs);
    });

    // word8be(n) == word8le(n) for all n
    self.word8 = self.word8u = self.word8be;
    self.word8s = self.word8bs;

    return self;
}


/***/ }),

/***/ "./src/node_modules/binary/lib/vars.js":
/*!*********************************************!*\
  !*** ./src/node_modules/binary/lib/vars.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (store) {
    function getset (name, value) {
        var node = vars.store;
        var keys = name.split('.');
        keys.slice(0,-1).forEach(function (k) {
            if (node[k] === undefined) node[k] = {};
            node = node[k]
        });
        var key = keys[keys.length - 1];
        if (arguments.length == 1) {
            return node[key];
        }
        else {
            return node[key] = value;
        }
    }

    var vars = {
        get : function (name) {
            return getset(name);
        },
        set : function (name, value) {
            return getset(name, value);
        },
        store : store || {},
    };
    return vars;
};


/***/ }),

/***/ "./src/node_modules/binarysearch/index.js":
/*!************************************************!*\
  !*** ./src/node_modules/binarysearch/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {



module.exports = function(arr,search,comparitor) {
  if(!arr) return -1;
  // as long as it has a length i will try and itterate over it.
  if(arr.length === undefined) return -1;

  if(!comparitor) comparitor = module.exports._defaultComparitor();

  return bs(arr,search,comparitor);
}

module.exports.first = function(arr,search,comparitor) {
  return module.exports.closest(arr,search,{exists:true},comparitor);
}

module.exports.last = function(arr,search,comparitor) {
  return module.exports.closest(arr,search,{exists:true,end:true},comparitor);
}

module.exports.closest = function(arr,search,opts,comparitor) {

  if(typeof opts === 'function') {
    comparitor = opts;
    opts = {};
  }

  if(arr.length === 0) return -1;
  if(arr.length === 1) return 0;

  opts = opts||{};
  if(!comparitor) comparitor = this._defaultComparitor();

  var closest = bsclosest(arr, search, comparitor, opts.end, opts.exists?false:true);

  if(closest > arr.length-1) closest = arr.length-1;
  else if(closest < 0) closest = 0;

  return closest;
}

// inserts element into the correct sorted spot into the array
module.exports.insert = function(arr,search,opts,comparitor){

  if(typeof opts === 'function') {
    comparitor = opts;
    opts = {};
  }

  opts = opts||{};
  if(!comparitor) comparitor = module.exports._defaultComparitor();
  if(!arr.length) {
    arr[0] = search;
    return 0;
  }

  var closest = module.exports.closest(arr,search,comparitor);

  var cmp = comparitor(arr[closest],search);
  if(cmp < 0) {//less
    arr.splice(++closest,0,search);
  } else if(cmp > 0){
    arr.splice(closest,0,search);
  } else {
    if(opts.unique){
      arr[closest] = search;
    } else {
      // im equal. this value should be appended to the list of existing same sorted values.
      while(comparitor(arr[closest],search) === 0){
        if(closest >= arr.length-1) break;
        closest++;
      }

      arr.splice(closest,0,search);
    }
  }
  return closest;
}

// this method returns the start and end indicies of a range. [start,end]
module.exports.range = function(arr,from,to,comparitor) {
  if(!comparitor) comparitor = module.exports._defaultComparitor();

  var fromi = module.exports.closest(arr,from,comparitor);

  var toi = module.exports.closest(arr,to,{end:true},comparitor);

  // this is a hack.
  // i should be able to fix the algorithm and generate a correct range.

  while(fromi <= toi){
    if(comparitor(arr[fromi],from) > -1) break;

    fromi++
  }

  while(toi >= fromi){
    if(comparitor(arr[toi],to) < 1) break;
    toi--;
  }

  return [fromi,toi];
}

// this method returns the values of a range;
module.exports.rangeValue = function(arr,from,to,comparitor){
  var range = module.exports.range(arr,from,to,comparitor);
  return arr.slice(range[0],range[1]+1);
}

//
module.exports.indexObject = function(o,extractor) {
  var index = [];

  Object.keys(o).forEach(function(k){
    index.push({k:k,v:extractor(o[k])});
  });

  return index.sort(function(o1,o2){
    return o1.v - o2.v;
  });
}

module.exports.cmp = function(v1,v2){
  return v1 - v2;
}

module.exports._defaultComparitor = function() {
  var indexMode,indexModeSearch;
  return function(v,search){
    // support the object format of generated indexes
    if(indexMode === undefined){
      if(typeof v === 'object' && v.hasOwnProperty('v')) indexMode = true;
      if(typeof search === 'object' && search.hasOwnProperty('v')) indexModeSearch = true
    }

    if(indexMode) v = v.v;
    if(indexModeSearch) search = search.v;

    return v - search;
  };
};

module.exports._binarySearch = bs;
module.exports._binarySearchClosest = bsclosest;

function bs(arr, search, comparitor) {

  var max = arr.length-1,min = 0,middle,cmp;
  // continue searching while key may exist
  while (max >= min) {
    middle = mid(min, max);

    cmp = comparitor(arr[middle],search,middle);

    if (cmp < 0) {
      min = middle + 1;
    } else if (cmp > 0) {
      max = middle - 1;
    } else {
      return middle;
    }
  }
  // key not found
  return -1;
}

function bsclosest(arr, search, comparitor, invert, closest) {
  var mids = {}
  , min = 0,max = arr.length-1,middle,cmp
  , sanity = arr.length;

  while (min < max) {
    middle = midCareful(min, max,mids);
    cmp = comparitor(arr[middle],search,middle);
    if(invert){
      if (cmp > 0)max = middle - 1;
      else min = middle;
    } else {
      if (cmp < 0)min = middle + 1;
      else max = middle;
    }
    if(!--sanity) break;
  }

  if (max == min && comparitor(arr[min],search) === 0) return min;

  if(closest) {
    var match = comparitor(arr[min],search);
    if(min == arr.length-1 && match < 0) return min;
    if(min == 0 && match > 0) return 0;

    return closest?(invert?min+1:min-1):-1;
  }
  return -1;
}

function mid(v1,v2){
  return v1+Math.floor((v2-v1)/2);
}

function midCareful(v1,v2,mids){
  var mid = v1+Math.floor((v2-v1)/2);
  if(mids[mid]) mid = v1+Math.ceil((v2-v1)/2);
  mids[mid] = 1;
  return mid;
}


/***/ }),

/***/ "./src/node_modules/brace-expansion/index.js":
/*!***************************************************!*\
  !*** ./src/node_modules/brace-expansion/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var concatMap = __webpack_require__(/*! concat-map */ "./src/node_modules/concat-map/index.js");
var balanced = __webpack_require__(/*! balanced-match */ "./src/node_modules/balanced-match/index.js");

module.exports = expandTop;

var escSlash = '\0SLASH'+Math.random()+'\0';
var escOpen = '\0OPEN'+Math.random()+'\0';
var escClose = '\0CLOSE'+Math.random()+'\0';
var escComma = '\0COMMA'+Math.random()+'\0';
var escPeriod = '\0PERIOD'+Math.random()+'\0';

function numeric(str) {
  return parseInt(str, 10) == str
    ? parseInt(str, 10)
    : str.charCodeAt(0);
}

function escapeBraces(str) {
  return str.split('\\\\').join(escSlash)
            .split('\\{').join(escOpen)
            .split('\\}').join(escClose)
            .split('\\,').join(escComma)
            .split('\\.').join(escPeriod);
}

function unescapeBraces(str) {
  return str.split(escSlash).join('\\')
            .split(escOpen).join('{')
            .split(escClose).join('}')
            .split(escComma).join(',')
            .split(escPeriod).join('.');
}


// Basically just str.split(","), but handling cases
// where we have nested braced sections, which should be
// treated as individual members, like {a,{b,c},d}
function parseCommaParts(str) {
  if (!str)
    return [''];

  var parts = [];
  var m = balanced('{', '}', str);

  if (!m)
    return str.split(',');

  var pre = m.pre;
  var body = m.body;
  var post = m.post;
  var p = pre.split(',');

  p[p.length-1] += '{' + body + '}';
  var postParts = parseCommaParts(post);
  if (post.length) {
    p[p.length-1] += postParts.shift();
    p.push.apply(p, postParts);
  }

  parts.push.apply(parts, p);

  return parts;
}

function expandTop(str) {
  if (!str)
    return [];

  // I don't know why Bash 4.3 does this, but it does.
  // Anything starting with {} will have the first two bytes preserved
  // but *only* at the top level, so {},a}b will not expand to anything,
  // but a{},b}c will be expanded to [a}c,abc].
  // One could argue that this is a bug in Bash, but since the goal of
  // this module is to match Bash's rules, we escape a leading {}
  if (str.substr(0, 2) === '{}') {
    str = '\\{\\}' + str.substr(2);
  }

  return expand(escapeBraces(str), true).map(unescapeBraces);
}

function identity(e) {
  return e;
}

function embrace(str) {
  return '{' + str + '}';
}
function isPadded(el) {
  return /^-?0\d/.test(el);
}

function lte(i, y) {
  return i <= y;
}
function gte(i, y) {
  return i >= y;
}

function expand(str, isTop) {
  var expansions = [];

  var m = balanced('{', '}', str);
  if (!m || /\$$/.test(m.pre)) return [str];

  var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
  var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
  var isSequence = isNumericSequence || isAlphaSequence;
  var isOptions = m.body.indexOf(',') >= 0;
  if (!isSequence && !isOptions) {
    // {a},b}
    if (m.post.match(/,.*\}/)) {
      str = m.pre + '{' + m.body + escClose + m.post;
      return expand(str);
    }
    return [str];
  }

  var n;
  if (isSequence) {
    n = m.body.split(/\.\./);
  } else {
    n = parseCommaParts(m.body);
    if (n.length === 1) {
      // x{{a,b}}y ==> x{a}y x{b}y
      n = expand(n[0], false).map(embrace);
      if (n.length === 1) {
        var post = m.post.length
          ? expand(m.post, false)
          : [''];
        return post.map(function(p) {
          return m.pre + n[0] + p;
        });
      }
    }
  }

  // at this point, n is the parts, and we know it's not a comma set
  // with a single entry.

  // no need to expand pre, since it is guaranteed to be free of brace-sets
  var pre = m.pre;
  var post = m.post.length
    ? expand(m.post, false)
    : [''];

  var N;

  if (isSequence) {
    var x = numeric(n[0]);
    var y = numeric(n[1]);
    var width = Math.max(n[0].length, n[1].length)
    var incr = n.length == 3
      ? Math.abs(numeric(n[2]))
      : 1;
    var test = lte;
    var reverse = y < x;
    if (reverse) {
      incr *= -1;
      test = gte;
    }
    var pad = n.some(isPadded);

    N = [];

    for (var i = x; test(i, y); i += incr) {
      var c;
      if (isAlphaSequence) {
        c = String.fromCharCode(i);
        if (c === '\\')
          c = '';
      } else {
        c = String(i);
        if (pad) {
          var need = width - c.length;
          if (need > 0) {
            var z = new Array(need + 1).join('0');
            if (i < 0)
              c = '-' + z + c.slice(1);
            else
              c = z + c;
          }
        }
      }
      N.push(c);
    }
  } else {
    N = concatMap(n, function(el) { return expand(el, false) });
  }

  for (var j = 0; j < N.length; j++) {
    for (var k = 0; k < post.length; k++) {
      var expansion = pre + N[j] + post[k];
      if (!isTop || isSequence || expansion)
        expansions.push(expansion);
    }
  }

  return expansions;
}



/***/ }),

/***/ "./src/node_modules/buffers/index.js":
/*!*******************************************!*\
  !*** ./src/node_modules/buffers/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = Buffers;

function Buffers (bufs) {
    if (!(this instanceof Buffers)) return new Buffers(bufs);
    this.buffers = bufs || [];
    this.length = this.buffers.reduce(function (size, buf) {
        return size + buf.length
    }, 0);
}

Buffers.prototype.push = function () {
    for (var i = 0; i < arguments.length; i++) {
        if (!Buffer.isBuffer(arguments[i])) {
            throw new TypeError('Tried to push a non-buffer');
        }
    }

    for (var i = 0; i < arguments.length; i++) {
        var buf = arguments[i];
        this.buffers.push(buf);
        this.length += buf.length;
    }
    return this.length;
};

Buffers.prototype.unshift = function () {
    for (var i = 0; i < arguments.length; i++) {
        if (!Buffer.isBuffer(arguments[i])) {
            throw new TypeError('Tried to unshift a non-buffer');
        }
    }

    for (var i = 0; i < arguments.length; i++) {
        var buf = arguments[i];
        this.buffers.unshift(buf);
        this.length += buf.length;
    }
    return this.length;
};

Buffers.prototype.copy = function (dst, dStart, start, end) {
    return this.slice(start, end).copy(dst, dStart, 0, end - start);
};

Buffers.prototype.splice = function (i, howMany) {
    var buffers = this.buffers;
    var index = i >= 0 ? i : this.length - i;
    var reps = [].slice.call(arguments, 2);

    if (howMany === undefined) {
        howMany = this.length - index;
    }
    else if (howMany > this.length - index) {
        howMany = this.length - index;
    }

    for (var i = 0; i < reps.length; i++) {
        this.length += reps[i].length;
    }

    var removed = new Buffers();
    var bytes = 0;

    var startBytes = 0;
    for (
        var ii = 0;
        ii < buffers.length && startBytes + buffers[ii].length < index;
        ii ++
    ) { startBytes += buffers[ii].length }

    if (index - startBytes > 0) {
        var start = index - startBytes;

        if (start + howMany < buffers[ii].length) {
            removed.push(buffers[ii].slice(start, start + howMany));

            var orig = buffers[ii];
            //var buf = new Buffer(orig.length - howMany);
            var buf0 = new Buffer(start);
            for (var i = 0; i < start; i++) {
                buf0[i] = orig[i];
            }

            var buf1 = new Buffer(orig.length - start - howMany);
            for (var i = start + howMany; i < orig.length; i++) {
                buf1[ i - howMany - start ] = orig[i]
            }

            if (reps.length > 0) {
                var reps_ = reps.slice();
                reps_.unshift(buf0);
                reps_.push(buf1);
                buffers.splice.apply(buffers, [ ii, 1 ].concat(reps_));
                ii += reps_.length;
                reps = [];
            }
            else {
                buffers.splice(ii, 1, buf0, buf1);
                //buffers[ii] = buf;
                ii += 2;
            }
        }
        else {
            removed.push(buffers[ii].slice(start));
            buffers[ii] = buffers[ii].slice(0, start);
            ii ++;
        }
    }

    if (reps.length > 0) {
        buffers.splice.apply(buffers, [ ii, 0 ].concat(reps));
        ii += reps.length;
    }

    while (removed.length < howMany) {
        var buf = buffers[ii];
        var len = buf.length;
        var take = Math.min(len, howMany - removed.length);

        if (take === len) {
            removed.push(buf);
            buffers.splice(ii, 1);
        }
        else {
            removed.push(buf.slice(0, take));
            buffers[ii] = buffers[ii].slice(take);
        }
    }

    this.length -= removed.length;

    return removed;
};

Buffers.prototype.slice = function (i, j) {
    var buffers = this.buffers;
    if (j === undefined) j = this.length;
    if (i === undefined) i = 0;

    if (j > this.length) j = this.length;

    var startBytes = 0;
    for (
        var si = 0;
        si < buffers.length && startBytes + buffers[si].length <= i;
        si ++
    ) { startBytes += buffers[si].length }

    var target = new Buffer(j - i);

    var ti = 0;
    for (var ii = si; ti < j - i && ii < buffers.length; ii++) {
        var len = buffers[ii].length;

        var start = ti === 0 ? i - startBytes : 0;
        var end = ti + len >= j - i
            ? Math.min(start + (j - i) - ti, len)
            : len
        ;

        buffers[ii].copy(target, ti, start, end);
        ti += end - start;
    }

    return target;
};

Buffers.prototype.pos = function (i) {
    if (i < 0 || i >= this.length) throw new Error('oob');
    var l = i, bi = 0, bu = null;
    for (;;) {
        bu = this.buffers[bi];
        if (l < bu.length) {
            return {buf: bi, offset: l};
        } else {
            l -= bu.length;
        }
        bi++;
    }
};

Buffers.prototype.get = function get (i) {
    var pos = this.pos(i);

    return this.buffers[pos.buf].get(pos.offset);
};

Buffers.prototype.set = function set (i, b) {
    var pos = this.pos(i);

    return this.buffers[pos.buf].set(pos.offset, b);
};

Buffers.prototype.indexOf = function (needle, offset) {
    if ("string" === typeof needle) {
        needle = new Buffer(needle);
    } else if (needle instanceof Buffer) {
        // already a buffer
    } else {
        throw new Error('Invalid type for a search string');
    }

    if (!needle.length) {
        return 0;
    }

    if (!this.length) {
        return -1;
    }

    var i = 0, j = 0, match = 0, mstart, pos = 0;

    // start search from a particular point in the virtual buffer
    if (offset) {
        var p = this.pos(offset);
        i = p.buf;
        j = p.offset;
        pos = offset;
    }

    // for each character in virtual buffer
    for (;;) {
        while (j >= this.buffers[i].length) {
            j = 0;
            i++;

            if (i >= this.buffers.length) {
                // search string not found
                return -1;
            }
        }

        var char = this.buffers[i][j];

        if (char == needle[match]) {
            // keep track where match started
            if (match == 0) {
                mstart = {
                    i: i,
                    j: j,
                    pos: pos
                };
            }
            match++;
            if (match == needle.length) {
                // full match
                return mstart.pos;
            }
        } else if (match != 0) {
            // a partial match ended, go back to match starting position
            // this will continue the search at the next character
            i = mstart.i;
            j = mstart.j;
            pos = mstart.pos;
            match = 0;
        }

        j++;
        pos++;
    }
};

Buffers.prototype.toBuffer = function() {
    return this.slice();
}

Buffers.prototype.toString = function(encoding, start, end) {
    return this.slice(start, end).toString(encoding);
}


/***/ }),

/***/ "./src/node_modules/camelcase/index.js":
/*!*********************************************!*\
  !*** ./src/node_modules/camelcase/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function preserveCamelCase(str) {
	var isLastCharLower = false;

	for (var i = 0; i < str.length; i++) {
		var c = str.charAt(i);

		if (isLastCharLower && (/[a-zA-Z]/).test(c) && c.toUpperCase() === c) {
			str = str.substr(0, i) + '-' + str.substr(i);
			isLastCharLower = false;
			i++;
		} else {
			isLastCharLower = (c.toLowerCase() === c);
		}
	}

	return str;
}

module.exports = function () {
	var str = [].map.call(arguments, function (str) {
		return str.trim();
	}).filter(function (str) {
		return str.length;
	}).join('-');

	if (!str.length) {
		return '';
	}

	if (str.length === 1) {
		return str;
	}

	if (!(/[_.\- ]+/).test(str)) {
		if (str === str.toUpperCase()) {
			return str.toLowerCase();
		}

		if (str[0] !== str[0].toLowerCase()) {
			return str[0].toLowerCase() + str.slice(1);
		}

		return str;
	}

	str = preserveCamelCase(str);

	return str
	.replace(/^[_.\- ]+/, '')
	.toLowerCase()
	.replace(/[_.\- ]+(\w|$)/g, function (m, p1) {
		return p1.toUpperCase();
	});
};


/***/ }),

/***/ "./src/node_modules/chainsaw/index.js":
/*!********************************************!*\
  !*** ./src/node_modules/chainsaw/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Traverse = __webpack_require__(/*! traverse */ "./src/node_modules/traverse/index.js");
var EventEmitter = __webpack_require__(/*! events */ "events").EventEmitter;

module.exports = Chainsaw;
function Chainsaw (builder) {
    var saw = Chainsaw.saw(builder, {});
    var r = builder.call(saw.handlers, saw);
    if (r !== undefined) saw.handlers = r;
    saw.record();
    return saw.chain();
};

Chainsaw.light = function ChainsawLight (builder) {
    var saw = Chainsaw.saw(builder, {});
    var r = builder.call(saw.handlers, saw);
    if (r !== undefined) saw.handlers = r;
    return saw.chain();
};

Chainsaw.saw = function (builder, handlers) {
    var saw = new EventEmitter;
    saw.handlers = handlers;
    saw.actions = [];

    saw.chain = function () {
        var ch = Traverse(saw.handlers).map(function (node) {
            if (this.isRoot) return node;
            var ps = this.path;

            if (typeof node === 'function') {
                this.update(function () {
                    saw.actions.push({
                        path : ps,
                        args : [].slice.call(arguments)
                    });
                    return ch;
                });
            }
        });

        process.nextTick(function () {
            saw.emit('begin');
            saw.next();
        });

        return ch;
    };

    saw.pop = function () {
        return saw.actions.shift();
    };

    saw.next = function () {
        var action = saw.pop();

        if (!action) {
            saw.emit('end');
        }
        else if (!action.trap) {
            var node = saw.handlers;
            action.path.forEach(function (key) { node = node[key] });
            node.apply(saw.handlers, action.args);
        }
    };

    saw.nest = function (cb) {
        var args = [].slice.call(arguments, 1);
        var autonext = true;

        if (typeof cb === 'boolean') {
            var autonext = cb;
            cb = args.shift();
        }

        var s = Chainsaw.saw(builder, {});
        var r = builder.call(s.handlers, s);

        if (r !== undefined) s.handlers = r;

        // If we are recording...
        if ("undefined" !== typeof saw.step) {
            // ... our children should, too
            s.record();
        }

        cb.apply(s.chain(), args);
        if (autonext !== false) s.on('end', saw.next);
    };

    saw.record = function () {
        upgradeChainsaw(saw);
    };

    ['trap', 'down', 'jump'].forEach(function (method) {
        saw[method] = function () {
            throw new Error("To use the trap, down and jump features, please "+
                            "call record() first to start recording actions.");
        };
    });

    return saw;
};

function upgradeChainsaw(saw) {
    saw.step = 0;

    // override pop
    saw.pop = function () {
        return saw.actions[saw.step++];
    };

    saw.trap = function (name, cb) {
        var ps = Array.isArray(name) ? name : [name];
        saw.actions.push({
            path : ps,
            step : saw.step,
            cb : cb,
            trap : true
        });
    };

    saw.down = function (name) {
        var ps = (Array.isArray(name) ? name : [name]).join('/');
        var i = saw.actions.slice(saw.step).map(function (x) {
            if (x.trap && x.step <= saw.step) return false;
            return x.path.join('/') == ps;
        }).indexOf(true);

        if (i >= 0) saw.step += i;
        else saw.step = saw.actions.length;

        var act = saw.actions[saw.step - 1];
        if (act && act.trap) {
            // It's a trap!
            saw.step = act.step;
            act.cb();
        }
        else saw.next();
    };

    saw.jump = function (step) {
        saw.step = step;
        saw.next();
    };
};


/***/ }),

/***/ "./src/node_modules/cliui/index.js":
/*!*****************************************!*\
  !*** ./src/node_modules/cliui/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var stringWidth = __webpack_require__(/*! string-width */ "./src/node_modules/string-width/index.js")
var stripAnsi = __webpack_require__(/*! strip-ansi */ "./src/node_modules/strip-ansi/index.js")
var wrap = __webpack_require__(/*! wrap-ansi */ "./src/node_modules/wrap-ansi/index.js")
var align = {
  right: alignRight,
  center: alignCenter
}
var top = 0
var right = 1
var bottom = 2
var left = 3

function UI (opts) {
  this.width = opts.width
  this.wrap = opts.wrap
  this.rows = []
}

UI.prototype.span = function () {
  var cols = this.div.apply(this, arguments)
  cols.span = true
}

UI.prototype.div = function () {
  if (arguments.length === 0) this.div('')
  if (this.wrap && this._shouldApplyLayoutDSL.apply(this, arguments)) {
    return this._applyLayoutDSL(arguments[0])
  }

  var cols = []

  for (var i = 0, arg; (arg = arguments[i]) !== undefined; i++) {
    if (typeof arg === 'string') cols.push(this._colFromString(arg))
    else cols.push(arg)
  }

  this.rows.push(cols)
  return cols
}

UI.prototype._shouldApplyLayoutDSL = function () {
  return arguments.length === 1 && typeof arguments[0] === 'string' &&
    /[\t\n]/.test(arguments[0])
}

UI.prototype._applyLayoutDSL = function (str) {
  var _this = this
  var rows = str.split('\n')
  var leftColumnWidth = 0

  // simple heuristic for layout, make sure the
  // second column lines up along the left-hand.
  // don't allow the first column to take up more
  // than 50% of the screen.
  rows.forEach(function (row) {
    var columns = row.split('\t')
    if (columns.length > 1 && stringWidth(columns[0]) > leftColumnWidth) {
      leftColumnWidth = Math.min(
        Math.floor(_this.width * 0.5),
        stringWidth(columns[0])
      )
    }
  })

  // generate a table:
  //  replacing ' ' with padding calculations.
  //  using the algorithmically generated width.
  rows.forEach(function (row) {
    var columns = row.split('\t')
    _this.div.apply(_this, columns.map(function (r, i) {
      return {
        text: r.trim(),
        padding: _this._measurePadding(r),
        width: (i === 0 && columns.length > 1) ? leftColumnWidth : undefined
      }
    }))
  })

  return this.rows[this.rows.length - 1]
}

UI.prototype._colFromString = function (str) {
  return {
    text: str,
    padding: this._measurePadding(str)
  }
}

UI.prototype._measurePadding = function (str) {
  // measure padding without ansi escape codes
  var noAnsi = stripAnsi(str)
  return [0, noAnsi.match(/\s*$/)[0].length, 0, noAnsi.match(/^\s*/)[0].length]
}

UI.prototype.toString = function () {
  var _this = this
  var lines = []

  _this.rows.forEach(function (row, i) {
    _this.rowToString(row, lines)
  })

  // don't display any lines with the
  // hidden flag set.
  lines = lines.filter(function (line) {
    return !line.hidden
  })

  return lines.map(function (line) {
    return line.text
  }).join('\n')
}

UI.prototype.rowToString = function (row, lines) {
  var _this = this
  var padding
  var rrows = this._rasterize(row)
  var str = ''
  var ts
  var width
  var wrapWidth

  rrows.forEach(function (rrow, r) {
    str = ''
    rrow.forEach(function (col, c) {
      ts = '' // temporary string used during alignment/padding.
      width = row[c].width // the width with padding.
      wrapWidth = _this._negatePadding(row[c]) // the width without padding.

      ts += col

      for (var i = 0; i < wrapWidth - stringWidth(col); i++) {
        ts += ' '
      }

      // align the string within its column.
      if (row[c].align && row[c].align !== 'left' && _this.wrap) {
        ts = align[row[c].align](ts, wrapWidth)
        if (stringWidth(ts) < wrapWidth) ts += new Array(width - stringWidth(ts)).join(' ')
      }

      // apply border and padding to string.
      padding = row[c].padding || [0, 0, 0, 0]
      if (padding[left]) str += new Array(padding[left] + 1).join(' ')
      str += addBorder(row[c], ts, '| ')
      str += ts
      str += addBorder(row[c], ts, ' |')
      if (padding[right]) str += new Array(padding[right] + 1).join(' ')

      // if prior row is span, try to render the
      // current row on the prior line.
      if (r === 0 && lines.length > 0) {
        str = _this._renderInline(str, lines[lines.length - 1])
      }
    })

    // remove trailing whitespace.
    lines.push({
      text: str.replace(/ +$/, ''),
      span: row.span
    })
  })

  return lines
}

function addBorder (col, ts, style) {
  if (col.border) {
    if (/[.']-+[.']/.test(ts)) return ''
    else if (ts.trim().length) return style
    else return '  '
  }
  return ''
}

// if the full 'source' can render in
// the target line, do so.
UI.prototype._renderInline = function (source, previousLine) {
  var leadingWhitespace = source.match(/^ */)[0].length
  var target = previousLine.text
  var targetTextWidth = stringWidth(target.trimRight())

  if (!previousLine.span) return source

  // if we're not applying wrapping logic,
  // just always append to the span.
  if (!this.wrap) {
    previousLine.hidden = true
    return target + source
  }

  if (leadingWhitespace < targetTextWidth) return source

  previousLine.hidden = true

  return target.trimRight() + new Array(leadingWhitespace - targetTextWidth + 1).join(' ') + source.trimLeft()
}

UI.prototype._rasterize = function (row) {
  var _this = this
  var i
  var rrow
  var rrows = []
  var widths = this._columnWidths(row)
  var wrapped

  // word wrap all columns, and create
  // a data-structure that is easy to rasterize.
  row.forEach(function (col, c) {
    // leave room for left and right padding.
    col.width = widths[c]
    if (_this.wrap) wrapped = wrap(col.text, _this._negatePadding(col), {hard: true}).split('\n')
    else wrapped = col.text.split('\n')

    if (col.border) {
      wrapped.unshift('.' + new Array(_this._negatePadding(col) + 3).join('-') + '.')
      wrapped.push("'" + new Array(_this._negatePadding(col) + 3).join('-') + "'")
    }

    // add top and bottom padding.
    if (col.padding) {
      for (i = 0; i < (col.padding[top] || 0); i++) wrapped.unshift('')
      for (i = 0; i < (col.padding[bottom] || 0); i++) wrapped.push('')
    }

    wrapped.forEach(function (str, r) {
      if (!rrows[r]) rrows.push([])

      rrow = rrows[r]

      for (var i = 0; i < c; i++) {
        if (rrow[i] === undefined) rrow.push('')
      }
      rrow.push(str)
    })
  })

  return rrows
}

UI.prototype._negatePadding = function (col) {
  var wrapWidth = col.width
  if (col.padding) wrapWidth -= (col.padding[left] || 0) + (col.padding[right] || 0)
  if (col.border) wrapWidth -= 4
  return wrapWidth
}

UI.prototype._columnWidths = function (row) {
  var _this = this
  var widths = []
  var unset = row.length
  var unsetWidth
  var remainingWidth = this.width

  // column widths can be set in config.
  row.forEach(function (col, i) {
    if (col.width) {
      unset--
      widths[i] = col.width
      remainingWidth -= col.width
    } else {
      widths[i] = undefined
    }
  })

  // any unset widths should be calculated.
  if (unset) unsetWidth = Math.floor(remainingWidth / unset)
  widths.forEach(function (w, i) {
    if (!_this.wrap) widths[i] = row[i].width || stringWidth(row[i].text)
    else if (w === undefined) widths[i] = Math.max(unsetWidth, _minWidth(row[i]))
  })

  return widths
}

// calculates the minimum width of
// a column, based on padding preferences.
function _minWidth (col) {
  var padding = col.padding || []
  var minWidth = 1 + (padding[left] || 0) + (padding[right] || 0)
  if (col.border) minWidth += 4
  return minWidth
}

function alignRight (str, width) {
  str = str.trim()
  var padding = ''
  var strWidth = stringWidth(str)

  if (strWidth < width) {
    padding = new Array(width - strWidth + 1).join(' ')
  }

  return padding + str
}

function alignCenter (str, width) {
  str = str.trim()
  var padding = ''
  var strWidth = stringWidth(str.trim())

  if (strWidth < width) {
    padding = new Array(parseInt((width - strWidth) / 2, 10) + 1).join(' ')
  }

  return padding + str
}

module.exports = function (opts) {
  opts = opts || {}

  return new UI({
    width: (opts || {}).width || 80,
    wrap: typeof opts.wrap === 'boolean' ? opts.wrap : true
  })
}


/***/ }),

/***/ "./src/node_modules/code-point-at/index.js":
/*!*************************************************!*\
  !*** ./src/node_modules/code-point-at/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* eslint-disable babel/new-cap, xo/throw-new-error */

module.exports = function (str, pos) {
	if (str === null || str === undefined) {
		throw TypeError();
	}

	str = String(str);

	var size = str.length;
	var i = pos ? Number(pos) : 0;

	if (Number.isNaN(i)) {
		i = 0;
	}

	if (i < 0 || i >= size) {
		return undefined;
	}

	var first = str.charCodeAt(i);

	if (first >= 0xD800 && first <= 0xDBFF && size > i + 1) {
		var second = str.charCodeAt(i + 1);

		if (second >= 0xDC00 && second <= 0xDFFF) {
			return ((first - 0xD800) * 0x400) + second - 0xDC00 + 0x10000;
		}
	}

	return first;
};


/***/ }),

/***/ "./src/node_modules/concat-map/index.js":
/*!**********************************************!*\
  !*** ./src/node_modules/concat-map/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (xs, fn) {
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        var x = fn(xs[i], i);
        if (isArray(x)) res.push.apply(res, x);
        else res.push(x);
    }
    return res;
};

var isArray = Array.isArray || function (xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
};


/***/ }),

/***/ "./src/node_modules/cross-unzip/index.js":
/*!***********************************************!*\
  !*** ./src/node_modules/cross-unzip/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var spawn = __webpack_require__(/*! child_process */ "child_process").spawn
var slice = Array.prototype.slice

var unzip = process.platform === 'win32' ? forWin32 : forUnix
unzip.unzip = unzip
module.exports = unzip

// todo: progress feedback

// https://github.com/fritx/win-7zip
function forWin32 (inPath, outPath, callback) {
  var _7z = __webpack_require__(/*! 7zip */ "./src/node_modules/7zip/index.js")['7z']

  // very 奇葩
  // eg. 7z x archive.zip -oc:\Doc
  run(_7z, ['x', inPath, '-y', '-o' + outPath], callback)
}

function forUnix (inPath, outPath, callback) {
  run('unzip', ['-o', inPath, '-d', outPath], callback)
}

// https://nodejs.org/api/child_process.html#child_process_event_error
// Note that the 'exit' event may or may not fire after an error has occurred.
// If you are listening to both the 'exit' and 'error' events,
// it is important to guard against accidentally invoking handler functions multiple times.
function run (bin, args, callback) {
  callback = onceify(callback)

  var prc = spawn(bin, args, {
    stdio: 'ignore'
  })
  prc.on('error', function (err) {
    callback(err)
  })
  prc.on('exit', function (code) {
    callback(code ? new Error('Exited with code ' + code) : null)
  })
}

// http://stackoverflow.com/questions/30234908/javascript-v8-optimisation-and-leaking-arguments
// javascript V8 optimisation and “leaking arguments”
// making callback to be invoked only once
function onceify (fn) {
  var called = false
  return function () {
    if (called) return
    called = true
    fn.apply(this, slice.call(arguments)) // slice arguments
  }
}


/***/ }),

/***/ "./src/node_modules/damerau-levenshtein/damerau-levenshtein.js":
/*!*********************************************************************!*\
  !*** ./src/node_modules/damerau-levenshtein/damerau-levenshtein.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function DamerauLevenshtein (prices, damerau) {
    // 'prices' customisation of the edit costs by passing an
    // object with optional 'insert', 'remove', 'substitute', and
    // 'transpose' keys, corresponding to either a constant
    // number, or a function that returns the cost. The default
    // cost for each operation is 1. The price functions take
    // relevant character(s) as arguments, should return numbers,
    // and have the following form:
    //
    // insert: function (inserted) { return NUMBER; }
    //
    // remove: function (removed) { return NUMBER; }
    //
    // substitute: function (from, to) { return NUMBER; }
    //
    // transpose: function (backward, forward) { return NUMBER; }
    //
    // The damerau flag allows us to turn off transposition and
    // only do plain Levenshtein distance.

    if (damerau !== false) damerau = true;
    if (!prices) prices = {};
    var insert, remove, substitute, transpose;

    switch (typeof prices.insert) {
    case 'function': insert = prices.insert; break;
    case 'number': insert = function (c) { return prices.insert; }; break;
    default: insert = function (c) { return 1; }; break; }

    switch (typeof prices.remove) {
    case 'function': remove = prices.remove; break;
    case 'number': remove = function (c) { return prices.remove; }; break;
    default: remove = function (c) { return 1; }; break; }

    switch (typeof prices.substitute) {
    case 'function': substitute = prices.substitute; break;
    case 'number':
        substitute = function (from, to) { return prices.substitute; };
        break;
    default: substitute = function (from, to) { return 1; }; break; }

    switch (typeof prices.transpose) {
    case 'function': transpose = prices.transpose; break;
    case 'number':
        transpose = function (backward, forward) { return prices.transpose; };
        break;
    default: transpose = function (backward, forward) { return 1; }; break; }

    function distance(down, across) {
        // http://en.wikipedia.org/wiki/Damerau%E2%80%93Levenshtein_distance
        var ds = [];
        if ( down === across ) {
            return 0;
        } else {
            down = down.split(''); down.unshift(null);
            across = across.split(''); across.unshift(null);
            down.forEach(function (d, i) {
                if (!ds[i]) ds[i] = [];
                across.forEach(function (a, j) {
                    if (i === 0 && j === 0) ds[i][j] = 0;
                    // Empty down (i == 0) -> across[1..j] by inserting
                    else if (i === 0) ds[i][j] = ds[i][j-1] + insert(a);
                    // Down -> empty across (j == 0) by deleting
                    else if (j === 0) ds[i][j] = ds[i-1][j] + remove(d);
                    else {
                        // Find the least costly operation that turns
                        // the prefix down[1..i] into the prefix
                        // across[1..j] using already calculated costs
                        // for getting to shorter matches.
                        ds[i][j] = Math.min(
                            // Cost of editing down[1..i-1] to
                            // across[1..j] plus cost of deleting
                            // down[i] to get to down[1..i-1].
                            ds[i-1][j] + remove(d),
                            // Cost of editing down[1..i] to
                            // across[1..j-1] plus cost of inserting
                            // across[j] to get to across[1..j].
                            ds[i][j-1] + insert(a),
                            // Cost of editing down[1..i-1] to
                            // across[1..j-1] plus cost of
                            // substituting down[i] (d) with across[j]
                            // (a) to get to across[1..j].
                            ds[i-1][j-1] + (d === a ? 0 : substitute(d, a))
                        );
                        // Can we match the last two letters of down
                        // with across by transposing them? Cost of
                        // getting from down[i-2] to across[j-2] plus
                        // cost of moving down[i-1] forward and
                        // down[i] backward to match across[j-1..j].
                        if (damerau
                            && i > 1 && j > 1
                            && down[i-1] === a && d === across[j-1]) {
                            ds[i][j] = Math.min(
                                ds[i][j],
                                ds[i-2][j-2] + (d === a ? 0 : transpose(d, down[i-1]))
                            );
                        };
                    };
                });
            });
            return ds[down.length-1][across.length-1];
        };
    };
    return distance;
};

module.exports = DamerauLevenshtein;


/***/ }),

/***/ "./src/node_modules/decamelize/index.js":
/*!**********************************************!*\
  !*** ./src/node_modules/decamelize/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function (str, sep) {
	if (typeof str !== 'string') {
		throw new TypeError('Expected a string');
	}

	sep = typeof sep === 'undefined' ? '_' : sep;

	return str
		.replace(/([a-z\d])([A-Z])/g, '$1' + sep + '$2')
		.replace(/([A-Z]+)([A-Z][a-z\d]+)/g, '$1' + sep + '$2')
		.toLowerCase();
};


/***/ }),

/***/ "./src/node_modules/electron-devtools-installer/dist/downloadChromeExtension.js":
/*!**************************************************************************************!*\
  !*** ./src/node_modules/electron-devtools-installer/dist/downloadChromeExtension.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _fs = __webpack_require__(/*! fs */ "fs");

var _fs2 = _interopRequireDefault(_fs);

var _path = __webpack_require__(/*! path */ "path");

var _path2 = _interopRequireDefault(_path);

var _rimraf = __webpack_require__(/*! rimraf */ "./src/node_modules/rimraf/rimraf.js");

var _rimraf2 = _interopRequireDefault(_rimraf);

var _crossUnzip = __webpack_require__(/*! cross-unzip */ "./src/node_modules/cross-unzip/index.js");

var _crossUnzip2 = _interopRequireDefault(_crossUnzip);

var _utils = __webpack_require__(/*! ./utils */ "./src/node_modules/electron-devtools-installer/dist/utils.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var downloadChromeExtension = function downloadChromeExtension(chromeStoreID, forceDownload) {
  var attempts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 5;

  var extensionsStore = (0, _utils.getPath)();
  if (!_fs2.default.existsSync(extensionsStore)) {
    _fs2.default.mkdirSync(extensionsStore);
  }
  var extensionFolder = _path2.default.resolve(extensionsStore + '/' + chromeStoreID);
  return new Promise(function (resolve, reject) {
    if (!_fs2.default.existsSync(extensionFolder) || forceDownload) {
      if (_fs2.default.existsSync(extensionFolder)) {
        _rimraf2.default.sync(extensionFolder);
      }
      var fileURL = 'https://clients2.google.com/service/update2/crx?response=redirect&x=id%3D' + chromeStoreID + '%26uc&prodversion=32'; // eslint-disable-line
      var filePath = _path2.default.resolve(extensionFolder + '.crx');
      (0, _utils.downloadFile)(fileURL, filePath).then(function () {
        (0, _crossUnzip2.default)(filePath, extensionFolder, function (err) {
          if (err && !_fs2.default.existsSync(_path2.default.resolve(extensionFolder, 'manifest.json'))) {
            return reject(err);
          }
          (0, _utils.changePermissions)(extensionFolder, 755);
          resolve(extensionFolder);
        });
      }).catch(function (err) {
        console.log('Failed to fetch extension, trying ' + (attempts - 1) + ' more times'); // eslint-disable-line
        if (attempts <= 1) {
          return reject(err);
        }
        setTimeout(function () {
          downloadChromeExtension(chromeStoreID, forceDownload, attempts - 1).then(resolve).catch(reject);
        }, 200);
      });
    } else {
      resolve(extensionFolder);
    }
  });
};

exports.default = downloadChromeExtension;

/***/ }),

/***/ "./src/node_modules/electron-devtools-installer/dist/index.js":
/*!********************************************************************!*\
  !*** ./src/node_modules/electron-devtools-installer/dist/index.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MOBX_DEVTOOLS = exports.APOLLO_DEVELOPER_TOOLS = exports.CYCLEJS_DEVTOOL = exports.REACT_PERF = exports.REDUX_DEVTOOLS = exports.VUEJS_DEVTOOLS = exports.ANGULARJS_BATARANG = exports.JQUERY_DEBUGGER = exports.BACKBONE_DEBUGGER = exports.REACT_DEVELOPER_TOOLS = exports.EMBER_INSPECTOR = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _electron = __webpack_require__(/*! electron */ "electron");

var _electron2 = _interopRequireDefault(_electron);

var _fs = __webpack_require__(/*! fs */ "fs");

var _fs2 = _interopRequireDefault(_fs);

var _path = __webpack_require__(/*! path */ "path");

var _path2 = _interopRequireDefault(_path);

var _semver = __webpack_require__(/*! semver */ "./src/node_modules/semver/semver.js");

var _semver2 = _interopRequireDefault(_semver);

var _downloadChromeExtension = __webpack_require__(/*! ./downloadChromeExtension */ "./src/node_modules/electron-devtools-installer/dist/downloadChromeExtension.js");

var _downloadChromeExtension2 = _interopRequireDefault(_downloadChromeExtension);

var _utils = __webpack_require__(/*! ./utils */ "./src/node_modules/electron-devtools-installer/dist/utils.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var _ref = _electron.remote || _electron2.default,
    BrowserWindow = _ref.BrowserWindow;

var IDMap = {};
var IDMapPath = _path2.default.resolve((0, _utils.getPath)(), 'IDMap.json');
if (_fs2.default.existsSync(IDMapPath)) {
  try {
    IDMap = JSON.parse(_fs2.default.readFileSync(IDMapPath, 'utf8'));
  } catch (err) {
    console.error('electron-devtools-installer: Invalid JSON present in the IDMap file');
  }
}

var install = function install(extensionReference) {
  var forceDownload = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  if (Array.isArray(extensionReference)) {
    return Promise.all(extensionReference.map(function (extension) {
      return install(extension, forceDownload);
    }));
  }
  var chromeStoreID = void 0;
  if ((typeof extensionReference === 'undefined' ? 'undefined' : _typeof(extensionReference)) === 'object' && extensionReference.id) {
    chromeStoreID = extensionReference.id;
    var electronVersion = process.versions.electron.split('-')[0];
    if (!_semver2.default.satisfies(electronVersion, extensionReference.electron)) {
      return Promise.reject(new Error('Version of Electron: ' + electronVersion + ' does not match required range ' + extensionReference.electron + ' for extension ' + chromeStoreID) // eslint-disable-line
      );
    }
  } else if (typeof extensionReference === 'string') {
    chromeStoreID = extensionReference;
  } else {
    return Promise.reject(new Error('Invalid extensionReference passed in: "' + extensionReference + '"'));
  }
  var extensionName = IDMap[chromeStoreID];
  var extensionInstalled = extensionName && BrowserWindow.getDevToolsExtensions && BrowserWindow.getDevToolsExtensions()[extensionName];
  if (!forceDownload && extensionInstalled) {
    return Promise.resolve(IDMap[chromeStoreID]);
  }
  return (0, _downloadChromeExtension2.default)(chromeStoreID, forceDownload).then(function (extensionFolder) {
    // Use forceDownload, but already installed
    if (extensionInstalled) {
      BrowserWindow.removeDevToolsExtension(extensionName);
    }
    var name = BrowserWindow.addDevToolsExtension(extensionFolder); // eslint-disable-line
    _fs2.default.writeFileSync(IDMapPath, JSON.stringify(Object.assign(IDMap, _defineProperty({}, chromeStoreID, name))));
    return Promise.resolve(name);
  });
};

exports.default = install;
var EMBER_INSPECTOR = exports.EMBER_INSPECTOR = {
  id: 'bmdblncegkenkacieihfhpjfppoconhi',
  electron: '>=1.2.1'
};
var REACT_DEVELOPER_TOOLS = exports.REACT_DEVELOPER_TOOLS = {
  id: 'fmkadmapgofadopljbjfkapdkoienihi',
  electron: '>=1.2.1'
};
var BACKBONE_DEBUGGER = exports.BACKBONE_DEBUGGER = {
  id: 'bhljhndlimiafopmmhjlgfpnnchjjbhd',
  electron: '>=1.2.1'
};
var JQUERY_DEBUGGER = exports.JQUERY_DEBUGGER = {
  id: 'dbhhnnnpaeobfddmlalhnehgclcmjimi',
  electron: '>=1.2.1'
};
var ANGULARJS_BATARANG = exports.ANGULARJS_BATARANG = {
  id: 'ighdmehidhipcmcojjgiloacoafjmpfk',
  electron: '>=1.2.1'
};
var VUEJS_DEVTOOLS = exports.VUEJS_DEVTOOLS = {
  id: 'nhdogjmejiglipccpnnnanhbledajbpd',
  electron: '>=1.2.1'
};
var REDUX_DEVTOOLS = exports.REDUX_DEVTOOLS = {
  id: 'lmhkpmbekcpmknklioeibfkpmmfibljd',
  electron: '>=1.2.1'
};
var REACT_PERF = exports.REACT_PERF = {
  id: 'hacmcodfllhbnekmghgdlplbdnahmhmm',
  electron: '>=1.2.6'
};
var CYCLEJS_DEVTOOL = exports.CYCLEJS_DEVTOOL = {
  id: 'dfgplfmhhmdekalbpejekgfegkonjpfp',
  electron: '>=1.2.1'
};
var APOLLO_DEVELOPER_TOOLS = exports.APOLLO_DEVELOPER_TOOLS = {
  id: 'jdkknkkbebbapilgoeccciglkfbmbnfm',
  electron: '>=1.2.1'
};
var MOBX_DEVTOOLS = exports.MOBX_DEVTOOLS = {
  id: 'pfgnfdagidkfgccljigdamigbcnndkod',
  electron: '>=1.2.1'
};

/***/ }),

/***/ "./src/node_modules/electron-devtools-installer/dist/utils.js":
/*!********************************************************************!*\
  !*** ./src/node_modules/electron-devtools-installer/dist/utils.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.changePermissions = exports.downloadFile = exports.getPath = undefined;

var _electron = __webpack_require__(/*! electron */ "electron");

var _electron2 = _interopRequireDefault(_electron);

var _fs = __webpack_require__(/*! fs */ "fs");

var _fs2 = _interopRequireDefault(_fs);

var _path = __webpack_require__(/*! path */ "path");

var _path2 = _interopRequireDefault(_path);

var _https = __webpack_require__(/*! https */ "https");

var _https2 = _interopRequireDefault(_https);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var getPath = exports.getPath = function getPath() {
  var savePath = (_electron.remote || _electron2.default).app.getPath('userData');
  return _path2.default.resolve(savePath + '/extensions');
};

// Use https.get fallback for Electron < 1.4.5

var _ref = _electron.remote || _electron2.default,
    net = _ref.net;

var request = net ? net.request : _https2.default.get;

var downloadFile = exports.downloadFile = function downloadFile(from, to) {
  return new Promise(function (resolve, reject) {
    var req = request(from);
    req.on('response', function (res) {
      // Shouldn't handle redirect with `electron.net`, this is for https.get fallback
      if (res.statusCode >= 300 && res.statusCode < 400 && res.headers.location) {
        return downloadFile(res.headers.location, to).then(resolve).catch(reject);
      }
      res.pipe(_fs2.default.createWriteStream(to)).on('close', resolve);
    });
    req.on('error', reject);
    req.end();
  });
};

var changePermissions = exports.changePermissions = function changePermissions(dir, mode) {
  var files = _fs2.default.readdirSync(dir);
  files.forEach(function (file) {
    var filePath = _path2.default.join(dir, file);
    _fs2.default.chmodSync(filePath, parseInt(mode, 8));
    if (_fs2.default.statSync(filePath).isDirectory()) {
      changePermissions(filePath, mode);
    }
  });
};

/***/ }),

/***/ "./src/node_modules/electron-is-dev/index.js":
/*!***************************************************!*\
  !*** ./src/node_modules/electron-is-dev/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

const electron = __webpack_require__(/*! electron */ "electron");

const app = electron.app || electron.remote.app;

const isEnvSet = 'ELECTRON_IS_DEV' in process.env;
const getFromEnv = parseInt(process.env.ELECTRON_IS_DEV, 10) === 1;

module.exports = isEnvSet ? getFromEnv : !app.isPackaged;


/***/ }),

/***/ "./src/node_modules/electron-log/index.js":
/*!************************************************!*\
  !*** ./src/node_modules/electron-log/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (process.type === 'renderer') {
  module.exports = __webpack_require__(/*! ./renderer */ "./src/node_modules/electron-log/renderer.js");
} else {
  module.exports = __webpack_require__(/*! ./main */ "./src/node_modules/electron-log/main.js");
}

/***/ }),

/***/ "./src/node_modules/electron-log/lib/format.js":
/*!*****************************************************!*\
  !*** ./src/node_modules/electron-log/lib/format.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var util = __webpack_require__(/*! util */ "util");
var EOL  = __webpack_require__(/*! os */ "os").EOL;

module.exports = {
  format: format,
  formatTimeZone: formatTimeZone,
  pad: pad,
  stringifyArray: stringifyArray
};

function format(msg, formatter) {
  if (typeof formatter === 'function') {
    return formatter(msg);
  }

  var date = msg.date;

  return formatter
    .replace('{level}', msg.level)
    .replace('{text}', stringifyArray(msg.data))
    .replace('{y}', date.getFullYear())
    .replace('{m}', pad(date.getMonth() + 1))
    .replace('{d}', pad(date.getDate()))
    .replace('{h}', pad(date.getHours()))
    .replace('{i}', pad(date.getMinutes()))
    .replace('{s}', pad(date.getSeconds()))
    .replace('{ms}', pad(date.getMilliseconds(), 3))
    .replace('{z}', formatTimeZone(date.getTimezoneOffset()));
}

function stringifyArray(data) {
  data = data.map(function formatErrors(arg) {
    return arg instanceof Error ? arg.stack + EOL : arg;
  });
  return util.format.apply(util, data);
}

function pad(number, zeros) {
  zeros = zeros || 2;
  return (new Array(zeros + 1).join('0') + number).substr(-zeros, zeros);
}

function formatTimeZone(minutesOffset) {
  var m = Math.abs(minutesOffset);
  return (minutesOffset >= 0 ? '-' : '+') +
    pad(Math.floor(m / 60)) + ':' +
    pad(m % 60);
}


/***/ }),

/***/ "./src/node_modules/electron-log/lib/log.js":
/*!**************************************************!*\
  !*** ./src/node_modules/electron-log/lib/log.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// jshint -W040


var LEVELS = ['error', 'warn', 'info', 'verbose', 'debug', 'silly'];

module.exports = log;

function log(transports, level, text) {
  var data = Array.prototype.slice.call(arguments, 2);

  var msg = {
    data: data,
    date: new Date(),
    level: level
  };

  for (var i in transports) {
    // jshint -W089
    if (!transports.hasOwnProperty(i) || typeof transports[i] !== 'function') {
      continue;
    }

    var transport = transports[i];

    if (transport === false || !compareLevels(transport.level, level)) {
      continue;
    }

    if (transport.level === false) continue;

    transport.call(null, msg);
  }
}

function compareLevels(passLevel, checkLevel) {
  var pass = LEVELS.indexOf(passLevel);
  var check = LEVELS.indexOf(checkLevel);
  if (check === -1 || pass === -1) {
    return true;
  }
  return check <= pass;
}

/***/ }),

/***/ "./src/node_modules/electron-log/lib/original-console.js":
/*!***************************************************************!*\
  !*** ./src/node_modules/electron-log/lib/original-console.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Save console methods for using when originals are overridden
 */
module.exports = {
  context: console,
  error:   console.error,
  warn:    console.warn,
  info:    console.info,
  verbose: console.verbose,
  debug:   console.debug,
  silly:   console.silly,
  log:     console.log
};


/***/ }),

/***/ "./src/node_modules/electron-log/lib/transports/console.js":
/*!*****************************************************************!*\
  !*** ./src/node_modules/electron-log/lib/transports/console.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var format          = __webpack_require__(/*! ../format */ "./src/node_modules/electron-log/lib/format.js");
var originalConsole = __webpack_require__(/*! ../original-console */ "./src/node_modules/electron-log/lib/original-console.js");

transport.level  = 'silly';
transport.format = '[{h}:{i}:{s}.{ms}] [{level}] {text}';

module.exports = transport;

function transport(msg) {
  var text = format.format(msg, transport.format);
  if (originalConsole[msg.level]) {
    originalConsole[msg.level](text);
  } else {
    originalConsole.log(text);
  }
}



/***/ }),

/***/ "./src/node_modules/electron-log/lib/transports/file/find-log-path.js":
/*!****************************************************************************!*\
  !*** ./src/node_modules/electron-log/lib/transports/file/find-log-path.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var fs   = __webpack_require__(/*! fs */ "fs");
var path = __webpack_require__(/*! path */ "path");
var os   = __webpack_require__(/*! os */ "os");
var getAppName = __webpack_require__(/*! ./get-app-name */ "./src/node_modules/electron-log/lib/transports/file/get-app-name.js");

module.exports = findLogPath;

/**
 * Try to determine a platform-specific path where can write logs
 * @param {string} [appName] Used to determine the last part of a log path
 * @return {string|boolean}
 */
function findLogPath(appName) {
  appName = appName || getAppName();
  if (!appName) {
    return false;
  }

  var homeDir = os.homedir ? os.homedir() : process.env['HOME'];

  var dir;
  switch (process.platform) {
    case 'linux': {
      dir = prepareDir(process.env['XDG_CONFIG_HOME'], appName)
        .or(homeDir, '.config', appName)
        .or(process.env['XDG_DATA_HOME'], appName)
        .or(homeDir, '.local', 'share', appName)
        .result;
      break;
    }

    case 'darwin': {
      dir = prepareDir(homeDir, 'Library', 'Logs', appName)
        .or(homeDir, 'Library', 'Application Support', appName)
        .result;
      break;
    }

    case 'win32': {
      dir = prepareDir(process.env['APPDATA'], appName)
        .or(homeDir, 'AppData', 'Roaming', appName)
        .result;
      break;
    }
  }

  if (dir) {
    return path.join(dir, 'log.log');
  } else {
    return false;
  }
}



function prepareDir(dirPath) {
  // jshint -W040
  if (!this || this.or !== prepareDir || !this.result) {
    if (!dirPath) {
      return { or: prepareDir };
    }

    //noinspection JSCheckFunctionSignatures
    dirPath = path.join.apply(path, arguments);
    mkDir(dirPath);

    try {
      fs.accessSync(dirPath, fs.W_OK);
    } catch (e) {
      return { or: prepareDir };
    }
  }

  return {
    or: prepareDir,
    result: (this ? this.result : false) || dirPath
  };
}

function mkDir(dirPath, root) {
  var dirs = dirPath.split(path.sep);
  var dir = dirs.shift();
  root = (root || '') + dir + path.sep;

  try {
    fs.mkdirSync(root);
  } catch (e) {
    if (!fs.statSync(root).isDirectory()) {
      throw new Error(e);
    }
  }

  return !dirs.length || mkDir(dirs.join(path.sep), root);
}


/***/ }),

/***/ "./src/node_modules/electron-log/lib/transports/file/get-app-name.js":
/*!***************************************************************************!*\
  !*** ./src/node_modules/electron-log/lib/transports/file/get-app-name.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// jshint -W074


/** @name process.resourcesPath */

var fs   = __webpack_require__(/*! fs */ "fs");
var path = __webpack_require__(/*! path */ "path");
var consoleTransport = __webpack_require__(/*! ../console */ "./src/node_modules/electron-log/lib/transports/console.js");

module.exports = getAppName;

function getAppName() {
  try {
    var name = loadPackageName();
    if (name) {
      return name;
    }
    return warn('electron-log: unable to load the app name from package.json');
  } catch (e) {
    return warn('electron-log: ' + e.message);
  }
}

/**
 * Try to load main app package
 * @throws {Error}
 * @return {Object|null}
 */
function loadPackageName() {
  var packageFile;

  try {
    if (__webpack_require__.c[__webpack_require__.s].filename) {
      packageFile = find(path.dirname(__webpack_require__.c[__webpack_require__.s].filename));
    }
  } catch (e) {}

  if (!packageFile && process.resourcesPath) {
    packageFile = find(path.join(process.resourcesPath, 'app.asar'));
    var electronModule = path.join('node_modules', 'electron', 'package.json');
    if (packageFile && packageFile.indexOf(electronModule) !== -1) {
      packageFile = null;
    }
  }

  if (!packageFile) {
    packageFile = find(process.cwd());
  }

  if (!packageFile) {
    return null;
  }

  var content = fs.readFileSync(packageFile, 'utf-8');
  var packageData = JSON.parse(content);

  //noinspection JSUnresolvedVariable
  return packageData ? packageData.productName || packageData.name : false;
}

function find(root) {
  var file;

  while (!file) {
    var parent;
    file = path.join(root, 'package.json');

    try {
      fs.statSync(file);
    } catch (e) {
      parent = path.resolve(root, '..');
      file = null;
    }

    if (root === parent) {
      break;
    }

    root = parent;
  }

  return file;
}

function warn(message) {
  consoleTransport({
    data: [message],
    date: new Date(),
    level: 'warn'
  });
}

/***/ }),

/***/ "./src/node_modules/electron-log/lib/transports/file/index.js":
/*!********************************************************************!*\
  !*** ./src/node_modules/electron-log/lib/transports/file/index.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var fs               = __webpack_require__(/*! fs */ "fs");
var EOL              = __webpack_require__(/*! os */ "os").EOL;
var format           = __webpack_require__(/*! ../../format */ "./src/node_modules/electron-log/lib/format.js");
var consoleTransport = __webpack_require__(/*! ../console */ "./src/node_modules/electron-log/lib/transports/console.js");
var findLogPath      = __webpack_require__(/*! ./find-log-path */ "./src/node_modules/electron-log/lib/transports/file/find-log-path.js");

transport.findLogPath  = findLogPath;
transport.format       = '[{y}-{m}-{d} {h}:{i}:{s}.{ms}] [{level}] {text}';
transport.level        = 'warn';
transport.maxSize      = 1024 * 1024;
transport.streamConfig = undefined;

module.exports = transport;

function transport(msg) {
  var text = format.format(msg, transport.format) + EOL;

  if (transport.stream === undefined) {
    initSteamConfig();
    openStream();
  }

  if (transport.level === false) {
    return;
  }

  var needLogRotation = transport.maxSize > 0 &&
    getStreamSize(transport.stream) > transport.maxSize;

  if (needLogRotation) {
    archiveLog(transport.stream);
    openStream();
  }

  transport.stream.write(text);
}

function initSteamConfig() {
  transport.file = transport.file || findLogPath(transport.appName);

  if (!transport.file) {
    transport.level = false;
    logConsole('Could not set a log file');
  }
}

function openStream() {
  if (transport.level === false) {
    return;
  }

  transport.stream = fs.createWriteStream(
    transport.file,
    transport.streamConfig || { flags: 'a' }
  );
}

function getStreamSize(stream) {
  if (!stream) {
    return 0;
  }

  if (stream.logSizeAtStart === undefined) {
    try {
      stream.logSizeAtStart = fs.statSync(stream.path).size;
    } catch (e) {
      stream.logSizeAtStart = 0;
    }
  }

  return stream.logSizeAtStart + stream.bytesWritten;
}

function archiveLog(stream) {
  if (stream.end) {
    stream.end();
  }

  try {
    fs.renameSync(stream.path, stream.path.replace(/log$/, 'old.log'));
  } catch (e) {
    logConsole('Could not rotate log', e);
  }
}

function logConsole(message, error) {
  var data = ['electron-log.transports.file: ' + message];

  if (error) {
    data.push(error);
  }

  consoleTransport({ data: data, date: new Date(), level: 'warn' });
}


/***/ }),

/***/ "./src/node_modules/electron-log/lib/transports/log-s.js":
/*!***************************************************************!*\
  !*** ./src/node_modules/electron-log/lib/transports/log-s.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// jshint -W074, -W089


var http  = __webpack_require__(/*! http */ "http");
var https = __webpack_require__(/*! https */ "https");
var url   = __webpack_require__(/*! url */ "url");

transport.client = { name: 'electron-application' };
transport.depth  = 6;
transport.level  = false;
transport.url    = null;

module.exports = transport;

function transport(msg) {
  if (!transport.url) return;

  var data = jsonDepth({
    client: transport.client,
    data: msg.data,
    date: msg.date.getTime(),
    level: msg.level
  }, transport.depth + 1);

  post(transport.url, data);
}

function post(serverUrl, data) {
  var urlObject = url.parse(serverUrl);
  var transport = urlObject.protocol === 'https:' ? https : http;

  var body = JSON.stringify(data);

  var options = {
    hostname: urlObject.hostname,
    port:     urlObject.port,
    path:     urlObject.path,
    method:   'POST',
    headers:  {
      'Content-Type':  'application/json',
      'Content-Length': body.length
    }
  };

  var request = transport.request(options);
  request.write(body);
  request.end();
}

function jsonDepth(json, depth) {
  if (depth < 1) {
    if (Array.isArray(json))  return '[array]';
    if (typeof json === 'object')  return '[object]';
    return json;
  }

  if (Array.isArray(json)) {
    return json.map(function(child) {
      return jsonDepth(child, depth - 1);
    });
  }

  if (json && typeof json.getMonth === 'function') {
    return json;
  }

  if (json === null) {
    return null;
  }

  if (typeof json === 'object') {
    if (typeof json.toJSON === 'function') {
      json = json.toJSON();
    }

    var newJson = {};
    for (var i in json) {
      //noinspection JSUnfilteredForInLoop
      newJson[i] = jsonDepth(json[i], depth - 1);
    }

    return newJson;
  }

  return json;
}

/***/ }),

/***/ "./src/node_modules/electron-log/lib/transports/renderer-console.js":
/*!**************************************************************************!*\
  !*** ./src/node_modules/electron-log/lib/transports/renderer-console.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BrowserWindow;
try {
  BrowserWindow = __webpack_require__(/*! electron */ "electron").BrowserWindow;
} catch (e) {
  BrowserWindow = null;
}

var format = __webpack_require__(/*! ../format */ "./src/node_modules/electron-log/lib/format.js");

transport.level  = BrowserWindow ? 'silly' : false;
transport.format = '[{h}:{i}:{s}.{ms}] {text}';

module.exports = transport;

function transport(msg) {
  if (!BrowserWindow) return;

  var text = format.format(msg, transport.format);
  BrowserWindow.getAllWindows().forEach(function(wnd) {
    wnd.webContents.send('__ELECTRON_LOG_RENDERER__', msg.level, text);
  });
}


/***/ }),

/***/ "./src/node_modules/electron-log/main.js":
/*!***********************************************!*\
  !*** ./src/node_modules/electron-log/main.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var electron;
try {
  electron = __webpack_require__(/*! electron */ "electron");
} catch (e) {
  electron = null;
}

var log                      = __webpack_require__(/*! ./lib/log */ "./src/node_modules/electron-log/lib/log.js");
var transportConsole         = __webpack_require__(/*! ./lib/transports/console */ "./src/node_modules/electron-log/lib/transports/console.js");
var transportFile            = __webpack_require__(/*! ./lib/transports/file */ "./src/node_modules/electron-log/lib/transports/file/index.js");
var transportLogS            = __webpack_require__(/*! ./lib/transports/log-s */ "./src/node_modules/electron-log/lib/transports/log-s.js");
var transportRendererConsole = __webpack_require__(/*! ./lib/transports/renderer-console */ "./src/node_modules/electron-log/lib/transports/renderer-console.js");

var transports = {
  console: transportConsole,
  file: transportFile,
  logS: transportLogS,
  rendererConsole: transportRendererConsole
};

module.exports = {
  transports: transports,

  error:   log.bind(null, transports, 'error'),
  warn:    log.bind(null, transports, 'warn'),
  info:    log.bind(null, transports, 'info'),
  verbose: log.bind(null, transports, 'verbose'),
  debug:   log.bind(null, transports, 'debug'),
  silly:   log.bind(null, transports, 'silly'),
  log:     log.bind(null, transports, 'info')
};

module.exports.default = module.exports;

if (electron && electron.ipcMain) {
  electron.ipcMain.on('__ELECTRON_LOG__', onRendererLog);
  var appName = electron.app.getName();
  if (appName !== 'Electron') {
    transportFile.appName = appName;
  }
}

function onRendererLog(event, data) {
  if (Array.isArray(data)) {
    data.unshift(transports);
    log.apply(null, data);
  }
}


/***/ }),

/***/ "./src/node_modules/electron-log/renderer.js":
/*!***************************************************!*\
  !*** ./src/node_modules/electron-log/renderer.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = null;

var ipcRenderer;
try {
  ipcRenderer = __webpack_require__(/*! electron */ "electron").ipcRenderer;
} catch (e) {
  ipcRenderer = null;
}

var originalConsole = __webpack_require__(/*! ./lib/original-console */ "./src/node_modules/electron-log/lib/original-console.js");

if (ipcRenderer) {
  module.exports = {
    error:   log.bind(null, 'error'),
    warn:    log.bind(null, 'warn'),
    info:    log.bind(null, 'info'),
    verbose: log.bind(null, 'verbose'),
    debug:   log.bind(null, 'debug'),
    silly:   log.bind(null, 'silly'),
    log:     log.bind(null, 'info')
  };

  module.exports.default = module.exports;

  ipcRenderer.on('__ELECTRON_LOG_RENDERER__', function(event, level, data) {
    if (level === 'verbose') {
      level = 'log';
    } else if (level === 'silly') {
      level = 'debug';
    }

    originalConsole[level].apply(
      originalConsole.context,
      typeof data === 'string' ? [data] : data
    );
  });
}

function log() {
  var data = Array.prototype.slice.call(arguments);

  data = data.map(function(obj) {
    if (obj instanceof Error) {
      obj = obj.stack || obj;
    }

    return obj;
  });

  ipcRenderer.send('__ELECTRON_LOG__', data);
}


/***/ }),

/***/ "./src/node_modules/fs.realpath/index.js":
/*!***********************************************!*\
  !*** ./src/node_modules/fs.realpath/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = realpath
realpath.realpath = realpath
realpath.sync = realpathSync
realpath.realpathSync = realpathSync
realpath.monkeypatch = monkeypatch
realpath.unmonkeypatch = unmonkeypatch

var fs = __webpack_require__(/*! fs */ "fs")
var origRealpath = fs.realpath
var origRealpathSync = fs.realpathSync

var version = process.version
var ok = /^v[0-5]\./.test(version)
var old = __webpack_require__(/*! ./old.js */ "./src/node_modules/fs.realpath/old.js")

function newError (er) {
  return er && er.syscall === 'realpath' && (
    er.code === 'ELOOP' ||
    er.code === 'ENOMEM' ||
    er.code === 'ENAMETOOLONG'
  )
}

function realpath (p, cache, cb) {
  if (ok) {
    return origRealpath(p, cache, cb)
  }

  if (typeof cache === 'function') {
    cb = cache
    cache = null
  }
  origRealpath(p, cache, function (er, result) {
    if (newError(er)) {
      old.realpath(p, cache, cb)
    } else {
      cb(er, result)
    }
  })
}

function realpathSync (p, cache) {
  if (ok) {
    return origRealpathSync(p, cache)
  }

  try {
    return origRealpathSync(p, cache)
  } catch (er) {
    if (newError(er)) {
      return old.realpathSync(p, cache)
    } else {
      throw er
    }
  }
}

function monkeypatch () {
  fs.realpath = realpath
  fs.realpathSync = realpathSync
}

function unmonkeypatch () {
  fs.realpath = origRealpath
  fs.realpathSync = origRealpathSync
}


/***/ }),

/***/ "./src/node_modules/fs.realpath/old.js":
/*!*********************************************!*\
  !*** ./src/node_modules/fs.realpath/old.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var pathModule = __webpack_require__(/*! path */ "path");
var isWindows = process.platform === 'win32';
var fs = __webpack_require__(/*! fs */ "fs");

// JavaScript implementation of realpath, ported from node pre-v6

var DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);

function rethrow() {
  // Only enable in debug mode. A backtrace uses ~1000 bytes of heap space and
  // is fairly slow to generate.
  var callback;
  if (DEBUG) {
    var backtrace = new Error;
    callback = debugCallback;
  } else
    callback = missingCallback;

  return callback;

  function debugCallback(err) {
    if (err) {
      backtrace.message = err.message;
      err = backtrace;
      missingCallback(err);
    }
  }

  function missingCallback(err) {
    if (err) {
      if (process.throwDeprecation)
        throw err;  // Forgot a callback but don't know where? Use NODE_DEBUG=fs
      else if (!process.noDeprecation) {
        var msg = 'fs: missing callback ' + (err.stack || err.message);
        if (process.traceDeprecation)
          console.trace(msg);
        else
          console.error(msg);
      }
    }
  }
}

function maybeCallback(cb) {
  return typeof cb === 'function' ? cb : rethrow();
}

var normalize = pathModule.normalize;

// Regexp that finds the next partion of a (partial) path
// result is [base_with_slash, base], e.g. ['somedir/', 'somedir']
if (isWindows) {
  var nextPartRe = /(.*?)(?:[\/\\]+|$)/g;
} else {
  var nextPartRe = /(.*?)(?:[\/]+|$)/g;
}

// Regex to find the device root, including trailing slash. E.g. 'c:\\'.
if (isWindows) {
  var splitRootRe = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
} else {
  var splitRootRe = /^[\/]*/;
}

exports.realpathSync = function realpathSync(p, cache) {
  // make p is absolute
  p = pathModule.resolve(p);

  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
    return cache[p];
  }

  var original = p,
      seenLinks = {},
      knownHard = {};

  // current character position in p
  var pos;
  // the partial path so far, including a trailing slash if any
  var current;
  // the partial path without a trailing slash (except when pointing at a root)
  var base;
  // the partial path scanned in the previous round, with slash
  var previous;

  start();

  function start() {
    // Skip over roots
    var m = splitRootRe.exec(p);
    pos = m[0].length;
    current = m[0];
    base = m[0];
    previous = '';

    // On windows, check that the root exists. On unix there is no need.
    if (isWindows && !knownHard[base]) {
      fs.lstatSync(base);
      knownHard[base] = true;
    }
  }

  // walk down the path, swapping out linked pathparts for their real
  // values
  // NB: p.length changes.
  while (pos < p.length) {
    // find the next part
    nextPartRe.lastIndex = pos;
    var result = nextPartRe.exec(p);
    previous = current;
    current += result[0];
    base = previous + result[1];
    pos = nextPartRe.lastIndex;

    // continue if not a symlink
    if (knownHard[base] || (cache && cache[base] === base)) {
      continue;
    }

    var resolvedLink;
    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
      // some known symbolic link.  no need to stat again.
      resolvedLink = cache[base];
    } else {
      var stat = fs.lstatSync(base);
      if (!stat.isSymbolicLink()) {
        knownHard[base] = true;
        if (cache) cache[base] = base;
        continue;
      }

      // read the link if it wasn't read before
      // dev/ino always return 0 on windows, so skip the check.
      var linkTarget = null;
      if (!isWindows) {
        var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);
        if (seenLinks.hasOwnProperty(id)) {
          linkTarget = seenLinks[id];
        }
      }
      if (linkTarget === null) {
        fs.statSync(base);
        linkTarget = fs.readlinkSync(base);
      }
      resolvedLink = pathModule.resolve(previous, linkTarget);
      // track this, if given a cache.
      if (cache) cache[base] = resolvedLink;
      if (!isWindows) seenLinks[id] = linkTarget;
    }

    // resolve the link, then start over
    p = pathModule.resolve(resolvedLink, p.slice(pos));
    start();
  }

  if (cache) cache[original] = p;

  return p;
};


exports.realpath = function realpath(p, cache, cb) {
  if (typeof cb !== 'function') {
    cb = maybeCallback(cache);
    cache = null;
  }

  // make p is absolute
  p = pathModule.resolve(p);

  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
    return process.nextTick(cb.bind(null, null, cache[p]));
  }

  var original = p,
      seenLinks = {},
      knownHard = {};

  // current character position in p
  var pos;
  // the partial path so far, including a trailing slash if any
  var current;
  // the partial path without a trailing slash (except when pointing at a root)
  var base;
  // the partial path scanned in the previous round, with slash
  var previous;

  start();

  function start() {
    // Skip over roots
    var m = splitRootRe.exec(p);
    pos = m[0].length;
    current = m[0];
    base = m[0];
    previous = '';

    // On windows, check that the root exists. On unix there is no need.
    if (isWindows && !knownHard[base]) {
      fs.lstat(base, function(err) {
        if (err) return cb(err);
        knownHard[base] = true;
        LOOP();
      });
    } else {
      process.nextTick(LOOP);
    }
  }

  // walk down the path, swapping out linked pathparts for their real
  // values
  function LOOP() {
    // stop if scanned past end of path
    if (pos >= p.length) {
      if (cache) cache[original] = p;
      return cb(null, p);
    }

    // find the next part
    nextPartRe.lastIndex = pos;
    var result = nextPartRe.exec(p);
    previous = current;
    current += result[0];
    base = previous + result[1];
    pos = nextPartRe.lastIndex;

    // continue if not a symlink
    if (knownHard[base] || (cache && cache[base] === base)) {
      return process.nextTick(LOOP);
    }

    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
      // known symbolic link.  no need to stat again.
      return gotResolvedLink(cache[base]);
    }

    return fs.lstat(base, gotStat);
  }

  function gotStat(err, stat) {
    if (err) return cb(err);

    // if not a symlink, skip to the next path part
    if (!stat.isSymbolicLink()) {
      knownHard[base] = true;
      if (cache) cache[base] = base;
      return process.nextTick(LOOP);
    }

    // stat & read the link if not read before
    // call gotTarget as soon as the link target is known
    // dev/ino always return 0 on windows, so skip the check.
    if (!isWindows) {
      var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);
      if (seenLinks.hasOwnProperty(id)) {
        return gotTarget(null, seenLinks[id], base);
      }
    }
    fs.stat(base, function(err) {
      if (err) return cb(err);

      fs.readlink(base, function(err, target) {
        if (!isWindows) seenLinks[id] = target;
        gotTarget(err, target);
      });
    });
  }

  function gotTarget(err, target, base) {
    if (err) return cb(err);

    var resolvedLink = pathModule.resolve(previous, target);
    if (cache) cache[base] = resolvedLink;
    gotResolvedLink(resolvedLink);
  }

  function gotResolvedLink(resolvedLink) {
    // resolve the link, then start over
    p = pathModule.resolve(resolvedLink, p.slice(pos));
    start();
  }
};


/***/ }),

/***/ "./src/node_modules/glob/common.js":
/*!*****************************************!*\
  !*** ./src/node_modules/glob/common.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports.alphasort = alphasort
exports.alphasorti = alphasorti
exports.setopts = setopts
exports.ownProp = ownProp
exports.makeAbs = makeAbs
exports.finish = finish
exports.mark = mark
exports.isIgnored = isIgnored
exports.childrenIgnored = childrenIgnored

function ownProp (obj, field) {
  return Object.prototype.hasOwnProperty.call(obj, field)
}

var path = __webpack_require__(/*! path */ "path")
var minimatch = __webpack_require__(/*! minimatch */ "./src/node_modules/minimatch/minimatch.js")
var isAbsolute = __webpack_require__(/*! path-is-absolute */ "./src/node_modules/path-is-absolute/index.js")
var Minimatch = minimatch.Minimatch

function alphasorti (a, b) {
  return a.toLowerCase().localeCompare(b.toLowerCase())
}

function alphasort (a, b) {
  return a.localeCompare(b)
}

function setupIgnores (self, options) {
  self.ignore = options.ignore || []

  if (!Array.isArray(self.ignore))
    self.ignore = [self.ignore]

  if (self.ignore.length) {
    self.ignore = self.ignore.map(ignoreMap)
  }
}

// ignore patterns are always in dot:true mode.
function ignoreMap (pattern) {
  var gmatcher = null
  if (pattern.slice(-3) === '/**') {
    var gpattern = pattern.replace(/(\/\*\*)+$/, '')
    gmatcher = new Minimatch(gpattern, { dot: true })
  }

  return {
    matcher: new Minimatch(pattern, { dot: true }),
    gmatcher: gmatcher
  }
}

function setopts (self, pattern, options) {
  if (!options)
    options = {}

  // base-matching: just use globstar for that.
  if (options.matchBase && -1 === pattern.indexOf("/")) {
    if (options.noglobstar) {
      throw new Error("base matching requires globstar")
    }
    pattern = "**/" + pattern
  }

  self.silent = !!options.silent
  self.pattern = pattern
  self.strict = options.strict !== false
  self.realpath = !!options.realpath
  self.realpathCache = options.realpathCache || Object.create(null)
  self.follow = !!options.follow
  self.dot = !!options.dot
  self.mark = !!options.mark
  self.nodir = !!options.nodir
  if (self.nodir)
    self.mark = true
  self.sync = !!options.sync
  self.nounique = !!options.nounique
  self.nonull = !!options.nonull
  self.nosort = !!options.nosort
  self.nocase = !!options.nocase
  self.stat = !!options.stat
  self.noprocess = !!options.noprocess
  self.absolute = !!options.absolute

  self.maxLength = options.maxLength || Infinity
  self.cache = options.cache || Object.create(null)
  self.statCache = options.statCache || Object.create(null)
  self.symlinks = options.symlinks || Object.create(null)

  setupIgnores(self, options)

  self.changedCwd = false
  var cwd = process.cwd()
  if (!ownProp(options, "cwd"))
    self.cwd = cwd
  else {
    self.cwd = path.resolve(options.cwd)
    self.changedCwd = self.cwd !== cwd
  }

  self.root = options.root || path.resolve(self.cwd, "/")
  self.root = path.resolve(self.root)
  if (process.platform === "win32")
    self.root = self.root.replace(/\\/g, "/")

  // TODO: is an absolute `cwd` supposed to be resolved against `root`?
  // e.g. { cwd: '/test', root: __dirname } === path.join(__dirname, '/test')
  self.cwdAbs = isAbsolute(self.cwd) ? self.cwd : makeAbs(self, self.cwd)
  if (process.platform === "win32")
    self.cwdAbs = self.cwdAbs.replace(/\\/g, "/")
  self.nomount = !!options.nomount

  // disable comments and negation in Minimatch.
  // Note that they are not supported in Glob itself anyway.
  options.nonegate = true
  options.nocomment = true

  self.minimatch = new Minimatch(pattern, options)
  self.options = self.minimatch.options
}

function finish (self) {
  var nou = self.nounique
  var all = nou ? [] : Object.create(null)

  for (var i = 0, l = self.matches.length; i < l; i ++) {
    var matches = self.matches[i]
    if (!matches || Object.keys(matches).length === 0) {
      if (self.nonull) {
        // do like the shell, and spit out the literal glob
        var literal = self.minimatch.globSet[i]
        if (nou)
          all.push(literal)
        else
          all[literal] = true
      }
    } else {
      // had matches
      var m = Object.keys(matches)
      if (nou)
        all.push.apply(all, m)
      else
        m.forEach(function (m) {
          all[m] = true
        })
    }
  }

  if (!nou)
    all = Object.keys(all)

  if (!self.nosort)
    all = all.sort(self.nocase ? alphasorti : alphasort)

  // at *some* point we statted all of these
  if (self.mark) {
    for (var i = 0; i < all.length; i++) {
      all[i] = self._mark(all[i])
    }
    if (self.nodir) {
      all = all.filter(function (e) {
        var notDir = !(/\/$/.test(e))
        var c = self.cache[e] || self.cache[makeAbs(self, e)]
        if (notDir && c)
          notDir = c !== 'DIR' && !Array.isArray(c)
        return notDir
      })
    }
  }

  if (self.ignore.length)
    all = all.filter(function(m) {
      return !isIgnored(self, m)
    })

  self.found = all
}

function mark (self, p) {
  var abs = makeAbs(self, p)
  var c = self.cache[abs]
  var m = p
  if (c) {
    var isDir = c === 'DIR' || Array.isArray(c)
    var slash = p.slice(-1) === '/'

    if (isDir && !slash)
      m += '/'
    else if (!isDir && slash)
      m = m.slice(0, -1)

    if (m !== p) {
      var mabs = makeAbs(self, m)
      self.statCache[mabs] = self.statCache[abs]
      self.cache[mabs] = self.cache[abs]
    }
  }

  return m
}

// lotta situps...
function makeAbs (self, f) {
  var abs = f
  if (f.charAt(0) === '/') {
    abs = path.join(self.root, f)
  } else if (isAbsolute(f) || f === '') {
    abs = f
  } else if (self.changedCwd) {
    abs = path.resolve(self.cwd, f)
  } else {
    abs = path.resolve(f)
  }

  if (process.platform === 'win32')
    abs = abs.replace(/\\/g, '/')

  return abs
}


// Return true, if pattern ends with globstar '**', for the accompanying parent directory.
// Ex:- If node_modules/** is the pattern, add 'node_modules' to ignore list along with it's contents
function isIgnored (self, path) {
  if (!self.ignore.length)
    return false

  return self.ignore.some(function(item) {
    return item.matcher.match(path) || !!(item.gmatcher && item.gmatcher.match(path))
  })
}

function childrenIgnored (self, path) {
  if (!self.ignore.length)
    return false

  return self.ignore.some(function(item) {
    return !!(item.gmatcher && item.gmatcher.match(path))
  })
}


/***/ }),

/***/ "./src/node_modules/glob/glob.js":
/*!***************************************!*\
  !*** ./src/node_modules/glob/glob.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Approach:
//
// 1. Get the minimatch set
// 2. For each pattern in the set, PROCESS(pattern, false)
// 3. Store matches per-set, then uniq them
//
// PROCESS(pattern, inGlobStar)
// Get the first [n] items from pattern that are all strings
// Join these together.  This is PREFIX.
//   If there is no more remaining, then stat(PREFIX) and
//   add to matches if it succeeds.  END.
//
// If inGlobStar and PREFIX is symlink and points to dir
//   set ENTRIES = []
// else readdir(PREFIX) as ENTRIES
//   If fail, END
//
// with ENTRIES
//   If pattern[n] is GLOBSTAR
//     // handle the case where the globstar match is empty
//     // by pruning it out, and testing the resulting pattern
//     PROCESS(pattern[0..n] + pattern[n+1 .. $], false)
//     // handle other cases.
//     for ENTRY in ENTRIES (not dotfiles)
//       // attach globstar + tail onto the entry
//       // Mark that this entry is a globstar match
//       PROCESS(pattern[0..n] + ENTRY + pattern[n .. $], true)
//
//   else // not globstar
//     for ENTRY in ENTRIES (not dotfiles, unless pattern[n] is dot)
//       Test ENTRY against pattern[n]
//       If fails, continue
//       If passes, PROCESS(pattern[0..n] + item + pattern[n+1 .. $])
//
// Caveat:
//   Cache all stats and readdirs results to minimize syscall.  Since all
//   we ever care about is existence and directory-ness, we can just keep
//   `true` for files, and [children,...] for directories, or `false` for
//   things that don't exist.

module.exports = glob

var fs = __webpack_require__(/*! fs */ "fs")
var rp = __webpack_require__(/*! fs.realpath */ "./src/node_modules/fs.realpath/index.js")
var minimatch = __webpack_require__(/*! minimatch */ "./src/node_modules/minimatch/minimatch.js")
var Minimatch = minimatch.Minimatch
var inherits = __webpack_require__(/*! inherits */ "./src/node_modules/inherits/inherits.js")
var EE = __webpack_require__(/*! events */ "events").EventEmitter
var path = __webpack_require__(/*! path */ "path")
var assert = __webpack_require__(/*! assert */ "assert")
var isAbsolute = __webpack_require__(/*! path-is-absolute */ "./src/node_modules/path-is-absolute/index.js")
var globSync = __webpack_require__(/*! ./sync.js */ "./src/node_modules/glob/sync.js")
var common = __webpack_require__(/*! ./common.js */ "./src/node_modules/glob/common.js")
var alphasort = common.alphasort
var alphasorti = common.alphasorti
var setopts = common.setopts
var ownProp = common.ownProp
var inflight = __webpack_require__(/*! inflight */ "./src/node_modules/inflight/inflight.js")
var util = __webpack_require__(/*! util */ "util")
var childrenIgnored = common.childrenIgnored
var isIgnored = common.isIgnored

var once = __webpack_require__(/*! once */ "./src/node_modules/once/once.js")

function glob (pattern, options, cb) {
  if (typeof options === 'function') cb = options, options = {}
  if (!options) options = {}

  if (options.sync) {
    if (cb)
      throw new TypeError('callback provided to sync glob')
    return globSync(pattern, options)
  }

  return new Glob(pattern, options, cb)
}

glob.sync = globSync
var GlobSync = glob.GlobSync = globSync.GlobSync

// old api surface
glob.glob = glob

function extend (origin, add) {
  if (add === null || typeof add !== 'object') {
    return origin
  }

  var keys = Object.keys(add)
  var i = keys.length
  while (i--) {
    origin[keys[i]] = add[keys[i]]
  }
  return origin
}

glob.hasMagic = function (pattern, options_) {
  var options = extend({}, options_)
  options.noprocess = true

  var g = new Glob(pattern, options)
  var set = g.minimatch.set

  if (!pattern)
    return false

  if (set.length > 1)
    return true

  for (var j = 0; j < set[0].length; j++) {
    if (typeof set[0][j] !== 'string')
      return true
  }

  return false
}

glob.Glob = Glob
inherits(Glob, EE)
function Glob (pattern, options, cb) {
  if (typeof options === 'function') {
    cb = options
    options = null
  }

  if (options && options.sync) {
    if (cb)
      throw new TypeError('callback provided to sync glob')
    return new GlobSync(pattern, options)
  }

  if (!(this instanceof Glob))
    return new Glob(pattern, options, cb)

  setopts(this, pattern, options)
  this._didRealPath = false

  // process each pattern in the minimatch set
  var n = this.minimatch.set.length

  // The matches are stored as {<filename>: true,...} so that
  // duplicates are automagically pruned.
  // Later, we do an Object.keys() on these.
  // Keep them as a list so we can fill in when nonull is set.
  this.matches = new Array(n)

  if (typeof cb === 'function') {
    cb = once(cb)
    this.on('error', cb)
    this.on('end', function (matches) {
      cb(null, matches)
    })
  }

  var self = this
  this._processing = 0

  this._emitQueue = []
  this._processQueue = []
  this.paused = false

  if (this.noprocess)
    return this

  if (n === 0)
    return done()

  var sync = true
  for (var i = 0; i < n; i ++) {
    this._process(this.minimatch.set[i], i, false, done)
  }
  sync = false

  function done () {
    --self._processing
    if (self._processing <= 0) {
      if (sync) {
        process.nextTick(function () {
          self._finish()
        })
      } else {
        self._finish()
      }
    }
  }
}

Glob.prototype._finish = function () {
  assert(this instanceof Glob)
  if (this.aborted)
    return

  if (this.realpath && !this._didRealpath)
    return this._realpath()

  common.finish(this)
  this.emit('end', this.found)
}

Glob.prototype._realpath = function () {
  if (this._didRealpath)
    return

  this._didRealpath = true

  var n = this.matches.length
  if (n === 0)
    return this._finish()

  var self = this
  for (var i = 0; i < this.matches.length; i++)
    this._realpathSet(i, next)

  function next () {
    if (--n === 0)
      self._finish()
  }
}

Glob.prototype._realpathSet = function (index, cb) {
  var matchset = this.matches[index]
  if (!matchset)
    return cb()

  var found = Object.keys(matchset)
  var self = this
  var n = found.length

  if (n === 0)
    return cb()

  var set = this.matches[index] = Object.create(null)
  found.forEach(function (p, i) {
    // If there's a problem with the stat, then it means that
    // one or more of the links in the realpath couldn't be
    // resolved.  just return the abs value in that case.
    p = self._makeAbs(p)
    rp.realpath(p, self.realpathCache, function (er, real) {
      if (!er)
        set[real] = true
      else if (er.syscall === 'stat')
        set[p] = true
      else
        self.emit('error', er) // srsly wtf right here

      if (--n === 0) {
        self.matches[index] = set
        cb()
      }
    })
  })
}

Glob.prototype._mark = function (p) {
  return common.mark(this, p)
}

Glob.prototype._makeAbs = function (f) {
  return common.makeAbs(this, f)
}

Glob.prototype.abort = function () {
  this.aborted = true
  this.emit('abort')
}

Glob.prototype.pause = function () {
  if (!this.paused) {
    this.paused = true
    this.emit('pause')
  }
}

Glob.prototype.resume = function () {
  if (this.paused) {
    this.emit('resume')
    this.paused = false
    if (this._emitQueue.length) {
      var eq = this._emitQueue.slice(0)
      this._emitQueue.length = 0
      for (var i = 0; i < eq.length; i ++) {
        var e = eq[i]
        this._emitMatch(e[0], e[1])
      }
    }
    if (this._processQueue.length) {
      var pq = this._processQueue.slice(0)
      this._processQueue.length = 0
      for (var i = 0; i < pq.length; i ++) {
        var p = pq[i]
        this._processing--
        this._process(p[0], p[1], p[2], p[3])
      }
    }
  }
}

Glob.prototype._process = function (pattern, index, inGlobStar, cb) {
  assert(this instanceof Glob)
  assert(typeof cb === 'function')

  if (this.aborted)
    return

  this._processing++
  if (this.paused) {
    this._processQueue.push([pattern, index, inGlobStar, cb])
    return
  }

  //console.error('PROCESS %d', this._processing, pattern)

  // Get the first [n] parts of pattern that are all strings.
  var n = 0
  while (typeof pattern[n] === 'string') {
    n ++
  }
  // now n is the index of the first one that is *not* a string.

  // see if there's anything else
  var prefix
  switch (n) {
    // if not, then this is rather simple
    case pattern.length:
      this._processSimple(pattern.join('/'), index, cb)
      return

    case 0:
      // pattern *starts* with some non-trivial item.
      // going to readdir(cwd), but not include the prefix in matches.
      prefix = null
      break

    default:
      // pattern has some string bits in the front.
      // whatever it starts with, whether that's 'absolute' like /foo/bar,
      // or 'relative' like '../baz'
      prefix = pattern.slice(0, n).join('/')
      break
  }

  var remain = pattern.slice(n)

  // get the list of entries.
  var read
  if (prefix === null)
    read = '.'
  else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {
    if (!prefix || !isAbsolute(prefix))
      prefix = '/' + prefix
    read = prefix
  } else
    read = prefix

  var abs = this._makeAbs(read)

  //if ignored, skip _processing
  if (childrenIgnored(this, read))
    return cb()

  var isGlobStar = remain[0] === minimatch.GLOBSTAR
  if (isGlobStar)
    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb)
  else
    this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb)
}

Glob.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar, cb) {
  var self = this
  this._readdir(abs, inGlobStar, function (er, entries) {
    return self._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb)
  })
}

Glob.prototype._processReaddir2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {

  // if the abs isn't a dir, then nothing can match!
  if (!entries)
    return cb()

  // It will only match dot entries if it starts with a dot, or if
  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.
  var pn = remain[0]
  var negate = !!this.minimatch.negate
  var rawGlob = pn._glob
  var dotOk = this.dot || rawGlob.charAt(0) === '.'

  var matchedEntries = []
  for (var i = 0; i < entries.length; i++) {
    var e = entries[i]
    if (e.charAt(0) !== '.' || dotOk) {
      var m
      if (negate && !prefix) {
        m = !e.match(pn)
      } else {
        m = e.match(pn)
      }
      if (m)
        matchedEntries.push(e)
    }
  }

  //console.error('prd2', prefix, entries, remain[0]._glob, matchedEntries)

  var len = matchedEntries.length
  // If there are no matched entries, then nothing matches.
  if (len === 0)
    return cb()

  // if this is the last remaining pattern bit, then no need for
  // an additional stat *unless* the user has specified mark or
  // stat explicitly.  We know they exist, since readdir returned
  // them.

  if (remain.length === 1 && !this.mark && !this.stat) {
    if (!this.matches[index])
      this.matches[index] = Object.create(null)

    for (var i = 0; i < len; i ++) {
      var e = matchedEntries[i]
      if (prefix) {
        if (prefix !== '/')
          e = prefix + '/' + e
        else
          e = prefix + e
      }

      if (e.charAt(0) === '/' && !this.nomount) {
        e = path.join(this.root, e)
      }
      this._emitMatch(index, e)
    }
    // This was the last one, and no stats were needed
    return cb()
  }

  // now test all matched entries as stand-ins for that part
  // of the pattern.
  remain.shift()
  for (var i = 0; i < len; i ++) {
    var e = matchedEntries[i]
    var newPattern
    if (prefix) {
      if (prefix !== '/')
        e = prefix + '/' + e
      else
        e = prefix + e
    }
    this._process([e].concat(remain), index, inGlobStar, cb)
  }
  cb()
}

Glob.prototype._emitMatch = function (index, e) {
  if (this.aborted)
    return

  if (isIgnored(this, e))
    return

  if (this.paused) {
    this._emitQueue.push([index, e])
    return
  }

  var abs = isAbsolute(e) ? e : this._makeAbs(e)

  if (this.mark)
    e = this._mark(e)

  if (this.absolute)
    e = abs

  if (this.matches[index][e])
    return

  if (this.nodir) {
    var c = this.cache[abs]
    if (c === 'DIR' || Array.isArray(c))
      return
  }

  this.matches[index][e] = true

  var st = this.statCache[abs]
  if (st)
    this.emit('stat', e, st)

  this.emit('match', e)
}

Glob.prototype._readdirInGlobStar = function (abs, cb) {
  if (this.aborted)
    return

  // follow all symlinked directories forever
  // just proceed as if this is a non-globstar situation
  if (this.follow)
    return this._readdir(abs, false, cb)

  var lstatkey = 'lstat\0' + abs
  var self = this
  var lstatcb = inflight(lstatkey, lstatcb_)

  if (lstatcb)
    fs.lstat(abs, lstatcb)

  function lstatcb_ (er, lstat) {
    if (er && er.code === 'ENOENT')
      return cb()

    var isSym = lstat && lstat.isSymbolicLink()
    self.symlinks[abs] = isSym

    // If it's not a symlink or a dir, then it's definitely a regular file.
    // don't bother doing a readdir in that case.
    if (!isSym && lstat && !lstat.isDirectory()) {
      self.cache[abs] = 'FILE'
      cb()
    } else
      self._readdir(abs, false, cb)
  }
}

Glob.prototype._readdir = function (abs, inGlobStar, cb) {
  if (this.aborted)
    return

  cb = inflight('readdir\0'+abs+'\0'+inGlobStar, cb)
  if (!cb)
    return

  //console.error('RD %j %j', +inGlobStar, abs)
  if (inGlobStar && !ownProp(this.symlinks, abs))
    return this._readdirInGlobStar(abs, cb)

  if (ownProp(this.cache, abs)) {
    var c = this.cache[abs]
    if (!c || c === 'FILE')
      return cb()

    if (Array.isArray(c))
      return cb(null, c)
  }

  var self = this
  fs.readdir(abs, readdirCb(this, abs, cb))
}

function readdirCb (self, abs, cb) {
  return function (er, entries) {
    if (er)
      self._readdirError(abs, er, cb)
    else
      self._readdirEntries(abs, entries, cb)
  }
}

Glob.prototype._readdirEntries = function (abs, entries, cb) {
  if (this.aborted)
    return

  // if we haven't asked to stat everything, then just
  // assume that everything in there exists, so we can avoid
  // having to stat it a second time.
  if (!this.mark && !this.stat) {
    for (var i = 0; i < entries.length; i ++) {
      var e = entries[i]
      if (abs === '/')
        e = abs + e
      else
        e = abs + '/' + e
      this.cache[e] = true
    }
  }

  this.cache[abs] = entries
  return cb(null, entries)
}

Glob.prototype._readdirError = function (f, er, cb) {
  if (this.aborted)
    return

  // handle errors, and cache the information
  switch (er.code) {
    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205
    case 'ENOTDIR': // totally normal. means it *does* exist.
      var abs = this._makeAbs(f)
      this.cache[abs] = 'FILE'
      if (abs === this.cwdAbs) {
        var error = new Error(er.code + ' invalid cwd ' + this.cwd)
        error.path = this.cwd
        error.code = er.code
        this.emit('error', error)
        this.abort()
      }
      break

    case 'ENOENT': // not terribly unusual
    case 'ELOOP':
    case 'ENAMETOOLONG':
    case 'UNKNOWN':
      this.cache[this._makeAbs(f)] = false
      break

    default: // some unusual error.  Treat as failure.
      this.cache[this._makeAbs(f)] = false
      if (this.strict) {
        this.emit('error', er)
        // If the error is handled, then we abort
        // if not, we threw out of here
        this.abort()
      }
      if (!this.silent)
        console.error('glob error', er)
      break
  }

  return cb()
}

Glob.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar, cb) {
  var self = this
  this._readdir(abs, inGlobStar, function (er, entries) {
    self._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb)
  })
}


Glob.prototype._processGlobStar2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {
  //console.error('pgs2', prefix, remain[0], entries)

  // no entries means not a dir, so it can never have matches
  // foo.txt/** doesn't match foo.txt
  if (!entries)
    return cb()

  // test without the globstar, and with every child both below
  // and replacing the globstar.
  var remainWithoutGlobStar = remain.slice(1)
  var gspref = prefix ? [ prefix ] : []
  var noGlobStar = gspref.concat(remainWithoutGlobStar)

  // the noGlobStar pattern exits the inGlobStar state
  this._process(noGlobStar, index, false, cb)

  var isSym = this.symlinks[abs]
  var len = entries.length

  // If it's a symlink, and we're in a globstar, then stop
  if (isSym && inGlobStar)
    return cb()

  for (var i = 0; i < len; i++) {
    var e = entries[i]
    if (e.charAt(0) === '.' && !this.dot)
      continue

    // these two cases enter the inGlobStar state
    var instead = gspref.concat(entries[i], remainWithoutGlobStar)
    this._process(instead, index, true, cb)

    var below = gspref.concat(entries[i], remain)
    this._process(below, index, true, cb)
  }

  cb()
}

Glob.prototype._processSimple = function (prefix, index, cb) {
  // XXX review this.  Shouldn't it be doing the mounting etc
  // before doing stat?  kinda weird?
  var self = this
  this._stat(prefix, function (er, exists) {
    self._processSimple2(prefix, index, er, exists, cb)
  })
}
Glob.prototype._processSimple2 = function (prefix, index, er, exists, cb) {

  //console.error('ps2', prefix, exists)

  if (!this.matches[index])
    this.matches[index] = Object.create(null)

  // If it doesn't exist, then just mark the lack of results
  if (!exists)
    return cb()

  if (prefix && isAbsolute(prefix) && !this.nomount) {
    var trail = /[\/\\]$/.test(prefix)
    if (prefix.charAt(0) === '/') {
      prefix = path.join(this.root, prefix)
    } else {
      prefix = path.resolve(this.root, prefix)
      if (trail)
        prefix += '/'
    }
  }

  if (process.platform === 'win32')
    prefix = prefix.replace(/\\/g, '/')

  // Mark this as a match
  this._emitMatch(index, prefix)
  cb()
}

// Returns either 'DIR', 'FILE', or false
Glob.prototype._stat = function (f, cb) {
  var abs = this._makeAbs(f)
  var needDir = f.slice(-1) === '/'

  if (f.length > this.maxLength)
    return cb()

  if (!this.stat && ownProp(this.cache, abs)) {
    var c = this.cache[abs]

    if (Array.isArray(c))
      c = 'DIR'

    // It exists, but maybe not how we need it
    if (!needDir || c === 'DIR')
      return cb(null, c)

    if (needDir && c === 'FILE')
      return cb()

    // otherwise we have to stat, because maybe c=true
    // if we know it exists, but not what it is.
  }

  var exists
  var stat = this.statCache[abs]
  if (stat !== undefined) {
    if (stat === false)
      return cb(null, stat)
    else {
      var type = stat.isDirectory() ? 'DIR' : 'FILE'
      if (needDir && type === 'FILE')
        return cb()
      else
        return cb(null, type, stat)
    }
  }

  var self = this
  var statcb = inflight('stat\0' + abs, lstatcb_)
  if (statcb)
    fs.lstat(abs, statcb)

  function lstatcb_ (er, lstat) {
    if (lstat && lstat.isSymbolicLink()) {
      // If it's a symlink, then treat it as the target, unless
      // the target does not exist, then treat it as a file.
      return fs.stat(abs, function (er, stat) {
        if (er)
          self._stat2(f, abs, null, lstat, cb)
        else
          self._stat2(f, abs, er, stat, cb)
      })
    } else {
      self._stat2(f, abs, er, lstat, cb)
    }
  }
}

Glob.prototype._stat2 = function (f, abs, er, stat, cb) {
  if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {
    this.statCache[abs] = false
    return cb()
  }

  var needDir = f.slice(-1) === '/'
  this.statCache[abs] = stat

  if (abs.slice(-1) === '/' && stat && !stat.isDirectory())
    return cb(null, false, stat)

  var c = true
  if (stat)
    c = stat.isDirectory() ? 'DIR' : 'FILE'
  this.cache[abs] = this.cache[abs] || c

  if (needDir && c === 'FILE')
    return cb()

  return cb(null, c, stat)
}


/***/ }),

/***/ "./src/node_modules/glob/sync.js":
/*!***************************************!*\
  !*** ./src/node_modules/glob/sync.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = globSync
globSync.GlobSync = GlobSync

var fs = __webpack_require__(/*! fs */ "fs")
var rp = __webpack_require__(/*! fs.realpath */ "./src/node_modules/fs.realpath/index.js")
var minimatch = __webpack_require__(/*! minimatch */ "./src/node_modules/minimatch/minimatch.js")
var Minimatch = minimatch.Minimatch
var Glob = __webpack_require__(/*! ./glob.js */ "./src/node_modules/glob/glob.js").Glob
var util = __webpack_require__(/*! util */ "util")
var path = __webpack_require__(/*! path */ "path")
var assert = __webpack_require__(/*! assert */ "assert")
var isAbsolute = __webpack_require__(/*! path-is-absolute */ "./src/node_modules/path-is-absolute/index.js")
var common = __webpack_require__(/*! ./common.js */ "./src/node_modules/glob/common.js")
var alphasort = common.alphasort
var alphasorti = common.alphasorti
var setopts = common.setopts
var ownProp = common.ownProp
var childrenIgnored = common.childrenIgnored
var isIgnored = common.isIgnored

function globSync (pattern, options) {
  if (typeof options === 'function' || arguments.length === 3)
    throw new TypeError('callback provided to sync glob\n'+
                        'See: https://github.com/isaacs/node-glob/issues/167')

  return new GlobSync(pattern, options).found
}

function GlobSync (pattern, options) {
  if (!pattern)
    throw new Error('must provide pattern')

  if (typeof options === 'function' || arguments.length === 3)
    throw new TypeError('callback provided to sync glob\n'+
                        'See: https://github.com/isaacs/node-glob/issues/167')

  if (!(this instanceof GlobSync))
    return new GlobSync(pattern, options)

  setopts(this, pattern, options)

  if (this.noprocess)
    return this

  var n = this.minimatch.set.length
  this.matches = new Array(n)
  for (var i = 0; i < n; i ++) {
    this._process(this.minimatch.set[i], i, false)
  }
  this._finish()
}

GlobSync.prototype._finish = function () {
  assert(this instanceof GlobSync)
  if (this.realpath) {
    var self = this
    this.matches.forEach(function (matchset, index) {
      var set = self.matches[index] = Object.create(null)
      for (var p in matchset) {
        try {
          p = self._makeAbs(p)
          var real = rp.realpathSync(p, self.realpathCache)
          set[real] = true
        } catch (er) {
          if (er.syscall === 'stat')
            set[self._makeAbs(p)] = true
          else
            throw er
        }
      }
    })
  }
  common.finish(this)
}


GlobSync.prototype._process = function (pattern, index, inGlobStar) {
  assert(this instanceof GlobSync)

  // Get the first [n] parts of pattern that are all strings.
  var n = 0
  while (typeof pattern[n] === 'string') {
    n ++
  }
  // now n is the index of the first one that is *not* a string.

  // See if there's anything else
  var prefix
  switch (n) {
    // if not, then this is rather simple
    case pattern.length:
      this._processSimple(pattern.join('/'), index)
      return

    case 0:
      // pattern *starts* with some non-trivial item.
      // going to readdir(cwd), but not include the prefix in matches.
      prefix = null
      break

    default:
      // pattern has some string bits in the front.
      // whatever it starts with, whether that's 'absolute' like /foo/bar,
      // or 'relative' like '../baz'
      prefix = pattern.slice(0, n).join('/')
      break
  }

  var remain = pattern.slice(n)

  // get the list of entries.
  var read
  if (prefix === null)
    read = '.'
  else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {
    if (!prefix || !isAbsolute(prefix))
      prefix = '/' + prefix
    read = prefix
  } else
    read = prefix

  var abs = this._makeAbs(read)

  //if ignored, skip processing
  if (childrenIgnored(this, read))
    return

  var isGlobStar = remain[0] === minimatch.GLOBSTAR
  if (isGlobStar)
    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar)
  else
    this._processReaddir(prefix, read, abs, remain, index, inGlobStar)
}


GlobSync.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar) {
  var entries = this._readdir(abs, inGlobStar)

  // if the abs isn't a dir, then nothing can match!
  if (!entries)
    return

  // It will only match dot entries if it starts with a dot, or if
  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.
  var pn = remain[0]
  var negate = !!this.minimatch.negate
  var rawGlob = pn._glob
  var dotOk = this.dot || rawGlob.charAt(0) === '.'

  var matchedEntries = []
  for (var i = 0; i < entries.length; i++) {
    var e = entries[i]
    if (e.charAt(0) !== '.' || dotOk) {
      var m
      if (negate && !prefix) {
        m = !e.match(pn)
      } else {
        m = e.match(pn)
      }
      if (m)
        matchedEntries.push(e)
    }
  }

  var len = matchedEntries.length
  // If there are no matched entries, then nothing matches.
  if (len === 0)
    return

  // if this is the last remaining pattern bit, then no need for
  // an additional stat *unless* the user has specified mark or
  // stat explicitly.  We know they exist, since readdir returned
  // them.

  if (remain.length === 1 && !this.mark && !this.stat) {
    if (!this.matches[index])
      this.matches[index] = Object.create(null)

    for (var i = 0; i < len; i ++) {
      var e = matchedEntries[i]
      if (prefix) {
        if (prefix.slice(-1) !== '/')
          e = prefix + '/' + e
        else
          e = prefix + e
      }

      if (e.charAt(0) === '/' && !this.nomount) {
        e = path.join(this.root, e)
      }
      this._emitMatch(index, e)
    }
    // This was the last one, and no stats were needed
    return
  }

  // now test all matched entries as stand-ins for that part
  // of the pattern.
  remain.shift()
  for (var i = 0; i < len; i ++) {
    var e = matchedEntries[i]
    var newPattern
    if (prefix)
      newPattern = [prefix, e]
    else
      newPattern = [e]
    this._process(newPattern.concat(remain), index, inGlobStar)
  }
}


GlobSync.prototype._emitMatch = function (index, e) {
  if (isIgnored(this, e))
    return

  var abs = this._makeAbs(e)

  if (this.mark)
    e = this._mark(e)

  if (this.absolute) {
    e = abs
  }

  if (this.matches[index][e])
    return

  if (this.nodir) {
    var c = this.cache[abs]
    if (c === 'DIR' || Array.isArray(c))
      return
  }

  this.matches[index][e] = true

  if (this.stat)
    this._stat(e)
}


GlobSync.prototype._readdirInGlobStar = function (abs) {
  // follow all symlinked directories forever
  // just proceed as if this is a non-globstar situation
  if (this.follow)
    return this._readdir(abs, false)

  var entries
  var lstat
  var stat
  try {
    lstat = fs.lstatSync(abs)
  } catch (er) {
    if (er.code === 'ENOENT') {
      // lstat failed, doesn't exist
      return null
    }
  }

  var isSym = lstat && lstat.isSymbolicLink()
  this.symlinks[abs] = isSym

  // If it's not a symlink or a dir, then it's definitely a regular file.
  // don't bother doing a readdir in that case.
  if (!isSym && lstat && !lstat.isDirectory())
    this.cache[abs] = 'FILE'
  else
    entries = this._readdir(abs, false)

  return entries
}

GlobSync.prototype._readdir = function (abs, inGlobStar) {
  var entries

  if (inGlobStar && !ownProp(this.symlinks, abs))
    return this._readdirInGlobStar(abs)

  if (ownProp(this.cache, abs)) {
    var c = this.cache[abs]
    if (!c || c === 'FILE')
      return null

    if (Array.isArray(c))
      return c
  }

  try {
    return this._readdirEntries(abs, fs.readdirSync(abs))
  } catch (er) {
    this._readdirError(abs, er)
    return null
  }
}

GlobSync.prototype._readdirEntries = function (abs, entries) {
  // if we haven't asked to stat everything, then just
  // assume that everything in there exists, so we can avoid
  // having to stat it a second time.
  if (!this.mark && !this.stat) {
    for (var i = 0; i < entries.length; i ++) {
      var e = entries[i]
      if (abs === '/')
        e = abs + e
      else
        e = abs + '/' + e
      this.cache[e] = true
    }
  }

  this.cache[abs] = entries

  // mark and cache dir-ness
  return entries
}

GlobSync.prototype._readdirError = function (f, er) {
  // handle errors, and cache the information
  switch (er.code) {
    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205
    case 'ENOTDIR': // totally normal. means it *does* exist.
      var abs = this._makeAbs(f)
      this.cache[abs] = 'FILE'
      if (abs === this.cwdAbs) {
        var error = new Error(er.code + ' invalid cwd ' + this.cwd)
        error.path = this.cwd
        error.code = er.code
        throw error
      }
      break

    case 'ENOENT': // not terribly unusual
    case 'ELOOP':
    case 'ENAMETOOLONG':
    case 'UNKNOWN':
      this.cache[this._makeAbs(f)] = false
      break

    default: // some unusual error.  Treat as failure.
      this.cache[this._makeAbs(f)] = false
      if (this.strict)
        throw er
      if (!this.silent)
        console.error('glob error', er)
      break
  }
}

GlobSync.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar) {

  var entries = this._readdir(abs, inGlobStar)

  // no entries means not a dir, so it can never have matches
  // foo.txt/** doesn't match foo.txt
  if (!entries)
    return

  // test without the globstar, and with every child both below
  // and replacing the globstar.
  var remainWithoutGlobStar = remain.slice(1)
  var gspref = prefix ? [ prefix ] : []
  var noGlobStar = gspref.concat(remainWithoutGlobStar)

  // the noGlobStar pattern exits the inGlobStar state
  this._process(noGlobStar, index, false)

  var len = entries.length
  var isSym = this.symlinks[abs]

  // If it's a symlink, and we're in a globstar, then stop
  if (isSym && inGlobStar)
    return

  for (var i = 0; i < len; i++) {
    var e = entries[i]
    if (e.charAt(0) === '.' && !this.dot)
      continue

    // these two cases enter the inGlobStar state
    var instead = gspref.concat(entries[i], remainWithoutGlobStar)
    this._process(instead, index, true)

    var below = gspref.concat(entries[i], remain)
    this._process(below, index, true)
  }
}

GlobSync.prototype._processSimple = function (prefix, index) {
  // XXX review this.  Shouldn't it be doing the mounting etc
  // before doing stat?  kinda weird?
  var exists = this._stat(prefix)

  if (!this.matches[index])
    this.matches[index] = Object.create(null)

  // If it doesn't exist, then just mark the lack of results
  if (!exists)
    return

  if (prefix && isAbsolute(prefix) && !this.nomount) {
    var trail = /[\/\\]$/.test(prefix)
    if (prefix.charAt(0) === '/') {
      prefix = path.join(this.root, prefix)
    } else {
      prefix = path.resolve(this.root, prefix)
      if (trail)
        prefix += '/'
    }
  }

  if (process.platform === 'win32')
    prefix = prefix.replace(/\\/g, '/')

  // Mark this as a match
  this._emitMatch(index, prefix)
}

// Returns either 'DIR', 'FILE', or false
GlobSync.prototype._stat = function (f) {
  var abs = this._makeAbs(f)
  var needDir = f.slice(-1) === '/'

  if (f.length > this.maxLength)
    return false

  if (!this.stat && ownProp(this.cache, abs)) {
    var c = this.cache[abs]

    if (Array.isArray(c))
      c = 'DIR'

    // It exists, but maybe not how we need it
    if (!needDir || c === 'DIR')
      return c

    if (needDir && c === 'FILE')
      return false

    // otherwise we have to stat, because maybe c=true
    // if we know it exists, but not what it is.
  }

  var exists
  var stat = this.statCache[abs]
  if (!stat) {
    var lstat
    try {
      lstat = fs.lstatSync(abs)
    } catch (er) {
      if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {
        this.statCache[abs] = false
        return false
      }
    }

    if (lstat && lstat.isSymbolicLink()) {
      try {
        stat = fs.statSync(abs)
      } catch (er) {
        stat = lstat
      }
    } else {
      stat = lstat
    }
  }

  this.statCache[abs] = stat

  var c = true
  if (stat)
    c = stat.isDirectory() ? 'DIR' : 'FILE'

  this.cache[abs] = this.cache[abs] || c

  if (needDir && c === 'FILE')
    return false

  return c
}

GlobSync.prototype._mark = function (p) {
  return common.mark(this, p)
}

GlobSync.prototype._makeAbs = function (f) {
  return common.makeAbs(this, f)
}


/***/ }),

/***/ "./src/node_modules/inflight/inflight.js":
/*!***********************************************!*\
  !*** ./src/node_modules/inflight/inflight.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var wrappy = __webpack_require__(/*! wrappy */ "./src/node_modules/wrappy/wrappy.js")
var reqs = Object.create(null)
var once = __webpack_require__(/*! once */ "./src/node_modules/once/once.js")

module.exports = wrappy(inflight)

function inflight (key, cb) {
  if (reqs[key]) {
    reqs[key].push(cb)
    return null
  } else {
    reqs[key] = [cb]
    return makeres(key)
  }
}

function makeres (key) {
  return once(function RES () {
    var cbs = reqs[key]
    var len = cbs.length
    var args = slice(arguments)

    // XXX It's somewhat ambiguous whether a new callback added in this
    // pass should be queued for later execution if something in the
    // list of callbacks throws, or if it should just be discarded.
    // However, it's such an edge case that it hardly matters, and either
    // choice is likely as surprising as the other.
    // As it happens, we do go ahead and schedule it for later execution.
    try {
      for (var i = 0; i < len; i++) {
        cbs[i].apply(null, args)
      }
    } finally {
      if (cbs.length > len) {
        // added more in the interim.
        // de-zalgo, just in case, but don't call again.
        cbs.splice(0, len)
        process.nextTick(function () {
          RES.apply(null, args)
        })
      } else {
        delete reqs[key]
      }
    }
  })
}

function slice (args) {
  var length = args.length
  var array = []

  for (var i = 0; i < length; i++) array[i] = args[i]
  return array
}


/***/ }),

/***/ "./src/node_modules/inherits/inherits.js":
/*!***********************************************!*\
  !*** ./src/node_modules/inherits/inherits.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

try {
  var util = __webpack_require__(/*! util */ "util");
  if (typeof util.inherits !== 'function') throw '';
  module.exports = util.inherits;
} catch (e) {
  module.exports = __webpack_require__(/*! ./inherits_browser.js */ "./src/node_modules/inherits/inherits_browser.js");
}


/***/ }),

/***/ "./src/node_modules/inherits/inherits_browser.js":
/*!*******************************************************!*\
  !*** ./src/node_modules/inherits/inherits_browser.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}


/***/ }),

/***/ "./src/node_modules/invert-kv/index.js":
/*!*********************************************!*\
  !*** ./src/node_modules/invert-kv/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function (obj) {
	if (typeof obj !== 'object') {
		throw new TypeError('Expected an object');
	}

	var ret = {};

	for (var key in obj) {
		var val = obj[key];
		ret[val] = key;
	}

	return ret;
};


/***/ }),

/***/ "./src/node_modules/is-fullwidth-code-point/index.js":
/*!***********************************************************!*\
  !*** ./src/node_modules/is-fullwidth-code-point/index.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var numberIsNan = __webpack_require__(/*! number-is-nan */ "./src/node_modules/number-is-nan/index.js");

module.exports = function (x) {
	if (numberIsNan(x)) {
		return false;
	}

	// https://github.com/nodejs/io.js/blob/cff7300a578be1b10001f2d967aaedc88aee6402/lib/readline.js#L1369

	// code points are derived from:
	// http://www.unix.org/Public/UNIDATA/EastAsianWidth.txt
	if (x >= 0x1100 && (
		x <= 0x115f ||  // Hangul Jamo
		0x2329 === x || // LEFT-POINTING ANGLE BRACKET
		0x232a === x || // RIGHT-POINTING ANGLE BRACKET
		// CJK Radicals Supplement .. Enclosed CJK Letters and Months
		(0x2e80 <= x && x <= 0x3247 && x !== 0x303f) ||
		// Enclosed CJK Letters and Months .. CJK Unified Ideographs Extension A
		0x3250 <= x && x <= 0x4dbf ||
		// CJK Unified Ideographs .. Yi Radicals
		0x4e00 <= x && x <= 0xa4c6 ||
		// Hangul Jamo Extended-A
		0xa960 <= x && x <= 0xa97c ||
		// Hangul Syllables
		0xac00 <= x && x <= 0xd7a3 ||
		// CJK Compatibility Ideographs
		0xf900 <= x && x <= 0xfaff ||
		// Vertical Forms
		0xfe10 <= x && x <= 0xfe19 ||
		// CJK Compatibility Forms .. Small Form Variants
		0xfe30 <= x && x <= 0xfe6b ||
		// Halfwidth and Fullwidth Forms
		0xff01 <= x && x <= 0xff60 ||
		0xffe0 <= x && x <= 0xffe6 ||
		// Kana Supplement
		0x1b000 <= x && x <= 0x1b001 ||
		// Enclosed Ideographic Supplement
		0x1f200 <= x && x <= 0x1f251 ||
		// CJK Unified Ideographs Extension B .. Tertiary Ideographic Plane
		0x20000 <= x && x <= 0x3fffd)) {
		return true;
	}

	return false;
}


/***/ }),

/***/ "./src/node_modules/is-utf8/is-utf8.js":
/*!*********************************************!*\
  !*** ./src/node_modules/is-utf8/is-utf8.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {


exports = module.exports = function(bytes)
{
    var i = 0;
    while(i < bytes.length)
    {
        if(     (// ASCII
                    bytes[i] == 0x09 ||
                    bytes[i] == 0x0A ||
                    bytes[i] == 0x0D ||
                    (0x20 <= bytes[i] && bytes[i] <= 0x7E)
                )
          ) {
              i += 1;
              continue;
          }

        if(     (// non-overlong 2-byte
                    (0xC2 <= bytes[i] && bytes[i] <= 0xDF) &&
                    (0x80 <= bytes[i+1] && bytes[i+1] <= 0xBF)
                )
          ) {
              i += 2;
              continue;
          }

        if(     (// excluding overlongs
                    bytes[i] == 0xE0 &&
                    (0xA0 <= bytes[i + 1] && bytes[i + 1] <= 0xBF) &&
                    (0x80 <= bytes[i + 2] && bytes[i + 2] <= 0xBF)
                ) ||
                (// straight 3-byte
                 ((0xE1 <= bytes[i] && bytes[i] <= 0xEC) ||
                  bytes[i] == 0xEE ||
                  bytes[i] == 0xEF) &&
                 (0x80 <= bytes[i + 1] && bytes[i+1] <= 0xBF) &&
                 (0x80 <= bytes[i+2] && bytes[i+2] <= 0xBF)
                ) ||
                (// excluding surrogates
                 bytes[i] == 0xED &&
                 (0x80 <= bytes[i+1] && bytes[i+1] <= 0x9F) &&
                 (0x80 <= bytes[i+2] && bytes[i+2] <= 0xBF)
                )
          ) {
              i += 3;
              continue;
          }

        if(     (// planes 1-3
                    bytes[i] == 0xF0 &&
                    (0x90 <= bytes[i + 1] && bytes[i + 1] <= 0xBF) &&
                    (0x80 <= bytes[i + 2] && bytes[i + 2] <= 0xBF) &&
                    (0x80 <= bytes[i + 3] && bytes[i + 3] <= 0xBF)
                ) ||
                (// planes 4-15
                 (0xF1 <= bytes[i] && bytes[i] <= 0xF3) &&
                 (0x80 <= bytes[i + 1] && bytes[i + 1] <= 0xBF) &&
                 (0x80 <= bytes[i + 2] && bytes[i + 2] <= 0xBF) &&
                 (0x80 <= bytes[i + 3] && bytes[i + 3] <= 0xBF)
                ) ||
                (// plane 16
                 bytes[i] == 0xF4 &&
                 (0x80 <= bytes[i + 1] && bytes[i + 1] <= 0x8F) &&
                 (0x80 <= bytes[i + 2] && bytes[i + 2] <= 0xBF) &&
                 (0x80 <= bytes[i + 3] && bytes[i + 3] <= 0xBF)
                )
          ) {
              i += 4;
              continue;
          }

        return false;
    }

    return true;
}


/***/ }),

/***/ "./src/node_modules/lcid/index.js":
/*!****************************************!*\
  !*** ./src/node_modules/lcid/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var invertKv = __webpack_require__(/*! invert-kv */ "./src/node_modules/invert-kv/index.js");
var all = __webpack_require__(/*! ./lcid.json */ "./src/node_modules/lcid/lcid.json");
var inverted = invertKv(all);

exports.from = function (lcidCode) {
	if (typeof lcidCode !== 'number') {
		throw new TypeError('Expected a number');
	}

	return inverted[lcidCode];
};

exports.to = function (localeId) {
	if (typeof localeId !== 'string') {
		throw new TypeError('Expected a string');
	}

	return all[localeId];
};

exports.all = all;


/***/ }),

/***/ "./src/node_modules/lcid/lcid.json":
/*!*****************************************!*\
  !*** ./src/node_modules/lcid/lcid.json ***!
  \*****************************************/
/*! exports provided: af_ZA, am_ET, ar_AE, ar_BH, ar_DZ, ar_EG, ar_IQ, ar_JO, ar_KW, ar_LB, ar_LY, ar_MA, ar_OM, ar_QA, ar_SA, ar_SY, ar_TN, ar_YE, arn_CL, as_IN, az_AZ, ba_RU, be_BY, bg_BG, bn_IN, bo_BT, bo_CN, br_FR, bs_BA, ca_ES, co_FR, cs_CZ, cy_GB, da_DK, de_AT, de_CH, de_DE, de_LI, de_LU, div_MV, dsb_DE, el_GR, en_AU, en_BZ, en_CA, en_CB, en_GB, en_IE, en_IN, en_JA, en_MY, en_NZ, en_PH, en_TT, en_US, en_ZA, en_ZW, es_AR, es_BO, es_CL, es_CO, es_CR, es_DO, es_EC, es_ES, es_GT, es_HN, es_MX, es_NI, es_PA, es_PE, es_PR, es_PY, es_SV, es_UR, es_US, es_VE, et_EE, eu_ES, fa_IR, fi_FI, fil_PH, fo_FO, fr_BE, fr_CA, fr_CH, fr_FR, fr_LU, fr_MC, fy_NL, ga_IE, gbz_AF, gl_ES, gsw_FR, gu_IN, ha_NG, he_IL, hi_IN, hr_BA, hr_HR, hu_HU, hy_AM, id_ID, ii_CN, is_IS, it_CH, it_IT, iu_CA, ja_JP, ka_GE, kh_KH, kk_KZ, kl_GL, kn_IN, ko_KR, kok_IN, ky_KG, lb_LU, lo_LA, lt_LT, lv_LV, mi_NZ, mk_MK, ml_IN, mn_CN, mn_MN, moh_CA, mr_IN, ms_BN, ms_MY, mt_MT, my_MM, nb_NO, ne_NP, nl_BE, nl_NL, nn_NO, ns_ZA, oc_FR, or_IN, pa_IN, pl_PL, ps_AF, pt_BR, pt_PT, qut_GT, quz_BO, quz_EC, quz_PE, rm_CH, ro_RO, ru_RU, rw_RW, sa_IN, sah_RU, se_FI, se_NO, se_SE, si_LK, sk_SK, sl_SI, sma_NO, sma_SE, smj_NO, smj_SE, smn_FI, sms_FI, sq_AL, sr_BA, sr_SP, sv_FI, sv_SE, sw_KE, syr_SY, ta_IN, te_IN, tg_TJ, th_TH, tk_TM, tmz_DZ, tn_ZA, tr_TR, tt_RU, ug_CN, uk_UA, ur_IN, ur_PK, uz_UZ, vi_VN, wen_DE, wo_SN, xh_ZA, yo_NG, zh_CHS, zh_CHT, zh_CN, zh_HK, zh_MO, zh_SG, zh_TW, zu_ZA, default */
/***/ (function(module) {

module.exports = {"af_ZA":1078,"am_ET":1118,"ar_AE":14337,"ar_BH":15361,"ar_DZ":5121,"ar_EG":3073,"ar_IQ":2049,"ar_JO":11265,"ar_KW":13313,"ar_LB":12289,"ar_LY":4097,"ar_MA":6145,"ar_OM":8193,"ar_QA":16385,"ar_SA":1025,"ar_SY":10241,"ar_TN":7169,"ar_YE":9217,"arn_CL":1146,"as_IN":1101,"az_AZ":2092,"ba_RU":1133,"be_BY":1059,"bg_BG":1026,"bn_IN":1093,"bo_BT":2129,"bo_CN":1105,"br_FR":1150,"bs_BA":8218,"ca_ES":1027,"co_FR":1155,"cs_CZ":1029,"cy_GB":1106,"da_DK":1030,"de_AT":3079,"de_CH":2055,"de_DE":1031,"de_LI":5127,"de_LU":4103,"div_MV":1125,"dsb_DE":2094,"el_GR":1032,"en_AU":3081,"en_BZ":10249,"en_CA":4105,"en_CB":9225,"en_GB":2057,"en_IE":6153,"en_IN":18441,"en_JA":8201,"en_MY":17417,"en_NZ":5129,"en_PH":13321,"en_TT":11273,"en_US":1033,"en_ZA":7177,"en_ZW":12297,"es_AR":11274,"es_BO":16394,"es_CL":13322,"es_CO":9226,"es_CR":5130,"es_DO":7178,"es_EC":12298,"es_ES":3082,"es_GT":4106,"es_HN":18442,"es_MX":2058,"es_NI":19466,"es_PA":6154,"es_PE":10250,"es_PR":20490,"es_PY":15370,"es_SV":17418,"es_UR":14346,"es_US":21514,"es_VE":8202,"et_EE":1061,"eu_ES":1069,"fa_IR":1065,"fi_FI":1035,"fil_PH":1124,"fo_FO":1080,"fr_BE":2060,"fr_CA":3084,"fr_CH":4108,"fr_FR":1036,"fr_LU":5132,"fr_MC":6156,"fy_NL":1122,"ga_IE":2108,"gbz_AF":1164,"gl_ES":1110,"gsw_FR":1156,"gu_IN":1095,"ha_NG":1128,"he_IL":1037,"hi_IN":1081,"hr_BA":4122,"hr_HR":1050,"hu_HU":1038,"hy_AM":1067,"id_ID":1057,"ii_CN":1144,"is_IS":1039,"it_CH":2064,"it_IT":1040,"iu_CA":2141,"ja_JP":1041,"ka_GE":1079,"kh_KH":1107,"kk_KZ":1087,"kl_GL":1135,"kn_IN":1099,"ko_KR":1042,"kok_IN":1111,"ky_KG":1088,"lb_LU":1134,"lo_LA":1108,"lt_LT":1063,"lv_LV":1062,"mi_NZ":1153,"mk_MK":1071,"ml_IN":1100,"mn_CN":2128,"mn_MN":1104,"moh_CA":1148,"mr_IN":1102,"ms_BN":2110,"ms_MY":1086,"mt_MT":1082,"my_MM":1109,"nb_NO":1044,"ne_NP":1121,"nl_BE":2067,"nl_NL":1043,"nn_NO":2068,"ns_ZA":1132,"oc_FR":1154,"or_IN":1096,"pa_IN":1094,"pl_PL":1045,"ps_AF":1123,"pt_BR":1046,"pt_PT":2070,"qut_GT":1158,"quz_BO":1131,"quz_EC":2155,"quz_PE":3179,"rm_CH":1047,"ro_RO":1048,"ru_RU":1049,"rw_RW":1159,"sa_IN":1103,"sah_RU":1157,"se_FI":3131,"se_NO":1083,"se_SE":2107,"si_LK":1115,"sk_SK":1051,"sl_SI":1060,"sma_NO":6203,"sma_SE":7227,"smj_NO":4155,"smj_SE":5179,"smn_FI":9275,"sms_FI":8251,"sq_AL":1052,"sr_BA":7194,"sr_SP":3098,"sv_FI":2077,"sv_SE":1053,"sw_KE":1089,"syr_SY":1114,"ta_IN":1097,"te_IN":1098,"tg_TJ":1064,"th_TH":1054,"tk_TM":1090,"tmz_DZ":2143,"tn_ZA":1074,"tr_TR":1055,"tt_RU":1092,"ug_CN":1152,"uk_UA":1058,"ur_IN":2080,"ur_PK":1056,"uz_UZ":2115,"vi_VN":1066,"wen_DE":1070,"wo_SN":1160,"xh_ZA":1076,"yo_NG":1130,"zh_CHS":4,"zh_CHT":31748,"zh_CN":2052,"zh_HK":3076,"zh_MO":5124,"zh_SG":4100,"zh_TW":1028,"zu_ZA":1077};

/***/ }),

/***/ "./src/node_modules/minimatch/minimatch.js":
/*!*************************************************!*\
  !*** ./src/node_modules/minimatch/minimatch.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = minimatch
minimatch.Minimatch = Minimatch

var path = { sep: '/' }
try {
  path = __webpack_require__(/*! path */ "path")
} catch (er) {}

var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}
var expand = __webpack_require__(/*! brace-expansion */ "./src/node_modules/brace-expansion/index.js")

var plTypes = {
  '!': { open: '(?:(?!(?:', close: '))[^/]*?)'},
  '?': { open: '(?:', close: ')?' },
  '+': { open: '(?:', close: ')+' },
  '*': { open: '(?:', close: ')*' },
  '@': { open: '(?:', close: ')' }
}

// any single thing other than /
// don't need to escape / when using new RegExp()
var qmark = '[^/]'

// * => any number of characters
var star = qmark + '*?'

// ** when dots are allowed.  Anything goes, except .. and .
// not (^ or / followed by one or two dots followed by $ or /),
// followed by anything, any number of times.
var twoStarDot = '(?:(?!(?:\\\/|^)(?:\\.{1,2})($|\\\/)).)*?'

// not a ^ or / followed by a dot,
// followed by anything, any number of times.
var twoStarNoDot = '(?:(?!(?:\\\/|^)\\.).)*?'

// characters that need to be escaped in RegExp.
var reSpecials = charSet('().*{}+?[]^$\\!')

// "abc" -> { a:true, b:true, c:true }
function charSet (s) {
  return s.split('').reduce(function (set, c) {
    set[c] = true
    return set
  }, {})
}

// normalizes slashes.
var slashSplit = /\/+/

minimatch.filter = filter
function filter (pattern, options) {
  options = options || {}
  return function (p, i, list) {
    return minimatch(p, pattern, options)
  }
}

function ext (a, b) {
  a = a || {}
  b = b || {}
  var t = {}
  Object.keys(b).forEach(function (k) {
    t[k] = b[k]
  })
  Object.keys(a).forEach(function (k) {
    t[k] = a[k]
  })
  return t
}

minimatch.defaults = function (def) {
  if (!def || !Object.keys(def).length) return minimatch

  var orig = minimatch

  var m = function minimatch (p, pattern, options) {
    return orig.minimatch(p, pattern, ext(def, options))
  }

  m.Minimatch = function Minimatch (pattern, options) {
    return new orig.Minimatch(pattern, ext(def, options))
  }

  return m
}

Minimatch.defaults = function (def) {
  if (!def || !Object.keys(def).length) return Minimatch
  return minimatch.defaults(def).Minimatch
}

function minimatch (p, pattern, options) {
  if (typeof pattern !== 'string') {
    throw new TypeError('glob pattern string required')
  }

  if (!options) options = {}

  // shortcut: comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === '#') {
    return false
  }

  // "" only matches ""
  if (pattern.trim() === '') return p === ''

  return new Minimatch(pattern, options).match(p)
}

function Minimatch (pattern, options) {
  if (!(this instanceof Minimatch)) {
    return new Minimatch(pattern, options)
  }

  if (typeof pattern !== 'string') {
    throw new TypeError('glob pattern string required')
  }

  if (!options) options = {}
  pattern = pattern.trim()

  // windows support: need to use /, not \
  if (path.sep !== '/') {
    pattern = pattern.split(path.sep).join('/')
  }

  this.options = options
  this.set = []
  this.pattern = pattern
  this.regexp = null
  this.negate = false
  this.comment = false
  this.empty = false

  // make the set of regexps etc.
  this.make()
}

Minimatch.prototype.debug = function () {}

Minimatch.prototype.make = make
function make () {
  // don't do it more than once.
  if (this._made) return

  var pattern = this.pattern
  var options = this.options

  // empty patterns and comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === '#') {
    this.comment = true
    return
  }
  if (!pattern) {
    this.empty = true
    return
  }

  // step 1: figure out negation, etc.
  this.parseNegate()

  // step 2: expand braces
  var set = this.globSet = this.braceExpand()

  if (options.debug) this.debug = console.error

  this.debug(this.pattern, set)

  // step 3: now we have a set, so turn each one into a series of path-portion
  // matching patterns.
  // These will be regexps, except in the case of "**", which is
  // set to the GLOBSTAR object for globstar behavior,
  // and will not contain any / characters
  set = this.globParts = set.map(function (s) {
    return s.split(slashSplit)
  })

  this.debug(this.pattern, set)

  // glob --> regexps
  set = set.map(function (s, si, set) {
    return s.map(this.parse, this)
  }, this)

  this.debug(this.pattern, set)

  // filter out everything that didn't compile properly.
  set = set.filter(function (s) {
    return s.indexOf(false) === -1
  })

  this.debug(this.pattern, set)

  this.set = set
}

Minimatch.prototype.parseNegate = parseNegate
function parseNegate () {
  var pattern = this.pattern
  var negate = false
  var options = this.options
  var negateOffset = 0

  if (options.nonegate) return

  for (var i = 0, l = pattern.length
    ; i < l && pattern.charAt(i) === '!'
    ; i++) {
    negate = !negate
    negateOffset++
  }

  if (negateOffset) this.pattern = pattern.substr(negateOffset)
  this.negate = negate
}

// Brace expansion:
// a{b,c}d -> abd acd
// a{b,}c -> abc ac
// a{0..3}d -> a0d a1d a2d a3d
// a{b,c{d,e}f}g -> abg acdfg acefg
// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
//
// Invalid sets are not expanded.
// a{2..}b -> a{2..}b
// a{b}c -> a{b}c
minimatch.braceExpand = function (pattern, options) {
  return braceExpand(pattern, options)
}

Minimatch.prototype.braceExpand = braceExpand

function braceExpand (pattern, options) {
  if (!options) {
    if (this instanceof Minimatch) {
      options = this.options
    } else {
      options = {}
    }
  }

  pattern = typeof pattern === 'undefined'
    ? this.pattern : pattern

  if (typeof pattern === 'undefined') {
    throw new TypeError('undefined pattern')
  }

  if (options.nobrace ||
    !pattern.match(/\{.*\}/)) {
    // shortcut. no need to expand.
    return [pattern]
  }

  return expand(pattern)
}

// parse a component of the expanded set.
// At this point, no pattern may contain "/" in it
// so we're going to return a 2d array, where each entry is the full
// pattern, split on '/', and then turned into a regular expression.
// A regexp is made at the end which joins each array with an
// escaped /, and another full one which joins each regexp with |.
//
// Following the lead of Bash 4.1, note that "**" only has special meaning
// when it is the *only* thing in a path portion.  Otherwise, any series
// of * is equivalent to a single *.  Globstar behavior is enabled by
// default, and can be disabled by setting options.noglobstar.
Minimatch.prototype.parse = parse
var SUBPARSE = {}
function parse (pattern, isSub) {
  if (pattern.length > 1024 * 64) {
    throw new TypeError('pattern is too long')
  }

  var options = this.options

  // shortcuts
  if (!options.noglobstar && pattern === '**') return GLOBSTAR
  if (pattern === '') return ''

  var re = ''
  var hasMagic = !!options.nocase
  var escaping = false
  // ? => one single character
  var patternListStack = []
  var negativeLists = []
  var stateChar
  var inClass = false
  var reClassStart = -1
  var classStart = -1
  // . and .. never match anything that doesn't start with .,
  // even when options.dot is set.
  var patternStart = pattern.charAt(0) === '.' ? '' // anything
  // not (start or / followed by . or .. followed by / or end)
  : options.dot ? '(?!(?:^|\\\/)\\.{1,2}(?:$|\\\/))'
  : '(?!\\.)'
  var self = this

  function clearStateChar () {
    if (stateChar) {
      // we had some state-tracking character
      // that wasn't consumed by this pass.
      switch (stateChar) {
        case '*':
          re += star
          hasMagic = true
        break
        case '?':
          re += qmark
          hasMagic = true
        break
        default:
          re += '\\' + stateChar
        break
      }
      self.debug('clearStateChar %j %j', stateChar, re)
      stateChar = false
    }
  }

  for (var i = 0, len = pattern.length, c
    ; (i < len) && (c = pattern.charAt(i))
    ; i++) {
    this.debug('%s\t%s %s %j', pattern, i, re, c)

    // skip over any that are escaped.
    if (escaping && reSpecials[c]) {
      re += '\\' + c
      escaping = false
      continue
    }

    switch (c) {
      case '/':
        // completely not allowed, even escaped.
        // Should already be path-split by now.
        return false

      case '\\':
        clearStateChar()
        escaping = true
      continue

      // the various stateChar values
      // for the "extglob" stuff.
      case '?':
      case '*':
      case '+':
      case '@':
      case '!':
        this.debug('%s\t%s %s %j <-- stateChar', pattern, i, re, c)

        // all of those are literals inside a class, except that
        // the glob [!a] means [^a] in regexp
        if (inClass) {
          this.debug('  in class')
          if (c === '!' && i === classStart + 1) c = '^'
          re += c
          continue
        }

        // if we already have a stateChar, then it means
        // that there was something like ** or +? in there.
        // Handle the stateChar, then proceed with this one.
        self.debug('call clearStateChar %j', stateChar)
        clearStateChar()
        stateChar = c
        // if extglob is disabled, then +(asdf|foo) isn't a thing.
        // just clear the statechar *now*, rather than even diving into
        // the patternList stuff.
        if (options.noext) clearStateChar()
      continue

      case '(':
        if (inClass) {
          re += '('
          continue
        }

        if (!stateChar) {
          re += '\\('
          continue
        }

        patternListStack.push({
          type: stateChar,
          start: i - 1,
          reStart: re.length,
          open: plTypes[stateChar].open,
          close: plTypes[stateChar].close
        })
        // negation is (?:(?!js)[^/]*)
        re += stateChar === '!' ? '(?:(?!(?:' : '(?:'
        this.debug('plType %j %j', stateChar, re)
        stateChar = false
      continue

      case ')':
        if (inClass || !patternListStack.length) {
          re += '\\)'
          continue
        }

        clearStateChar()
        hasMagic = true
        var pl = patternListStack.pop()
        // negation is (?:(?!js)[^/]*)
        // The others are (?:<pattern>)<type>
        re += pl.close
        if (pl.type === '!') {
          negativeLists.push(pl)
        }
        pl.reEnd = re.length
      continue

      case '|':
        if (inClass || !patternListStack.length || escaping) {
          re += '\\|'
          escaping = false
          continue
        }

        clearStateChar()
        re += '|'
      continue

      // these are mostly the same in regexp and glob
      case '[':
        // swallow any state-tracking char before the [
        clearStateChar()

        if (inClass) {
          re += '\\' + c
          continue
        }

        inClass = true
        classStart = i
        reClassStart = re.length
        re += c
      continue

      case ']':
        //  a right bracket shall lose its special
        //  meaning and represent itself in
        //  a bracket expression if it occurs
        //  first in the list.  -- POSIX.2 2.8.3.2
        if (i === classStart + 1 || !inClass) {
          re += '\\' + c
          escaping = false
          continue
        }

        // handle the case where we left a class open.
        // "[z-a]" is valid, equivalent to "\[z-a\]"
        if (inClass) {
          // split where the last [ was, make sure we don't have
          // an invalid re. if so, re-walk the contents of the
          // would-be class to re-translate any characters that
          // were passed through as-is
          // TODO: It would probably be faster to determine this
          // without a try/catch and a new RegExp, but it's tricky
          // to do safely.  For now, this is safe and works.
          var cs = pattern.substring(classStart + 1, i)
          try {
            RegExp('[' + cs + ']')
          } catch (er) {
            // not a valid class!
            var sp = this.parse(cs, SUBPARSE)
            re = re.substr(0, reClassStart) + '\\[' + sp[0] + '\\]'
            hasMagic = hasMagic || sp[1]
            inClass = false
            continue
          }
        }

        // finish up the class.
        hasMagic = true
        inClass = false
        re += c
      continue

      default:
        // swallow any state char that wasn't consumed
        clearStateChar()

        if (escaping) {
          // no need
          escaping = false
        } else if (reSpecials[c]
          && !(c === '^' && inClass)) {
          re += '\\'
        }

        re += c

    } // switch
  } // for

  // handle the case where we left a class open.
  // "[abc" is valid, equivalent to "\[abc"
  if (inClass) {
    // split where the last [ was, and escape it
    // this is a huge pita.  We now have to re-walk
    // the contents of the would-be class to re-translate
    // any characters that were passed through as-is
    cs = pattern.substr(classStart + 1)
    sp = this.parse(cs, SUBPARSE)
    re = re.substr(0, reClassStart) + '\\[' + sp[0]
    hasMagic = hasMagic || sp[1]
  }

  // handle the case where we had a +( thing at the *end*
  // of the pattern.
  // each pattern list stack adds 3 chars, and we need to go through
  // and escape any | chars that were passed through as-is for the regexp.
  // Go through and escape them, taking care not to double-escape any
  // | chars that were already escaped.
  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
    var tail = re.slice(pl.reStart + pl.open.length)
    this.debug('setting tail', re, pl)
    // maybe some even number of \, then maybe 1 \, followed by a |
    tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function (_, $1, $2) {
      if (!$2) {
        // the | isn't already escaped, so escape it.
        $2 = '\\'
      }

      // need to escape all those slashes *again*, without escaping the
      // one that we need for escaping the | character.  As it works out,
      // escaping an even number of slashes can be done by simply repeating
      // it exactly after itself.  That's why this trick works.
      //
      // I am sorry that you have to see this.
      return $1 + $1 + $2 + '|'
    })

    this.debug('tail=%j\n   %s', tail, tail, pl, re)
    var t = pl.type === '*' ? star
      : pl.type === '?' ? qmark
      : '\\' + pl.type

    hasMagic = true
    re = re.slice(0, pl.reStart) + t + '\\(' + tail
  }

  // handle trailing things that only matter at the very end.
  clearStateChar()
  if (escaping) {
    // trailing \\
    re += '\\\\'
  }

  // only need to apply the nodot start if the re starts with
  // something that could conceivably capture a dot
  var addPatternStart = false
  switch (re.charAt(0)) {
    case '.':
    case '[':
    case '(': addPatternStart = true
  }

  // Hack to work around lack of negative lookbehind in JS
  // A pattern like: *.!(x).!(y|z) needs to ensure that a name
  // like 'a.xyz.yz' doesn't match.  So, the first negative
  // lookahead, has to look ALL the way ahead, to the end of
  // the pattern.
  for (var n = negativeLists.length - 1; n > -1; n--) {
    var nl = negativeLists[n]

    var nlBefore = re.slice(0, nl.reStart)
    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8)
    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd)
    var nlAfter = re.slice(nl.reEnd)

    nlLast += nlAfter

    // Handle nested stuff like *(*.js|!(*.json)), where open parens
    // mean that we should *not* include the ) in the bit that is considered
    // "after" the negated section.
    var openParensBefore = nlBefore.split('(').length - 1
    var cleanAfter = nlAfter
    for (i = 0; i < openParensBefore; i++) {
      cleanAfter = cleanAfter.replace(/\)[+*?]?/, '')
    }
    nlAfter = cleanAfter

    var dollar = ''
    if (nlAfter === '' && isSub !== SUBPARSE) {
      dollar = '$'
    }
    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast
    re = newRe
  }

  // if the re is not "" at this point, then we need to make sure
  // it doesn't match against an empty path part.
  // Otherwise a/* will match a/, which it should not.
  if (re !== '' && hasMagic) {
    re = '(?=.)' + re
  }

  if (addPatternStart) {
    re = patternStart + re
  }

  // parsing just a piece of a larger pattern.
  if (isSub === SUBPARSE) {
    return [re, hasMagic]
  }

  // skip the regexp for non-magical patterns
  // unescape anything in it, though, so that it'll be
  // an exact match against a file etc.
  if (!hasMagic) {
    return globUnescape(pattern)
  }

  var flags = options.nocase ? 'i' : ''
  try {
    var regExp = new RegExp('^' + re + '$', flags)
  } catch (er) {
    // If it was an invalid regular expression, then it can't match
    // anything.  This trick looks for a character after the end of
    // the string, which is of course impossible, except in multi-line
    // mode, but it's not a /m regex.
    return new RegExp('$.')
  }

  regExp._glob = pattern
  regExp._src = re

  return regExp
}

minimatch.makeRe = function (pattern, options) {
  return new Minimatch(pattern, options || {}).makeRe()
}

Minimatch.prototype.makeRe = makeRe
function makeRe () {
  if (this.regexp || this.regexp === false) return this.regexp

  // at this point, this.set is a 2d array of partial
  // pattern strings, or "**".
  //
  // It's better to use .match().  This function shouldn't
  // be used, really, but it's pretty convenient sometimes,
  // when you just want to work with a regex.
  var set = this.set

  if (!set.length) {
    this.regexp = false
    return this.regexp
  }
  var options = this.options

  var twoStar = options.noglobstar ? star
    : options.dot ? twoStarDot
    : twoStarNoDot
  var flags = options.nocase ? 'i' : ''

  var re = set.map(function (pattern) {
    return pattern.map(function (p) {
      return (p === GLOBSTAR) ? twoStar
      : (typeof p === 'string') ? regExpEscape(p)
      : p._src
    }).join('\\\/')
  }).join('|')

  // must match entire pattern
  // ending in a * or ** will make it less strict.
  re = '^(?:' + re + ')$'

  // can match anything, as long as it's not this.
  if (this.negate) re = '^(?!' + re + ').*$'

  try {
    this.regexp = new RegExp(re, flags)
  } catch (ex) {
    this.regexp = false
  }
  return this.regexp
}

minimatch.match = function (list, pattern, options) {
  options = options || {}
  var mm = new Minimatch(pattern, options)
  list = list.filter(function (f) {
    return mm.match(f)
  })
  if (mm.options.nonull && !list.length) {
    list.push(pattern)
  }
  return list
}

Minimatch.prototype.match = match
function match (f, partial) {
  this.debug('match', f, this.pattern)
  // short-circuit in the case of busted things.
  // comments, etc.
  if (this.comment) return false
  if (this.empty) return f === ''

  if (f === '/' && partial) return true

  var options = this.options

  // windows: need to use /, not \
  if (path.sep !== '/') {
    f = f.split(path.sep).join('/')
  }

  // treat the test path as a set of pathparts.
  f = f.split(slashSplit)
  this.debug(this.pattern, 'split', f)

  // just ONE of the pattern sets in this.set needs to match
  // in order for it to be valid.  If negating, then just one
  // match means that we have failed.
  // Either way, return on the first hit.

  var set = this.set
  this.debug(this.pattern, 'set', set)

  // Find the basename of the path by looking for the last non-empty segment
  var filename
  var i
  for (i = f.length - 1; i >= 0; i--) {
    filename = f[i]
    if (filename) break
  }

  for (i = 0; i < set.length; i++) {
    var pattern = set[i]
    var file = f
    if (options.matchBase && pattern.length === 1) {
      file = [filename]
    }
    var hit = this.matchOne(file, pattern, partial)
    if (hit) {
      if (options.flipNegate) return true
      return !this.negate
    }
  }

  // didn't get any hits.  this is success if it's a negative
  // pattern, failure otherwise.
  if (options.flipNegate) return false
  return this.negate
}

// set partial to true to test if, for example,
// "/a/b" matches the start of "/*/b/*/d"
// Partial means, if you run out of file before you run
// out of pattern, then that's fine, as long as all
// the parts match.
Minimatch.prototype.matchOne = function (file, pattern, partial) {
  var options = this.options

  this.debug('matchOne',
    { 'this': this, file: file, pattern: pattern })

  this.debug('matchOne', file.length, pattern.length)

  for (var fi = 0,
      pi = 0,
      fl = file.length,
      pl = pattern.length
      ; (fi < fl) && (pi < pl)
      ; fi++, pi++) {
    this.debug('matchOne loop')
    var p = pattern[pi]
    var f = file[fi]

    this.debug(pattern, p, f)

    // should be impossible.
    // some invalid regexp stuff in the set.
    if (p === false) return false

    if (p === GLOBSTAR) {
      this.debug('GLOBSTAR', [pattern, p, f])

      // "**"
      // a/**/b/**/c would match the following:
      // a/b/x/y/z/c
      // a/x/y/z/b/c
      // a/b/x/b/x/c
      // a/b/c
      // To do this, take the rest of the pattern after
      // the **, and see if it would match the file remainder.
      // If so, return success.
      // If not, the ** "swallows" a segment, and try again.
      // This is recursively awful.
      //
      // a/**/b/**/c matching a/b/x/y/z/c
      // - a matches a
      // - doublestar
      //   - matchOne(b/x/y/z/c, b/**/c)
      //     - b matches b
      //     - doublestar
      //       - matchOne(x/y/z/c, c) -> no
      //       - matchOne(y/z/c, c) -> no
      //       - matchOne(z/c, c) -> no
      //       - matchOne(c, c) yes, hit
      var fr = fi
      var pr = pi + 1
      if (pr === pl) {
        this.debug('** at the end')
        // a ** at the end will just swallow the rest.
        // We have found a match.
        // however, it will not swallow /.x, unless
        // options.dot is set.
        // . and .. are *never* matched by **, for explosively
        // exponential reasons.
        for (; fi < fl; fi++) {
          if (file[fi] === '.' || file[fi] === '..' ||
            (!options.dot && file[fi].charAt(0) === '.')) return false
        }
        return true
      }

      // ok, let's see if we can swallow whatever we can.
      while (fr < fl) {
        var swallowee = file[fr]

        this.debug('\nglobstar while', file, fr, pattern, pr, swallowee)

        // XXX remove this slice.  Just pass the start index.
        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
          this.debug('globstar found match!', fr, fl, swallowee)
          // found a match.
          return true
        } else {
          // can't swallow "." or ".." ever.
          // can only swallow ".foo" when explicitly asked.
          if (swallowee === '.' || swallowee === '..' ||
            (!options.dot && swallowee.charAt(0) === '.')) {
            this.debug('dot detected!', file, fr, pattern, pr)
            break
          }

          // ** swallows a segment, and continue.
          this.debug('globstar swallow a segment, and continue')
          fr++
        }
      }

      // no match was found.
      // However, in partial mode, we can't say this is necessarily over.
      // If there's more *pattern* left, then
      if (partial) {
        // ran out of file
        this.debug('\n>>> no match, partial?', file, fr, pattern, pr)
        if (fr === fl) return true
      }
      return false
    }

    // something other than **
    // non-magic patterns just have to match exactly
    // patterns with magic have been turned into regexps.
    var hit
    if (typeof p === 'string') {
      if (options.nocase) {
        hit = f.toLowerCase() === p.toLowerCase()
      } else {
        hit = f === p
      }
      this.debug('string match', p, f, hit)
    } else {
      hit = f.match(p)
      this.debug('pattern match', p, f, hit)
    }

    if (!hit) return false
  }

  // Note: ending in / means that we'll get a final ""
  // at the end of the pattern.  This can only match a
  // corresponding "" at the end of the file.
  // If the file ends in /, then it can only match a
  // a pattern that ends in /, unless the pattern just
  // doesn't have any more for it. But, a/b/ should *not*
  // match "a/b/*", even though "" matches against the
  // [^/]*? pattern, except in partial mode, where it might
  // simply not be reached yet.
  // However, a/b/ should still satisfy a/*

  // now either we fell off the end of the pattern, or we're done.
  if (fi === fl && pi === pl) {
    // ran out of pattern and filename at the same time.
    // an exact hit!
    return true
  } else if (fi === fl) {
    // ran out of file, but still had pattern left.
    // this is ok if we're doing the match as part of
    // a glob fs traversal.
    return partial
  } else if (pi === pl) {
    // ran out of pattern, still have file left.
    // this is only acceptable if we're on the very last
    // empty segment of a file with a trailing slash.
    // a/* should match a/b/
    var emptyFileEnd = (fi === fl - 1) && (file[fi] === '')
    return emptyFileEnd
  }

  // should be unreachable.
  throw new Error('wtf?')
}

// replace stuff like \* with *
function globUnescape (s) {
  return s.replace(/\\(.)/g, '$1')
}

function regExpEscape (s) {
  return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&')
}


/***/ }),

/***/ "./src/node_modules/mkdirp/index.js":
/*!******************************************!*\
  !*** ./src/node_modules/mkdirp/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var path = __webpack_require__(/*! path */ "path");
var fs = __webpack_require__(/*! fs */ "fs");
var _0777 = parseInt('0777', 8);

module.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;

function mkdirP (p, opts, f, made) {
    if (typeof opts === 'function') {
        f = opts;
        opts = {};
    }
    else if (!opts || typeof opts !== 'object') {
        opts = { mode: opts };
    }

    var mode = opts.mode;
    var xfs = opts.fs || fs;

    if (mode === undefined) {
        mode = _0777 & (~process.umask());
    }
    if (!made) made = null;

    var cb = f || function () {};
    p = path.resolve(p);

    xfs.mkdir(p, mode, function (er) {
        if (!er) {
            made = made || p;
            return cb(null, made);
        }
        switch (er.code) {
            case 'ENOENT':
                mkdirP(path.dirname(p), opts, function (er, made) {
                    if (er) cb(er, made);
                    else mkdirP(p, opts, cb, made);
                });
                break;

            // In the case of any other error, just see if there's a dir
            // there already.  If so, then hooray!  If not, then something
            // is borked.
            default:
                xfs.stat(p, function (er2, stat) {
                    // if the stat fails, then that's super weird.
                    // let the original error be the failure reason.
                    if (er2 || !stat.isDirectory()) cb(er, made)
                    else cb(null, made);
                });
                break;
        }
    });
}

mkdirP.sync = function sync (p, opts, made) {
    if (!opts || typeof opts !== 'object') {
        opts = { mode: opts };
    }

    var mode = opts.mode;
    var xfs = opts.fs || fs;

    if (mode === undefined) {
        mode = _0777 & (~process.umask());
    }
    if (!made) made = null;

    p = path.resolve(p);

    try {
        xfs.mkdirSync(p, mode);
        made = made || p;
    }
    catch (err0) {
        switch (err0.code) {
            case 'ENOENT' :
                made = sync(path.dirname(p), opts, made);
                sync(p, opts, made);
                break;

            // In the case of any other error, just see if there's a dir
            // there already.  If so, then hooray!  If not, then something
            // is borked.
            default:
                var stat;
                try {
                    stat = xfs.statSync(p);
                }
                catch (err1) {
                    throw err0;
                }
                if (!stat.isDirectory()) throw err0;
                break;
        }
    }

    return made;
};


/***/ }),

/***/ "./src/node_modules/number-is-nan/index.js":
/*!*************************************************!*\
  !*** ./src/node_modules/number-is-nan/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = Number.isNaN || function (x) {
	return x !== x;
};


/***/ }),

/***/ "./src/node_modules/once/once.js":
/*!***************************************!*\
  !*** ./src/node_modules/once/once.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var wrappy = __webpack_require__(/*! wrappy */ "./src/node_modules/wrappy/wrappy.js")
module.exports = wrappy(once)
module.exports.strict = wrappy(onceStrict)

once.proto = once(function () {
  Object.defineProperty(Function.prototype, 'once', {
    value: function () {
      return once(this)
    },
    configurable: true
  })

  Object.defineProperty(Function.prototype, 'onceStrict', {
    value: function () {
      return onceStrict(this)
    },
    configurable: true
  })
})

function once (fn) {
  var f = function () {
    if (f.called) return f.value
    f.called = true
    return f.value = fn.apply(this, arguments)
  }
  f.called = false
  return f
}

function onceStrict (fn) {
  var f = function () {
    if (f.called)
      throw new Error(f.onceError)
    f.called = true
    return f.value = fn.apply(this, arguments)
  }
  var name = fn.name || 'Function wrapped with `once`'
  f.onceError = name + " shouldn't be called more than once"
  f.called = false
  return f
}


/***/ }),

/***/ "./src/node_modules/os-locale/index.js":
/*!*********************************************!*\
  !*** ./src/node_modules/os-locale/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var childProcess = __webpack_require__(/*! child_process */ "child_process");
var execFileSync = childProcess.execFileSync;
var lcid = __webpack_require__(/*! lcid */ "./src/node_modules/lcid/index.js");
var defaultOpts = {spawn: true};
var cache;

function fallback() {
	cache = 'en_US';
	return cache;
}

function getEnvLocale(env) {
	env = env || process.env;
	var ret = env.LC_ALL || env.LC_MESSAGES || env.LANG || env.LANGUAGE;
	cache = getLocale(ret);
	return ret;
}

function parseLocale(x) {
	var env = x.split('\n').reduce(function (env, def) {
		def = def.split('=');
		env[def[0]] = def[1];
		return env;
	}, {});
	return getEnvLocale(env);
}

function getLocale(str) {
	return (str && str.replace(/[.:].*/, '')) || fallback();
}

module.exports = function (opts, cb) {
	if (typeof opts === 'function') {
		cb = opts;
		opts = defaultOpts;
	} else {
		opts = opts || defaultOpts;
	}

	if (cache || getEnvLocale() || opts.spawn === false) {
		setImmediate(cb, null, cache);
		return;
	}

	var getAppleLocale = function () {
		childProcess.execFile('defaults', ['read', '-g', 'AppleLocale'], function (err, stdout) {
			if (err) {
				fallback();
				return;
			}

			cache = stdout.trim() || fallback();
			cb(null, cache);
		});
	};

	if (process.platform === 'win32') {
		childProcess.execFile('wmic', ['os', 'get', 'locale'], function (err, stdout) {
			if (err) {
				fallback();
				return;
			}

			var lcidCode = parseInt(stdout.replace('Locale', ''), 16);
			cache = lcid.from(lcidCode) || fallback();
			cb(null, cache);
		});
	} else {
		childProcess.execFile('locale', function (err, stdout) {
			if (err) {
				fallback();
				return;
			}

			var res = parseLocale(stdout);

			if (!res && process.platform === 'darwin') {
				getAppleLocale();
				return;
			}

			cache = getLocale(res);
			cb(null, cache);
		});
	}
};

module.exports.sync = function (opts) {
	opts = opts || defaultOpts;

	if (cache || getEnvLocale() || !execFileSync || opts.spawn === false) {
		return cache;
	}

	if (process.platform === 'win32') {
		var stdout;

		try {
			stdout = execFileSync('wmic', ['os', 'get', 'locale'], {encoding: 'utf8'});
		} catch (err) {
			return fallback();
		}

		var lcidCode = parseInt(stdout.replace('Locale', ''), 16);
		cache = lcid.from(lcidCode) || fallback();
		return cache;
	}

	var res;

	try {
		res = parseLocale(execFileSync('locale', {encoding: 'utf8'}));
	} catch (err) {}

	if (!res && process.platform === 'darwin') {
		try {
			cache = execFileSync('defaults', ['read', '-g', 'AppleLocale'], {encoding: 'utf8'}).trim() || fallback();
			return cache;
		} catch (err) {
			return fallback();
		}
	}

	cache = getLocale(res);
	return cache;
};


/***/ }),

/***/ "./src/node_modules/path-is-absolute/index.js":
/*!****************************************************!*\
  !*** ./src/node_modules/path-is-absolute/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function posix(path) {
	return path.charAt(0) === '/';
}

function win32(path) {
	// https://github.com/nodejs/node/blob/b3fcc245fb25539909ef1d5eaa01dbf92e168633/lib/path.js#L56
	var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
	var result = splitDeviceRe.exec(path);
	var device = result[1] || '';
	var isUnc = Boolean(device && device.charAt(1) !== ':');

	// UNC paths are always absolute
	return Boolean(result[2] || isUnc);
}

module.exports = process.platform === 'win32' ? win32 : posix;
module.exports.posix = posix;
module.exports.win32 = win32;


/***/ }),

/***/ "./src/node_modules/rimraf/rimraf.js":
/*!*******************************************!*\
  !*** ./src/node_modules/rimraf/rimraf.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = rimraf
rimraf.sync = rimrafSync

var assert = __webpack_require__(/*! assert */ "assert")
var path = __webpack_require__(/*! path */ "path")
var fs = __webpack_require__(/*! fs */ "fs")
var glob = __webpack_require__(/*! glob */ "./src/node_modules/glob/glob.js")
var _0666 = parseInt('666', 8)

var defaultGlobOpts = {
  nosort: true,
  silent: true
}

// for EMFILE handling
var timeout = 0

var isWindows = (process.platform === "win32")

function defaults (options) {
  var methods = [
    'unlink',
    'chmod',
    'stat',
    'lstat',
    'rmdir',
    'readdir'
  ]
  methods.forEach(function(m) {
    options[m] = options[m] || fs[m]
    m = m + 'Sync'
    options[m] = options[m] || fs[m]
  })

  options.maxBusyTries = options.maxBusyTries || 3
  options.emfileWait = options.emfileWait || 1000
  if (options.glob === false) {
    options.disableGlob = true
  }
  options.disableGlob = options.disableGlob || false
  options.glob = options.glob || defaultGlobOpts
}

function rimraf (p, options, cb) {
  if (typeof options === 'function') {
    cb = options
    options = {}
  }

  assert(p, 'rimraf: missing path')
  assert.equal(typeof p, 'string', 'rimraf: path should be a string')
  assert.equal(typeof cb, 'function', 'rimraf: callback function required')
  assert(options, 'rimraf: invalid options argument provided')
  assert.equal(typeof options, 'object', 'rimraf: options should be object')

  defaults(options)

  var busyTries = 0
  var errState = null
  var n = 0

  if (options.disableGlob || !glob.hasMagic(p))
    return afterGlob(null, [p])

  options.lstat(p, function (er, stat) {
    if (!er)
      return afterGlob(null, [p])

    glob(p, options.glob, afterGlob)
  })

  function next (er) {
    errState = errState || er
    if (--n === 0)
      cb(errState)
  }

  function afterGlob (er, results) {
    if (er)
      return cb(er)

    n = results.length
    if (n === 0)
      return cb()

    results.forEach(function (p) {
      rimraf_(p, options, function CB (er) {
        if (er) {
          if ((er.code === "EBUSY" || er.code === "ENOTEMPTY" || er.code === "EPERM") &&
              busyTries < options.maxBusyTries) {
            busyTries ++
            var time = busyTries * 100
            // try again, with the same exact callback as this one.
            return setTimeout(function () {
              rimraf_(p, options, CB)
            }, time)
          }

          // this one won't happen if graceful-fs is used.
          if (er.code === "EMFILE" && timeout < options.emfileWait) {
            return setTimeout(function () {
              rimraf_(p, options, CB)
            }, timeout ++)
          }

          // already gone
          if (er.code === "ENOENT") er = null
        }

        timeout = 0
        next(er)
      })
    })
  }
}

// Two possible strategies.
// 1. Assume it's a file.  unlink it, then do the dir stuff on EPERM or EISDIR
// 2. Assume it's a directory.  readdir, then do the file stuff on ENOTDIR
//
// Both result in an extra syscall when you guess wrong.  However, there
// are likely far more normal files in the world than directories.  This
// is based on the assumption that a the average number of files per
// directory is >= 1.
//
// If anyone ever complains about this, then I guess the strategy could
// be made configurable somehow.  But until then, YAGNI.
function rimraf_ (p, options, cb) {
  assert(p)
  assert(options)
  assert(typeof cb === 'function')

  // sunos lets the root user unlink directories, which is... weird.
  // so we have to lstat here and make sure it's not a dir.
  options.lstat(p, function (er, st) {
    if (er && er.code === "ENOENT")
      return cb(null)

    // Windows can EPERM on stat.  Life is suffering.
    if (er && er.code === "EPERM" && isWindows)
      fixWinEPERM(p, options, er, cb)

    if (st && st.isDirectory())
      return rmdir(p, options, er, cb)

    options.unlink(p, function (er) {
      if (er) {
        if (er.code === "ENOENT")
          return cb(null)
        if (er.code === "EPERM")
          return (isWindows)
            ? fixWinEPERM(p, options, er, cb)
            : rmdir(p, options, er, cb)
        if (er.code === "EISDIR")
          return rmdir(p, options, er, cb)
      }
      return cb(er)
    })
  })
}

function fixWinEPERM (p, options, er, cb) {
  assert(p)
  assert(options)
  assert(typeof cb === 'function')
  if (er)
    assert(er instanceof Error)

  options.chmod(p, _0666, function (er2) {
    if (er2)
      cb(er2.code === "ENOENT" ? null : er)
    else
      options.stat(p, function(er3, stats) {
        if (er3)
          cb(er3.code === "ENOENT" ? null : er)
        else if (stats.isDirectory())
          rmdir(p, options, er, cb)
        else
          options.unlink(p, cb)
      })
  })
}

function fixWinEPERMSync (p, options, er) {
  assert(p)
  assert(options)
  if (er)
    assert(er instanceof Error)

  try {
    options.chmodSync(p, _0666)
  } catch (er2) {
    if (er2.code === "ENOENT")
      return
    else
      throw er
  }

  try {
    var stats = options.statSync(p)
  } catch (er3) {
    if (er3.code === "ENOENT")
      return
    else
      throw er
  }

  if (stats.isDirectory())
    rmdirSync(p, options, er)
  else
    options.unlinkSync(p)
}

function rmdir (p, options, originalEr, cb) {
  assert(p)
  assert(options)
  if (originalEr)
    assert(originalEr instanceof Error)
  assert(typeof cb === 'function')

  // try to rmdir first, and only readdir on ENOTEMPTY or EEXIST (SunOS)
  // if we guessed wrong, and it's not a directory, then
  // raise the original error.
  options.rmdir(p, function (er) {
    if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM"))
      rmkids(p, options, cb)
    else if (er && er.code === "ENOTDIR")
      cb(originalEr)
    else
      cb(er)
  })
}

function rmkids(p, options, cb) {
  assert(p)
  assert(options)
  assert(typeof cb === 'function')

  options.readdir(p, function (er, files) {
    if (er)
      return cb(er)
    var n = files.length
    if (n === 0)
      return options.rmdir(p, cb)
    var errState
    files.forEach(function (f) {
      rimraf(path.join(p, f), options, function (er) {
        if (errState)
          return
        if (er)
          return cb(errState = er)
        if (--n === 0)
          options.rmdir(p, cb)
      })
    })
  })
}

// this looks simpler, and is strictly *faster*, but will
// tie up the JavaScript thread and fail on excessively
// deep directory trees.
function rimrafSync (p, options) {
  options = options || {}
  defaults(options)

  assert(p, 'rimraf: missing path')
  assert.equal(typeof p, 'string', 'rimraf: path should be a string')
  assert(options, 'rimraf: missing options')
  assert.equal(typeof options, 'object', 'rimraf: options should be object')

  var results

  if (options.disableGlob || !glob.hasMagic(p)) {
    results = [p]
  } else {
    try {
      options.lstatSync(p)
      results = [p]
    } catch (er) {
      results = glob.sync(p, options.glob)
    }
  }

  if (!results.length)
    return

  for (var i = 0; i < results.length; i++) {
    var p = results[i]

    try {
      var st = options.lstatSync(p)
    } catch (er) {
      if (er.code === "ENOENT")
        return

      // Windows can EPERM on stat.  Life is suffering.
      if (er.code === "EPERM" && isWindows)
        fixWinEPERMSync(p, options, er)
    }

    try {
      // sunos lets the root user unlink directories, which is... weird.
      if (st && st.isDirectory())
        rmdirSync(p, options, null)
      else
        options.unlinkSync(p)
    } catch (er) {
      if (er.code === "ENOENT")
        return
      if (er.code === "EPERM")
        return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er)
      if (er.code !== "EISDIR")
        throw er

      rmdirSync(p, options, er)
    }
  }
}

function rmdirSync (p, options, originalEr) {
  assert(p)
  assert(options)
  if (originalEr)
    assert(originalEr instanceof Error)

  try {
    options.rmdirSync(p)
  } catch (er) {
    if (er.code === "ENOENT")
      return
    if (er.code === "ENOTDIR")
      throw originalEr
    if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")
      rmkidsSync(p, options)
  }
}

function rmkidsSync (p, options) {
  assert(p)
  assert(options)
  options.readdirSync(p).forEach(function (f) {
    rimrafSync(path.join(p, f), options)
  })

  // We only end up here once we got ENOTEMPTY at least once, and
  // at this point, we are guaranteed to have removed all the kids.
  // So, we know that it won't be ENOENT or ENOTDIR or anything else.
  // try really hard to delete stuff on windows, because it has a
  // PROFOUNDLY annoying habit of not closing handles promptly when
  // files are deleted, resulting in spurious ENOTEMPTY errors.
  var retries = isWindows ? 100 : 1
  var i = 0
  do {
    var threw = true
    try {
      var ret = options.rmdirSync(p, options)
      threw = false
      return ret
    } finally {
      if (++i < retries && threw)
        continue
    }
  } while (true)
}


/***/ }),

/***/ "./src/node_modules/semver/semver.js":
/*!*******************************************!*\
  !*** ./src/node_modules/semver/semver.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports = module.exports = SemVer;

// The debug function is excluded entirely from the minified version.
/* nomin */ var debug;
/* nomin */ if (typeof process === 'object' &&
    /* nomin */ process.env &&
    /* nomin */ process.env.NODE_DEBUG &&
    /* nomin */ /\bsemver\b/i.test(process.env.NODE_DEBUG))
  /* nomin */ debug = function() {
    /* nomin */ var args = Array.prototype.slice.call(arguments, 0);
    /* nomin */ args.unshift('SEMVER');
    /* nomin */ console.log.apply(console, args);
    /* nomin */ };
/* nomin */ else
  /* nomin */ debug = function() {};

// Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.
exports.SEMVER_SPEC_VERSION = '2.0.0';

var MAX_LENGTH = 256;
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;

// Max safe segment length for coercion.
var MAX_SAFE_COMPONENT_LENGTH = 16;

// The actual regexps go on exports.re
var re = exports.re = [];
var src = exports.src = [];
var R = 0;

// The following Regular Expressions can be used for tokenizing,
// validating, and parsing SemVer version strings.

// ## Numeric Identifier
// A single `0`, or a non-zero digit followed by zero or more digits.

var NUMERICIDENTIFIER = R++;
src[NUMERICIDENTIFIER] = '0|[1-9]\\d*';
var NUMERICIDENTIFIERLOOSE = R++;
src[NUMERICIDENTIFIERLOOSE] = '[0-9]+';


// ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.

var NONNUMERICIDENTIFIER = R++;
src[NONNUMERICIDENTIFIER] = '\\d*[a-zA-Z-][a-zA-Z0-9-]*';


// ## Main Version
// Three dot-separated numeric identifiers.

var MAINVERSION = R++;
src[MAINVERSION] = '(' + src[NUMERICIDENTIFIER] + ')\\.' +
                   '(' + src[NUMERICIDENTIFIER] + ')\\.' +
                   '(' + src[NUMERICIDENTIFIER] + ')';

var MAINVERSIONLOOSE = R++;
src[MAINVERSIONLOOSE] = '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' +
                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' +
                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')';

// ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.

var PRERELEASEIDENTIFIER = R++;
src[PRERELEASEIDENTIFIER] = '(?:' + src[NUMERICIDENTIFIER] +
                            '|' + src[NONNUMERICIDENTIFIER] + ')';

var PRERELEASEIDENTIFIERLOOSE = R++;
src[PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[NUMERICIDENTIFIERLOOSE] +
                                 '|' + src[NONNUMERICIDENTIFIER] + ')';


// ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.

var PRERELEASE = R++;
src[PRERELEASE] = '(?:-(' + src[PRERELEASEIDENTIFIER] +
                  '(?:\\.' + src[PRERELEASEIDENTIFIER] + ')*))';

var PRERELEASELOOSE = R++;
src[PRERELEASELOOSE] = '(?:-?(' + src[PRERELEASEIDENTIFIERLOOSE] +
                       '(?:\\.' + src[PRERELEASEIDENTIFIERLOOSE] + ')*))';

// ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.

var BUILDIDENTIFIER = R++;
src[BUILDIDENTIFIER] = '[0-9A-Za-z-]+';

// ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.

var BUILD = R++;
src[BUILD] = '(?:\\+(' + src[BUILDIDENTIFIER] +
             '(?:\\.' + src[BUILDIDENTIFIER] + ')*))';


// ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.

// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.

var FULL = R++;
var FULLPLAIN = 'v?' + src[MAINVERSION] +
                src[PRERELEASE] + '?' +
                src[BUILD] + '?';

src[FULL] = '^' + FULLPLAIN + '$';

// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.
var LOOSEPLAIN = '[v=\\s]*' + src[MAINVERSIONLOOSE] +
                 src[PRERELEASELOOSE] + '?' +
                 src[BUILD] + '?';

var LOOSE = R++;
src[LOOSE] = '^' + LOOSEPLAIN + '$';

var GTLT = R++;
src[GTLT] = '((?:<|>)?=?)';

// Something like "2.*" or "1.2.x".
// Note that "x.x" is a valid xRange identifer, meaning "any version"
// Only the first item is strictly required.
var XRANGEIDENTIFIERLOOSE = R++;
src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + '|x|X|\\*';
var XRANGEIDENTIFIER = R++;
src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + '|x|X|\\*';

var XRANGEPLAIN = R++;
src[XRANGEPLAIN] = '[v=\\s]*(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:' + src[PRERELEASE] + ')?' +
                   src[BUILD] + '?' +
                   ')?)?';

var XRANGEPLAINLOOSE = R++;
src[XRANGEPLAINLOOSE] = '[v=\\s]*(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:' + src[PRERELEASELOOSE] + ')?' +
                        src[BUILD] + '?' +
                        ')?)?';

var XRANGE = R++;
src[XRANGE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAIN] + '$';
var XRANGELOOSE = R++;
src[XRANGELOOSE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAINLOOSE] + '$';

// Coercion.
// Extract anything that could conceivably be a part of a valid semver
var COERCE = R++;
src[COERCE] = '(?:^|[^\\d])' +
              '(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '})' +
              '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +
              '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +
              '(?:$|[^\\d])';

// Tilde ranges.
// Meaning is "reasonably at or greater than"
var LONETILDE = R++;
src[LONETILDE] = '(?:~>?)';

var TILDETRIM = R++;
src[TILDETRIM] = '(\\s*)' + src[LONETILDE] + '\\s+';
re[TILDETRIM] = new RegExp(src[TILDETRIM], 'g');
var tildeTrimReplace = '$1~';

var TILDE = R++;
src[TILDE] = '^' + src[LONETILDE] + src[XRANGEPLAIN] + '$';
var TILDELOOSE = R++;
src[TILDELOOSE] = '^' + src[LONETILDE] + src[XRANGEPLAINLOOSE] + '$';

// Caret ranges.
// Meaning is "at least and backwards compatible with"
var LONECARET = R++;
src[LONECARET] = '(?:\\^)';

var CARETTRIM = R++;
src[CARETTRIM] = '(\\s*)' + src[LONECARET] + '\\s+';
re[CARETTRIM] = new RegExp(src[CARETTRIM], 'g');
var caretTrimReplace = '$1^';

var CARET = R++;
src[CARET] = '^' + src[LONECARET] + src[XRANGEPLAIN] + '$';
var CARETLOOSE = R++;
src[CARETLOOSE] = '^' + src[LONECARET] + src[XRANGEPLAINLOOSE] + '$';

// A simple gt/lt/eq thing, or just "" to indicate "any version"
var COMPARATORLOOSE = R++;
src[COMPARATORLOOSE] = '^' + src[GTLT] + '\\s*(' + LOOSEPLAIN + ')$|^$';
var COMPARATOR = R++;
src[COMPARATOR] = '^' + src[GTLT] + '\\s*(' + FULLPLAIN + ')$|^$';


// An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `> 1.2.3` ==> `>1.2.3`
var COMPARATORTRIM = R++;
src[COMPARATORTRIM] = '(\\s*)' + src[GTLT] +
                      '\\s*(' + LOOSEPLAIN + '|' + src[XRANGEPLAIN] + ')';

// this one has to use the /g flag
re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], 'g');
var comparatorTrimReplace = '$1$2$3';


// Something like `1.2.3 - 1.2.4`
// Note that these all use the loose form, because they'll be
// checked against either the strict or loose comparator form
// later.
var HYPHENRANGE = R++;
src[HYPHENRANGE] = '^\\s*(' + src[XRANGEPLAIN] + ')' +
                   '\\s+-\\s+' +
                   '(' + src[XRANGEPLAIN] + ')' +
                   '\\s*$';

var HYPHENRANGELOOSE = R++;
src[HYPHENRANGELOOSE] = '^\\s*(' + src[XRANGEPLAINLOOSE] + ')' +
                        '\\s+-\\s+' +
                        '(' + src[XRANGEPLAINLOOSE] + ')' +
                        '\\s*$';

// Star ranges basically just allow anything at all.
var STAR = R++;
src[STAR] = '(<|>)?=?\\s*\\*';

// Compile to actual regexp objects.
// All are flag-free, unless they were created above with a flag.
for (var i = 0; i < R; i++) {
  debug(i, src[i]);
  if (!re[i])
    re[i] = new RegExp(src[i]);
}

exports.parse = parse;
function parse(version, loose) {
  if (version instanceof SemVer)
    return version;

  if (typeof version !== 'string')
    return null;

  if (version.length > MAX_LENGTH)
    return null;

  var r = loose ? re[LOOSE] : re[FULL];
  if (!r.test(version))
    return null;

  try {
    return new SemVer(version, loose);
  } catch (er) {
    return null;
  }
}

exports.valid = valid;
function valid(version, loose) {
  var v = parse(version, loose);
  return v ? v.version : null;
}


exports.clean = clean;
function clean(version, loose) {
  var s = parse(version.trim().replace(/^[=v]+/, ''), loose);
  return s ? s.version : null;
}

exports.SemVer = SemVer;

function SemVer(version, loose) {
  if (version instanceof SemVer) {
    if (version.loose === loose)
      return version;
    else
      version = version.version;
  } else if (typeof version !== 'string') {
    throw new TypeError('Invalid Version: ' + version);
  }

  if (version.length > MAX_LENGTH)
    throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters')

  if (!(this instanceof SemVer))
    return new SemVer(version, loose);

  debug('SemVer', version, loose);
  this.loose = loose;
  var m = version.trim().match(loose ? re[LOOSE] : re[FULL]);

  if (!m)
    throw new TypeError('Invalid Version: ' + version);

  this.raw = version;

  // these are actually numbers
  this.major = +m[1];
  this.minor = +m[2];
  this.patch = +m[3];

  if (this.major > MAX_SAFE_INTEGER || this.major < 0)
    throw new TypeError('Invalid major version')

  if (this.minor > MAX_SAFE_INTEGER || this.minor < 0)
    throw new TypeError('Invalid minor version')

  if (this.patch > MAX_SAFE_INTEGER || this.patch < 0)
    throw new TypeError('Invalid patch version')

  // numberify any prerelease numeric ids
  if (!m[4])
    this.prerelease = [];
  else
    this.prerelease = m[4].split('.').map(function(id) {
      if (/^[0-9]+$/.test(id)) {
        var num = +id;
        if (num >= 0 && num < MAX_SAFE_INTEGER)
          return num;
      }
      return id;
    });

  this.build = m[5] ? m[5].split('.') : [];
  this.format();
}

SemVer.prototype.format = function() {
  this.version = this.major + '.' + this.minor + '.' + this.patch;
  if (this.prerelease.length)
    this.version += '-' + this.prerelease.join('.');
  return this.version;
};

SemVer.prototype.toString = function() {
  return this.version;
};

SemVer.prototype.compare = function(other) {
  debug('SemVer.compare', this.version, this.loose, other);
  if (!(other instanceof SemVer))
    other = new SemVer(other, this.loose);

  return this.compareMain(other) || this.comparePre(other);
};

SemVer.prototype.compareMain = function(other) {
  if (!(other instanceof SemVer))
    other = new SemVer(other, this.loose);

  return compareIdentifiers(this.major, other.major) ||
         compareIdentifiers(this.minor, other.minor) ||
         compareIdentifiers(this.patch, other.patch);
};

SemVer.prototype.comparePre = function(other) {
  if (!(other instanceof SemVer))
    other = new SemVer(other, this.loose);

  // NOT having a prerelease is > having one
  if (this.prerelease.length && !other.prerelease.length)
    return -1;
  else if (!this.prerelease.length && other.prerelease.length)
    return 1;
  else if (!this.prerelease.length && !other.prerelease.length)
    return 0;

  var i = 0;
  do {
    var a = this.prerelease[i];
    var b = other.prerelease[i];
    debug('prerelease compare', i, a, b);
    if (a === undefined && b === undefined)
      return 0;
    else if (b === undefined)
      return 1;
    else if (a === undefined)
      return -1;
    else if (a === b)
      continue;
    else
      return compareIdentifiers(a, b);
  } while (++i);
};

// preminor will bump the version up to the next minor release, and immediately
// down to pre-release. premajor and prepatch work the same way.
SemVer.prototype.inc = function(release, identifier) {
  switch (release) {
    case 'premajor':
      this.prerelease.length = 0;
      this.patch = 0;
      this.minor = 0;
      this.major++;
      this.inc('pre', identifier);
      break;
    case 'preminor':
      this.prerelease.length = 0;
      this.patch = 0;
      this.minor++;
      this.inc('pre', identifier);
      break;
    case 'prepatch':
      // If this is already a prerelease, it will bump to the next version
      // drop any prereleases that might already exist, since they are not
      // relevant at this point.
      this.prerelease.length = 0;
      this.inc('patch', identifier);
      this.inc('pre', identifier);
      break;
    // If the input is a non-prerelease version, this acts the same as
    // prepatch.
    case 'prerelease':
      if (this.prerelease.length === 0)
        this.inc('patch', identifier);
      this.inc('pre', identifier);
      break;

    case 'major':
      // If this is a pre-major version, bump up to the same major version.
      // Otherwise increment major.
      // 1.0.0-5 bumps to 1.0.0
      // 1.1.0 bumps to 2.0.0
      if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0)
        this.major++;
      this.minor = 0;
      this.patch = 0;
      this.prerelease = [];
      break;
    case 'minor':
      // If this is a pre-minor version, bump up to the same minor version.
      // Otherwise increment minor.
      // 1.2.0-5 bumps to 1.2.0
      // 1.2.1 bumps to 1.3.0
      if (this.patch !== 0 || this.prerelease.length === 0)
        this.minor++;
      this.patch = 0;
      this.prerelease = [];
      break;
    case 'patch':
      // If this is not a pre-release version, it will increment the patch.
      // If it is a pre-release it will bump up to the same patch version.
      // 1.2.0-5 patches to 1.2.0
      // 1.2.0 patches to 1.2.1
      if (this.prerelease.length === 0)
        this.patch++;
      this.prerelease = [];
      break;
    // This probably shouldn't be used publicly.
    // 1.0.0 "pre" would become 1.0.0-0 which is the wrong direction.
    case 'pre':
      if (this.prerelease.length === 0)
        this.prerelease = [0];
      else {
        var i = this.prerelease.length;
        while (--i >= 0) {
          if (typeof this.prerelease[i] === 'number') {
            this.prerelease[i]++;
            i = -2;
          }
        }
        if (i === -1) // didn't increment anything
          this.prerelease.push(0);
      }
      if (identifier) {
        // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
        // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
        if (this.prerelease[0] === identifier) {
          if (isNaN(this.prerelease[1]))
            this.prerelease = [identifier, 0];
        } else
          this.prerelease = [identifier, 0];
      }
      break;

    default:
      throw new Error('invalid increment argument: ' + release);
  }
  this.format();
  this.raw = this.version;
  return this;
};

exports.inc = inc;
function inc(version, release, loose, identifier) {
  if (typeof(loose) === 'string') {
    identifier = loose;
    loose = undefined;
  }

  try {
    return new SemVer(version, loose).inc(release, identifier).version;
  } catch (er) {
    return null;
  }
}

exports.diff = diff;
function diff(version1, version2) {
  if (eq(version1, version2)) {
    return null;
  } else {
    var v1 = parse(version1);
    var v2 = parse(version2);
    if (v1.prerelease.length || v2.prerelease.length) {
      for (var key in v1) {
        if (key === 'major' || key === 'minor' || key === 'patch') {
          if (v1[key] !== v2[key]) {
            return 'pre'+key;
          }
        }
      }
      return 'prerelease';
    }
    for (var key in v1) {
      if (key === 'major' || key === 'minor' || key === 'patch') {
        if (v1[key] !== v2[key]) {
          return key;
        }
      }
    }
  }
}

exports.compareIdentifiers = compareIdentifiers;

var numeric = /^[0-9]+$/;
function compareIdentifiers(a, b) {
  var anum = numeric.test(a);
  var bnum = numeric.test(b);

  if (anum && bnum) {
    a = +a;
    b = +b;
  }

  return (anum && !bnum) ? -1 :
         (bnum && !anum) ? 1 :
         a < b ? -1 :
         a > b ? 1 :
         0;
}

exports.rcompareIdentifiers = rcompareIdentifiers;
function rcompareIdentifiers(a, b) {
  return compareIdentifiers(b, a);
}

exports.major = major;
function major(a, loose) {
  return new SemVer(a, loose).major;
}

exports.minor = minor;
function minor(a, loose) {
  return new SemVer(a, loose).minor;
}

exports.patch = patch;
function patch(a, loose) {
  return new SemVer(a, loose).patch;
}

exports.compare = compare;
function compare(a, b, loose) {
  return new SemVer(a, loose).compare(new SemVer(b, loose));
}

exports.compareLoose = compareLoose;
function compareLoose(a, b) {
  return compare(a, b, true);
}

exports.rcompare = rcompare;
function rcompare(a, b, loose) {
  return compare(b, a, loose);
}

exports.sort = sort;
function sort(list, loose) {
  return list.sort(function(a, b) {
    return exports.compare(a, b, loose);
  });
}

exports.rsort = rsort;
function rsort(list, loose) {
  return list.sort(function(a, b) {
    return exports.rcompare(a, b, loose);
  });
}

exports.gt = gt;
function gt(a, b, loose) {
  return compare(a, b, loose) > 0;
}

exports.lt = lt;
function lt(a, b, loose) {
  return compare(a, b, loose) < 0;
}

exports.eq = eq;
function eq(a, b, loose) {
  return compare(a, b, loose) === 0;
}

exports.neq = neq;
function neq(a, b, loose) {
  return compare(a, b, loose) !== 0;
}

exports.gte = gte;
function gte(a, b, loose) {
  return compare(a, b, loose) >= 0;
}

exports.lte = lte;
function lte(a, b, loose) {
  return compare(a, b, loose) <= 0;
}

exports.cmp = cmp;
function cmp(a, op, b, loose) {
  var ret;
  switch (op) {
    case '===':
      if (typeof a === 'object') a = a.version;
      if (typeof b === 'object') b = b.version;
      ret = a === b;
      break;
    case '!==':
      if (typeof a === 'object') a = a.version;
      if (typeof b === 'object') b = b.version;
      ret = a !== b;
      break;
    case '': case '=': case '==': ret = eq(a, b, loose); break;
    case '!=': ret = neq(a, b, loose); break;
    case '>': ret = gt(a, b, loose); break;
    case '>=': ret = gte(a, b, loose); break;
    case '<': ret = lt(a, b, loose); break;
    case '<=': ret = lte(a, b, loose); break;
    default: throw new TypeError('Invalid operator: ' + op);
  }
  return ret;
}

exports.Comparator = Comparator;
function Comparator(comp, loose) {
  if (comp instanceof Comparator) {
    if (comp.loose === loose)
      return comp;
    else
      comp = comp.value;
  }

  if (!(this instanceof Comparator))
    return new Comparator(comp, loose);

  debug('comparator', comp, loose);
  this.loose = loose;
  this.parse(comp);

  if (this.semver === ANY)
    this.value = '';
  else
    this.value = this.operator + this.semver.version;

  debug('comp', this);
}

var ANY = {};
Comparator.prototype.parse = function(comp) {
  var r = this.loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
  var m = comp.match(r);

  if (!m)
    throw new TypeError('Invalid comparator: ' + comp);

  this.operator = m[1];
  if (this.operator === '=')
    this.operator = '';

  // if it literally is just '>' or '' then allow anything.
  if (!m[2])
    this.semver = ANY;
  else
    this.semver = new SemVer(m[2], this.loose);
};

Comparator.prototype.toString = function() {
  return this.value;
};

Comparator.prototype.test = function(version) {
  debug('Comparator.test', version, this.loose);

  if (this.semver === ANY)
    return true;

  if (typeof version === 'string')
    version = new SemVer(version, this.loose);

  return cmp(version, this.operator, this.semver, this.loose);
};

Comparator.prototype.intersects = function(comp, loose) {
  if (!(comp instanceof Comparator)) {
    throw new TypeError('a Comparator is required');
  }

  var rangeTmp;

  if (this.operator === '') {
    rangeTmp = new Range(comp.value, loose);
    return satisfies(this.value, rangeTmp, loose);
  } else if (comp.operator === '') {
    rangeTmp = new Range(this.value, loose);
    return satisfies(comp.semver, rangeTmp, loose);
  }

  var sameDirectionIncreasing =
    (this.operator === '>=' || this.operator === '>') &&
    (comp.operator === '>=' || comp.operator === '>');
  var sameDirectionDecreasing =
    (this.operator === '<=' || this.operator === '<') &&
    (comp.operator === '<=' || comp.operator === '<');
  var sameSemVer = this.semver.version === comp.semver.version;
  var differentDirectionsInclusive =
    (this.operator === '>=' || this.operator === '<=') &&
    (comp.operator === '>=' || comp.operator === '<=');
  var oppositeDirectionsLessThan =
    cmp(this.semver, '<', comp.semver, loose) &&
    ((this.operator === '>=' || this.operator === '>') &&
    (comp.operator === '<=' || comp.operator === '<'));
  var oppositeDirectionsGreaterThan =
    cmp(this.semver, '>', comp.semver, loose) &&
    ((this.operator === '<=' || this.operator === '<') &&
    (comp.operator === '>=' || comp.operator === '>'));

  return sameDirectionIncreasing || sameDirectionDecreasing ||
    (sameSemVer && differentDirectionsInclusive) ||
    oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
};


exports.Range = Range;
function Range(range, loose) {
  if (range instanceof Range) {
    if (range.loose === loose) {
      return range;
    } else {
      return new Range(range.raw, loose);
    }
  }

  if (range instanceof Comparator) {
    return new Range(range.value, loose);
  }

  if (!(this instanceof Range))
    return new Range(range, loose);

  this.loose = loose;

  // First, split based on boolean or ||
  this.raw = range;
  this.set = range.split(/\s*\|\|\s*/).map(function(range) {
    return this.parseRange(range.trim());
  }, this).filter(function(c) {
    // throw out any that are not relevant for whatever reason
    return c.length;
  });

  if (!this.set.length) {
    throw new TypeError('Invalid SemVer Range: ' + range);
  }

  this.format();
}

Range.prototype.format = function() {
  this.range = this.set.map(function(comps) {
    return comps.join(' ').trim();
  }).join('||').trim();
  return this.range;
};

Range.prototype.toString = function() {
  return this.range;
};

Range.prototype.parseRange = function(range) {
  var loose = this.loose;
  range = range.trim();
  debug('range', range, loose);
  // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
  var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE];
  range = range.replace(hr, hyphenReplace);
  debug('hyphen replace', range);
  // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
  range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace);
  debug('comparator trim', range, re[COMPARATORTRIM]);

  // `~ 1.2.3` => `~1.2.3`
  range = range.replace(re[TILDETRIM], tildeTrimReplace);

  // `^ 1.2.3` => `^1.2.3`
  range = range.replace(re[CARETTRIM], caretTrimReplace);

  // normalize spaces
  range = range.split(/\s+/).join(' ');

  // At this point, the range is completely trimmed and
  // ready to be split into comparators.

  var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
  var set = range.split(' ').map(function(comp) {
    return parseComparator(comp, loose);
  }).join(' ').split(/\s+/);
  if (this.loose) {
    // in loose mode, throw out any that are not valid comparators
    set = set.filter(function(comp) {
      return !!comp.match(compRe);
    });
  }
  set = set.map(function(comp) {
    return new Comparator(comp, loose);
  });

  return set;
};

Range.prototype.intersects = function(range, loose) {
  if (!(range instanceof Range)) {
    throw new TypeError('a Range is required');
  }

  return this.set.some(function(thisComparators) {
    return thisComparators.every(function(thisComparator) {
      return range.set.some(function(rangeComparators) {
        return rangeComparators.every(function(rangeComparator) {
          return thisComparator.intersects(rangeComparator, loose);
        });
      });
    });
  });
};

// Mostly just for testing and legacy API reasons
exports.toComparators = toComparators;
function toComparators(range, loose) {
  return new Range(range, loose).set.map(function(comp) {
    return comp.map(function(c) {
      return c.value;
    }).join(' ').trim().split(' ');
  });
}

// comprised of xranges, tildes, stars, and gtlt's at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.
function parseComparator(comp, loose) {
  debug('comp', comp);
  comp = replaceCarets(comp, loose);
  debug('caret', comp);
  comp = replaceTildes(comp, loose);
  debug('tildes', comp);
  comp = replaceXRanges(comp, loose);
  debug('xrange', comp);
  comp = replaceStars(comp, loose);
  debug('stars', comp);
  return comp;
}

function isX(id) {
  return !id || id.toLowerCase() === 'x' || id === '*';
}

// ~, ~> --> * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0
// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0
// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0
// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0
// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0
function replaceTildes(comp, loose) {
  return comp.trim().split(/\s+/).map(function(comp) {
    return replaceTilde(comp, loose);
  }).join(' ');
}

function replaceTilde(comp, loose) {
  var r = loose ? re[TILDELOOSE] : re[TILDE];
  return comp.replace(r, function(_, M, m, p, pr) {
    debug('tilde', comp, _, M, m, p, pr);
    var ret;

    if (isX(M))
      ret = '';
    else if (isX(m))
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
    else if (isX(p))
      // ~1.2 == >=1.2.0 <1.3.0
      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
    else if (pr) {
      debug('replaceTilde pr', pr);
      if (pr.charAt(0) !== '-')
        pr = '-' + pr;
      ret = '>=' + M + '.' + m + '.' + p + pr +
            ' <' + M + '.' + (+m + 1) + '.0';
    } else
      // ~1.2.3 == >=1.2.3 <1.3.0
      ret = '>=' + M + '.' + m + '.' + p +
            ' <' + M + '.' + (+m + 1) + '.0';

    debug('tilde return', ret);
    return ret;
  });
}

// ^ --> * (any, kinda silly)
// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0
// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0
// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0
// ^1.2.3 --> >=1.2.3 <2.0.0
// ^1.2.0 --> >=1.2.0 <2.0.0
function replaceCarets(comp, loose) {
  return comp.trim().split(/\s+/).map(function(comp) {
    return replaceCaret(comp, loose);
  }).join(' ');
}

function replaceCaret(comp, loose) {
  debug('caret', comp, loose);
  var r = loose ? re[CARETLOOSE] : re[CARET];
  return comp.replace(r, function(_, M, m, p, pr) {
    debug('caret', comp, _, M, m, p, pr);
    var ret;

    if (isX(M))
      ret = '';
    else if (isX(m))
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
    else if (isX(p)) {
      if (M === '0')
        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
      else
        ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0';
    } else if (pr) {
      debug('replaceCaret pr', pr);
      if (pr.charAt(0) !== '-')
        pr = '-' + pr;
      if (M === '0') {
        if (m === '0')
          ret = '>=' + M + '.' + m + '.' + p + pr +
                ' <' + M + '.' + m + '.' + (+p + 1);
        else
          ret = '>=' + M + '.' + m + '.' + p + pr +
                ' <' + M + '.' + (+m + 1) + '.0';
      } else
        ret = '>=' + M + '.' + m + '.' + p + pr +
              ' <' + (+M + 1) + '.0.0';
    } else {
      debug('no pr');
      if (M === '0') {
        if (m === '0')
          ret = '>=' + M + '.' + m + '.' + p +
                ' <' + M + '.' + m + '.' + (+p + 1);
        else
          ret = '>=' + M + '.' + m + '.' + p +
                ' <' + M + '.' + (+m + 1) + '.0';
      } else
        ret = '>=' + M + '.' + m + '.' + p +
              ' <' + (+M + 1) + '.0.0';
    }

    debug('caret return', ret);
    return ret;
  });
}

function replaceXRanges(comp, loose) {
  debug('replaceXRanges', comp, loose);
  return comp.split(/\s+/).map(function(comp) {
    return replaceXRange(comp, loose);
  }).join(' ');
}

function replaceXRange(comp, loose) {
  comp = comp.trim();
  var r = loose ? re[XRANGELOOSE] : re[XRANGE];
  return comp.replace(r, function(ret, gtlt, M, m, p, pr) {
    debug('xRange', comp, ret, gtlt, M, m, p, pr);
    var xM = isX(M);
    var xm = xM || isX(m);
    var xp = xm || isX(p);
    var anyX = xp;

    if (gtlt === '=' && anyX)
      gtlt = '';

    if (xM) {
      if (gtlt === '>' || gtlt === '<') {
        // nothing is allowed
        ret = '<0.0.0';
      } else {
        // nothing is forbidden
        ret = '*';
      }
    } else if (gtlt && anyX) {
      // replace X with 0
      if (xm)
        m = 0;
      if (xp)
        p = 0;

      if (gtlt === '>') {
        // >1 => >=2.0.0
        // >1.2 => >=1.3.0
        // >1.2.3 => >= 1.2.4
        gtlt = '>=';
        if (xm) {
          M = +M + 1;
          m = 0;
          p = 0;
        } else if (xp) {
          m = +m + 1;
          p = 0;
        }
      } else if (gtlt === '<=') {
        // <=0.7.x is actually <0.8.0, since any 0.7.x should
        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
        gtlt = '<';
        if (xm)
          M = +M + 1;
        else
          m = +m + 1;
      }

      ret = gtlt + M + '.' + m + '.' + p;
    } else if (xm) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
    } else if (xp) {
      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
    }

    debug('xRange return', ret);

    return ret;
  });
}

// Because * is AND-ed with everything else in the comparator,
// and '' means "any version", just remove the *s entirely.
function replaceStars(comp, loose) {
  debug('replaceStars', comp, loose);
  // Looseness is ignored here.  star is always as loose as it gets!
  return comp.trim().replace(re[STAR], '');
}

// This function is passed to string.replace(re[HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
// 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do
// 1.2 - 3.4 => >=1.2.0 <3.5.0
function hyphenReplace($0,
                       from, fM, fm, fp, fpr, fb,
                       to, tM, tm, tp, tpr, tb) {

  if (isX(fM))
    from = '';
  else if (isX(fm))
    from = '>=' + fM + '.0.0';
  else if (isX(fp))
    from = '>=' + fM + '.' + fm + '.0';
  else
    from = '>=' + from;

  if (isX(tM))
    to = '';
  else if (isX(tm))
    to = '<' + (+tM + 1) + '.0.0';
  else if (isX(tp))
    to = '<' + tM + '.' + (+tm + 1) + '.0';
  else if (tpr)
    to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr;
  else
    to = '<=' + to;

  return (from + ' ' + to).trim();
}


// if ANY of the sets match ALL of its comparators, then pass
Range.prototype.test = function(version) {
  if (!version)
    return false;

  if (typeof version === 'string')
    version = new SemVer(version, this.loose);

  for (var i = 0; i < this.set.length; i++) {
    if (testSet(this.set[i], version))
      return true;
  }
  return false;
};

function testSet(set, version) {
  for (var i = 0; i < set.length; i++) {
    if (!set[i].test(version))
      return false;
  }

  if (version.prerelease.length) {
    // Find the set of versions that are allowed to have prereleases
    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
    // That should allow `1.2.3-pr.2` to pass.
    // However, `1.2.4-alpha.notready` should NOT be allowed,
    // even though it's within the range set by the comparators.
    for (var i = 0; i < set.length; i++) {
      debug(set[i].semver);
      if (set[i].semver === ANY)
        continue;

      if (set[i].semver.prerelease.length > 0) {
        var allowed = set[i].semver;
        if (allowed.major === version.major &&
            allowed.minor === version.minor &&
            allowed.patch === version.patch)
          return true;
      }
    }

    // Version has a -pre, but it's not one of the ones we like.
    return false;
  }

  return true;
}

exports.satisfies = satisfies;
function satisfies(version, range, loose) {
  try {
    range = new Range(range, loose);
  } catch (er) {
    return false;
  }
  return range.test(version);
}

exports.maxSatisfying = maxSatisfying;
function maxSatisfying(versions, range, loose) {
  var max = null;
  var maxSV = null;
  try {
    var rangeObj = new Range(range, loose);
  } catch (er) {
    return null;
  }
  versions.forEach(function (v) {
    if (rangeObj.test(v)) { // satisfies(v, range, loose)
      if (!max || maxSV.compare(v) === -1) { // compare(max, v, true)
        max = v;
        maxSV = new SemVer(max, loose);
      }
    }
  })
  return max;
}

exports.minSatisfying = minSatisfying;
function minSatisfying(versions, range, loose) {
  var min = null;
  var minSV = null;
  try {
    var rangeObj = new Range(range, loose);
  } catch (er) {
    return null;
  }
  versions.forEach(function (v) {
    if (rangeObj.test(v)) { // satisfies(v, range, loose)
      if (!min || minSV.compare(v) === 1) { // compare(min, v, true)
        min = v;
        minSV = new SemVer(min, loose);
      }
    }
  })
  return min;
}

exports.validRange = validRange;
function validRange(range, loose) {
  try {
    // Return '*' instead of '' so that truthiness works.
    // This will throw if it's invalid anyway
    return new Range(range, loose).range || '*';
  } catch (er) {
    return null;
  }
}

// Determine if version is less than all the versions possible in the range
exports.ltr = ltr;
function ltr(version, range, loose) {
  return outside(version, range, '<', loose);
}

// Determine if version is greater than all the versions possible in the range.
exports.gtr = gtr;
function gtr(version, range, loose) {
  return outside(version, range, '>', loose);
}

exports.outside = outside;
function outside(version, range, hilo, loose) {
  version = new SemVer(version, loose);
  range = new Range(range, loose);

  var gtfn, ltefn, ltfn, comp, ecomp;
  switch (hilo) {
    case '>':
      gtfn = gt;
      ltefn = lte;
      ltfn = lt;
      comp = '>';
      ecomp = '>=';
      break;
    case '<':
      gtfn = lt;
      ltefn = gte;
      ltfn = gt;
      comp = '<';
      ecomp = '<=';
      break;
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"');
  }

  // If it satisifes the range it is not outside
  if (satisfies(version, range, loose)) {
    return false;
  }

  // From now on, variable terms are as if we're in "gtr" mode.
  // but note that everything is flipped for the "ltr" function.

  for (var i = 0; i < range.set.length; ++i) {
    var comparators = range.set[i];

    var high = null;
    var low = null;

    comparators.forEach(function(comparator) {
      if (comparator.semver === ANY) {
        comparator = new Comparator('>=0.0.0')
      }
      high = high || comparator;
      low = low || comparator;
      if (gtfn(comparator.semver, high.semver, loose)) {
        high = comparator;
      } else if (ltfn(comparator.semver, low.semver, loose)) {
        low = comparator;
      }
    });

    // If the edge version comparator has a operator then our version
    // isn't outside it
    if (high.operator === comp || high.operator === ecomp) {
      return false;
    }

    // If the lowest version comparator has an operator and our version
    // is less than it then it isn't higher than the range
    if ((!low.operator || low.operator === comp) &&
        ltefn(version, low.semver)) {
      return false;
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return false;
    }
  }
  return true;
}

exports.prerelease = prerelease;
function prerelease(version, loose) {
  var parsed = parse(version, loose);
  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null;
}

exports.intersects = intersects;
function intersects(r1, r2, loose) {
  r1 = new Range(r1, loose)
  r2 = new Range(r2, loose)
  return r1.intersects(r2)
}

exports.coerce = coerce;
function coerce(version) {
  if (version instanceof SemVer)
    return version;

  if (typeof version !== 'string')
    return null;

  var match = version.match(re[COERCE]);

  if (match == null)
    return null;

  return parse((match[1] || '0') + '.' + (match[2] || '0') + '.' + (match[3] || '0'));
}


/***/ }),

/***/ "./src/node_modules/simple-spellchecker/dictionary.js":
/*!************************************************************!*\
  !*** ./src/node_modules/simple-spellchecker/dictionary.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
 * Copyright (c) 2016 José F. Maldonado
 * This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. 
 * If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */

// Load dependencies.
const BinarySearch = __webpack_require__(/*! binarysearch */ "./src/node_modules/binarysearch/index.js");
const EditDistance = __webpack_require__(/*! damerau-levenshtein */ "./src/node_modules/damerau-levenshtein/damerau-levenshtein.js")();

// Use this object for consider accents and special characters when comparing UTF-8 strings.
var Collator = new Intl.Collator(undefined, {'sensitivity': 'accent'});
 
// The search for suggestions is going to be limited to words that are next to the position, in the word list, in which the word would be inserted.
var SuggestRadius = 1000;

/**
 * Creates an instance of Dictionary.
 *
 * @constructor
 * @this {Dictionary}
 * @param {string[]} wordlist A sorted array of strings.
 */
function Dictionary(wordlist) {
    this.wordlist = [];
    this.setWordlist(wordlist);
    this.clearRegexs();
}

/**
 * Returns the number of words in the dictionary.
 *
 * @return {number} The number of words in the dictionary.
 */
Dictionary.prototype.getLength = function() {
    return this.wordlist != null? this.wordlist.length : 0;
};

/**
 * Set the list of words of the dictionary. a new Circle from a diameter.
 *
 * @param {string[]} wordlist A sorted array of strings.
 */
Dictionary.prototype.setWordlist = function(wordlist) {
    if(wordlist != null && Array.isArray(wordlist)) this.wordlist = wordlist;
};

/**
 * Verify if a word is in the dictionary.
 *
 * @param {string} word A string.
 * @return {bool} 'true' if the word is in the dictionary, 'false' otherwise.
 */
Dictionary.prototype.spellCheck = function(word) {
    // Verify if the word satifies one of the regular expressions.
    for(var i=0; i<this.regexs.length; i++) {
        if(this.regexs[i].test(word)) return true;
    }
  
    // Since the list is sorted, is more fast to do a binary search than 'this.wordlist.indexOf(word)'.
    var res = BinarySearch(
        this.wordlist, // Haystack
        word.toLowerCase(), // Needle
        Collator.compare // Comparison method
    );
    return res >= 0;
};

/**
 * Verify if a word is misspelled.
 *
 * @param {string} word A string.
 * @return {bool} 'true' if the word is misspelled, 'false' otherwise.
 */
Dictionary.prototype.isMisspelled = function(word) {
    return ! this.spellCheck(word);
};

/**
 * Get a list of suggestions for a misspelled word.
 *
 * @param {string} word A string.
 * @param {number} limit An integer indicating the maximum number of suggestions (by default 5).
 * @param {number} maxDistance An integer indicating the maximum edit distance between the word and the suggestions (by default 3).
 * @return {string[]} An array of strings with the suggestions.
 */
Dictionary.prototype.getSuggestions = function(word, limit, maxDistance) {
    var suggestions = [];
    if(word != null && word.length > 0) {
        // Validate parameters.
        word = word.toLowerCase();
        if(limit == null || isNaN(limit) || limit <= 0) limit = 5;
        if(maxDistance == null || isNaN(maxDistance) || maxDistance <= 0) maxDistance = 2;
        if(maxDistance >= word.length) maxDistance = word.length - 1;
      
        // Search index of closest item.
        var closest = BinarySearch.closest(this.wordlist, word, Collator.compare);
        
        // Initialize variables for store results.
        var res = [];
        for(var i=0; i<=maxDistance; i++) res.push([]);
        
        // Search suggestions around the position in which the word would be inserted.
        var k, dist;
        for(var i=0; i<SuggestRadius; i++) {
            // The index 'k' is going to be 0, 1, -1, 2, -2... 
            k = closest + (i%2 != 0? ((i+1)/2) : (-i/2) );
            if(k >=0 && k < this.wordlist.length) {
                dist = EditDistance(word, this.wordlist[k].toLowerCase()); 
                if(dist <= maxDistance) res[dist].push(this.wordlist[k]);
            }
        }
        
        // Prepare result.
        for(var d=0; d<=maxDistance && suggestions.length < limit; d++) {
            var remaining = limit - suggestions.length;
            suggestions = suggestions.concat( (res[d].length > remaining)? res[d].slice(0, remaining) : res[d] );
        }
    }
    return suggestions;
}

/**
 * Verify if a word is misspelled and get a list of suggestions.
 *
 * @param {string} word A string.
 * @param {number} limit An integer indicating the maximum number of suggestions (by default 5).
 * @param {number} maxDistance An integer indicating the maximum edit distance between the word and the suggestions (by default 3).
 * @return {Object} An object with the properties 'misspelled' (a boolean) and 'suggestions' (an array of strings).
 */
Dictionary.prototype.checkAndSuggest = function(word, limit, maxDistance) {
    // Get suggestions.
    var suggestions = this.getSuggestions(word, limit+1, maxDistance);
    
    // Prepare response.
    var res = {'misspelled': true, 'suggestions': []};
    res.misspelled = suggestions.length == 0 || suggestions[0].toLowerCase() != word.toLowerCase();
    res.suggestions = suggestions;
    if(res.misspelled && (suggestions.length > limit)) res.suggestions = suggestions.slice(0, limit);
    if(!res.misspelled) res.suggestions = suggestions.slice(1, suggestions.length);

    // Verify if the word satifies one of the regular expressions.
    if(res.misspelled) {
        for(var i=0; i<this.regexs.length; i++) {
            if(this.regexs[i].test(word)) res.misspelled = false;
        }
    }
    
    return res;
}

/**
 * Adds a regular expression that will be used to verify if a word is valid even though is not on the dictionary.
 * Useful indicate that numbers, URLs and emails should not be marked as misspelled words.
 *
 * @param {RegEx} regexp A regular expression.
 */
Dictionary.prototype.addRegex = function(regex) {
    this.regexs.push(regex);
};

/**
 * Clear the list of regultar expressions used to verify if a word is valid even though is not on the dictionary.
 */
Dictionary.prototype.clearRegexs = function() {
    this.regexs = [];
};

// Export class.
module.exports = Dictionary;


/***/ }),

/***/ "./src/node_modules/simple-spellchecker/index.js":
/*!*******************************************************!*\
  !*** ./src/node_modules/simple-spellchecker/index.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(__dirname) {/*
 * Copyright (c) 2016 José F. Maldonado
 * This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. 
 * If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */

// Load dependencies.
const fs = __webpack_require__(/*! fs */ "fs");
const unzip = __webpack_require__(/*! unzip-stream */ "./src/node_modules/unzip-stream/unzip.js");
const stripBOM = __webpack_require__(/*! strip-bom */ "./src/node_modules/strip-bom/index.js");
const Dictionary = __webpack_require__(/*! ./dictionary.js */ "./src/node_modules/simple-spellchecker/dictionary.js");

const FOLDER_PATH = __dirname + '/dict';

// Define module.
var SpellChecker = {
    /**
     * Create a dictionary from a file, which might be either a .dic or a .zip file.
     *
     * @param {String} fileName The name of the file from which read the word list.
     * @param {String} folderPath The path to the directory in which the file is located (optional).
     * @param {Callback} callback A function to invoke when either the dictionary was created or an error was found.
     */
    getDictionary: function(fileName, folderPath /*, callback*/) {
        try{
            // Initialize variables.
            var folder = (!folderPath || typeof folderPath != 'string')? FOLDER_PATH : folderPath;
            var callback = arguments[arguments.length - 1];
            var dic_path = folder + '/' + fileName + '.dic';
            var zip_path = folder + '/' + fileName + '.zip';
            
            // Verify if the dictionary file exists.
            fs.exists(dic_path, function(exists) {
                if(exists) {
                    // The file exists, read it.
                    SpellChecker._readFile(dic_path, callback);
                } else {
                    // The file do not exists, verify if the ZIP file exists.
                    fs.exists(zip_path, function(exists) {
                        if(exists) {
                            // The file ZIP exists, unzip it.
                            fs.createReadStream(zip_path).pipe( unzip.Extract({ path: folder }) ).on('close', function() {
                                // The file was extracted, now read it.
                                SpellChecker._readFile(dic_path, callback);
                            });
                        } else {
                            // The ZIP file also doesn't exists, return an error.
                            callback('The dictionary could not be read, no file with the name "' + fileName + '" could be found', null);
                        } 
                    });
                }
            });
        } catch(err) {
            // Return error.
            if(callback) callback('An unexpected error ocurred: ' + err, null);
        }
    },
  
    /**
     * Create a dictionary from a .dic file.
     *
     * @param {String} file_path The path of the file.
     * @param {Callback} callback A function to invoke when either the dictionary was created or an error was found.
     */  
    _readFile: function(file_path, callback) {
        fs.readFile(file_path, 'utf8', function(err, text) {
            // Check for errors.
            if (!err) {
                // Create dictionary and return it.
                var dictionary = new Dictionary(text.split('\n'));
                callback(null, dictionary);
            } else {
                // Return an error.
                callback("The dictionary file could not be read: " + err, null);
            }
        });
    },
  
    /**
     * Create a dictionary from a .dic file .
     *
     * @param {String} fileName The name of the file from which read the word list.
     * @param {String} folderPath The path to the directory in which the file is located (optional).
     * @return {Object} An instance of the Dictionary class.
     * @throws {Exception} If the dictionary's file can't be found or is invalid.
     */  
    getDictionarySync: function(fileName, folderPath) {
        try{
            // Initialize variables.
            var folder = (!folderPath || typeof folderPath != 'string')? FOLDER_PATH : folderPath;
            var dic_path = folder + '/' + fileName + '.dic';
            var zip_path = folder + '/' + fileName + '.zip';
          
            // Verify if the dictionary file exists.
            if(fs.existsSync(dic_path)) {
                // The file exists, read it.
                var text = fs.readFileSync(dic_path, 'utf8');
                var dictionary = new Dictionary(text.split('\n'));
                return dictionary;
            } else {
                // The file do not exists, throw an error (only the asynchronous versions of this method unzip the compressed files).
                throw new Error('The dictionary could not be created, no file with the name "' + fileName + '" could be found');
            }
        } catch(err) {
            // Throw an error.
            throw new Error('An unexpected error ocurred: ' + err);
        }
    },
    
    /**
     * Reads a UTF8 dictionary file, removes the BOM and \r characters and sorts the list of words.
     *
     * @param {String} inputPath The path for the input file.
     * @param {String} outputPath The path to output (optional, by default is equals to the input file).
     * @param {Callback} callback A function to invoke after finishing.
     */
    normalizeDictionary: function(inputPath, outputPath /*, callback*/) {
        try{
            // Parses arguments
            if(!outputPath || typeof outputPath != 'string') outputPath = inputPath;
            var callback = arguments.length > 0? arguments[arguments.length - 1] : function() {};
            
            // Verify if the dictionary file exists.
            fs.exists(inputPath, function(exists) {
                if(exists) {
                    // The file exists, read it.
                    fs.readFile(inputPath, 'utf8', function(err, content) {
                        // Check for errors.
                        if (!err) {
                            // Remove BOM and \r characters.
                            content = stripBOM(content);
                            content = content.replace(/\r/g, '');
                            
                            // Sort words.
                            var lines = content.split('\n');      
                            var collator = new Intl.Collator(); // Use this comparator for consider accents and special characters.
                            lines = lines.sort(collator.compare);
                            
                            // Generate output content.
                            var newContent = '';  
                            var first = true;
                            for(var i=0; i<lines.length; i++) {          
                                if(lines[i] != '' && lines[i] != '\n') {
                                    if(!first) newContent += '\n';
                                    newContent += lines[i];
                                    first = false;
                                }
                            }
                            
                            // Write output file.
                            fs.writeFile(outputPath, newContent, 'utf8', function(err) {
                                // Return result.
                                callback(err? ("The output file could not be writted: " + err) : null, !err);
                            });
                        } else {
                            // Return an error.
                            callback("The input file could not be read: " + err, false);
                        }
                    });
                } else {
                    // Return an error indicating that the file doens't exists.
                    callback("The input file does not exists", false);
                }            
            });
        } catch(err) {
            // Return an error.
            callback('An unexpected error ocurred: ' + err, false);
        }
    }
}

// Export module.
module.exports = SpellChecker;

/* WEBPACK VAR INJECTION */}.call(this, "src/node_modules/simple-spellchecker"))

/***/ }),

/***/ "./src/node_modules/string-width/index.js":
/*!************************************************!*\
  !*** ./src/node_modules/string-width/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var stripAnsi = __webpack_require__(/*! strip-ansi */ "./src/node_modules/strip-ansi/index.js");
var codePointAt = __webpack_require__(/*! code-point-at */ "./src/node_modules/code-point-at/index.js");
var isFullwidthCodePoint = __webpack_require__(/*! is-fullwidth-code-point */ "./src/node_modules/is-fullwidth-code-point/index.js");

// https://github.com/nodejs/io.js/blob/cff7300a578be1b10001f2d967aaedc88aee6402/lib/readline.js#L1345
module.exports = function (str) {
	if (typeof str !== 'string' || str.length === 0) {
		return 0;
	}

	var width = 0;

	str = stripAnsi(str);

	for (var i = 0; i < str.length; i++) {
		var code = codePointAt(str, i);

		// ignore control characters
		if (code <= 0x1f || (code >= 0x7f && code <= 0x9f)) {
			continue;
		}

		// surrogates
		if (code >= 0x10000) {
			i++;
		}

		if (isFullwidthCodePoint(code)) {
			width += 2;
		} else {
			width++;
		}
	}

	return width;
};


/***/ }),

/***/ "./src/node_modules/strip-ansi/index.js":
/*!**********************************************!*\
  !*** ./src/node_modules/strip-ansi/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ansiRegex = __webpack_require__(/*! ansi-regex */ "./src/node_modules/ansi-regex/index.js")();

module.exports = function (str) {
	return typeof str === 'string' ? str.replace(ansiRegex, '') : str;
};


/***/ }),

/***/ "./src/node_modules/strip-bom/index.js":
/*!*********************************************!*\
  !*** ./src/node_modules/strip-bom/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var isUtf8 = __webpack_require__(/*! is-utf8 */ "./src/node_modules/is-utf8/is-utf8.js");

module.exports = function (x) {
	// Catches EFBBBF (UTF-8 BOM) because the buffer-to-string
	// conversion translates it to FEFF (UTF-16 BOM)
	if (typeof x === 'string' && x.charCodeAt(0) === 0xFEFF) {
		return x.slice(1);
	}

	if (Buffer.isBuffer(x) && isUtf8(x) &&
		x[0] === 0xEF && x[1] === 0xBB && x[2] === 0xBF) {
		return x.slice(3);
	}

	return x;
};


/***/ }),

/***/ "./src/node_modules/traverse/index.js":
/*!********************************************!*\
  !*** ./src/node_modules/traverse/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = Traverse;
function Traverse (obj) {
    if (!(this instanceof Traverse)) return new Traverse(obj);
    this.value = obj;
}

Traverse.prototype.get = function (ps) {
    var node = this.value;
    for (var i = 0; i < ps.length; i ++) {
        var key = ps[i];
        if (!Object.hasOwnProperty.call(node, key)) {
            node = undefined;
            break;
        }
        node = node[key];
    }
    return node;
};

Traverse.prototype.set = function (ps, value) {
    var node = this.value;
    for (var i = 0; i < ps.length - 1; i ++) {
        var key = ps[i];
        if (!Object.hasOwnProperty.call(node, key)) node[key] = {};
        node = node[key];
    }
    node[ps[i]] = value;
    return value;
};

Traverse.prototype.map = function (cb) {
    return walk(this.value, cb, true);
};

Traverse.prototype.forEach = function (cb) {
    this.value = walk(this.value, cb, false);
    return this.value;
};

Traverse.prototype.reduce = function (cb, init) {
    var skip = arguments.length === 1;
    var acc = skip ? this.value : init;
    this.forEach(function (x) {
        if (!this.isRoot || !skip) {
            acc = cb.call(this, acc, x);
        }
    });
    return acc;
};

Traverse.prototype.deepEqual = function (obj) {
    if (arguments.length !== 1) {
        throw new Error(
            'deepEqual requires exactly one object to compare against'
        );
    }

    var equal = true;
    var node = obj;

    this.forEach(function (y) {
        var notEqual = (function () {
            equal = false;
            //this.stop();
            return undefined;
        }).bind(this);

        //if (node === undefined || node === null) return notEqual();

        if (!this.isRoot) {
        /*
            if (!Object.hasOwnProperty.call(node, this.key)) {
                return notEqual();
            }
        */
            if (typeof node !== 'object') return notEqual();
            node = node[this.key];
        }

        var x = node;

        this.post(function () {
            node = x;
        });

        var toS = function (o) {
            return Object.prototype.toString.call(o);
        };

        if (this.circular) {
            if (Traverse(obj).get(this.circular.path) !== x) notEqual();
        }
        else if (typeof x !== typeof y) {
            notEqual();
        }
        else if (x === null || y === null || x === undefined || y === undefined) {
            if (x !== y) notEqual();
        }
        else if (x.__proto__ !== y.__proto__) {
            notEqual();
        }
        else if (x === y) {
            // nop
        }
        else if (typeof x === 'function') {
            if (x instanceof RegExp) {
                // both regexps on account of the __proto__ check
                if (x.toString() != y.toString()) notEqual();
            }
            else if (x !== y) notEqual();
        }
        else if (typeof x === 'object') {
            if (toS(y) === '[object Arguments]'
            || toS(x) === '[object Arguments]') {
                if (toS(x) !== toS(y)) {
                    notEqual();
                }
            }
            else if (x instanceof Date || y instanceof Date) {
                if (!(x instanceof Date) || !(y instanceof Date)
                || x.getTime() !== y.getTime()) {
                    notEqual();
                }
            }
            else {
                var kx = Object.keys(x);
                var ky = Object.keys(y);
                if (kx.length !== ky.length) return notEqual();
                for (var i = 0; i < kx.length; i++) {
                    var k = kx[i];
                    if (!Object.hasOwnProperty.call(y, k)) {
                        notEqual();
                    }
                }
            }
        }
    });

    return equal;
};

Traverse.prototype.paths = function () {
    var acc = [];
    this.forEach(function (x) {
        acc.push(this.path);
    });
    return acc;
};

Traverse.prototype.nodes = function () {
    var acc = [];
    this.forEach(function (x) {
        acc.push(this.node);
    });
    return acc;
};

Traverse.prototype.clone = function () {
    var parents = [], nodes = [];

    return (function clone (src) {
        for (var i = 0; i < parents.length; i++) {
            if (parents[i] === src) {
                return nodes[i];
            }
        }

        if (typeof src === 'object' && src !== null) {
            var dst = copy(src);

            parents.push(src);
            nodes.push(dst);

            Object.keys(src).forEach(function (key) {
                dst[key] = clone(src[key]);
            });

            parents.pop();
            nodes.pop();
            return dst;
        }
        else {
            return src;
        }
    })(this.value);
};

function walk (root, cb, immutable) {
    var path = [];
    var parents = [];
    var alive = true;

    return (function walker (node_) {
        var node = immutable ? copy(node_) : node_;
        var modifiers = {};

        var state = {
            node : node,
            node_ : node_,
            path : [].concat(path),
            parent : parents.slice(-1)[0],
            key : path.slice(-1)[0],
            isRoot : path.length === 0,
            level : path.length,
            circular : null,
            update : function (x) {
                if (!state.isRoot) {
                    state.parent.node[state.key] = x;
                }
                state.node = x;
            },
            'delete' : function () {
                delete state.parent.node[state.key];
            },
            remove : function () {
                if (Array.isArray(state.parent.node)) {
                    state.parent.node.splice(state.key, 1);
                }
                else {
                    delete state.parent.node[state.key];
                }
            },
            before : function (f) { modifiers.before = f },
            after : function (f) { modifiers.after = f },
            pre : function (f) { modifiers.pre = f },
            post : function (f) { modifiers.post = f },
            stop : function () { alive = false }
        };

        if (!alive) return state;

        if (typeof node === 'object' && node !== null) {
            state.isLeaf = Object.keys(node).length == 0;

            for (var i = 0; i < parents.length; i++) {
                if (parents[i].node_ === node_) {
                    state.circular = parents[i];
                    break;
                }
            }
        }
        else {
            state.isLeaf = true;
        }

        state.notLeaf = !state.isLeaf;
        state.notRoot = !state.isRoot;

        // use return values to update if defined
        var ret = cb.call(state, state.node);
        if (ret !== undefined && state.update) state.update(ret);
        if (modifiers.before) modifiers.before.call(state, state.node);

        if (typeof state.node == 'object'
        && state.node !== null && !state.circular) {
            parents.push(state);

            var keys = Object.keys(state.node);
            keys.forEach(function (key, i) {
                path.push(key);

                if (modifiers.pre) modifiers.pre.call(state, state.node[key], key);

                var child = walker(state.node[key]);
                if (immutable && Object.hasOwnProperty.call(state.node, key)) {
                    state.node[key] = child.node;
                }

                child.isLast = i == keys.length - 1;
                child.isFirst = i == 0;

                if (modifiers.post) modifiers.post.call(state, child);

                path.pop();
            });
            parents.pop();
        }

        if (modifiers.after) modifiers.after.call(state, state.node);

        return state;
    })(root).node;
}

Object.keys(Traverse.prototype).forEach(function (key) {
    Traverse[key] = function (obj) {
        var args = [].slice.call(arguments, 1);
        var t = Traverse(obj);
        return t[key].apply(t, args);
    };
});

function copy (src) {
    if (typeof src === 'object' && src !== null) {
        var dst;

        if (Array.isArray(src)) {
            dst = [];
        }
        else if (src instanceof Date) {
            dst = new Date(src);
        }
        else if (src instanceof Boolean) {
            dst = new Boolean(src);
        }
        else if (src instanceof Number) {
            dst = new Number(src);
        }
        else if (src instanceof String) {
            dst = new String(src);
        }
        else {
            dst = Object.create(Object.getPrototypeOf(src));
        }

        Object.keys(src).forEach(function (key) {
            dst[key] = src[key];
        });
        return dst;
    }
    else return src;
}


/***/ }),

/***/ "./src/node_modules/untildify/index.js":
/*!*********************************************!*\
  !*** ./src/node_modules/untildify/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const home = __webpack_require__(/*! os */ "os").homedir();

module.exports = str => {
	if (typeof str !== 'string') {
		throw new TypeError(`Expected a string, got ${typeof str}`);
	}

	return home ? str.replace(/^~(?=$|\/|\\)/, home) : str;
};


/***/ }),

/***/ "./src/node_modules/unzip-stream/lib/entry.js":
/*!****************************************************!*\
  !*** ./src/node_modules/unzip-stream/lib/entry.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var stream = __webpack_require__(/*! stream */ "stream");
var inherits = __webpack_require__(/*! util */ "util").inherits;

function Entry() {
    if (!(this instanceof Entry)) {
        return new Entry();
    }

    stream.PassThrough.call(this);

    this.path = null;
    this.type = null;
    this.isDirectory = false;
}

inherits(Entry, stream.PassThrough);

Entry.prototype.autodrain = function () {
    return this.pipe(new stream.Transform({ transform: function (d, e, cb) { cb(); } }));
}

module.exports = Entry;

/***/ }),

/***/ "./src/node_modules/unzip-stream/lib/extract.js":
/*!******************************************************!*\
  !*** ./src/node_modules/unzip-stream/lib/extract.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var fs = __webpack_require__(/*! fs */ "fs");
var path = __webpack_require__(/*! path */ "path");
var util = __webpack_require__(/*! util */ "util");
var mkdirp = __webpack_require__(/*! mkdirp */ "./src/node_modules/mkdirp/index.js");
var Transform = __webpack_require__(/*! stream */ "stream").Transform;
var UnzipStream = __webpack_require__(/*! ./unzip-stream */ "./src/node_modules/unzip-stream/lib/unzip-stream.js");

function Extract (opts) {
    if (!(this instanceof Extract))
    return new Extract(opts);

    Transform.call(this);

    this.opts = opts || {};
    this.unzipStream = new UnzipStream();
    this.unfinishedEntries = 0;
    this.afterFlushWait = false;
    this.createdDirectories = {};

    var self = this;
    this.unzipStream.on('entry', this._processEntry.bind(this));
    this.unzipStream.on('error', function(error) {
        self.emit('error', error);
    });
}

util.inherits(Extract, Transform);

Extract.prototype._transform = function (chunk, encoding, cb) {
    this.unzipStream.write(chunk, encoding, cb);
}

Extract.prototype._flush = function (cb) {
    var self = this;

    var allDone = function() {
        process.nextTick(function() { self.emit('close'); });
        cb();
    }

    this.unzipStream.end(function() {
        if (self.unfinishedEntries > 0) {
            self.afterFlushWait = true;
            return self.on('await-finished', allDone);
        }
        allDone();
    });
}

Extract.prototype._processEntry = function (entry) {
    var self = this;
    var destPath = path.join(this.opts.path, entry.path);
    var directory = entry.isDirectory ? destPath : path.dirname(destPath);

    this.unfinishedEntries++;

    var writeFileFn = function() {
        var pipedStream = fs.createWriteStream(destPath);

        pipedStream.on('close', function() {
            self.unfinishedEntries--;
            self._notifyAwaiter();
        });
        pipedStream.on('error', function (error) {
            self.emit('error', error);
        });
        entry.pipe(pipedStream);
    }

    if (this.createdDirectories[directory] || directory === '.') {
        return writeFileFn();
    }

    // FIXME: calls to mkdirp can still be duplicated
    mkdirp(directory, function(err) {
        if (err) return self.emit('error', err);

        self.createdDirectories[directory] = true;

        if (entry.isDirectory) {
            self.unfinishedEntries--;
            self._notifyAwaiter();
            return;
        }

        writeFileFn();
    });
}

Extract.prototype._notifyAwaiter = function() {
    if (this.afterFlushWait && this.unfinishedEntries === 0) {
        this.emit('await-finished');
        this.afterFlushWait = false;
    }
}

module.exports = Extract;

/***/ }),

/***/ "./src/node_modules/unzip-stream/lib/matcher-stream.js":
/*!*************************************************************!*\
  !*** ./src/node_modules/unzip-stream/lib/matcher-stream.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Transform = __webpack_require__(/*! stream */ "stream").Transform;
var util = __webpack_require__(/*! util */ "util");

function MatcherStream(patternDesc, matchFn) {
    if (!(this instanceof MatcherStream)) {
        return new MatcherStream();
    }

    Transform.call(this);

    var p = typeof patternDesc === 'object' ? patternDesc.pattern : patternDesc;

    this.pattern = Buffer.isBuffer(p) ? p : Buffer.from(p);
    this.requiredLength = this.pattern.length;
    if (patternDesc.requiredExtraSize) this.requiredLength += patternDesc.requiredExtraSize;

    this.data = new Buffer('');
    this.bytesSoFar = 0;

    this.matchFn = matchFn;
}

util.inherits(MatcherStream, Transform);

MatcherStream.prototype.checkDataChunk = function (ignoreMatchZero) {
    var enoughData = this.data.length >= this.requiredLength; // strict more than ?
    if (!enoughData) { return; }

    var matchIndex = this.data.indexOf(this.pattern, ignoreMatchZero ? 1 : 0);
    if (matchIndex >= 0 && matchIndex + this.requiredLength > this.data.length) {
        if (matchIndex > 0) {
            var packet = this.data.slice(0, matchIndex);
            this.push(packet);
            this.bytesSoFar += matchIndex;
            this.data = this.data.slice(matchIndex);
        }
        return;
    }

    if (matchIndex === -1) {
        var packetLen = this.data.length - this.requiredLength + 1;

        var packet = this.data.slice(0, packetLen);
        this.push(packet);
        this.bytesSoFar += packetLen;
        this.data = this.data.slice(packetLen);
        return;
    }

    // found match
    if (matchIndex > 0) {
        var packet = this.data.slice(0, matchIndex);
        this.data = this.data.slice(matchIndex);
        this.push(packet);
        this.bytesSoFar += matchIndex;
    }

    var finished = this.matchFn ? this.matchFn(this.data, this.bytesSoFar) : true;
    if (finished) {
        this.data = new Buffer('');
        return;
    }

    return true;
}

MatcherStream.prototype._transform = function (chunk, encoding, cb) {
    this.data = Buffer.concat([this.data, chunk]);

    var firstIteration = true;
    while (this.checkDataChunk(!firstIteration)) {
        firstIteration = false;
    }

    cb();
}

MatcherStream.prototype._flush = function (cb) {
    if (this.data.length > 0) {
        var firstIteration = true;
        while (this.checkDataChunk(!firstIteration)) {
            firstIteration = false;
        }
    }

    if (this.data.length > 0) {
        this.push(this.data);
        this.data = null;
    }

    cb();
}

module.exports = MatcherStream;

/***/ }),

/***/ "./src/node_modules/unzip-stream/lib/parser-stream.js":
/*!************************************************************!*\
  !*** ./src/node_modules/unzip-stream/lib/parser-stream.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Transform = __webpack_require__(/*! stream */ "stream").Transform;
var util = __webpack_require__(/*! util */ "util");
var UnzipStream = __webpack_require__(/*! ./unzip-stream */ "./src/node_modules/unzip-stream/lib/unzip-stream.js");

function ParserStream(opts) {
    if (!(this instanceof ParserStream)) {
        return new ParserStream(opts);
    }

    var transformOpts = opts || {};
    Transform.call(this, { readableObjectMode: true });

    this.opts = opts || {};
    this.unzipStream = new UnzipStream(this.opts);

    var self = this;
    this.unzipStream.on('entry', function(entry) {
        self.push(entry);
    });
    this.unzipStream.on('error', function(error) {
        self.emit('error', error);
    });
}

util.inherits(ParserStream, Transform);

ParserStream.prototype._transform = function (chunk, encoding, cb) {
    this.unzipStream.write(chunk, encoding, cb);
}

ParserStream.prototype._flush = function (cb) {
    var self = this;
    this.unzipStream.end(function() {
        process.nextTick(function() { self.emit('close'); });
        cb();
    });
}

ParserStream.prototype.on = function(eventName, fn) {
    if (eventName === 'entry') {
        return Transform.prototype.on.call(this, 'data', fn);
    }
    return Transform.prototype.on.call(this, eventName, fn);
}

ParserStream.prototype.drainAll = function () {
    this.unzipStream.drainAll();
    return this.pipe(new Transform({ objectMode: true, transform: function (d, e, cb) { cb(); } }));
}

module.exports = ParserStream;


/***/ }),

/***/ "./src/node_modules/unzip-stream/lib/unzip-stream.js":
/*!***********************************************************!*\
  !*** ./src/node_modules/unzip-stream/lib/unzip-stream.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var binary = __webpack_require__(/*! binary */ "./src/node_modules/binary/index.js");
var stream = __webpack_require__(/*! stream */ "stream");
var util = __webpack_require__(/*! util */ "util");
var zlib = __webpack_require__(/*! zlib */ "zlib");
var MatcherStream = __webpack_require__(/*! ./matcher-stream */ "./src/node_modules/unzip-stream/lib/matcher-stream.js");
var Entry = __webpack_require__(/*! ./entry */ "./src/node_modules/unzip-stream/lib/entry.js");

const states = {
    STREAM_START:                         0,
    START:                                1,
    LOCAL_FILE_HEADER:                    2,
    LOCAL_FILE_HEADER_SUFFIX:             3,
    FILE_DATA:                            4,
    FILE_DATA_END:                        5,
    DATA_DESCRIPTOR:                      6,
    CENTRAL_DIRECTORY_FILE_HEADER:        7,
    CENTRAL_DIRECTORY_FILE_HEADER_SUFFIX: 8,
    CDIR64_END:                           9,
    CDIR64_END_DATA_SECTOR:               10,
    CDIR64_LOCATOR:                       11,
    CENTRAL_DIRECTORY_END:                12,
    CENTRAL_DIRECTORY_END_COMMENT:        13,
    TRAILING_JUNK:                        14,

    ERROR: 99
}

const FOUR_GIGS = 4294967296;

const SIG_LOCAL_FILE_HEADER  = 0x04034b50;
const SIG_DATA_DESCRIPTOR    = 0x08074b50;
const SIG_CDIR_RECORD        = 0x02014b50;
const SIG_CDIR64_RECORD_END  = 0x06064b50;
const SIG_CDIR64_LOCATOR_END = 0x07064b50;
const SIG_CDIR_RECORD_END    = 0x06054b50;

function UnzipStream(options) {
    if (!(this instanceof UnzipStream)) {
        return new UnzipStream(options);
    }

    stream.Transform.call(this);

    this.options = options || {};
    this.data = new Buffer('');
    this.state = states.STREAM_START;
    this.skippedBytes = 0;
    this.parsedEntity = null;
    this.outStreamInfo = {};
}

util.inherits(UnzipStream, stream.Transform);

UnzipStream.prototype.processDataChunk = function (chunk) {
    var requiredLength;

    switch (this.state) {
        case states.STREAM_START:
        case states.START:
            requiredLength = 4;
            break;
        case states.LOCAL_FILE_HEADER:
            requiredLength = 26;
            break;
        case states.LOCAL_FILE_HEADER_SUFFIX:
            requiredLength = this.parsedEntity.fileNameLength + this.parsedEntity.extraFieldLength;
            break;
        case states.DATA_DESCRIPTOR:
            requiredLength = 12;
            break;
        case states.CENTRAL_DIRECTORY_FILE_HEADER:
            requiredLength = 42;
            break;
        case states.CENTRAL_DIRECTORY_FILE_HEADER_SUFFIX:
            requiredLength = this.parsedEntity.fileNameLength + this.parsedEntity.extraFieldLength + this.parsedEntity.fileCommentLength;
            break;
        case states.CDIR64_END:
            requiredLength = 52;
            break;
        case states.CDIR64_END_DATA_SECTOR:
            requiredLength = this.parsedEntity.centralDirectoryRecordSize - 44;
            break;
        case states.CDIR64_LOCATOR:
            requiredLength = 16;
            break;
        case states.CENTRAL_DIRECTORY_END:
            requiredLength = 18;
            break;
        case states.CENTRAL_DIRECTORY_END_COMMENT:
            requiredLength = this.parsedEntity.commentLength;
            break;
        case states.FILE_DATA:
            return 0;
        case states.FILE_DATA_END:
            return 0;
        case states.TRAILING_JUNK:
            if (this.options.debug) console.log("found", chunk.length, "bytes of TRAILING_JUNK");
            return chunk.length;
        default:
            return chunk.length;
    }

    var chunkLength = chunk.length;
    if (chunkLength < requiredLength) {
        return 0;
    }

    switch (this.state) {
        case states.STREAM_START:
        case states.START:
            var signature = chunk.readUInt32LE(0);
            switch (signature) {
                case SIG_LOCAL_FILE_HEADER:
                    this.state = states.LOCAL_FILE_HEADER;
                    break;
                case SIG_CDIR_RECORD:
                    this.state = states.CENTRAL_DIRECTORY_FILE_HEADER;
                    break;
                case SIG_CDIR64_RECORD_END:
                    this.state = states.CDIR64_END;
                    break;
                case SIG_CDIR64_LOCATOR_END:
                    this.state = states.CDIR64_LOCATOR;
                    break;
                case SIG_CDIR_RECORD_END:
                    this.state = states.CENTRAL_DIRECTORY_END;
                    break;
                default:
                    var isStreamStart = this.state === states.STREAM_START;
                    if (!isStreamStart && (signature & 0xffff) !== 0x4b50 && this.skippedBytes < 26) {
                        // we'll allow a padding of max 28 bytes
                        var remaining = signature;
                        var toSkip = 4;
                        for (var i = 1; i < 4 && remaining !== 0; i++) {
                            remaining = remaining >>> 8;
                            if ((remaining & 0xff) === 0x50) {
                                toSkip = i;
                                break;
                            }
                        }
                        this.skippedBytes += toSkip;
                        if (this.options.debug) console.log('Skipped', this.skippedBytes, 'bytes');
                        return toSkip;
                    }
                    this.state = states.ERROR;
                    var errMsg = isStreamStart ? "Not a valid zip file" : "Invalid signature in zip file";
                    if (this.options.debug) {
                        var sig = chunk.readUInt32LE(0);
                        var asString;
                        try { asString = chunk.slice(0, 4).toString(); } catch (e) {}
                        console.log("Unexpected signature in zip file: 0x" + sig.toString(16), '"' + asString + '", skipped', this.skippedBytes, 'bytes');
                    }
                    this.emit("error", new Error(errMsg));
                    return chunk.length;
            }
            this.skippedBytes = 0;
            return requiredLength;

        case states.LOCAL_FILE_HEADER:
            this.parsedEntity = this._readFile(chunk);
            this.state = states.LOCAL_FILE_HEADER_SUFFIX;

            return requiredLength;

        case states.LOCAL_FILE_HEADER_SUFFIX:
            var entry = new Entry();
            var isUtf8 = (this.parsedEntity.flags & 0x800) !== 0;
            entry.path = this._decodeString(chunk.slice(0, this.parsedEntity.fileNameLength), isUtf8);
            var extraDataBuffer = chunk.slice(this.parsedEntity.fileNameLength, this.parsedEntity.fileNameLength + this.parsedEntity.extraFieldLength);
            var extra = this._readExtraFields(extraDataBuffer);
            if (extra && extra.parsed) {
                if (extra.parsed.path && !isUtf8) {
                    entry.path = extra.parsed.path;
                }
                if (Number.isFinite(extra.parsed.uncompressedSize) && this.parsedEntity.uncompressedSize === FOUR_GIGS-1) {
                    this.parsedEntity.uncompressedSize = extra.parsed.uncompressedSize;
                }
                if (Number.isFinite(extra.parsed.compressedSize) && this.parsedEntity.compressedSize === FOUR_GIGS-1) {
                    this.parsedEntity.compressedSize = extra.parsed.compressedSize;
                }
            }
            this.parsedEntity.extra = extra.parsed || {};

            if (this.options.debug) {
                const debugObj = Object.assign({}, this.parsedEntity, {
                    path: entry.path,
                    flags: '0x' + this.parsedEntity.flags.toString(16),
                    extraFields: extra && extra.debug
                });
                console.log("decoded LOCAL_FILE_HEADER:", JSON.stringify(debugObj, null, 2));
            }
            this._prepareOutStream(this.parsedEntity, entry);

            this.emit("entry", entry);

            this.state = states.FILE_DATA;

            return requiredLength;

        case states.CENTRAL_DIRECTORY_FILE_HEADER:
            this.parsedEntity = this._readCentralDirectoryEntry(chunk);
            this.state = states.CENTRAL_DIRECTORY_FILE_HEADER_SUFFIX;

            return requiredLength;

        case states.CENTRAL_DIRECTORY_FILE_HEADER_SUFFIX:
            // got file name in chunk[0..]
            var isUtf8 = (this.parsedEntity.flags & 0x800) !== 0;
            var path = this._decodeString(chunk.slice(0, this.parsedEntity.fileNameLength), isUtf8);
            var extraDataBuffer = chunk.slice(this.parsedEntity.fileNameLength, this.parsedEntity.fileNameLength + this.parsedEntity.extraFieldLength);
            var extra = this._readExtraFields(extraDataBuffer);
            if (extra && extra.parsed && extra.parsed.path && !isUtf8) {
                path = extra.parsed.path;
            }
            this.parsedEntity.extra = extra.parsed;

            var isUnix = ((this.parsedEntity.versionMadeBy & 0xff00) >> 8) === 3;
            var unixAttrs, isSymlink;
            if (isUnix) {
                unixAttrs = this.parsedEntity.externalFileAttributes >>> 16;
                var fileType = unixAttrs >>> 12;
                isSymlink = (fileType & 0o12) === 0o12; // __S_IFLNK
            }
            if (this.options.debug) {
                const debugObj = Object.assign({}, this.parsedEntity, {
                    path: path,
                    flags: '0x' + this.parsedEntity.flags.toString(16),
                    unixAttrs: unixAttrs && '0' + unixAttrs.toString(8),
                    isSymlink: isSymlink,
                    extraFields: extra.debug,
                });
                console.log("decoded CENTRAL_DIRECTORY_FILE_HEADER:", JSON.stringify(debugObj, null, 2));
            }
            this.state = states.START;

            return requiredLength;

        case states.CDIR64_END:
            this.parsedEntity = this._readEndOfCentralDirectory64(chunk);
            if (this.options.debug) {
                console.log("decoded CDIR64_END_RECORD:", this.parsedEntity);
            }
            this.state = states.CDIR64_END_DATA_SECTOR;

            return requiredLength;

        case states.CDIR64_END_DATA_SECTOR:
            this.state = states.START;

            return requiredLength;

        case states.CDIR64_LOCATOR:
            // ignore, nothing interesting
            this.state = states.START;

            return requiredLength;

        case states.CENTRAL_DIRECTORY_END:
            this.parsedEntity = this._readEndOfCentralDirectory(chunk);
            if (this.options.debug) {
                console.log("decoded CENTRAL_DIRECTORY_END:", this.parsedEntity);
            }
            this.state = states.CENTRAL_DIRECTORY_END_COMMENT;

            return requiredLength;

        case states.CENTRAL_DIRECTORY_END_COMMENT:
            if (this.options.debug) {
                console.log("decoded CENTRAL_DIRECTORY_END_COMMENT:", chunk.slice(0, requiredLength).toString());
            }
            this.state = states.TRAILING_JUNK;

            return requiredLength;

        case states.ERROR:
            return chunk.length; // discard

        default:
            console.log("didn't handle state #", this.state, "discarding");
            return chunk.length;
    }
}

UnzipStream.prototype._prepareOutStream = function (vars, entry) {
    var self = this;

    var isDirectory = vars.uncompressedSize === 0 && /[\/\\]$/.test(entry.path);
    // protect against malicious zip files which want to extract to parent dirs
    entry.path = entry.path.replace(/^([/\\]*[.]+[/\\]+)*[/\\]*/, "");
    entry.type = isDirectory ? 'Directory' : 'File';
    entry.isDirectory = isDirectory;

    var fileSizeKnown = !(vars.flags & 0x08);
    if (fileSizeKnown) {
        entry.size = vars.uncompressedSize;
    }

    var isVersionSupported = vars.versionsNeededToExtract <= 45;

    this.outStreamInfo = {
        stream: null,
        limit: fileSizeKnown ? vars.compressedSize : -1,
        written: 0
    };

    if (!fileSizeKnown) {
        var pattern = new Buffer(4);
        pattern.writeUInt32LE(SIG_DATA_DESCRIPTOR, 0);
        var zip64Mode = vars.extra.zip64Mode;
        var extraSize = zip64Mode ? 20 : 12;
        var searchPattern = {
            pattern: pattern,
            requiredExtraSize: extraSize
        }

        var matcherStream = new MatcherStream(searchPattern, function (matchedChunk, sizeSoFar) {
            var vars = self._readDataDescriptor(matchedChunk, zip64Mode);

            var compressedSizeMatches = vars.compressedSize === sizeSoFar;
            // let's also deal with archives with 4GiB+ files without zip64
            if (!zip64Mode && !compressedSizeMatches && sizeSoFar >= FOUR_GIGS) {
                var overflown = sizeSoFar - FOUR_GIGS;
                while (overflown >= 0) {
                    compressedSizeMatches = vars.compressedSize === overflown;
                    if (compressedSizeMatches) break;
                    overflown -= FOUR_GIGS;
                }
            }
            if (!compressedSizeMatches) { return; }

            self.state = states.FILE_DATA_END;
            var sliceOffset = zip64Mode ? 24 : 16;
            if (self.data.length > 0) {
                self.data = Buffer.concat([matchedChunk.slice(sliceOffset), self.data]);
            } else {
                self.data = matchedChunk.slice(sliceOffset);
            }

            return true;
        });
        this.outStreamInfo.stream = matcherStream;
    } else {
        this.outStreamInfo.stream = new stream.PassThrough();
    }

    var isEncrypted = (vars.flags & 0x01) || (vars.flags & 0x40);
    if (isEncrypted || !isVersionSupported) {
        var message = isEncrypted ? "Encrypted files are not supported!"
            : ("Zip version " + Math.floor(vars.versionsNeededToExtract / 10) + "." + vars.versionsNeededToExtract % 10 + " is not supported");

        entry.skip = true;
        setImmediate(() => {
            entry.emit("error", new Error(message));
        });

        // try to skip over this entry
        this.outStreamInfo.stream.pipe(new Entry().autodrain());
        return;
    }

    var isCompressed = vars.compressionMethod > 0;
    if (isCompressed) {
        var inflater = zlib.createInflateRaw();
        inflater.on('error', function (err) {
            self.state = states.ERROR;
            self.emit('error', err);
        });
        this.outStreamInfo.stream.pipe(inflater).pipe(entry);
    } else {
        this.outStreamInfo.stream.pipe(entry);
    }

    if (this._drainAllEntries) {
        entry.autodrain();
    }
}

UnzipStream.prototype._readFile = function (data) {
    var vars = binary.parse(data)
        .word16lu('versionsNeededToExtract')
        .word16lu('flags')
        .word16lu('compressionMethod')
        .word16lu('lastModifiedTime')
        .word16lu('lastModifiedDate')
        .word32lu('crc32')
        .word32lu('compressedSize')
        .word32lu('uncompressedSize')
        .word16lu('fileNameLength')
        .word16lu('extraFieldLength')
        .vars;

    return vars;
}

UnzipStream.prototype._readExtraFields = function (data) {
    var extra = {};
    var result = { parsed: extra };
    if (this.options.debug) {
        result.debug = [];
    }
    var index = 0;
    while (index < data.length) {
        var vars = binary.parse(data)
            .skip(index)
            .word16lu('extraId')
            .word16lu('extraSize')
            .vars;

        index += 4;

        var fieldType = undefined;
        switch (vars.extraId) {
            case 0x0001:
                fieldType = "Zip64 extended information extra field";
                var z64vars = binary.parse(data.slice(index, index+vars.extraSize))
                    .word64lu('uncompressedSize')
                    .word64lu('compressedSize')
                    .word64lu('offsetToLocalHeader')
                    .word32lu('diskStartNumber')
                    .vars;
                if (z64vars.uncompressedSize !== null) {
                    extra.uncompressedSize = z64vars.uncompressedSize;
                }
                if (z64vars.compressedSize !== null) {
                    extra.compressedSize = z64vars.compressedSize;
                }
                extra.zip64Mode = true;
                break;
            case 0x000a:
                fieldType = "NTFS extra field";
                break;
            case 0x5455:
                fieldType = "extended timestamp";
                var timestampFields = data.readUInt8(index);
                var offset = 1;
                if (timestampFields & 1) {
                    extra.mtime = new Date(data.readUInt32LE(index + offset) * 1000);
                    offset += 4;
                }
                if (timestampFields & 2) {
                    extra.atime = new Date(data.readUInt32LE(index + offset) * 1000);
                    offset += 4;
                }
                if (timestampFields & 4) {
                    extra.ctime = new Date(data.readUInt32LE(index + offset) * 1000);
                }
                break;
            case 0x7075:
                fieldType = "Info-ZIP Unicode Path Extra Field";
                var fieldVer = data.readUInt8(index);
                if (fieldVer === 1) {
                    var offset = 1;
                    // TODO: should be checking this against our path buffer
                    var nameCrc32 = data.readUInt32LE(index + offset);
                    offset += 4;
                    var pathBuffer = data.slice(index + offset);
                    extra.path = pathBuffer.toString();
                }
                break;
            case 0x000d:
            case 0x5855:
                fieldType = vars.extraId === 0x000d ? "PKWARE Unix" : "Info-ZIP UNIX (type 1)";
                var offset = 0;
                if (vars.extraSize >= 8) {
                    var atime = new Date(data.readUInt32LE(index + offset) * 1000);
                    offset += 4;
                    var mtime = new Date(data.readUInt32LE(index + offset) * 1000);
                    offset += 4;
                    extra.atime = atime;
                    extra.mtime = mtime;

                    if (vars.extraSize >= 12) {
                        var uid = data.readUInt16LE(index + offset);
                        offset += 2;
                        var gid = data.readUInt16LE(index + offset);
                        offset += 2;
                        extra.uid = uid;
                        extra.gid = gid;
                    }
                }
                break;
            case 0x7855:
                fieldType = "Info-ZIP UNIX (type 2)";
                var offset = 0;
                if (vars.extraSize >= 4) {
                    var uid = data.readUInt16LE(index + offset);
                    offset += 2;
                    var gid = data.readUInt16LE(index + offset);
                    offset += 2;
                    extra.uid = uid;
                    extra.gid = gid;
                }
                break;
            case 0x7875:
                fieldType = "Info-ZIP New Unix";
                var offset = 0;
                var extraVer = data.readUInt8(index);
                offset += 1;
                if (extraVer === 1) {
                    var uidSize = data.readUInt8(index + offset);
                    offset += 1;
                    if (uidSize <= 6) {
                        extra.uid = data.readUIntLE(index + offset, uidSize);
                    }
                    offset += uidSize;

                    var gidSize = data.readUInt8(index + offset);
                    offset += 1;
                    if (gidSize <= 6) {
                        extra.gid = data.readUIntLE(index + offset, gidSize);
                    }
                }
                break;
            case 0x756e:
                fieldType = "ASi Unix";
                var offset = 0;
                if (vars.extraSize >= 14) {
                    var crc = data.readUInt32LE(index + offset);
                    offset += 4;
                    var mode = data.readUInt16LE(index + offset);
                    offset += 2;
                    var sizdev = data.readUInt32LE(index + offset);
                    offset += 4;
                    var uid = data.readUInt16LE(index + offset);
                    offset += 2;
                    var gid = data.readUInt16LE(index + offset);
                    offset += 2;
                    extra.mode = mode;
                    extra.uid = uid;
                    extra.gid = gid;
                    if (vars.extraSize > 14) {
                        var start = index + offset;
                        var end = index + vars.extraSize - 14;
                        var symlinkName = this._decodeString(data.slice(start, end));
                        extra.symlink = symlinkName;
                    }
                }
                break;
        }

        if (this.options.debug) {
            result.debug.push({
                extraId: '0x' + vars.extraId.toString(16),
                description: fieldType,
                data: data.slice(index, index + vars.extraSize).inspect()
            });
        }

        index += vars.extraSize;
    }

    return result;
}

UnzipStream.prototype._readDataDescriptor = function (data, zip64Mode) {
    if (zip64Mode) {
        var vars = binary.parse(data)
            .word32lu('dataDescriptorSignature')
            .word32lu('crc32')
            .word64lu('compressedSize')
            .word64lu('uncompressedSize')
            .vars;

        return vars;
    }

    var vars = binary.parse(data)
        .word32lu('dataDescriptorSignature')
        .word32lu('crc32')
        .word32lu('compressedSize')
        .word32lu('uncompressedSize')
        .vars;

    return vars;
}

UnzipStream.prototype._readCentralDirectoryEntry = function (data) {
    var vars = binary.parse(data)
        .word16lu('versionMadeBy')
        .word16lu('versionsNeededToExtract')
        .word16lu('flags')
        .word16lu('compressionMethod')
        .word16lu('lastModifiedTime')
        .word16lu('lastModifiedDate')
        .word32lu('crc32')
        .word32lu('compressedSize')
        .word32lu('uncompressedSize')
        .word16lu('fileNameLength')
        .word16lu('extraFieldLength')
        .word16lu('fileCommentLength')
        .word16lu('diskNumber')
        .word16lu('internalFileAttributes')
        .word32lu('externalFileAttributes')
        .word32lu('offsetToLocalFileHeader')
        .vars;

    return vars;
}

UnzipStream.prototype._readEndOfCentralDirectory64 = function (data) {
    var vars = binary.parse(data)
        .word64lu('centralDirectoryRecordSize')
        .word16lu('versionMadeBy')
        .word16lu('versionsNeededToExtract')
        .word32lu('diskNumber')
        .word32lu('diskNumberWithCentralDirectoryStart')
        .word64lu('centralDirectoryEntries')
        .word64lu('totalCentralDirectoryEntries')
        .word64lu('sizeOfCentralDirectory')
        .word64lu('offsetToStartOfCentralDirectory')
        .vars;

    return vars;
}

UnzipStream.prototype._readEndOfCentralDirectory = function (data) {
    var vars = binary.parse(data)
        .word16lu('diskNumber')
        .word16lu('diskStart')
        .word16lu('centralDirectoryEntries')
        .word16lu('totalCentralDirectoryEntries')
        .word32lu('sizeOfCentralDirectory')
        .word32lu('offsetToStartOfCentralDirectory')
        .word16lu('commentLength')
        .vars;

    return vars;
}

const cp437 = '\u0000☺☻♥♦♣♠•◘○◙♂♀♪♫☼►◄↕‼¶§▬↨↑↓→←∟↔▲▼ !"#$%&\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~⌂ÇüéâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜ¢£¥₧ƒáíóúñÑªº¿⌐¬½¼¡«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ ';

UnzipStream.prototype._decodeString = function (buffer, isUtf8) {
    if (isUtf8) {
        return buffer.toString('utf8');
    }
    // allow passing custom decoder
    if (this.options.decodeString) {
        return this.options.decodeString(buffer);
    }
    let result = "";
    for (var i=0; i<buffer.length; i++) {
        result += cp437[buffer[i]];
    }
    return result;
}

UnzipStream.prototype._parseOrOutput = function (encoding, cb) {
    var consume;
    while ((consume = this.processDataChunk(this.data)) > 0) {
        this.data = this.data.slice(consume);
        if (this.data.length === 0) break;
    }

    if (this.state === states.FILE_DATA) {
        if (this.outStreamInfo.limit >= 0) {
            var remaining = this.outStreamInfo.limit - this.outStreamInfo.written;
            var packet;
            if (remaining < this.data.length) {
                packet = this.data.slice(0, remaining);
                this.data = this.data.slice(remaining);
            } else {
                packet = this.data;
                this.data = new Buffer('');
            }

            this.outStreamInfo.written += packet.length;
            if (this.outStreamInfo.limit === this.outStreamInfo.written) {
                this.state = states.START;

                this.outStreamInfo.stream.end(packet, encoding, cb);
            } else {
                this.outStreamInfo.stream.write(packet, encoding, cb);
            }
        } else {
            var packet = this.data;
            this.data = new Buffer('');

            this.outStreamInfo.written += packet.length;
            var outputStream = this.outStreamInfo.stream;
            outputStream.write(packet, encoding, () => {
                if (this.state === states.FILE_DATA_END) {
                    this.state = states.START;
                    return outputStream.end(cb);
                }
                cb();
            });
        }
        // we've written to the output stream, letting that write deal with the callback
        return;
    }

    cb();
}

UnzipStream.prototype.drainAll = function () {
    this._drainAllEntries = true;
}

UnzipStream.prototype._transform = function (chunk, encoding, cb) {
    var self = this;
    if (self.data.length > 0) {
        self.data = Buffer.concat([self.data, chunk]);
    } else {
        self.data = chunk;
    }

    var startDataLength = self.data.length;
    var done = function () {
        if (self.data.length > 0 && self.data.length < startDataLength) {
            startDataLength = self.data.length;
            self._parseOrOutput(encoding, done);
            return;
        }
        cb();
    };
    self._parseOrOutput(encoding, done);
}

UnzipStream.prototype._flush = function (cb) {
    var self = this;
    if (self.data.length > 0) {
        self._parseOrOutput('buffer', function () {
            if (self.data.length > 0) return setImmediate(function () { self._flush(cb); });
            cb();
        });

        return;
    }

    if (self.state === states.FILE_DATA) {
        // uh oh, something went wrong
        return cb(new Error("Stream finished in an invalid state, uncompression failed"));
    }

    setImmediate(cb);
}

module.exports = UnzipStream;


/***/ }),

/***/ "./src/node_modules/unzip-stream/unzip.js":
/*!************************************************!*\
  !*** ./src/node_modules/unzip-stream/unzip.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.Parse = __webpack_require__(/*! ./lib/parser-stream */ "./src/node_modules/unzip-stream/lib/parser-stream.js");
exports.Extract = __webpack_require__(/*! ./lib/extract */ "./src/node_modules/unzip-stream/lib/extract.js");

/***/ }),

/***/ "./src/node_modules/valid-url/index.js":
/*!*********************************************!*\
  !*** ./src/node_modules/valid-url/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {(function(module) {
    'use strict';

    module.exports.is_uri = is_iri;
    module.exports.is_http_uri = is_http_iri;
    module.exports.is_https_uri = is_https_iri;
    module.exports.is_web_uri = is_web_iri;
    // Create aliases
    module.exports.isUri = is_iri;
    module.exports.isHttpUri = is_http_iri;
    module.exports.isHttpsUri = is_https_iri;
    module.exports.isWebUri = is_web_iri;


    // private function
    // internal URI spitter method - direct from RFC 3986
    var splitUri = function(uri) {
        var splitted = uri.match(/(?:([^:\/?#]+):)?(?:\/\/([^\/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?/);
        return splitted;
    };

    function is_iri(value) {
        if (!value) {
            return;
        }

        // check for illegal characters
        if (/[^a-z0-9\:\/\?\#\[\]\@\!\$\&\'\(\)\*\+\,\;\=\.\-\_\~\%]/i.test(value)) return;

        // check for hex escapes that aren't complete
        if (/%[^0-9a-f]/i.test(value)) return;
        if (/%[0-9a-f](:?[^0-9a-f]|$)/i.test(value)) return;

        var splitted = [];
        var scheme = '';
        var authority = '';
        var path = '';
        var query = '';
        var fragment = '';
        var out = '';

        // from RFC 3986
        splitted = splitUri(value);
        scheme = splitted[1];
        authority = splitted[2];
        path = splitted[3];
        query = splitted[4];
        fragment = splitted[5];

        // scheme and path are required, though the path can be empty
        if (!(scheme && scheme.length && path.length >= 0)) return;

        // if authority is present, the path must be empty or begin with a /
        if (authority && authority.length) {
            if (!(path.length === 0 || /^\//.test(path))) return;
        } else {
            // if authority is not present, the path must not start with //
            if (/^\/\//.test(path)) return;
        }

        // scheme must begin with a letter, then consist of letters, digits, +, ., or -
        if (!/^[a-z][a-z0-9\+\-\.]*$/.test(scheme.toLowerCase()))  return;

        // re-assemble the URL per section 5.3 in RFC 3986
        out += scheme + ':';
        if (authority && authority.length) {
            out += '//' + authority;
        }

        out += path;

        if (query && query.length) {
            out += '?' + query;
        }

        if (fragment && fragment.length) {
            out += '#' + fragment;
        }

        return out;
    }

    function is_http_iri(value, allowHttps) {
        if (!is_iri(value)) {
            return;
        }

        var splitted = [];
        var scheme = '';
        var authority = '';
        var path = '';
        var port = '';
        var query = '';
        var fragment = '';
        var out = '';

        // from RFC 3986
        splitted = splitUri(value);
        scheme = splitted[1];
        authority = splitted[2];
        path = splitted[3];
        query = splitted[4];
        fragment = splitted[5];

        if (!scheme)  return;

        if(allowHttps) {
            if (scheme.toLowerCase() != 'https') return;
        } else {
            if (scheme.toLowerCase() != 'http') return;
        }

        // fully-qualified URIs must have an authority section that is
        // a valid host
        if (!authority) {
            return;
        }

        // enable port component
        if (/:(\d+)$/.test(authority)) {
            port = authority.match(/:(\d+)$/)[0];
            authority = authority.replace(/:\d+$/, '');
        }

        out += scheme + ':';
        out += '//' + authority;

        if (port) {
            out += port;
        }

        out += path;

        if(query && query.length){
            out += '?' + query;
        }

        if(fragment && fragment.length){
            out += '#' + fragment;
        }

        return out;
    }

    function is_https_iri(value) {
        return is_http_iri(value, true);
    }

    function is_web_iri(value) {
        return (is_http_iri(value) || is_https_iri(value));
    }

})(module);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./src/node_modules/window-size/index.js":
/*!***********************************************!*\
  !*** ./src/node_modules/window-size/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*!
 * window-size <https://github.com/jonschlinkert/window-size>
 *
 * Copyright (c) 2014-2015 Jon Schlinkert
 * Licensed under the MIT license.
 */

var tty = __webpack_require__(/*! tty */ "tty");

module.exports = (function () {
  var width;
  var height;

  if (tty.isatty(1) && tty.isatty(2)) {
    if (process.stdout.getWindowSize) {
      width = process.stdout.getWindowSize(1)[0];
      height = process.stdout.getWindowSize(1)[1];
    } else if (tty.getWindowSize) {
      width = tty.getWindowSize()[1];
      height = tty.getWindowSize()[0];
    } else if (process.stdout.columns && process.stdout.rows) {
      height = process.stdout.columns;
      width = process.stdout.rows;
    }
  } else {
    Error('window-size could not get size with tty or process.stdout.');
  }

  return {height: height, width: width};
})();


/***/ }),

/***/ "./src/node_modules/winreg/lib/registry.js":
/*!*************************************************!*\
  !*** ./src/node_modules/winreg/lib/registry.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/************************************************************************************************************
 * registry.js - contains a wrapper for the REG command under Windows, which provides access to the registry
 *
 * @author Paul Bottin a/k/a FrEsC
 *
 */

/* imports */
var util          = __webpack_require__(/*! util */ "util")
,   path          = __webpack_require__(/*! path */ "path")
,   spawn         = __webpack_require__(/*! child_process */ "child_process").spawn

/* set to console.log for debugging */
,   log           = function () {}

/* registry hive ids */
,   HKLM          = 'HKLM'
,   HKCU          = 'HKCU'
,   HKCR          = 'HKCR'
,   HKU           = 'HKU'
,   HKCC          = 'HKCC'
,   HIVES         = [ HKLM, HKCU, HKCR, HKU, HKCC ]

/* registry value type ids */
,   REG_SZ        = 'REG_SZ'
,   REG_MULTI_SZ  = 'REG_MULTI_SZ'
,   REG_EXPAND_SZ = 'REG_EXPAND_SZ'
,   REG_DWORD     = 'REG_DWORD'
,   REG_QWORD     = 'REG_QWORD'
,   REG_BINARY    = 'REG_BINARY'
,   REG_NONE      = 'REG_NONE'
,   REG_TYPES     = [ REG_SZ, REG_MULTI_SZ, REG_EXPAND_SZ, REG_DWORD, REG_QWORD, REG_BINARY, REG_NONE ]

/* default registry value name */
,   DEFAULT_VALUE = ''

/* general key pattern */
,   KEY_PATTERN   = /(\\[a-zA-Z0-9_\s]+)*/

/* key path pattern (as returned by REG-cli) */
,   PATH_PATTERN  = /^(HKEY_LOCAL_MACHINE|HKEY_CURRENT_USER|HKEY_CLASSES_ROOT|HKEY_USERS|HKEY_CURRENT_CONFIG)(.*)$/

/* registry item pattern */
,   ITEM_PATTERN  = /^(.*)\s(REG_SZ|REG_MULTI_SZ|REG_EXPAND_SZ|REG_DWORD|REG_QWORD|REG_BINARY|REG_NONE)\s+([^\s].*)$/

/**
 * Creates an Error object that contains the exit code of the REG.EXE process.
 * This contructor is private. Objects of this type are created internally and returned in the <code>err</code> parameters in case the REG.EXE process doesn't exit cleanly.
 *
 * @private
 * @class
 *
 * @param {string} message - the error message
 * @param {number} code - the process exit code
 *
 */
function ProcessUncleanExitError(message, code) {
  if (!(this instanceof ProcessUncleanExitError))
    return new ProcessUncleanExitError(message, code);

  Error.captureStackTrace(this, ProcessUncleanExitError);

  /**
   * The error name.
   * @readonly
   * @member {string} ProcessUncleanExitError#name
   */
  this.__defineGetter__('name', function () { return ProcessUncleanExitError.name; });

  /**
   * The error message.
   * @readonly
   * @member {string} ProcessUncleanExitError#message
   */
  this.__defineGetter__('message', function () { return message; });

  /**
   * The process exit code.
   * @readonly
   * @member {number} ProcessUncleanExitError#code
   */
  this.__defineGetter__('code', function () { return code; });

}

util.inherits(ProcessUncleanExitError, Error);

/*
 * Captures stdout/stderr for a child process
 */
function captureOutput(child) {
  // Use a mutable data structure so we can append as we get new data and have
  // the calling context see the new data
  var output = {'stdout': '', 'stderr': ''};

  child.stdout.on('data', function(data) { output["stdout"] += data.toString(); });
  child.stderr.on('data', function(data) { output["stderr"] += data.toString(); });

  return output;
}


/*
 * Returns an error message containing the stdout/stderr of the child process
 */
function mkErrorMsg(registryCommand, code, output) {
    var stdout = output['stdout'].trim();
    var stderr = output['stderr'].trim();

    var msg = util.format("%s command exited with code %d:\n%s\n%s", registryCommand, code, stdout, stderr);
    return new ProcessUncleanExitError(msg, code);
}


/*
 * Converts x86/x64 to 32/64
 */
function convertArchString(archString) {
  if (archString == 'x64') {
    return '64';
  } else if (archString == 'x86') {
    return '32';
  } else {
    throw new Error('illegal architecture: ' + archString + ' (use x86 or x64)');
  }
}


/*
 * Adds correct architecture to reg args
 */
function pushArch(args, arch) {
  if (arch) {
    args.push('/reg:' + convertArchString(arch));
  }
}

/*
 * Get the path to system's reg.exe. Useful when another reg.exe is added to the PATH
 * Implemented only for Windows
 */
function getRegExePath() {
    if (process.platform === 'win32') {
        return path.join(process.env.windir, 'system32', 'reg.exe');
    } else {
        return "REG";
    }
}


/**
 * Creates a single registry value record.
 * This contructor is private. Objects of this type are created internally and returned by methods of {@link Registry} objects.
 *
 * @private
 * @class
 *
 * @param {string} host - the hostname
 * @param {string} hive - the hive id
 * @param {string} key - the registry key
 * @param {string} name - the value name
 * @param {string} type - the value type
 * @param {string} value - the value
 * @param {string} arch - the hive architecture ('x86' or 'x64')
 *
 */
function RegistryItem (host, hive, key, name, type, value, arch) {

  if (!(this instanceof RegistryItem))
    return new RegistryItem(host, hive, key, name, type, value, arch);

  /* private members */
  var _host = host    // hostname
  ,   _hive = hive    // registry hive
  ,   _key = key      // registry key
  ,   _name = name    // property name
  ,   _type = type    // property type
  ,   _value = value  // property value
  ,   _arch = arch    // hive architecture

  /* getters/setters */

  /**
   * The hostname.
   * @readonly
   * @member {string} RegistryItem#host
   */
  this.__defineGetter__('host', function () { return _host; });

  /**
   * The hive id.
   * @readonly
   * @member {string} RegistryItem#hive
   */
  this.__defineGetter__('hive', function () { return _hive; });

  /**
   * The registry key.
   * @readonly
   * @member {string} RegistryItem#key
   */
  this.__defineGetter__('key', function () { return _key; });

  /**
   * The value name.
   * @readonly
   * @member {string} RegistryItem#name
   */
  this.__defineGetter__('name', function () { return _name; });

  /**
   * The value type.
   * @readonly
   * @member {string} RegistryItem#type
   */
  this.__defineGetter__('type', function () { return _type; });

  /**
   * The value.
   * @readonly
   * @member {string} RegistryItem#value
   */
  this.__defineGetter__('value', function () { return _value; });

  /**
   * The hive architecture.
   * @readonly
   * @member {string} RegistryItem#arch
   */
  this.__defineGetter__('arch', function () { return _arch; });

}

util.inherits(RegistryItem, Object);

/**
 * Creates a registry object, which provides access to a single registry key.
 * Note: This class is returned by a call to ```require('winreg')```.
 *
 * @public
 * @class
 *
 * @param {object} options - the options
 * @param {string=} options.host - the hostname
 * @param {string=} options.hive - the hive id
 * @param {string=} options.key - the registry key
 * @param {string=} options.arch - the optional registry hive architecture ('x86' or 'x64'; only valid on Windows 64 Bit Operating Systems)
 *
 * @example
 * var Registry = require('winreg')
 * ,   autoStartCurrentUser = new Registry({
 *       hive: Registry.HKCU,
 *       key:  '\\Software\\Microsoft\\Windows\\CurrentVersion\\Run'
 *     });
 *
 */
function Registry (options) {

  if (!(this instanceof Registry))
    return new Registry(options);

  /* private members */
  var _options = options || {}
  ,   _host = '' + (_options.host || '')    // hostname
  ,   _hive = '' + (_options.hive || HKLM)  // registry hive
  ,   _key  = '' + (_options.key  || '')    // registry key
  ,   _arch = _options.arch || null         // hive architecture

  /* getters/setters */

  /**
   * The hostname.
   * @readonly
   * @member {string} Registry#host
   */
  this.__defineGetter__('host', function () { return _host; });

  /**
   * The hive id.
   * @readonly
   * @member {string} Registry#hive
   */
  this.__defineGetter__('hive', function () { return _hive; });

  /**
   * The registry key name.
   * @readonly
   * @member {string} Registry#key
   */
  this.__defineGetter__('key', function () { return _key; });

  /**
   * The full path to the registry key.
   * @readonly
   * @member {string} Registry#path
   */
  this.__defineGetter__('path', function () { return (_host.length == 0 ? '' : '\\\\' + _host + '\\') + _hive + _key; });

  /**
   * The registry hive architecture ('x86' or 'x64').
   * @readonly
   * @member {string} Registry#arch
   */
  this.__defineGetter__('arch', function () { return _arch; });

  /**
   * Creates a new {@link Registry} instance that points to the parent registry key.
   * @readonly
   * @member {Registry} Registry#parent
   */
  this.__defineGetter__('parent', function () {
    var i = _key.lastIndexOf('\\')
    return new Registry({
      host: this.host,
      hive: this.hive,
      key:  (i == -1)?'':_key.substring(0, i),
      arch: this.arch
    });
  });

  // validate options...
  if (HIVES.indexOf(_hive) == -1)
    throw new Error('illegal hive specified.');

  if (!KEY_PATTERN.test(_key))
    throw new Error('illegal key specified.');

  if (_arch && _arch != 'x64' && _arch != 'x86')
    throw new Error('illegal architecture specified (use x86 or x64)');

}

/**
 * Registry hive key HKEY_LOCAL_MACHINE.
 * Note: For writing to this hive your program has to run with admin privileges.
 * @type {string}
 */
Registry.HKLM = HKLM;

/**
 * Registry hive key HKEY_CURRENT_USER.
 * @type {string}
 */
Registry.HKCU = HKCU;

/**
 * Registry hive key HKEY_CLASSES_ROOT.
 * Note: For writing to this hive your program has to run with admin privileges.
 * @type {string}
 */
Registry.HKCR = HKCR;

/**
 * Registry hive key HKEY_USERS.
 * Note: For writing to this hive your program has to run with admin privileges.
 * @type {string}
 */
Registry.HKU = HKU;

/**
 * Registry hive key HKEY_CURRENT_CONFIG.
 * Note: For writing to this hive your program has to run with admin privileges.
 * @type {string}
 */
Registry.HKCC = HKCC;

/**
 * Collection of available registry hive keys.
 * @type {array}
 */
Registry.HIVES = HIVES;

/**
 * Registry value type STRING.
 * @type {string}
 */
Registry.REG_SZ = REG_SZ;

/**
 * Registry value type MULTILINE_STRING.
 * @type {string}
 */
Registry.REG_MULTI_SZ = REG_MULTI_SZ;

/**
 * Registry value type EXPANDABLE_STRING.
 * @type {string}
 */
Registry.REG_EXPAND_SZ = REG_EXPAND_SZ;

/**
 * Registry value type DOUBLE_WORD.
 * @type {string}
 */
Registry.REG_DWORD = REG_DWORD;

/**
 * Registry value type QUAD_WORD.
 * @type {string}
 */
Registry.REG_QWORD = REG_QWORD;

/**
 * Registry value type BINARY.
 * @type {string}
 */
Registry.REG_BINARY = REG_BINARY;

/**
 * Registry value type UNKNOWN.
 * @type {string}
 */
Registry.REG_NONE = REG_NONE;

/**
 * Collection of available registry value types.
 * @type {array}
 */
Registry.REG_TYPES = REG_TYPES;

/**
 * The name of the default value. May be used instead of the empty string literal for better readability.
 * @type {string}
 */
Registry.DEFAULT_VALUE = DEFAULT_VALUE;

/**
 * Retrieve all values from this registry key.
 * @param {valuesCallback} cb - callback function
 * @param {ProcessUncleanExitError=} cb.err - error object or null if successful
 * @param {array=} cb.items - an array of {@link RegistryItem} objects
 * @returns {Registry} this registry key object
 */
Registry.prototype.values = function values (cb) {

  if (typeof cb !== 'function')
    throw new TypeError('must specify a callback');

  var args = [ 'QUERY', this.path ];

  pushArch(args, this.arch);

  var proc = spawn(getRegExePath(), args, {
        cwd: undefined,
        env: process.env,
        stdio: [ 'ignore', 'pipe', 'pipe' ]
      })
  ,   buffer = ''
  ,   self = this
  ,   error = null // null means no error previously reported.

  var output = captureOutput(proc);

  proc.on('close', function (code) {
    if (error) {
      return;
    } else if (code !== 0) {
      log('process exited with code ' + code);
      cb(mkErrorMsg('QUERY', code, output), null);
    } else {
      var items = []
      ,   result = []
      ,   lines = buffer.split('\n')
      ,   lineNumber = 0

      for (var i = 0, l = lines.length; i < l; i++) {
        var line = lines[i].trim();
        if (line.length > 0) {
          log(line);
          if (lineNumber != 0) {
            items.push(line);
          }
          ++lineNumber;
        }
      }

      for (var i = 0, l = items.length; i < l; i++) {

        var match = ITEM_PATTERN.exec(items[i])
        ,   name
        ,   type
        ,   value

        if (match) {
          name = match[1].trim();
          type = match[2].trim();
          value = match[3];
          result.push(new RegistryItem(self.host, self.hive, self.key, name, type, value, self.arch));
        }
      }

      cb(null, result);

    }
  });

  proc.stdout.on('data', function (data) {
    buffer += data.toString();
  });

  proc.on('error', function(err) {
    error = err;
    cb(err);
  });

  return this;
};

/**
 * Retrieve all subkeys from this registry key.
 * @param {function (err, items)} cb - callback function
 * @param {ProcessUncleanExitError=} cb.err - error object or null if successful
 * @param {array=} cb.items - an array of {@link Registry} objects
 * @returns {Registry} this registry key object
 */
Registry.prototype.keys = function keys (cb) {

  if (typeof cb !== 'function')
    throw new TypeError('must specify a callback');

  var args = [ 'QUERY', this.path ];

  pushArch(args, this.arch);

  var proc = spawn(getRegExePath(), args, {
        cwd: undefined,
        env: process.env,
        stdio: [ 'ignore', 'pipe', 'pipe' ]
      })
  ,   buffer = ''
  ,   self = this
  ,   error = null // null means no error previously reported.

  var output = captureOutput(proc);

  proc.on('close', function (code) {
    if (error) {
      return;
    } else if (code !== 0) {
      log('process exited with code ' + code);
      cb(mkErrorMsg('QUERY', code, output), null);
    }
  });

  proc.stdout.on('data', function (data) {
    buffer += data.toString();
  });

  proc.stdout.on('end', function () {

    var items = []
    ,   result = []
    ,   lines = buffer.split('\n')

    for (var i = 0, l = lines.length; i < l; i++) {
      var line = lines[i].trim();
      if (line.length > 0) {
        log(line);
        items.push(line);
      }
    }

    for (var i = 0, l = items.length; i < l; i++) {

      var match = PATH_PATTERN.exec(items[i])
      ,   hive
      ,   key

      if (match) {
        hive = match[1];
        key  = match[2];
        if (key && (key !== self.key)) {
          result.push(new Registry({
            host: self.host,
            hive: self.hive,
            key:  key,
            arch: self.arch
          }));
        }
      }
    }

    cb(null, result);

  });

  proc.on('error', function(err) {
    error = err;
    cb(err);
  });

  return this;
};

/**
 * Gets a named value from this registry key.
 * @param {string} name - the value name, use {@link Registry.DEFAULT_VALUE} or an empty string for the default value
 * @param {function (err, item)} cb - callback function
 * @param {ProcessUncleanExitError=} cb.err - error object or null if successful
 * @param {RegistryItem=} cb.item - the retrieved registry item
 * @returns {Registry} this registry key object
 */
Registry.prototype.get = function get (name, cb) {

  if (typeof cb !== 'function')
    throw new TypeError('must specify a callback');

  var args = ['QUERY', this.path];
  if (name == '')
    args.push('/ve');
  else
    args = args.concat(['/v', name]);

  pushArch(args, this.arch);

  var proc = spawn(getRegExePath(), args, {
        cwd: undefined,
        env: process.env,
        stdio: [ 'ignore', 'pipe', 'pipe' ]
      })
  ,   buffer = ''
  ,   self = this
  ,   error = null // null means no error previously reported.

  var output = captureOutput(proc);

  proc.on('close', function (code) {
    if (error) {
      return;
    } else if (code !== 0) {
      log('process exited with code ' + code);
      cb(mkErrorMsg('QUERY', code, output), null);
    } else {
      var items = []
      ,   result = null
      ,   lines = buffer.split('\n')
      ,   lineNumber = 0

      for (var i = 0, l = lines.length; i < l; i++) {
        var line = lines[i].trim();
        if (line.length > 0) {
          log(line);
          if (lineNumber != 0) {
             items.push(line);
          }
          ++lineNumber;
        }
      }

      //Get last item - so it works in XP where REG QUERY returns with a header
      var item = items[items.length-1] || ''
      ,   match = ITEM_PATTERN.exec(item)
      ,   name
      ,   type
      ,   value

      if (match) {
        name = match[1].trim();
        type = match[2].trim();
        value = match[3];
        result = new RegistryItem(self.host, self.hive, self.key, name, type, value, self.arch);
      }

      cb(null, result);
    }
  });

  proc.stdout.on('data', function (data) {
    buffer += data.toString();
  });

  proc.on('error', function(err) {
    error = err;
    cb(err);
  });

  return this;
};

/**
 * Sets a named value in this registry key, overwriting an already existing value.
 * @param {string} name - the value name, use {@link Registry.DEFAULT_VALUE} or an empty string for the default value
 * @param {string} type - the value type
 * @param {string} value - the value
 * @param {function (err)} cb - callback function
 * @param {ProcessUncleanExitError=} cb.err - error object or null if successful
 * @returns {Registry} this registry key object
 */
Registry.prototype.set = function set (name, type, value, cb) {

  if (typeof cb !== 'function')
    throw new TypeError('must specify a callback');

  if (REG_TYPES.indexOf(type) == -1)
    throw Error('illegal type specified.');

  var args = ['ADD', this.path];
  if (name == '')
    args.push('/ve');
  else
    args = args.concat(['/v', name]);

  args = args.concat(['/t', type, '/d', value, '/f']);

  pushArch(args, this.arch);

  var proc = spawn(getRegExePath(), args, {
        cwd: undefined,
        env: process.env,
        stdio: [ 'ignore', 'pipe', 'pipe' ]
      })
  ,   error = null // null means no error previously reported.

  var output = captureOutput(proc);

  proc.on('close', function (code) {
    if(error) {
      return;
    } else if (code !== 0) {
      log('process exited with code ' + code);
      cb(mkErrorMsg('ADD', code, output, null));
    } else {
      cb(null);
    }
  });

  proc.stdout.on('data', function (data) {
    // simply discard output
    log(''+data);
  });

  proc.on('error', function(err) {
    error = err;
    cb(err);
  });

  return this;
};

/**
 * Remove a named value from this registry key. If name is empty, sets the default value of this key.
 * Note: This key must be already existing.
 * @param {string} name - the value name, use {@link Registry.DEFAULT_VALUE} or an empty string for the default value
 * @param {function (err)} cb - callback function
 * @param {ProcessUncleanExitError=} cb.err - error object or null if successful
 * @returns {Registry} this registry key object
 */
Registry.prototype.remove = function remove (name, cb) {

  if (typeof cb !== 'function')
    throw new TypeError('must specify a callback');

  var args = name ? ['DELETE', this.path, '/f', '/v', name] : ['DELETE', this.path, '/f', '/ve'];

  pushArch(args, this.arch);

  var proc = spawn(getRegExePath(), args, {
        cwd: undefined,
        env: process.env,
        stdio: [ 'ignore', 'pipe', 'pipe' ]
      })
  ,   error = null // null means no error previously reported.

  var output = captureOutput(proc);

  proc.on('close', function (code) {
    if(error) {
      return;
    } else if (code !== 0) {
      log('process exited with code ' + code);
      cb(mkErrorMsg('DELETE', code, output), null);
    } else {
      cb(null);
    }
  });

  proc.stdout.on('data', function (data) {
    // simply discard output
    log(''+data);
  });

  proc.on('error', function(err) {
    error = err;
    cb(err);
  });

  return this;
};

/**
 * Remove all subkeys and values (including the default value) from this registry key.
 * @param {function (err)} cb - callback function
 * @param {ProcessUncleanExitError=} cb.err - error object or null if successful
 * @returns {Registry} this registry key object
 */
Registry.prototype.clear = function clear (cb) {

  if (typeof cb !== 'function')
    throw new TypeError('must specify a callback');

  var args = ['DELETE', this.path, '/f', '/va'];

  pushArch(args, this.arch);

  var proc = spawn(getRegExePath(), args, {
        cwd: undefined,
        env: process.env,
        stdio: [ 'ignore', 'pipe', 'pipe' ]
      })
  ,   error = null // null means no error previously reported.

  var output = captureOutput(proc);

  proc.on('close', function (code) {
    if(error) {
      return;
    } else if (code !== 0) {
      log('process exited with code ' + code);
      cb(mkErrorMsg("DELETE", code, output), null);
    } else {
      cb(null);
    }
  });

  proc.stdout.on('data', function (data) {
    // simply discard output
    log(''+data);
  });

  proc.on('error', function(err) {
    error = err;
    cb(err);
  });

  return this;
};

/**
 * Alias for the clear method to keep it backward compatible.
 * @method
 * @deprecated Use {@link Registry#clear} or {@link Registry#destroy} in favour of this method.
 * @param {function (err)} cb - callback function
 * @param {ProcessUncleanExitError=} cb.err - error object or null if successful
 * @returns {Registry} this registry key object
 */
Registry.prototype.erase = Registry.prototype.clear;

/**
 * Delete this key and all subkeys from the registry.
 * @param {function (err)} cb - callback function
 * @param {ProcessUncleanExitError=} cb.err - error object or null if successful
 * @returns {Registry} this registry key object
 */
Registry.prototype.destroy = function destroy (cb) {

  if (typeof cb !== 'function')
    throw new TypeError('must specify a callback');

  var args = ['DELETE', this.path, '/f'];

  pushArch(args, this.arch);

  var proc = spawn(getRegExePath(), args, {
        cwd: undefined,
        env: process.env,
        stdio: [ 'ignore', 'pipe', 'pipe' ]
      })
  ,   error = null // null means no error previously reported.

  var output = captureOutput(proc);

  proc.on('close', function (code) {
    if (error) {
      return;
    } else if (code !== 0) {
      log('process exited with code ' + code);
      cb(mkErrorMsg('DELETE', code, output), null);
    } else {
      cb(null);
    }
  });

  proc.stdout.on('data', function (data) {
    // simply discard output
    log(''+data);
  });

  proc.on('error', function(err) {
    error = err;
    cb(err);
  });

  return this;
};

/**
 * Create this registry key. Note that this is a no-op if the key already exists.
 * @param {function (err)} cb - callback function
 * @param {ProcessUncleanExitError=} cb.err - error object or null if successful
 * @returns {Registry} this registry key object
 */
Registry.prototype.create = function create (cb) {

  if (typeof cb !== 'function')
    throw new TypeError('must specify a callback');

  var args = ['ADD', this.path, '/f'];

  pushArch(args, this.arch);

  var proc = spawn(getRegExePath(), args, {
        cwd: undefined,
        env: process.env,
        stdio: [ 'ignore', 'pipe', 'pipe' ]
      })
  ,   error = null // null means no error previously reported.

  var output = captureOutput(proc);

  proc.on('close', function (code) {
    if (error) {
      return;
    } else if (code !== 0) {
      log('process exited with code ' + code);
      cb(mkErrorMsg('ADD', code, output), null);
    } else {
      cb(null);
    }
  });

  proc.stdout.on('data', function (data) {
    // simply discard output
    log(''+data);
  });

  proc.on('error', function(err) {
    error = err;
    cb(err);
  });

  return this;
};

/**
 * Checks if this key already exists.
 * @param {function (err, exists)} cb - callback function
 * @param {ProcessUncleanExitError=} cb.err - error object or null if successful
 * @param {boolean=} cb.exists - true if a registry key with this name already exists
 * @returns {Registry} this registry key object
 */
Registry.prototype.keyExists = function keyExists (cb) {

  this.values(function (err, items) {
    if (err) {
      // process should return with code 1 if key not found
      if (err.code == 1) {
        return cb(null, false);
      }
      // other error
      return cb(err);
    }
    cb(null, true);
  });

  return this;
};

/**
 * Checks if a value with the given name already exists within this key.
 * @param {string} name - the value name, use {@link Registry.DEFAULT_VALUE} or an empty string for the default value
 * @param {function (err, exists)} cb - callback function
 * @param {ProcessUncleanExitError=} cb.err - error object or null if successful
 * @param {boolean=} cb.exists - true if a value with the given name was found in this key
 * @returns {Registry} this registry key object
 */
Registry.prototype.valueExists = function valueExists (name, cb) {

  this.get(name, function (err, item) {
    if (err) {
      // process should return with code 1 if value not found
      if (err.code == 1) {
        return cb(null, false);
      }
      // other error
      return cb(err);
    }
    cb(null, true);
  });

  return this;
};

module.exports = Registry;


/***/ }),

/***/ "./src/node_modules/wrap-ansi/index.js":
/*!*********************************************!*\
  !*** ./src/node_modules/wrap-ansi/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var stringWidth = __webpack_require__(/*! string-width */ "./src/node_modules/string-width/index.js");
var stripAnsi = __webpack_require__(/*! strip-ansi */ "./src/node_modules/strip-ansi/index.js");

var ESCAPES = [
	'\u001b',
	'\u009b'
];

var END_CODE = 39;

var ESCAPE_CODES = {
	0: 0,
	1: 22,
	2: 22,
	3: 23,
	4: 24,
	7: 27,
	8: 28,
	9: 29,
	30: 39,
	31: 39,
	32: 39,
	33: 39,
	34: 39,
	35: 39,
	36: 39,
	37: 39,
	90: 39,
	40: 49,
	41: 49,
	42: 49,
	43: 49,
	44: 49,
	45: 49,
	46: 49,
	47: 49
};

function wrapAnsi(code) {
	return ESCAPES[0] + '[' + code + 'm';
}

// calculate the length of words split on ' ', ignoring
// the extra characters added by ansi escape codes.
function wordLengths(str) {
	return str.split(' ').map(function (s) {
		return stringWidth(s);
	});
}

// wrap a long word across multiple rows.
// ansi escape codes do not count towards length.
function wrapWord(rows, word, cols) {
	var insideEscape = false;
	var visible = stripAnsi(rows[rows.length - 1]).length;

	for (var i = 0; i < word.length; i++) {
		var x = word[i];

		rows[rows.length - 1] += x;

		if (ESCAPES.indexOf(x) !== -1) {
			insideEscape = true;
		} else if (insideEscape && x === 'm') {
			insideEscape = false;
			continue;
		}

		if (insideEscape) {
			continue;
		}

		visible++;

		if (visible >= cols && i < word.length - 1) {
			rows.push('');
			visible = 0;
		}
	}

	// it's possible that the last row we copy over is only
	// ansi escape characters, handle this edge-case.
	if (!visible && rows[rows.length - 1].length > 0 && rows.length > 1) {
		rows[rows.length - 2] += rows.pop();
	}
}

// the wrap-ansi module can be invoked
// in either 'hard' or 'soft' wrap mode.
//
// 'hard' will never allow a string to take up more
// than cols characters.
//
// 'soft' allows long words to expand past the column length.
function exec(str, cols, opts) {
	var options = opts || {};

	var pre = '';
	var ret = '';
	var escapeCode;

	var lengths = wordLengths(str);
	var words = str.split(' ');
	var rows = [''];

	for (var i = 0, word; (word = words[i]) !== undefined; i++) {
		var rowLength = stringWidth(rows[rows.length - 1]);

		if (rowLength) {
			rows[rows.length - 1] += ' ';
			rowLength++;
		}

		// in 'hard' wrap mode, the length of a line is
		// never allowed to extend past 'cols'.
		if (lengths[i] > cols && options.hard) {
			if (rowLength) {
				rows.push('');
			}
			wrapWord(rows, word, cols);
			continue;
		}

		if (rowLength + lengths[i] > cols && rowLength > 0) {
			if (options.wordWrap === false && rowLength < cols) {
				wrapWord(rows, word, cols);
				continue;
			}

			rows.push('');
		}

		rows[rows.length - 1] += word;
	}

	pre = rows.map(function (r) {
		return r.trim();
	}).join('\n');

	for (var j = 0; j < pre.length; j++) {
		var y = pre[j];

		ret += y;

		if (ESCAPES.indexOf(y) !== -1) {
			var code = parseFloat(/[0-9][^m]*/.exec(pre.slice(j, j + 4)));
			escapeCode = code === END_CODE ? null : code;
		}

		if (escapeCode && ESCAPE_CODES[escapeCode]) {
			if (pre[j + 1] === '\n') {
				ret += wrapAnsi(ESCAPE_CODES[escapeCode]);
			} else if (y === '\n') {
				ret += wrapAnsi(escapeCode);
			}
		}
	}

	return ret;
}

// for each line break, invoke the method separately.
module.exports = function (str, cols, opts) {
	return String(str).split('\n').map(function (substr) {
		return exec(substr, cols, opts);
	}).join('\n');
};


/***/ }),

/***/ "./src/node_modules/wrappy/wrappy.js":
/*!*******************************************!*\
  !*** ./src/node_modules/wrappy/wrappy.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Returns a wrapper function that returns a wrapped callback
// The wrapper function should do some stuff, and return a
// presumably different callback function.
// This makes sure that own properties are retained, so that
// decorations and such are not lost along the way.
module.exports = wrappy
function wrappy (fn, cb) {
  if (fn && cb) return wrappy(fn)(cb)

  if (typeof fn !== 'function')
    throw new TypeError('need wrapper function')

  Object.keys(fn).forEach(function (k) {
    wrapper[k] = fn[k]
  })

  return wrapper

  function wrapper() {
    var args = new Array(arguments.length)
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i]
    }
    var ret = fn.apply(this, args)
    var cb = args[args.length-1]
    if (typeof ret === 'function' && ret !== cb) {
      Object.keys(cb).forEach(function (k) {
        ret[k] = cb[k]
      })
    }
    return ret
  }
}


/***/ }),

/***/ "./src/node_modules/y18n/index.js":
/*!****************************************!*\
  !*** ./src/node_modules/y18n/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var fs = __webpack_require__(/*! fs */ "fs")
var path = __webpack_require__(/*! path */ "path")
var util = __webpack_require__(/*! util */ "util")

function Y18N (opts) {
  // configurable options.
  opts = opts || {}
  this.directory = opts.directory || './locales'
  this.updateFiles = typeof opts.updateFiles === 'boolean' ? opts.updateFiles : true
  this.locale = opts.locale || 'en'
  this.fallbackToLanguage = typeof opts.fallbackToLanguage === 'boolean' ? opts.fallbackToLanguage : true

  // internal stuff.
  this.cache = {}
  this.writeQueue = []
}

Y18N.prototype.__ = function () {
  var args = Array.prototype.slice.call(arguments)
  var str = args.shift()
  var cb = function () {} // start with noop.

  if (typeof args[args.length - 1] === 'function') cb = args.pop()
  cb = cb || function () {} // noop.

  if (!this.cache[this.locale]) this._readLocaleFile()

  // we've observed a new string, update the language file.
  if (!this.cache[this.locale][str] && this.updateFiles) {
    this.cache[this.locale][str] = str

    // include the current directory and locale,
    // since these values could change before the
    // write is performed.
    this._enqueueWrite([this.directory, this.locale, cb])
  } else {
    cb()
  }

  return util.format.apply(util, [this.cache[this.locale][str] || str].concat(args))
}

Y18N.prototype._enqueueWrite = function (work) {
  this.writeQueue.push(work)
  if (this.writeQueue.length === 1) this._processWriteQueue()
}

Y18N.prototype._processWriteQueue = function () {
  var _this = this
  var work = this.writeQueue[0]

  // destructure the enqueued work.
  var directory = work[0]
  var locale = work[1]
  var cb = work[2]

  var languageFile = this._resolveLocaleFile(directory, locale)
  var serializedLocale = JSON.stringify(this.cache[locale], null, 2)

  fs.writeFile(languageFile, serializedLocale, 'utf-8', function (err) {
    _this.writeQueue.shift()
    if (_this.writeQueue.length > 0) _this._processWriteQueue()
    cb(err)
  })
}

Y18N.prototype._readLocaleFile = function () {
  var localeLookup = {}
  var languageFile = this._resolveLocaleFile(this.directory, this.locale)

  try {
    localeLookup = JSON.parse(fs.readFileSync(languageFile, 'utf-8'))
  } catch (err) {
    if (err instanceof SyntaxError) {
      err.message = 'syntax error in ' + languageFile
    }

    if (err.code === 'ENOENT') localeLookup = {}
    else throw err
  }

  this.cache[this.locale] = localeLookup
}

Y18N.prototype._resolveLocaleFile = function (directory, locale) {
  var file = path.resolve(directory, './', locale + '.json')
  if (this.fallbackToLanguage && !this._fileExistsSync(file) && ~locale.lastIndexOf('_')) {
    // attempt fallback to language only
    var languageFile = path.resolve(directory, './', locale.split('_')[0] + '.json')
    if (this._fileExistsSync(languageFile)) file = languageFile
  }
  return file
}

// this only exists because fs.existsSync() "will be deprecated"
// see https://nodejs.org/api/fs.html#fs_fs_existssync_path
Y18N.prototype._fileExistsSync = function (file) {
  try {
    return fs.statSync(file).isFile()
  } catch (err) {
    return false
  }
}

Y18N.prototype.__n = function () {
  var args = Array.prototype.slice.call(arguments)
  var singular = args.shift()
  var plural = args.shift()
  var quantity = args.shift()

  var cb = function () {} // start with noop.
  if (typeof args[args.length - 1] === 'function') cb = args.pop()

  if (!this.cache[this.locale]) this._readLocaleFile()

  var str = quantity === 1 ? singular : plural
  if (this.cache[this.locale][singular]) {
    str = this.cache[this.locale][singular][quantity === 1 ? 'one' : 'other']
  }

  // we've observed a new string, update the language file.
  if (!this.cache[this.locale][singular] && this.updateFiles) {
    this.cache[this.locale][singular] = {
      one: singular,
      other: plural
    }

    // include the current directory and locale,
    // since these values could change before the
    // write is performed.
    this._enqueueWrite([this.directory, this.locale, cb])
  } else {
    cb()
  }

  // if a %d placeholder is provided, add quantity
  // to the arguments expanded by util.format.
  var values = [str]
  if (~str.indexOf('%d')) values.push(quantity)

  return util.format.apply(util, values.concat(args))
}

Y18N.prototype.setLocale = function (locale) {
  this.locale = locale
}

Y18N.prototype.getLocale = function () {
  return this.locale
}

Y18N.prototype.updateLocale = function (obj) {
  if (!this.cache[this.locale]) this._readLocaleFile()

  for (var key in obj) {
    this.cache[this.locale][key] = obj[key]
  }
}

module.exports = function (opts) {
  var y18n = new Y18N(opts)

  // bind all functions to y18n, so that
  // they can be used in isolation.
  for (var key in y18n) {
    if (typeof y18n[key] === 'function') {
      y18n[key] = y18n[key].bind(y18n)
    }
  }

  return y18n
}


/***/ }),

/***/ "./src/node_modules/yargs/index.js":
/*!*****************************************!*\
  !*** ./src/node_modules/yargs/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(__dirname) {var assert = __webpack_require__(/*! assert */ "assert")
var Completion = __webpack_require__(/*! ./lib/completion */ "./src/node_modules/yargs/lib/completion.js")
var Parser = __webpack_require__(/*! ./lib/parser */ "./src/node_modules/yargs/lib/parser.js")
var path = __webpack_require__(/*! path */ "path")
var tokenizeArgString = __webpack_require__(/*! ./lib/tokenize-arg-string */ "./src/node_modules/yargs/lib/tokenize-arg-string.js")
var Usage = __webpack_require__(/*! ./lib/usage */ "./src/node_modules/yargs/lib/usage.js")
var Validation = __webpack_require__(/*! ./lib/validation */ "./src/node_modules/yargs/lib/validation.js")
var Y18n = __webpack_require__(/*! y18n */ "./src/node_modules/y18n/index.js")

Argv(process.argv.slice(2))

var exports = module.exports = Argv
function Argv (processArgs, cwd) {
  processArgs = processArgs || [] // handle calling yargs().

  var self = {}
  var completion = null
  var usage = null
  var validation = null
  var y18n = Y18n({
    directory: path.resolve(__dirname, './locales'),
    updateFiles: false
  })

  if (!cwd) cwd = process.cwd()

  self.$0 = process.argv
    .slice(0, 2)
    .map(function (x, i) {
      // ignore the node bin, specify this in your
      // bin file with #!/usr/bin/env node
      if (i === 0 && /\b(node|iojs)$/.test(x)) return
      var b = rebase(cwd, x)
      return x.match(/^\//) && b.length < x.length ? b : x
    })
    .join(' ').trim()

  if (process.env._ !== undefined && process.argv[1] === process.env._) {
    self.$0 = process.env._.replace(
      path.dirname(process.execPath) + '/', ''
    )
  }

  var options
  self.resetOptions = self.reset = function () {
    // put yargs back into its initial
    // state, this is useful for creating a
    // nested CLI.
    options = {
      array: [],
      boolean: [],
      string: [],
      narg: {},
      key: {},
      alias: {},
      default: {},
      defaultDescription: {},
      choices: {},
      requiresArg: [],
      count: [],
      normalize: [],
      config: {},
      envPrefix: undefined
    }

    usage = Usage(self, y18n) // handle usage output.
    validation = Validation(self, usage, y18n) // handle arg validation.
    completion = Completion(self, usage)

    demanded = {}
    groups = {}

    exitProcess = true
    strict = false
    helpOpt = null
    versionOpt = null
    commandHandlers = {}
    self.parsed = false

    return self
  }
  self.resetOptions()

  self.boolean = function (bools) {
    options.boolean.push.apply(options.boolean, [].concat(bools))
    return self
  }

  self.array = function (arrays) {
    options.array.push.apply(options.array, [].concat(arrays))
    return self
  }

  self.nargs = function (key, n) {
    if (typeof key === 'object') {
      Object.keys(key).forEach(function (k) {
        self.nargs(k, key[k])
      })
    } else {
      options.narg[key] = n
    }
    return self
  }

  self.choices = function (key, values) {
    if (typeof key === 'object') {
      Object.keys(key).forEach(function (k) {
        self.choices(k, key[k])
      })
    } else {
      options.choices[key] = (options.choices[key] || []).concat(values)
    }
    return self
  }

  self.normalize = function (strings) {
    options.normalize.push.apply(options.normalize, [].concat(strings))
    return self
  }

  self.config = function (key, msg, parseFn) {
    if (typeof msg === 'function') {
      parseFn = msg
      msg = null
    }
    self.describe(key, msg || usage.deferY18nLookup('Path to JSON config file'))
    ;(Array.isArray(key) ? key : [key]).forEach(function (k) {
      options.config[k] = parseFn || true
    })
    return self
  }

  self.example = function (cmd, description) {
    usage.example(cmd, description)
    return self
  }

  self.command = function (cmd, description, fn) {
    if (description !== false) {
      usage.command(cmd, description)
    }
    if (fn) commandHandlers[cmd] = fn
    return self
  }

  var commandHandlers = {}
  self.getCommandHandlers = function () {
    return commandHandlers
  }

  self.string = function (strings) {
    options.string.push.apply(options.string, [].concat(strings))
    return self
  }

  self.default = function (key, value, defaultDescription) {
    if (typeof key === 'object') {
      Object.keys(key).forEach(function (k) {
        self.default(k, key[k])
      })
    } else {
      if (defaultDescription) options.defaultDescription[key] = defaultDescription
      if (typeof value === 'function') {
        if (!options.defaultDescription[key]) options.defaultDescription[key] = usage.functionDescription(value)
        value = value.call()
      }
      options.default[key] = value
    }
    return self
  }

  self.alias = function (x, y) {
    if (typeof x === 'object') {
      Object.keys(x).forEach(function (key) {
        self.alias(key, x[key])
      })
    } else {
      // perhaps 'x' is already an alias in another list?
      // if so we should append to x's list.
      var aliases = null
      Object.keys(options.alias).forEach(function (key) {
        if (~options.alias[key].indexOf(x)) aliases = options.alias[key]
      })

      if (aliases) { // x was an alias itself.
        aliases.push(y)
      } else { // x is a new alias key.
        options.alias[x] = (options.alias[x] || []).concat(y)
      }

      // wait! perhaps we've created two lists of aliases
      // that reference each other?
      if (options.alias[y]) {
        Array.prototype.push.apply((options.alias[x] || aliases), options.alias[y])
        delete options.alias[y]
      }
    }
    return self
  }

  self.count = function (counts) {
    options.count.push.apply(options.count, [].concat(counts))
    return self
  }

  var demanded = {}
  self.demand = self.required = self.require = function (keys, max, msg) {
    // you can optionally provide a 'max' key,
    // which will raise an exception if too many '_'
    // options are provided.
    if (typeof max !== 'number') {
      msg = max
      max = Infinity
    }

    if (typeof keys === 'number') {
      if (!demanded._) demanded._ = { count: 0, msg: null, max: max }
      demanded._.count = keys
      demanded._.msg = msg
    } else if (Array.isArray(keys)) {
      keys.forEach(function (key) {
        self.demand(key, msg)
      })
    } else {
      if (typeof msg === 'string') {
        demanded[keys] = { msg: msg }
      } else if (msg === true || typeof msg === 'undefined') {
        demanded[keys] = { msg: undefined }
      }
    }

    return self
  }
  self.getDemanded = function () {
    return demanded
  }

  self.requiresArg = function (requiresArgs) {
    options.requiresArg.push.apply(options.requiresArg, [].concat(requiresArgs))
    return self
  }

  self.implies = function (key, value) {
    validation.implies(key, value)
    return self
  }

  self.usage = function (msg, opts) {
    if (!opts && typeof msg === 'object') {
      opts = msg
      msg = null
    }

    usage.usage(msg)

    if (opts) self.options(opts)

    return self
  }

  self.epilogue = self.epilog = function (msg) {
    usage.epilog(msg)
    return self
  }

  self.fail = function (f) {
    usage.failFn(f)
    return self
  }

  self.check = function (f) {
    validation.check(f)
    return self
  }

  self.defaults = self.default

  self.describe = function (key, desc) {
    options.key[key] = true
    usage.describe(key, desc)
    return self
  }

  self.parse = function (args) {
    return parseArgs(args)
  }

  self.option = self.options = function (key, opt) {
    if (typeof key === 'object') {
      Object.keys(key).forEach(function (k) {
        self.options(k, key[k])
      })
    } else {
      assert(typeof opt === 'object', 'second argument to option must be an object')

      options.key[key] = true // track manually set keys.

      if (opt.alias) self.alias(key, opt.alias)

      var demand = opt.demand || opt.required || opt.require

      if (demand) {
        self.demand(key, demand)
      } if ('config' in opt) {
        self.config(key, opt.configParser)
      } if ('default' in opt) {
        self.default(key, opt.default)
      } if ('nargs' in opt) {
        self.nargs(key, opt.nargs)
      } if ('choices' in opt) {
        self.choices(key, opt.choices)
      } if ('group' in opt) {
        self.group(key, opt.group)
      } if (opt.boolean || opt.type === 'boolean') {
        self.boolean(key)
        if (opt.alias) self.boolean(opt.alias)
      } if (opt.array || opt.type === 'array') {
        self.array(key)
        if (opt.alias) self.array(opt.alias)
      } if (opt.string || opt.type === 'string') {
        self.string(key)
        if (opt.alias) self.string(opt.alias)
      } if (opt.count || opt.type === 'count') {
        self.count(key)
      } if (opt.defaultDescription) {
        options.defaultDescription[key] = opt.defaultDescription
      }

      var desc = opt.describe || opt.description || opt.desc
      if (desc) {
        self.describe(key, desc)
      }

      if (opt.requiresArg) {
        self.requiresArg(key)
      }
    }

    return self
  }
  self.getOptions = function () {
    return options
  }

  var groups = {}
  self.group = function (opts, groupName) {
    var seen = {}
    groups[groupName] = (groups[groupName] || []).concat(opts).filter(function (key) {
      if (seen[key]) return false
      return (seen[key] = true)
    })
    return self
  }
  self.getGroups = function () {
    return groups
  }

  // as long as options.envPrefix is not undefined,
  // parser will apply env vars matching prefix to argv
  self.env = function (prefix) {
    if (prefix === false) options.envPrefix = undefined
    else options.envPrefix = prefix || ''
    return self
  }

  self.wrap = function (cols) {
    usage.wrap(cols)
    return self
  }

  var strict = false
  self.strict = function () {
    strict = true
    return self
  }
  self.getStrict = function () {
    return strict
  }

  self.showHelp = function (level) {
    if (!self.parsed) parseArgs(processArgs) // run parser, if it has not already been executed.
    usage.showHelp(level)
    return self
  }

  var versionOpt = null
  self.version = function (ver, opt, msg) {
    versionOpt = opt || 'version'
    usage.version(ver)
    self.boolean(versionOpt)
    self.describe(versionOpt, msg || usage.deferY18nLookup('Show version number'))
    return self
  }

  var helpOpt = null
  self.addHelpOpt = function (opt, msg) {
    helpOpt = opt
    self.boolean(opt)
    self.describe(opt, msg || usage.deferY18nLookup('Show help'))
    return self
  }

  self.showHelpOnFail = function (enabled, message) {
    usage.showHelpOnFail(enabled, message)
    return self
  }

  var exitProcess = true
  self.exitProcess = function (enabled) {
    if (typeof enabled !== 'boolean') {
      enabled = true
    }
    exitProcess = enabled
    return self
  }
  self.getExitProcess = function () {
    return exitProcess
  }

  self.help = function () {
    if (arguments.length > 0) return self.addHelpOpt.apply(self, arguments)

    if (!self.parsed) parseArgs(processArgs) // run parser, if it has not already been executed.

    return usage.help()
  }

  var completionCommand = null
  self.completion = function (cmd, desc, fn) {
    // a function to execute when generating
    // completions can be provided as the second
    // or third argument to completion.
    if (typeof desc === 'function') {
      fn = desc
      desc = null
    }

    // register the completion command.
    completionCommand = cmd || 'completion'
    if (!desc && desc !== false) {
      desc = 'generate bash completion script'
    }
    self.command(completionCommand, desc)

    // a function can be provided
    if (fn) completion.registerFunction(fn)

    return self
  }

  self.showCompletionScript = function ($0) {
    $0 = $0 || self.$0
    console.log(completion.generateCompletionScript($0))
    return self
  }

  self.locale = function (locale) {
    if (arguments.length === 0) {
      guessLocale()
      return y18n.getLocale()
    }
    detectLocale = false
    y18n.setLocale(locale)
    return self
  }

  self.updateStrings = self.updateLocale = function (obj) {
    detectLocale = false
    y18n.updateLocale(obj)
    return self
  }

  var detectLocale = true
  self.detectLocale = function (detect) {
    detectLocale = detect
    return self
  }
  self.getDetectLocale = function () {
    return detectLocale
  }

  self.getUsageInstance = function () {
    return usage
  }

  self.getValidationInstance = function () {
    return validation
  }

  self.terminalWidth = function () {
    return __webpack_require__(/*! window-size */ "./src/node_modules/window-size/index.js").width
  }

  Object.defineProperty(self, 'argv', {
    get: function () {
      var args = null

      try {
        args = parseArgs(processArgs)
      } catch (err) {
        usage.fail(err.message)
      }

      return args
    },
    enumerable: true
  })

  function parseArgs (args) {
    args = normalizeArgs(args)

    var parsed = Parser(args, options, y18n)
    var argv = parsed.argv
    var aliases = parsed.aliases

    argv.$0 = self.$0

    self.parsed = parsed

    guessLocale() // guess locale lazily, so that it can be turned off in chain.

    // while building up the argv object, there
    // are two passes through the parser. If completion
    // is being performed short-circuit on the first pass.
    if (completionCommand &&
      (process.argv.join(' ')).indexOf(completion.completionKey) !== -1 &&
      !argv[completion.completionKey]) {
      return argv
    }

    // if there's a handler associated with a
    // command defer processing to it.
    var handlerKeys = Object.keys(self.getCommandHandlers())
    for (var i = 0, command; (command = handlerKeys[i]) !== undefined; i++) {
      if (~argv._.indexOf(command)) {
        runCommand(command, self, argv)
        return self.argv
      }
    }

    // generate a completion script for adding to ~/.bashrc.
    if (completionCommand && ~argv._.indexOf(completionCommand) && !argv[completion.completionKey]) {
      self.showCompletionScript()
      if (exitProcess) {
        process.exit(0)
      }
    }

    // we must run completions first, a user might
    // want to complete the --help or --version option.
    if (completion.completionKey in argv) {
      // we allow for asynchronous completions,
      // e.g., loading in a list of commands from an API.
      completion.getCompletion(function (completions) {
        ;(completions || []).forEach(function (completion) {
          console.log(completion)
        })

        if (exitProcess) {
          process.exit(0)
        }
      })
      return
    }

    var helpOrVersion = false
    Object.keys(argv).forEach(function (key) {
      if (key === helpOpt && argv[key]) {
        helpOrVersion = true
        self.showHelp('log')
        if (exitProcess) {
          process.exit(0)
        }
      } else if (key === versionOpt && argv[key]) {
        helpOrVersion = true
        usage.showVersion()
        if (exitProcess) {
          process.exit(0)
        }
      }
    })

    // If the help or version options where used and exitProcess is false,
    // we won't run validations
    if (!helpOrVersion) {
      if (parsed.error) throw parsed.error

      // if we're executed via bash completion, don't
      // bother with validation.
      if (!argv[completion.completionKey]) {
        validation.nonOptionCount(argv)
        validation.missingArgumentValue(argv)
        validation.requiredArguments(argv)
        if (strict) validation.unknownArguments(argv, aliases)
        validation.customChecks(argv, aliases)
        validation.limitedChoices(argv)
        validation.implications(argv)
      }
    }

    setPlaceholderKeys(argv)

    return argv
  }

  function guessLocale () {
    if (!detectLocale) return

    try {
      var osLocale = __webpack_require__(/*! os-locale */ "./src/node_modules/os-locale/index.js")
      self.locale(osLocale.sync({ spawn: false }))
    } catch (err) {
      // if we explode looking up locale just noop
      // we'll keep using the default language 'en'.
    }
  }

  function runCommand (command, yargs, argv) {
    setPlaceholderKeys(argv)
    yargs.getCommandHandlers()[command](yargs.reset(), argv)
  }

  function setPlaceholderKeys (argv) {
    Object.keys(options.key).forEach(function (key) {
      // don't set placeholder keys for dot
      // notation options 'foo.bar'.
      if (~key.indexOf('.')) return
      if (typeof argv[key] === 'undefined') argv[key] = undefined
    })
  }

  function normalizeArgs (args) {
    if (typeof args === 'string') {
      return tokenizeArgString(args)
    }
    return args
  }

  singletonify(self)
  return self
}

// rebase an absolute path to a relative one with respect to a base directory
// exported for tests
exports.rebase = rebase
function rebase (base, dir) {
  return path.relative(base, dir)
}

/*  Hack an instance of Argv with process.argv into Argv
    so people can do
    require('yargs')(['--beeble=1','-z','zizzle']).argv
    to parse a list of args and
    require('yargs').argv
    to get a parsed version of process.argv.
*/
function singletonify (inst) {
  Object.keys(inst).forEach(function (key) {
    if (key === 'argv') {
      Argv.__defineGetter__(key, inst.__lookupGetter__(key))
    } else {
      Argv[key] = typeof inst[key] === 'function' ? inst[key].bind(inst) : inst[key]
    }
  })
}

/* WEBPACK VAR INJECTION */}.call(this, "src/node_modules/yargs"))

/***/ }),

/***/ "./src/node_modules/yargs/lib sync recursive":
/*!*****************************************!*\
  !*** ./src/node_modules/yargs/lib sync ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = function() { return []; };
webpackEmptyContext.resolve = webpackEmptyContext;
module.exports = webpackEmptyContext;
webpackEmptyContext.id = "./src/node_modules/yargs/lib sync recursive";

/***/ }),

/***/ "./src/node_modules/yargs/lib/completion.js":
/*!**************************************************!*\
  !*** ./src/node_modules/yargs/lib/completion.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(__dirname) {var fs = __webpack_require__(/*! fs */ "fs")
var path = __webpack_require__(/*! path */ "path")

// add bash completions to your
//  yargs-powered applications.
module.exports = function (yargs, usage) {
  var self = {
    completionKey: 'get-yargs-completions'
  }

  // get a list of completion commands.
  self.getCompletion = function (done) {
    var completions = []
    var current = process.argv[process.argv.length - 1]
    var previous = process.argv.slice(process.argv.indexOf('--' + self.completionKey) + 1)
    var argv = yargs.parse(previous)

    // a custom completion function can be provided
    // to completion().
    if (completionFunction) {
      if (completionFunction.length < 3) {
        var result = completionFunction(current, argv)

        // promise based completion function.
        if (typeof result.then === 'function') {
          return result.then(function (list) {
            process.nextTick(function () { done(list) })
          }).catch(function (err) {
            process.nextTick(function () { throw err })
          })
        }

        // synchronous completion function.
        return done(result)
      } else {
        // asynchronous completion function
        return completionFunction(current, argv, function (completions) {
          done(completions)
        })
      }
    }

    var handlers = yargs.getCommandHandlers()
    for (var i = 0, ii = previous.length; i < ii; ++i) {
      if (handlers[previous[i]]) {
        return handlers[previous[i]](yargs.reset())
      }
    }

    if (!current.match(/^-/)) {
      usage.getCommands().forEach(function (command) {
        if (previous.indexOf(command[0]) === -1) {
          completions.push(command[0])
        }
      })
    }

    if (current.match(/^-/)) {
      Object.keys(yargs.getOptions().key).forEach(function (key) {
        completions.push('--' + key)
      })
    }

    done(completions)
  }

  // generate the completion script to add to your .bashrc.
  self.generateCompletionScript = function ($0) {
    var script = fs.readFileSync(
      path.resolve(__dirname, '../completion.sh.hbs'),
      'utf-8'
    )
    var name = path.basename($0)

    // add ./to applications not yet installed as bin.
    if ($0.match(/\.js$/)) $0 = './' + $0

    script = script.replace(/{{app_name}}/g, name)
    return script.replace(/{{app_path}}/g, $0)
  }

  // register a function to perform your own custom
  // completions., this function can be either
  // synchrnous or asynchronous.
  var completionFunction = null
  self.registerFunction = function (fn) {
    completionFunction = fn
  }

  return self
}

/* WEBPACK VAR INJECTION */}.call(this, "src/node_modules/yargs/lib"))

/***/ }),

/***/ "./src/node_modules/yargs/lib/parser.js":
/*!**********************************************!*\
  !*** ./src/node_modules/yargs/lib/parser.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// fancy-pants parsing of argv, originally forked
// from minimist: https://www.npmjs.com/package/minimist
var camelCase = __webpack_require__(/*! camelcase */ "./src/node_modules/camelcase/index.js")
var path = __webpack_require__(/*! path */ "path")

function increment (orig) {
  return orig !== undefined ? orig + 1 : 0
}

module.exports = function (args, opts, y18n) {
  if (!opts) opts = {}

  var __ = y18n.__
  var error = null
  var flags = { arrays: {}, bools: {}, strings: {}, counts: {}, normalize: {}, configs: {}, defaulted: {} }

  ;[].concat(opts['array']).filter(Boolean).forEach(function (key) {
    flags.arrays[key] = true
  })

  ;[].concat(opts['boolean']).filter(Boolean).forEach(function (key) {
    flags.bools[key] = true
  })

  ;[].concat(opts.string).filter(Boolean).forEach(function (key) {
    flags.strings[key] = true
  })

  ;[].concat(opts.count).filter(Boolean).forEach(function (key) {
    flags.counts[key] = true
  })

  ;[].concat(opts.normalize).filter(Boolean).forEach(function (key) {
    flags.normalize[key] = true
  })

  Object.keys(opts.config).forEach(function (k) {
    flags.configs[k] = opts.config[k]
  })

  var aliases = {}
  var newAliases = {}

  extendAliases(opts.key)
  extendAliases(opts.alias)
  extendAliases(opts.default)

  var defaults = opts['default'] || {}
  Object.keys(defaults).forEach(function (key) {
    if (/-/.test(key) && !opts.alias[key]) {
      aliases[key] = aliases[key] || []
    }
    (aliases[key] || []).forEach(function (alias) {
      defaults[alias] = defaults[key]
    })
  })

  var argv = { _: [] }

  Object.keys(flags.bools).forEach(function (key) {
    setArg(key, !(key in defaults) ? false : defaults[key])
    setDefaulted(key)
  })

  var notFlags = []
  if (args.indexOf('--') !== -1) {
    notFlags = args.slice(args.indexOf('--') + 1)
    args = args.slice(0, args.indexOf('--'))
  }

  for (var i = 0; i < args.length; i++) {
    var arg = args[i]
    var broken
    var key
    var letters
    var m
    var next
    var value

    // -- seperated by =
    if (arg.match(/^--.+=/)) {
      // Using [\s\S] instead of . because js doesn't support the
      // 'dotall' regex modifier. See:
      // http://stackoverflow.com/a/1068308/13216
      m = arg.match(/^--([^=]+)=([\s\S]*)$/)

      // nargs format = '--f=monkey washing cat'
      if (checkAllAliases(m[1], opts.narg)) {
        args.splice(i + 1, m[1], m[2])
        i = eatNargs(i, m[1], args)
      // arrays format = '--f=a b c'
      } else if (checkAllAliases(m[1], flags.arrays) && args.length > i + 1) {
        args.splice(i + 1, m[1], m[2])
        i = eatArray(i, m[1], args)
      } else {
        setArg(m[1], m[2])
      }
    } else if (arg.match(/^--no-.+/)) {
      key = arg.match(/^--no-(.+)/)[1]
      setArg(key, false)

    // -- seperated by space.
    } else if (arg.match(/^--.+/)) {
      key = arg.match(/^--(.+)/)[1]

      // nargs format = '--foo a b c'
      if (checkAllAliases(key, opts.narg)) {
        i = eatNargs(i, key, args)
      // array format = '--foo a b c'
      } else if (checkAllAliases(key, flags.arrays) && args.length > i + 1) {
        i = eatArray(i, key, args)
      } else {
        next = args[i + 1]

        if (next !== undefined && !next.match(/^-/) &&
          !checkAllAliases(key, flags.bools) &&
          !checkAllAliases(key, flags.counts)) {
          setArg(key, next)
          i++
        } else if (/^(true|false)$/.test(next)) {
          setArg(key, next)
          i++
        } else {
          setArg(key, defaultForType(guessType(key, flags)))
        }
      }

    // dot-notation flag seperated by '='.
    } else if (arg.match(/^-.\..+=/)) {
      m = arg.match(/^-([^=]+)=([\s\S]*)$/)
      setArg(m[1], m[2])

    // dot-notation flag seperated by space.
    } else if (arg.match(/^-.\..+/)) {
      next = args[i + 1]
      key = arg.match(/^-(.\..+)/)[1]

      if (next !== undefined && !next.match(/^-/) &&
        !checkAllAliases(key, flags.bools) &&
        !checkAllAliases(key, flags.counts)) {
        setArg(key, next)
        i++
      } else {
        setArg(key, defaultForType(guessType(key, flags)))
      }
    } else if (arg.match(/^-[^-]+/)) {
      letters = arg.slice(1, -1).split('')
      broken = false

      for (var j = 0; j < letters.length; j++) {
        next = arg.slice(j + 2)

        if (letters[j + 1] && letters[j + 1] === '=') {
          value = arg.slice(j + 3)
          key = letters[j]

          // nargs format = '-f=monkey washing cat'
          if (checkAllAliases(letters[j], opts.narg)) {
            args.splice(i + 1, 0, value)
            i = eatNargs(i, key, args)
          // array format = '-f=a b c'
          } else if (checkAllAliases(key, flags.arrays) && args.length > i + 1) {
            args.splice(i + 1, 0, value)
            i = eatArray(i, key, args)
          } else {
            setArg(key, value)
          }

          broken = true
          break
        }

        if (next === '-') {
          setArg(letters[j], next)
          continue
        }

        if (/[A-Za-z]/.test(letters[j]) &&
          /-?\d+(\.\d*)?(e-?\d+)?$/.test(next)) {
          setArg(letters[j], next)
          broken = true
          break
        }

        if (letters[j + 1] && letters[j + 1].match(/\W/)) {
          setArg(letters[j], arg.slice(j + 2))
          broken = true
          break
        } else {
          setArg(letters[j], defaultForType(guessType(letters[j], flags)))
        }
      }

      key = arg.slice(-1)[0]

      if (!broken && key !== '-') {
        // nargs format = '-f a b c'
        if (checkAllAliases(key, opts.narg)) {
          i = eatNargs(i, key, args)
        // array format = '-f a b c'
        } else if (checkAllAliases(key, flags.arrays) && args.length > i + 1) {
          i = eatArray(i, key, args)
        } else {
          if (args[i + 1] && !/^(-|--)[^-]/.test(args[i + 1]) &&
            !checkAllAliases(key, flags.bools) &&
            !checkAllAliases(key, flags.counts)) {
            setArg(key, args[i + 1])
            i++
          } else if (args[i + 1] && /true|false/.test(args[i + 1])) {
            setArg(key, args[i + 1])
            i++
          } else {
            setArg(key, defaultForType(guessType(key, flags)))
          }
        }
      }
    } else {
      argv._.push(
        flags.strings['_'] || !isNumber(arg) ? arg : Number(arg)
      )
    }
  }

  // order of precedence:
  // 1. command line arg
  // 2. value from config file
  // 3. value from env var
  // 4. configured default value
  applyEnvVars(opts, argv, true) // special case: check env vars that point to config file
  setConfig(argv)
  applyEnvVars(opts, argv, false)
  applyDefaultsAndAliases(argv, aliases, defaults)

  Object.keys(flags.counts).forEach(function (key) {
    setArg(key, defaults[key])
  })

  notFlags.forEach(function (key) {
    argv._.push(key)
  })

  // how many arguments should we consume, based
  // on the nargs option?
  function eatNargs (i, key, args) {
    var toEat = checkAllAliases(key, opts.narg)

    if (args.length - (i + 1) < toEat) error = Error(__('Not enough arguments following: %s', key))

    for (var ii = i + 1; ii < (toEat + i + 1); ii++) {
      setArg(key, args[ii])
    }

    return (i + toEat)
  }

  // if an option is an array, eat all non-hyphenated arguments
  // following it... YUM!
  // e.g., --foo apple banana cat becomes ["apple", "banana", "cat"]
  function eatArray (i, key, args) {
    for (var ii = i + 1; ii < args.length; ii++) {
      if (/^-/.test(args[ii])) break
      i = ii
      setArg(key, args[ii])
    }

    return i
  }

  function setArg (key, val) {
    unsetDefaulted(key)

    // handle parsing boolean arguments --foo=true --bar false.
    if (checkAllAliases(key, flags.bools) || checkAllAliases(key, flags.counts)) {
      if (typeof val === 'string') val = val === 'true'
    }

    if (/-/.test(key) && !(aliases[key] && aliases[key].length)) {
      var c = camelCase(key)
      aliases[key] = [c]
      newAliases[c] = true
    }

    var value = !checkAllAliases(key, flags.strings) && isNumber(val) ? Number(val) : val

    if (checkAllAliases(key, flags.counts)) {
      value = increment
    }

    var splitKey = key.split('.')
    setKey(argv, splitKey, value)

    // alias references an inner-value within
    // a dot-notation object. see #279.
    if (~key.indexOf('.') && aliases[key]) {
      aliases[key].forEach(function (x) {
        x = x.split('.')
        setKey(argv, x, value)
      })
    }

    ;(aliases[splitKey[0]] || []).forEach(function (x) {
      x = x.split('.')

      // handle populating dot notation for both
      // the key and its aliases.
      if (splitKey.length > 1) {
        var a = [].concat(splitKey)
        a.shift() // nuke the old key.
        x = x.concat(a)
      }

      setKey(argv, x, value)
    })

    var keys = [key].concat(aliases[key] || [])
    for (var i = 0, l = keys.length; i < l; i++) {
      if (flags.normalize[keys[i]]) {
        keys.forEach(function (key) {
          argv.__defineSetter__(key, function (v) {
            val = path.normalize(v)
          })

          argv.__defineGetter__(key, function () {
            return typeof val === 'string' ? path.normalize(val) : val
          })
        })
        break
      }
    }
  }

  // set args from config.json file, this should be
  // applied last so that defaults can be applied.
  function setConfig (argv) {
    var configLookup = {}

    // expand defaults/aliases, in-case any happen to reference
    // the config.json file.
    applyDefaultsAndAliases(configLookup, aliases, defaults)

    Object.keys(flags.configs).forEach(function (configKey) {
      var configPath = argv[configKey] || configLookup[configKey]
      if (configPath) {
        try {
          var config = null
          var resolvedConfigPath = path.resolve(process.cwd(), configPath)

          if (typeof flags.configs[configKey] === 'function') {
            try {
              config = flags.configs[configKey](resolvedConfigPath)
            } catch (e) {
              config = e
            }
            if (config instanceof Error) {
              error = config
              return
            }
          } else {
            config = __webpack_require__("./src/node_modules/yargs/lib sync recursive")(resolvedConfigPath)
          }

          Object.keys(config).forEach(function (key) {
            // setting arguments via CLI takes precedence over
            // values within the config file.
            if (argv[key] === undefined || (flags.defaulted[key])) {
              delete argv[key]
              setArg(key, config[key])
            }
          })
        } catch (ex) {
          if (argv[configKey]) error = Error(__('Invalid JSON config file: %s', configPath))
        }
      }
    })
  }

  function applyEnvVars (opts, argv, configOnly) {
    if (typeof opts.envPrefix === 'undefined') return

    var prefix = typeof opts.envPrefix === 'string' ? opts.envPrefix : ''
    Object.keys(process.env).forEach(function (envVar) {
      if (prefix === '' || envVar.lastIndexOf(prefix, 0) === 0) {
        var key = camelCase(envVar.substring(prefix.length))
        if (((configOnly && flags.configs[key]) || !configOnly) && (!(key in argv) || flags.defaulted[key])) {
          setArg(key, process.env[envVar])
        }
      }
    })
  }

  function applyDefaultsAndAliases (obj, aliases, defaults) {
    Object.keys(defaults).forEach(function (key) {
      if (!hasKey(obj, key.split('.'))) {
        setKey(obj, key.split('.'), defaults[key])

        ;(aliases[key] || []).forEach(function (x) {
          if (hasKey(obj, x.split('.'))) return
          setKey(obj, x.split('.'), defaults[key])
        })
      }
    })
  }

  function hasKey (obj, keys) {
    var o = obj
    keys.slice(0, -1).forEach(function (key) {
      o = (o[key] || {})
    })

    var key = keys[keys.length - 1]

    if (typeof o !== 'object') return false
    else return key in o
  }

  function setKey (obj, keys, value) {
    var o = obj
    keys.slice(0, -1).forEach(function (key) {
      if (o[key] === undefined) o[key] = {}
      o = o[key]
    })

    var key = keys[keys.length - 1]
    if (value === increment) {
      o[key] = increment(o[key])
    } else if (o[key] === undefined && checkAllAliases(key, flags.arrays)) {
      o[key] = Array.isArray(value) ? value : [value]
    } else if (o[key] === undefined || typeof o[key] === 'boolean') {
      o[key] = value
    } else if (Array.isArray(o[key])) {
      o[key].push(value)
    } else {
      o[key] = [ o[key], value ]
    }
  }

  // extend the aliases list with inferred aliases.
  function extendAliases (obj) {
    Object.keys(obj || {}).forEach(function (key) {
      // short-circuit if we've already added a key
      // to the aliases array, for example it might
      // exist in both 'opts.default' and 'opts.key'.
      if (aliases[key]) return

      aliases[key] = [].concat(opts.alias[key] || [])
      // For "--option-name", also set argv.optionName
      aliases[key].concat(key).forEach(function (x) {
        if (/-/.test(x)) {
          var c = camelCase(x)
          aliases[key].push(c)
          newAliases[c] = true
        }
      })
      aliases[key].forEach(function (x) {
        aliases[x] = [key].concat(aliases[key].filter(function (y) {
          return x !== y
        }))
      })
    })
  }

  // check if a flag is set for any of a key's aliases.
  function checkAllAliases (key, flag) {
    var isSet = false
    var toCheck = [].concat(aliases[key] || [], key)

    toCheck.forEach(function (key) {
      if (flag[key]) isSet = flag[key]
    })

    return isSet
  }

  function setDefaulted (key) {
    [].concat(aliases[key] || [], key).forEach(function (k) {
      flags.defaulted[k] = true
    })
  }

  function unsetDefaulted (key) {
    [].concat(aliases[key] || [], key).forEach(function (k) {
      delete flags.defaulted[k]
    })
  }

  // return a default value, given the type of a flag.,
  // e.g., key of type 'string' will default to '', rather than 'true'.
  function defaultForType (type) {
    var def = {
      boolean: true,
      string: '',
      array: []
    }

    return def[type]
  }

  // given a flag, enforce a default type.
  function guessType (key, flags) {
    var type = 'boolean'

    if (flags.strings && flags.strings[key]) type = 'string'
    else if (flags.arrays && flags.arrays[key]) type = 'array'

    return type
  }

  function isNumber (x) {
    if (typeof x === 'number') return true
    if (/^0x[0-9a-f]+$/i.test(x)) return true
    return /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(x)
  }

  return {
    argv: argv,
    aliases: aliases,
    error: error,
    newAliases: newAliases
  }
}


/***/ }),

/***/ "./src/node_modules/yargs/lib/tokenize-arg-string.js":
/*!***********************************************************!*\
  !*** ./src/node_modules/yargs/lib/tokenize-arg-string.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// take an un-split argv string and tokenize it.
module.exports = function (argString) {
  var i = 0
  var c = null
  var opening = null
  var args = []

  for (var ii = 0; ii < argString.length; ii++) {
    c = argString.charAt(ii)

    // split on spaces unless we're in quotes.
    if (c === ' ' && !opening) {
      i++
      continue
    }

    // don't split the string if we're in matching
    // opening or closing single and double quotes.
    if (c === opening) {
      opening = null
      continue
    } else if ((c === "'" || c === '"') && !opening) {
      opening = c
      continue
    }

    if (!args[i]) args[i] = ''
    args[i] += c
  }

  return args
}


/***/ }),

/***/ "./src/node_modules/yargs/lib/usage.js":
/*!*********************************************!*\
  !*** ./src/node_modules/yargs/lib/usage.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// this file handles outputting usage instructions,
// failures, etc. keeps logging in one place.
var cliui = __webpack_require__(/*! cliui */ "./src/node_modules/cliui/index.js")
var decamelize = __webpack_require__(/*! decamelize */ "./src/node_modules/decamelize/index.js")
var stringWidth = __webpack_require__(/*! string-width */ "./src/node_modules/string-width/index.js")
var wsize = __webpack_require__(/*! window-size */ "./src/node_modules/window-size/index.js")

module.exports = function (yargs, y18n) {
  var __ = y18n.__
  var self = {}

  // methods for ouputting/building failure message.
  var fails = []
  self.failFn = function (f) {
    fails.push(f)
  }

  var failMessage = null
  var showHelpOnFail = true
  self.showHelpOnFail = function (enabled, message) {
    if (typeof enabled === 'string') {
      message = enabled
      enabled = true
    } else if (typeof enabled === 'undefined') {
      enabled = true
    }
    failMessage = message
    showHelpOnFail = enabled
    return self
  }

  var failureOutput = false
  self.fail = function (msg) {
    if (fails.length) {
      fails.forEach(function (f) {
        f(msg)
      })
    } else {
      // don't output failure message more than once
      if (!failureOutput) {
        failureOutput = true
        if (showHelpOnFail) yargs.showHelp('error')
        if (msg) console.error(msg)
        if (failMessage) {
          if (msg) console.error('')
          console.error(failMessage)
        }
      }
      if (yargs.getExitProcess()) {
        process.exit(1)
      } else {
        throw new Error(msg)
      }
    }
  }

  // methods for ouputting/building help (usage) message.
  var usage
  self.usage = function (msg) {
    usage = msg
  }

  var examples = []
  self.example = function (cmd, description) {
    examples.push([cmd, description || ''])
  }

  var commands = []
  self.command = function (cmd, description) {
    commands.push([cmd, description || ''])
  }
  self.getCommands = function () {
    return commands
  }

  var descriptions = {}
  self.describe = function (key, desc) {
    if (typeof key === 'object') {
      Object.keys(key).forEach(function (k) {
        self.describe(k, key[k])
      })
    } else {
      descriptions[key] = desc
    }
  }
  self.getDescriptions = function () {
    return descriptions
  }

  var epilog
  self.epilog = function (msg) {
    epilog = msg
  }

  var wrap = windowWidth()
  self.wrap = function (cols) {
    wrap = cols
  }

  var deferY18nLookupPrefix = '__yargsString__:'
  self.deferY18nLookup = function (str) {
    return deferY18nLookupPrefix + str
  }

  var defaultGroup = 'Options:'
  self.help = function () {
    normalizeAliases()

    var demanded = yargs.getDemanded()
    var groups = yargs.getGroups()
    var options = yargs.getOptions()
    var keys = Object.keys(
      Object.keys(descriptions)
      .concat(Object.keys(demanded))
      .concat(Object.keys(options.default))
      .reduce(function (acc, key) {
        if (key !== '_') acc[key] = true
        return acc
      }, {})
    )
    var ui = cliui({
      width: wrap,
      wrap: !!wrap
    })

    // the usage string.
    if (usage) {
      var u = usage.replace(/\$0/g, yargs.$0)
      ui.div(u + '\n')
    }

    // your application's commands, i.e., non-option
    // arguments populated in '_'.
    if (commands.length) {
      ui.div(__('Commands:'))

      commands.forEach(function (command) {
        ui.div(
          {text: command[0], padding: [0, 2, 0, 2], width: maxWidth(commands) + 4},
          {text: command[1]}
        )
      })

      ui.div()
    }

    // perform some cleanup on the keys array, making it
    // only include top-level keys not their aliases.
    var aliasKeys = (Object.keys(options.alias) || [])
      .concat(Object.keys(yargs.parsed.newAliases) || [])

    keys = keys.filter(function (key) {
      return !yargs.parsed.newAliases[key] && aliasKeys.every(function (alias) {
        return (options.alias[alias] || []).indexOf(key) === -1
      })
    })

    // populate 'Options:' group with any keys that have not
    // explicitly had a group set.
    if (!groups[defaultGroup]) groups[defaultGroup] = []
    addUngroupedKeys(keys, options.alias, groups)

    // display 'Options:' table along with any custom tables:
    Object.keys(groups).forEach(function (groupName) {
      if (!groups[groupName].length) return

      ui.div(__(groupName))

      // if we've grouped the key 'f', but 'f' aliases 'foobar',
      // normalizedKeys should contain only 'foobar'.
      var normalizedKeys = groups[groupName].map(function (key) {
        if (~aliasKeys.indexOf(key)) return key
        for (var i = 0, aliasKey; (aliasKey = aliasKeys[i]) !== undefined; i++) {
          if (~(options.alias[aliasKey] || []).indexOf(key)) return aliasKey
        }
        return key
      })

      // actually generate the switches string --foo, -f, --bar.
      var switches = normalizedKeys.reduce(function (acc, key) {
        acc[key] = [ key ].concat(options.alias[key] || [])
          .map(function (sw) {
            return (sw.length > 1 ? '--' : '-') + sw
          })
          .join(', ')

        return acc
      }, {})

      normalizedKeys.forEach(function (key) {
        var kswitch = switches[key]
        var desc = descriptions[key] || ''
        var type = null

        if (~desc.lastIndexOf(deferY18nLookupPrefix)) desc = __(desc.substring(deferY18nLookupPrefix.length))

        if (~options.boolean.indexOf(key)) type = '[' + __('boolean') + ']'
        if (~options.count.indexOf(key)) type = '[' + __('count') + ']'
        if (~options.string.indexOf(key)) type = '[' + __('string') + ']'
        if (~options.normalize.indexOf(key)) type = '[' + __('string') + ']'
        if (~options.array.indexOf(key)) type = '[' + __('array') + ']'

        var extra = [
          type,
          demanded[key] ? '[' + __('required') + ']' : null,
          options.choices && options.choices[key] ? '[' + __('choices:') + ' ' +
            self.stringifiedValues(options.choices[key]) + ']' : null,
          defaultString(options.default[key], options.defaultDescription[key])
        ].filter(Boolean).join(' ')

        ui.span(
          {text: kswitch, padding: [0, 2, 0, 2], width: maxWidth(switches) + 4},
          desc
        )

        if (extra) ui.div({text: extra, padding: [0, 0, 0, 2], align: 'right'})
        else ui.div()
      })

      ui.div()
    })

    // describe some common use-cases for your application.
    if (examples.length) {
      ui.div(__('Examples:'))

      examples.forEach(function (example) {
        example[0] = example[0].replace(/\$0/g, yargs.$0)
      })

      examples.forEach(function (example) {
        ui.div(
          {text: example[0], padding: [0, 2, 0, 2], width: maxWidth(examples) + 4},
          example[1]
        )
      })

      ui.div()
    }

    // the usage string.
    if (epilog) {
      var e = epilog.replace(/\$0/g, yargs.$0)
      ui.div(e + '\n')
    }

    return ui.toString()
  }

  // return the maximum width of a string
  // in the left-hand column of a table.
  function maxWidth (table) {
    var width = 0

    // table might be of the form [leftColumn],
    // or {key: leftColumn}}
    if (!Array.isArray(table)) {
      table = Object.keys(table).map(function (key) {
        return [table[key]]
      })
    }

    table.forEach(function (v) {
      width = Math.max(stringWidth(v[0]), width)
    })

    // if we've enabled 'wrap' we should limit
    // the max-width of the left-column.
    if (wrap) width = Math.min(width, parseInt(wrap * 0.5, 10))

    return width
  }

  // make sure any options set for aliases,
  // are copied to the keys being aliased.
  function normalizeAliases () {
    var demanded = yargs.getDemanded()
    var options = yargs.getOptions()

    ;(Object.keys(options.alias) || []).forEach(function (key) {
      options.alias[key].forEach(function (alias) {
        // copy descriptions.
        if (descriptions[alias]) self.describe(key, descriptions[alias])
        // copy demanded.
        if (demanded[alias]) yargs.demand(key, demanded[alias].msg)
        // type messages.
        if (~options.boolean.indexOf(alias)) yargs.boolean(key)
        if (~options.count.indexOf(alias)) yargs.count(key)
        if (~options.string.indexOf(alias)) yargs.string(key)
        if (~options.normalize.indexOf(alias)) yargs.normalize(key)
        if (~options.array.indexOf(alias)) yargs.array(key)
      })
    })
  }

  // given a set of keys, place any keys that are
  // ungrouped under the 'Options:' grouping.
  function addUngroupedKeys (keys, aliases, groups) {
    var groupedKeys = []
    var toCheck = null
    Object.keys(groups).forEach(function (group) {
      groupedKeys = groupedKeys.concat(groups[group])
    })

    keys.forEach(function (key) {
      toCheck = [key].concat(aliases[key])
      if (!toCheck.some(function (k) {
        return groupedKeys.indexOf(k) !== -1
      })) {
        groups[defaultGroup].push(key)
      }
    })
    return groupedKeys
  }

  self.showHelp = function (level) {
    level = level || 'error'
    console[level](self.help())
  }

  self.functionDescription = function (fn) {
    var description = fn.name ? decamelize(fn.name, '-') : __('generated-value')
    return ['(', description, ')'].join('')
  }

  self.stringifiedValues = function (values, separator) {
    var string = ''
    var sep = separator || ', '
    var array = [].concat(values)

    if (!values || !array.length) return string

    array.forEach(function (value) {
      if (string.length) string += sep
      string += JSON.stringify(value)
    })

    return string
  }

  // format the default-value-string displayed in
  // the right-hand column.
  function defaultString (value, defaultDescription) {
    var string = '[' + __('default:') + ' '

    if (value === undefined && !defaultDescription) return null

    if (defaultDescription) {
      string += defaultDescription
    } else {
      switch (typeof value) {
        case 'string':
          string += JSON.stringify(value)
          break
        case 'object':
          string += JSON.stringify(value)
          break
        default:
          string += value
      }
    }

    return string + ']'
  }

  // guess the width of the console window, max-width 80.
  function windowWidth () {
    return wsize.width ? Math.min(80, wsize.width) : null
  }

  // logic for displaying application version.
  var version = null
  self.version = function (ver, opt, msg) {
    version = ver
  }

  self.showVersion = function () {
    if (typeof version === 'function') console.log(version())
    else console.log(version)
  }

  return self
}


/***/ }),

/***/ "./src/node_modules/yargs/lib/validation.js":
/*!**************************************************!*\
  !*** ./src/node_modules/yargs/lib/validation.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// validation-type-stuff, missing params,
// bad implications, custom checks.
module.exports = function (yargs, usage, y18n) {
  var __ = y18n.__
  var __n = y18n.__n
  var self = {}

  // validate appropriate # of non-option
  // arguments were provided, i.e., '_'.
  self.nonOptionCount = function (argv) {
    var demanded = yargs.getDemanded()
    var _s = argv._.length

    if (demanded._ && (_s < demanded._.count || _s > demanded._.max)) {
      if (demanded._.msg !== undefined) {
        usage.fail(demanded._.msg)
      } else if (_s < demanded._.count) {
        usage.fail(
          __('Not enough non-option arguments: got %s, need at least %s', argv._.length, demanded._.count)
        )
      } else {
        usage.fail(
          __('Too many non-option arguments: got %s, maximum of %s', argv._.length, demanded._.max)
        )
      }
    }
  }

  // make sure that any args that require an
  // value (--foo=bar), have a value.
  self.missingArgumentValue = function (argv) {
    var defaultValues = [true, false, '']
    var options = yargs.getOptions()

    if (options.requiresArg.length > 0) {
      var missingRequiredArgs = []

      options.requiresArg.forEach(function (key) {
        var value = argv[key]

        // if a value is explicitly requested,
        // flag argument as missing if it does not
        // look like foo=bar was entered.
        if (~defaultValues.indexOf(value) ||
          (Array.isArray(value) && !value.length)) {
          missingRequiredArgs.push(key)
        }
      })

      if (missingRequiredArgs.length > 0) {
        usage.fail(__n(
          'Missing argument value: %s',
          'Missing argument values: %s',
          missingRequiredArgs.length,
          missingRequiredArgs.join(', ')
        ))
      }
    }
  }

  // make sure all the required arguments are present.
  self.requiredArguments = function (argv) {
    var demanded = yargs.getDemanded()
    var missing = null

    Object.keys(demanded).forEach(function (key) {
      if (!argv.hasOwnProperty(key)) {
        missing = missing || {}
        missing[key] = demanded[key]
      }
    })

    if (missing) {
      var customMsgs = []
      Object.keys(missing).forEach(function (key) {
        var msg = missing[key].msg
        if (msg && customMsgs.indexOf(msg) < 0) {
          customMsgs.push(msg)
        }
      })

      var customMsg = customMsgs.length ? '\n' + customMsgs.join('\n') : ''

      usage.fail(__n(
        'Missing required argument: %s',
        'Missing required arguments: %s',
        Object.keys(missing).length,
        Object.keys(missing).join(', ') + customMsg
      ))
    }
  }

  // check for unknown arguments (strict-mode).
  self.unknownArguments = function (argv, aliases) {
    var aliasLookup = {}
    var descriptions = usage.getDescriptions()
    var demanded = yargs.getDemanded()
    var unknown = []

    Object.keys(aliases).forEach(function (key) {
      aliases[key].forEach(function (alias) {
        aliasLookup[alias] = key
      })
    })

    Object.keys(argv).forEach(function (key) {
      if (key !== '$0' && key !== '_' &&
        !descriptions.hasOwnProperty(key) &&
        !demanded.hasOwnProperty(key) &&
        !aliasLookup.hasOwnProperty(key)) {
        unknown.push(key)
      }
    })

    if (unknown.length > 0) {
      usage.fail(__n(
        'Unknown argument: %s',
        'Unknown arguments: %s',
        unknown.length,
        unknown.join(', ')
      ))
    }
  }

  // validate arguments limited to enumerated choices
  self.limitedChoices = function (argv) {
    var options = yargs.getOptions()
    var invalid = {}

    if (!Object.keys(options.choices).length) return

    Object.keys(argv).forEach(function (key) {
      if (key !== '$0' && key !== '_' &&
        options.choices.hasOwnProperty(key)) {
        [].concat(argv[key]).forEach(function (value) {
          // TODO case-insensitive configurability
          if (options.choices[key].indexOf(value) === -1) {
            invalid[key] = (invalid[key] || []).concat(value)
          }
        })
      }
    })

    var invalidKeys = Object.keys(invalid)

    if (!invalidKeys.length) return

    var msg = __('Invalid values:')
    invalidKeys.forEach(function (key) {
      msg += '\n  ' + __(
        'Argument: %s, Given: %s, Choices: %s',
        key,
        usage.stringifiedValues(invalid[key]),
        usage.stringifiedValues(options.choices[key])
      )
    })
    usage.fail(msg)
  }

  // custom checks, added using the `check` option on yargs.
  var checks = []
  self.check = function (f) {
    checks.push(f)
  }

  self.customChecks = function (argv, aliases) {
    checks.forEach(function (f) {
      try {
        var result = f(argv, aliases)
        if (!result) {
          usage.fail(__('Argument check failed: %s', f.toString()))
        } else if (typeof result === 'string') {
          usage.fail(result)
        }
      } catch (err) {
        usage.fail(err.message ? err.message : err)
      }
    })
  }

  // check implications, argument foo implies => argument bar.
  var implied = {}
  self.implies = function (key, value) {
    if (typeof key === 'object') {
      Object.keys(key).forEach(function (k) {
        self.implies(k, key[k])
      })
    } else {
      implied[key] = value
    }
  }
  self.getImplied = function () {
    return implied
  }

  self.implications = function (argv) {
    var implyFail = []

    Object.keys(implied).forEach(function (key) {
      var num
      var origKey = key
      var value = implied[key]

      // convert string '1' to number 1
      num = Number(key)
      key = isNaN(num) ? key : num

      if (typeof key === 'number') {
        // check length of argv._
        key = argv._.length >= key
      } else if (key.match(/^--no-.+/)) {
        // check if key doesn't exist
        key = key.match(/^--no-(.+)/)[1]
        key = !argv[key]
      } else {
        // check if key exists
        key = argv[key]
      }

      num = Number(value)
      value = isNaN(num) ? value : num

      if (typeof value === 'number') {
        value = argv._.length >= value
      } else if (value.match(/^--no-.+/)) {
        value = value.match(/^--no-(.+)/)[1]
        value = !argv[value]
      } else {
        value = argv[value]
      }

      if (key && !value) {
        implyFail.push(origKey)
      }
    })

    if (implyFail.length) {
      var msg = __('Implications failed:') + '\n'

      implyFail.forEach(function (key) {
        msg += ('  ' + key + ' -> ' + implied[key])
      })

      usage.fail(msg)
    }
  }

  return self
}


/***/ }),

/***/ "./src/utils/util.js":
/*!***************************!*\
  !*** ./src/utils/util.js ***!
  \***************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! url */ "url");
/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(url__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! electron */ "electron");
/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(electron__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var valid_url__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! valid-url */ "./src/node_modules/valid-url/index.js");
/* harmony import */ var valid_url__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(valid_url__WEBPACK_IMPORTED_MODULE_2__);
// Copyright (c) 2015-2016 Yuya Ochiai
// Copyright (c) 2016-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.





function getDomain(inputURL) {
  const parsedURL = url__WEBPACK_IMPORTED_MODULE_0___default.a.parse(inputURL);
  return `${parsedURL.protocol}//${parsedURL.host}`;
}

function isValidURL(testURL) {
  return Boolean(Object(valid_url__WEBPACK_IMPORTED_MODULE_2__["isHttpUri"])(testURL) || Object(valid_url__WEBPACK_IMPORTED_MODULE_2__["isHttpsUri"])(testURL));
}

function isValidURI(testURL) {
  return Boolean(Object(valid_url__WEBPACK_IMPORTED_MODULE_2__["isUri"])(testURL));
}

// isInternalURL determines if the target url is internal to the application.
// - currentURL is the current url inside the webview
// - basename is the global export from the Mattermost application defining the subpath, if any
function isInternalURL(targetURL, currentURL, basename = '/') {
  if (targetURL.host !== currentURL.host) {
    return false;
  }

  if (!(targetURL.pathname || '/').startsWith(basename)) {
    return false;
  }

  return true;
}

function getDisplayBoundaries() {
  const {screen} = electron__WEBPACK_IMPORTED_MODULE_1___default.a;

  const displays = screen.getAllDisplays();

  return displays.map((display) => {
    return {
      maxX: display.workArea.x + display.workArea.width,
      maxY: display.workArea.y + display.workArea.height,
      minX: display.workArea.x,
      minY: display.workArea.y,
      maxWidth: display.workArea.width,
      maxHeight: display.workArea.height,
    };
  });
}

/* harmony default export */ __webpack_exports__["default"] = ({
  getDomain,
  isValidURL,
  isValidURI,
  isInternalURL,
  getDisplayBoundaries,
});


/***/ }),

/***/ "assert":
/*!*************************!*\
  !*** external "assert" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("assert");

/***/ }),

/***/ "child_process":
/*!********************************!*\
  !*** external "child_process" ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("child_process");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("crypto");

/***/ }),

/***/ "electron":
/*!***************************!*\
  !*** external "electron" ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("electron");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("events");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("fs");

/***/ }),

/***/ "http":
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("http");

/***/ }),

/***/ "https":
/*!************************!*\
  !*** external "https" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("https");

/***/ }),

/***/ "net":
/*!**********************!*\
  !*** external "net" ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("net");

/***/ }),

/***/ "os":
/*!*********************!*\
  !*** external "os" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("os");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("path");

/***/ }),

/***/ "punycode":
/*!***************************!*\
  !*** external "punycode" ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("punycode");

/***/ }),

/***/ "stream":
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("stream");

/***/ }),

/***/ "tty":
/*!**********************!*\
  !*** external "tty" ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("tty");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("url");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("util");

/***/ }),

/***/ "zlib":
/*!***********************!*\
  !*** external "zlib" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("zlib");

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tbW9uL0pzb25GaWxlTWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tbW9uL2NvbmZpZy9SZWdpc3RyeUNvbmZpZy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tbW9uL2NvbmZpZy9idWlsZENvbmZpZy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tbW9uL2NvbmZpZy9kZWZhdWx0UHJlZmVyZW5jZXMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbW1vbi9jb25maWcvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbW1vbi9jb25maWcvcGFzdERlZmF1bHRQcmVmZXJlbmNlcy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tbW9uL2NvbmZpZy91cGdyYWRlUHJlZmVyZW5jZXMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21haW4uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21haW4vQXBwU3RhdGVNYW5hZ2VyLmpzIiwid2VicGFjazovLy8uL3NyYy9tYWluL0F1dG9MYXVuY2hlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbWFpbi9Dcml0aWNhbEVycm9ySGFuZGxlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbWFpbi9QYXJzZUFyZ3MuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21haW4vU3BlbGxDaGVja2VyLmpzIiwid2VicGFjazovLy8uL3NyYy9tYWluL1VzZXJBY3Rpdml0eU1vbml0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21haW4vVmFsaWRhdG9yLmpzIiwid2VicGFjazovLy8uL3NyYy9tYWluL2FsbG93UHJvdG9jb2xEaWFsb2cuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21haW4vYXV0b0xhdW5jaC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbWFpbi9jZXJ0aWZpY2F0ZVN0b3JlLmpzIiwid2VicGFjazovLy8uL3NyYy9tYWluL2Nvb2tpZU1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21haW4vZG93bmxvYWRVUkwuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21haW4vbWFpbldpbmRvdy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbWFpbi9tZW51cy9hcHAuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21haW4vbWVudXMvdHJheS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbWFpbi91dGlscy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbm9kZV9tb2R1bGVzLzd6aXAvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL25vZGVfbW9kdWxlcy9AaGFwaS9hZGRyZXNzL2xpYi9hYm5mLmpzIiwid2VicGFjazovLy8uL3NyYy9ub2RlX21vZHVsZXMvQGhhcGkvYWRkcmVzcy9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL25vZGVfbW9kdWxlcy9AaGFwaS9hZGRyZXNzL2xpYi90bGRzLmpzIiwid2VicGFjazovLy8uL3NyYy9ub2RlX21vZHVsZXMvQGhhcGkvaG9lay9saWIvZGVlcC1lcXVhbC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbm9kZV9tb2R1bGVzL0BoYXBpL2hvZWsvbGliL2VzY2FwZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbm9kZV9tb2R1bGVzL0BoYXBpL2hvZWsvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9ub2RlX21vZHVsZXMvQGhhcGkvaG9lay9saWIvdHlwZXMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL25vZGVfbW9kdWxlcy9AaGFwaS9qb2kvbGliL2Nhc3QuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL25vZGVfbW9kdWxlcy9AaGFwaS9qb2kvbGliL2Vycm9ycy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbm9kZV9tb2R1bGVzL0BoYXBpL2pvaS9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL25vZGVfbW9kdWxlcy9AaGFwaS9qb2kvbGliL2xhbmd1YWdlLmpzIiwid2VicGFjazovLy8uL3NyYy9ub2RlX21vZHVsZXMvQGhhcGkvam9pL2xpYi9yZWYuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL25vZGVfbW9kdWxlcy9AaGFwaS9qb2kvbGliL3NjaGVtYXMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL25vZGVfbW9kdWxlcy9AaGFwaS9qb2kvbGliL3NldC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbm9kZV9tb2R1bGVzL0BoYXBpL2pvaS9saWIvdHlwZXMvYWx0ZXJuYXRpdmVzL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9ub2RlX21vZHVsZXMvQGhhcGkvam9pL2xpYi90eXBlcy9hbnkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL25vZGVfbW9kdWxlcy9AaGFwaS9qb2kvbGliL3R5cGVzL2FueS9zZXR0aW5ncy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbm9kZV9tb2R1bGVzL0BoYXBpL2pvaS9saWIvdHlwZXMvYXJyYXkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL25vZGVfbW9kdWxlcy9AaGFwaS9qb2kvbGliL3R5cGVzL2JpbmFyeS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbm9kZV9tb2R1bGVzL0BoYXBpL2pvaS9saWIvdHlwZXMvYm9vbGVhbi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbm9kZV9tb2R1bGVzL0BoYXBpL2pvaS9saWIvdHlwZXMvZGF0ZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbm9kZV9tb2R1bGVzL0BoYXBpL2pvaS9saWIvdHlwZXMvZnVuYy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbm9kZV9tb2R1bGVzL0BoYXBpL2pvaS9saWIvdHlwZXMvbGF6eS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbm9kZV9tb2R1bGVzL0BoYXBpL2pvaS9saWIvdHlwZXMvbnVtYmVyL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9ub2RlX21vZHVsZXMvQGhhcGkvam9pL2xpYi90eXBlcy9vYmplY3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL25vZGVfbW9kdWxlcy9AaGFwaS9qb2kvbGliL3R5cGVzL3N0YXRlLmpzIiwid2VicGFjazovLy8uL3NyYy9ub2RlX21vZHVsZXMvQGhhcGkvam9pL2xpYi90eXBlcy9zdHJpbmcvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL25vZGVfbW9kdWxlcy9AaGFwaS9qb2kvbGliL3R5cGVzL3N0cmluZy9pcC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbm9kZV9tb2R1bGVzL0BoYXBpL2pvaS9saWIvdHlwZXMvc3RyaW5nL3JmYzM5ODYuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL25vZGVfbW9kdWxlcy9AaGFwaS9qb2kvbGliL3R5cGVzL3N0cmluZy91cmkuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL25vZGVfbW9kdWxlcy9AaGFwaS9qb2kvbGliL3R5cGVzL3N5bWJvbC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbm9kZV9tb2R1bGVzL0BoYXBpL2pvaS9saWIvdHlwZXMvc3ltYm9scy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbm9kZV9tb2R1bGVzL0BoYXBpL21hcmtlci9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL25vZGVfbW9kdWxlcy9AaGFwaS90b3BvL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbm9kZV9tb2R1bGVzL0BoYXBpL3RvcG8vbm9kZV9tb2R1bGVzL0BoYXBpL2hvZWsvbGliL2RlZXAtZXF1YWwuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL25vZGVfbW9kdWxlcy9AaGFwaS90b3BvL25vZGVfbW9kdWxlcy9AaGFwaS9ob2VrL2xpYi9lc2NhcGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL25vZGVfbW9kdWxlcy9AaGFwaS90b3BvL25vZGVfbW9kdWxlcy9AaGFwaS9ob2VrL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbm9kZV9tb2R1bGVzL0BoYXBpL3RvcG8vbm9kZV9tb2R1bGVzL0BoYXBpL2hvZWsvbGliL3R5cGVzLmpzIiwid2VicGFjazovLy8uL3NyYy9ub2RlX21vZHVsZXMvYW5zaS1yZWdleC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbm9kZV9tb2R1bGVzL2FwcGxlc2NyaXB0L2xpYi9hcHBsZXNjcmlwdC1wYXJzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL25vZGVfbW9kdWxlcy9hcHBsZXNjcmlwdC9saWIvYXBwbGVzY3JpcHQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL25vZGVfbW9kdWxlcy9hdXRvLWxhdW5jaC9kaXN0L0F1dG9MYXVuY2hMaW51eC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbm9kZV9tb2R1bGVzL2F1dG8tbGF1bmNoL2Rpc3QvQXV0b0xhdW5jaE1hYy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbm9kZV9tb2R1bGVzL2F1dG8tbGF1bmNoL2Rpc3QvQXV0b0xhdW5jaFdpbmRvd3MuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL25vZGVfbW9kdWxlcy9hdXRvLWxhdW5jaC9kaXN0L2ZpbGVCYXNlZFV0aWxpdGllcy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbm9kZV9tb2R1bGVzL2F1dG8tbGF1bmNoL2Rpc3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL25vZGVfbW9kdWxlcy9iYWxhbmNlZC1tYXRjaC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbm9kZV9tb2R1bGVzL2JpbmFyeS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbm9kZV9tb2R1bGVzL2JpbmFyeS9saWIvdmFycy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbm9kZV9tb2R1bGVzL2JpbmFyeXNlYXJjaC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbm9kZV9tb2R1bGVzL2JyYWNlLWV4cGFuc2lvbi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbm9kZV9tb2R1bGVzL2J1ZmZlcnMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL25vZGVfbW9kdWxlcy9jYW1lbGNhc2UvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL25vZGVfbW9kdWxlcy9jaGFpbnNhdy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbm9kZV9tb2R1bGVzL2NsaXVpL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9ub2RlX21vZHVsZXMvY29kZS1wb2ludC1hdC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbm9kZV9tb2R1bGVzL2NvbmNhdC1tYXAvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL25vZGVfbW9kdWxlcy9jcm9zcy11bnppcC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbm9kZV9tb2R1bGVzL2RhbWVyYXUtbGV2ZW5zaHRlaW4vZGFtZXJhdS1sZXZlbnNodGVpbi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbm9kZV9tb2R1bGVzL2RlY2FtZWxpemUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL25vZGVfbW9kdWxlcy9lbGVjdHJvbi1kZXZ0b29scy1pbnN0YWxsZXIvZGlzdC9kb3dubG9hZENocm9tZUV4dGVuc2lvbi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbm9kZV9tb2R1bGVzL2VsZWN0cm9uLWRldnRvb2xzLWluc3RhbGxlci9kaXN0L2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9ub2RlX21vZHVsZXMvZWxlY3Ryb24tZGV2dG9vbHMtaW5zdGFsbGVyL2Rpc3QvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL25vZGVfbW9kdWxlcy9lbGVjdHJvbi1pcy1kZXYvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL25vZGVfbW9kdWxlcy9lbGVjdHJvbi1sb2cvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL25vZGVfbW9kdWxlcy9lbGVjdHJvbi1sb2cvbGliL2Zvcm1hdC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbm9kZV9tb2R1bGVzL2VsZWN0cm9uLWxvZy9saWIvbG9nLmpzIiwid2VicGFjazovLy8uL3NyYy9ub2RlX21vZHVsZXMvZWxlY3Ryb24tbG9nL2xpYi9vcmlnaW5hbC1jb25zb2xlLmpzIiwid2VicGFjazovLy8uL3NyYy9ub2RlX21vZHVsZXMvZWxlY3Ryb24tbG9nL2xpYi90cmFuc3BvcnRzL2NvbnNvbGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL25vZGVfbW9kdWxlcy9lbGVjdHJvbi1sb2cvbGliL3RyYW5zcG9ydHMvZmlsZS9maW5kLWxvZy1wYXRoLmpzIiwid2VicGFjazovLy8uL3NyYy9ub2RlX21vZHVsZXMvZWxlY3Ryb24tbG9nL2xpYi90cmFuc3BvcnRzL2ZpbGUvZ2V0LWFwcC1uYW1lLmpzIiwid2VicGFjazovLy8uL3NyYy9ub2RlX21vZHVsZXMvZWxlY3Ryb24tbG9nL2xpYi90cmFuc3BvcnRzL2ZpbGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL25vZGVfbW9kdWxlcy9lbGVjdHJvbi1sb2cvbGliL3RyYW5zcG9ydHMvbG9nLXMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL25vZGVfbW9kdWxlcy9lbGVjdHJvbi1sb2cvbGliL3RyYW5zcG9ydHMvcmVuZGVyZXItY29uc29sZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbm9kZV9tb2R1bGVzL2VsZWN0cm9uLWxvZy9tYWluLmpzIiwid2VicGFjazovLy8uL3NyYy9ub2RlX21vZHVsZXMvZWxlY3Ryb24tbG9nL3JlbmRlcmVyLmpzIiwid2VicGFjazovLy8uL3NyYy9ub2RlX21vZHVsZXMvZnMucmVhbHBhdGgvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL25vZGVfbW9kdWxlcy9mcy5yZWFscGF0aC9vbGQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL25vZGVfbW9kdWxlcy9nbG9iL2NvbW1vbi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbm9kZV9tb2R1bGVzL2dsb2IvZ2xvYi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbm9kZV9tb2R1bGVzL2dsb2Ivc3luYy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbm9kZV9tb2R1bGVzL2luZmxpZ2h0L2luZmxpZ2h0LmpzIiwid2VicGFjazovLy8uL3NyYy9ub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL25vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzIiwid2VicGFjazovLy8uL3NyYy9ub2RlX21vZHVsZXMvaW52ZXJ0LWt2L2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9ub2RlX21vZHVsZXMvaXMtZnVsbHdpZHRoLWNvZGUtcG9pbnQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL25vZGVfbW9kdWxlcy9pcy11dGY4L2lzLXV0ZjguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL25vZGVfbW9kdWxlcy9sY2lkL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9ub2RlX21vZHVsZXMvbWluaW1hdGNoL21pbmltYXRjaC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbm9kZV9tb2R1bGVzL21rZGlycC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbm9kZV9tb2R1bGVzL251bWJlci1pcy1uYW4vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL25vZGVfbW9kdWxlcy9vbmNlL29uY2UuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL25vZGVfbW9kdWxlcy9vcy1sb2NhbGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL25vZGVfbW9kdWxlcy9wYXRoLWlzLWFic29sdXRlL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9ub2RlX21vZHVsZXMvcmltcmFmL3JpbXJhZi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbm9kZV9tb2R1bGVzL3NlbXZlci9zZW12ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL25vZGVfbW9kdWxlcy9zaW1wbGUtc3BlbGxjaGVja2VyL2RpY3Rpb25hcnkuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL25vZGVfbW9kdWxlcy9zaW1wbGUtc3BlbGxjaGVja2VyL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9ub2RlX21vZHVsZXMvc3RyaW5nLXdpZHRoL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9ub2RlX21vZHVsZXMvc3RyaXAtYW5zaS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbm9kZV9tb2R1bGVzL3N0cmlwLWJvbS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbm9kZV9tb2R1bGVzL3RyYXZlcnNlL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9ub2RlX21vZHVsZXMvdW50aWxkaWZ5L2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9ub2RlX21vZHVsZXMvdW56aXAtc3RyZWFtL2xpYi9lbnRyeS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbm9kZV9tb2R1bGVzL3VuemlwLXN0cmVhbS9saWIvZXh0cmFjdC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbm9kZV9tb2R1bGVzL3VuemlwLXN0cmVhbS9saWIvbWF0Y2hlci1zdHJlYW0uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL25vZGVfbW9kdWxlcy91bnppcC1zdHJlYW0vbGliL3BhcnNlci1zdHJlYW0uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL25vZGVfbW9kdWxlcy91bnppcC1zdHJlYW0vbGliL3VuemlwLXN0cmVhbS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbm9kZV9tb2R1bGVzL3VuemlwLXN0cmVhbS91bnppcC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbm9kZV9tb2R1bGVzL3ZhbGlkLXVybC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbm9kZV9tb2R1bGVzL3dpbmRvdy1zaXplL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9ub2RlX21vZHVsZXMvd2lucmVnL2xpYi9yZWdpc3RyeS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbm9kZV9tb2R1bGVzL3dyYXAtYW5zaS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbm9kZV9tb2R1bGVzL3dyYXBweS93cmFwcHkuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL25vZGVfbW9kdWxlcy95MThuL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9ub2RlX21vZHVsZXMveWFyZ3MvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL25vZGVfbW9kdWxlcy95YXJncy9saWIgc3luYyIsIndlYnBhY2s6Ly8vLi9zcmMvbm9kZV9tb2R1bGVzL3lhcmdzL2xpYi9jb21wbGV0aW9uLmpzIiwid2VicGFjazovLy8uL3NyYy9ub2RlX21vZHVsZXMveWFyZ3MvbGliL3BhcnNlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbm9kZV9tb2R1bGVzL3lhcmdzL2xpYi90b2tlbml6ZS1hcmctc3RyaW5nLmpzIiwid2VicGFjazovLy8uL3NyYy9ub2RlX21vZHVsZXMveWFyZ3MvbGliL3VzYWdlLmpzIiwid2VicGFjazovLy8uL3NyYy9ub2RlX21vZHVsZXMveWFyZ3MvbGliL3ZhbGlkYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3V0aWxzL3V0aWwuanMiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiYXNzZXJ0XCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiY2hpbGRfcHJvY2Vzc1wiIiwid2VicGFjazovLy9leHRlcm5hbCBcImNyeXB0b1wiIiwid2VicGFjazovLy9leHRlcm5hbCBcImVsZWN0cm9uXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiZXZlbnRzXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiZnNcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJodHRwXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiaHR0cHNcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJuZXRcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJvc1wiIiwid2VicGFjazovLy9leHRlcm5hbCBcInBhdGhcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJwdW55Y29kZVwiIiwid2VicGFjazovLy9leHRlcm5hbCBcInN0cmVhbVwiIiwid2VicGFjazovLy9leHRlcm5hbCBcInR0eVwiIiwid2VicGFjazovLy9leHRlcm5hbCBcInVybFwiIiwid2VicGFjazovLy9leHRlcm5hbCBcInV0aWxcIiIsIndlYnBhY2s6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O0FBQ0E7QUFDQSxrQkFBa0IsMkNBQUk7QUFDdEI7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIseUNBQUU7QUFDdkIsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFLGtFQUFXO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDRDQUFHO0FBQ1gsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFD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QUNBO0FBQ0E7OztBQUdBOztBQUVBLGlDQUFpQztBQUNqQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQSxZQUFZO0FBQ1o7Ozs7Ozs7Ozs7Ozs7QUN2UGE7O0FBRWI7OztBQUdBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7Ozs7Ozs7Ozs7OztBQzNnRGE7O0FBRWI7O0FBRUEsY0FBYyxtQkFBTyxDQUFDLDJEQUFTOzs7QUFHL0I7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQSxlQUFlOztBQUVmO0FBQ0E7OztBQUdBOztBQUVBLHNCQUFzQjtBQUN0QjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMENBQTBDO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDLFFBQVE7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O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUNBQXVDLFFBQVEsR0FBRyxpQkFBaUI7QUFDbkU7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkIscUJBQXFCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSw4Q0FBOEM7O0FBRTlDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxTQUFTOztBQUVU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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsaURBQWlEO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixtQkFBTyxDQUFDLGtCQUFNO0FBQy9CO0FBQ0EsU0FBUyxtQkFBTyxDQUFDLGNBQUk7O0FBRXJCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMENBQTBDLEVBQUU7QUFDNUMsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQjtBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQjtBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQzlTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFdBQVcsbUJBQU8sQ0FBQyxrQkFBTTtBQUN6QixnQkFBZ0IsbUJBQU8sQ0FBQyw0REFBVztBQUNuQyxpQkFBaUIsbUJBQU8sQ0FBQyxzRUFBa0I7QUFDM0M7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxZQUFZO0FBQ3BEOztBQUVBO0FBQ0EscUNBQXFDLFlBQVk7QUFDakQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxnQ0FBZ0M7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwwQ0FBMEMsT0FBTztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLGdCQUFnQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7Ozs7Ozs7Ozs7QUMvT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLFNBQVMsbUJBQU8sQ0FBQyxjQUFJO0FBQ3JCLFNBQVMsbUJBQU8sQ0FBQyw0REFBYTtBQUM5QixnQkFBZ0IsbUJBQU8sQ0FBQyw0REFBVztBQUNuQztBQUNBLGVBQWUsbUJBQU8sQ0FBQyx5REFBVTtBQUNqQyxTQUFTLG1CQUFPLENBQUMsc0JBQVE7QUFDekIsV0FBVyxtQkFBTyxDQUFDLGtCQUFNO0FBQ3pCLGFBQWEsbUJBQU8sQ0FBQyxzQkFBUTtBQUM3QixpQkFBaUIsbUJBQU8sQ0FBQyxzRUFBa0I7QUFDM0MsZUFBZSxtQkFBTyxDQUFDLGtEQUFXO0FBQ2xDLGFBQWEsbUJBQU8sQ0FBQyxzREFBYTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyx5REFBVTtBQUNqQyxXQUFXLG1CQUFPLENBQUMsa0JBQU07QUFDekI7QUFDQTs7QUFFQSxXQUFXLG1CQUFPLENBQUMsNkNBQU07O0FBRXpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCO0FBQ3pCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQixtQkFBbUI7QUFDcEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxnQ0FBZ0MscUJBQXFCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLHlCQUF5QjtBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixlQUFlO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGVBQWU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixvQkFBb0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsb0JBQW9CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNyeEJBO0FBQ0E7O0FBRUEsU0FBUyxtQkFBTyxDQUFDLGNBQUk7QUFDckIsU0FBUyxtQkFBTyxDQUFDLDREQUFhO0FBQzlCLGdCQUFnQixtQkFBTyxDQUFDLDREQUFXO0FBQ25DO0FBQ0EsV0FBVyxtQkFBTyxDQUFDLGtEQUFXO0FBQzlCLFdBQVcsbUJBQU8sQ0FBQyxrQkFBTTtBQUN6QixXQUFXLG1CQUFPLENBQUMsa0JBQU07QUFDekIsYUFBYSxtQkFBTyxDQUFDLHNCQUFRO0FBQzdCLGlCQUFpQixtQkFBTyxDQUFDLHNFQUFrQjtBQUMzQyxhQUFhLG1CQUFPLENBQUMsc0RBQWE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixvQkFBb0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixvQkFBb0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7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QTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsSUFBSTtBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLElBQUk7QUFDeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxJQUFJO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxFQUFFLEVBQUUsS0FBSztBQUN6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsUUFBUTtBQUNoRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxzQkFBc0I7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNkNBQTZDO0FBQzdDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7O0FBRUEsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSyw2Q0FBNkM7O0FBRWxEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Rzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUIsb0JBQW9CO0FBQ3JDOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7Ozs7Ozs7Ozs7QUMzV0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9DQUFvQztBQUN4RCwwQkFBMEIsb0NBQW9DO0FBQzlELDBCQUEwQixvQ0FBb0M7QUFDOUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hELHNDQUFzQztBQUN0QyxvQ0FBb0M7QUFDcEMsc0NBQXNDO0FBQ3RDLG9DQUFvQztBQUNwQyxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUIscUJBQXFCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZ0JBQWdCO0FBQ25DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQiwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQixzQkFBc0I7QUFDdkM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxzRjtBQUNBOzs7Ozs7Ozs7Ozs7QUMzeUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsbUJBQU8sQ0FBQyw4REFBYztBQUMzQyxxQkFBcUIsbUJBQU8sQ0FBQywwRkFBcUI7O0FBRWxEO0FBQ0EsNkNBQTZDLHdCQUF3Qjs7QUFFckU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVksS0FBSztBQUNqQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isc0JBQXNCO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWSxLQUFLO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjs7QUFFcEM7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0EsMEU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsOENBQThDO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3pLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsY0FBYyxtQkFBTyxDQUFDLDhEQUFjO0FBQ3BDLGlCQUFpQixtQkFBTyxDQUFDLHdEQUFXO0FBQ3BDLG1CQUFtQixtQkFBTyxDQUFDLDZFQUFpQjs7QUFFNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxlQUFlO0FBQzlGO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSx5QjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEQ7QUFDQSwrREFBK0Q7QUFDL0Q7O0FBRUE7QUFDQSxnRDtBQUNBO0FBQ0Esd0NBQXdDLGdCQUFnQixPO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3Qix5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUI7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUM1S2E7QUFDYixnQkFBZ0IsbUJBQU8sQ0FBQywwREFBWTtBQUNwQyxrQkFBa0IsbUJBQU8sQ0FBQyxnRUFBZTtBQUN6QywyQkFBMkIsbUJBQU8sQ0FBQyxvRkFBeUI7O0FBRTVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsZ0JBQWdCLGdCQUFnQjtBQUNoQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDcENhO0FBQ2IsZ0JBQWdCLG1CQUFPLENBQUMsMERBQVk7O0FBRXBDO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ0xhO0FBQ2IsYUFBYSxtQkFBTyxDQUFDLHNEQUFTOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixlQUFlO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixlQUFlO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLG9CQUFvQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixtQ0FBbUMsdUJBQXVCO0FBQzFELGtDQUFrQyxzQkFBc0I7QUFDeEQsZ0NBQWdDLG9CQUFvQjtBQUNwRCxpQ0FBaUMscUJBQXFCO0FBQ3RELGdDQUFnQztBQUNoQzs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDJCQUEyQixvQkFBb0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNqVWE7O0FBRWIsYUFBYSxtQkFBTyxDQUFDLGNBQUk7O0FBRXpCO0FBQ0E7QUFDQSxnREFBZ0QsV0FBVztBQUMzRDs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDVmE7O0FBRWIsYUFBYSxtQkFBTyxDQUFDLHNCQUFRO0FBQzdCLGVBQWUsbUJBQU8sQ0FBQyxrQkFBTTs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSwyQ0FBMkMsaUNBQWlDLE1BQU0sRUFBRSxFQUFFO0FBQ3RGOztBQUVBLHVCOzs7Ozs7Ozs7OztBQ3ZCQSxTQUFTLG1CQUFPLENBQUMsY0FBSTtBQUNyQixXQUFXLG1CQUFPLENBQUMsa0JBQU07QUFDekIsV0FBVyxtQkFBTyxDQUFDLGtCQUFNO0FBQ3pCLGFBQWEsbUJBQU8sQ0FBQyxrREFBUTtBQUM3QixnQkFBZ0IsbUJBQU8sQ0FBQyxzQkFBUTtBQUNoQyxrQkFBa0IsbUJBQU8sQ0FBQywyRUFBZ0I7O0FBRTFDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EscUNBQXFDLG9CQUFvQixFQUFFO0FBQzNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCOzs7Ozs7Ozs7OztBQ2hHQSxnQkFBZ0IsbUJBQU8sQ0FBQyxzQkFBUTtBQUNoQyxXQUFXLG1CQUFPLENBQUMsa0JBQU07O0FBRXpCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSw2REFBNkQ7QUFDN0Qsc0JBQXNCLFFBQVE7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwrQjs7Ozs7Ozs7Ozs7QUM3RkEsZ0JBQWdCLG1CQUFPLENBQUMsc0JBQVE7QUFDaEMsV0FBVyxtQkFBTyxDQUFDLGtCQUFNO0FBQ3pCLGtCQUFrQixtQkFBTyxDQUFDLDJFQUFnQjs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEIsMkJBQTJCOztBQUVyRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsb0JBQW9CLEVBQUU7QUFDM0Q7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQ0FBb0MsbURBQW1ELE1BQU0sRUFBRSxFQUFFO0FBQ2pHOztBQUVBOzs7Ozs7Ozs7Ozs7O0FDbERhOztBQUViLGFBQWEsbUJBQU8sQ0FBQyxrREFBUTtBQUM3QixhQUFhLG1CQUFPLENBQUMsc0JBQVE7QUFDN0IsV0FBVyxtQkFBTyxDQUFDLGtCQUFNO0FBQ3pCLFdBQVcsbUJBQU8sQ0FBQyxrQkFBTTtBQUN6QixvQkFBb0IsbUJBQU8sQ0FBQywrRUFBa0I7QUFDOUMsWUFBWSxtQkFBTyxDQUFDLDZEQUFTOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLDBCQUEwQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIseUNBQXlDLEVBQUU7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsZ0NBQWdDOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFFBQVE7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUZBQWlGLGlFQUFpRSxFQUFFOztBQUVwSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNQLEtBQUs7QUFDTDtBQUNBLDBCQUEwQjtBQUMxQixPQUFPO0FBQ1AsMEJBQTBCO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxtQkFBTyxDQUFDLDREQUFhO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDBDQUEwQztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDUDs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7OztBQzlYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3hQQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNzQjs7QUFFVTtBQUN1Qjs7QUFFdkQ7QUFDQSxvQkFBb0IsMENBQUc7QUFDdkIsWUFBWSxtQkFBbUIsSUFBSSxlQUFlO0FBQ2xEOztBQUVBO0FBQ0EsaUJBQWlCLDJEQUFTLGFBQWEsNERBQVU7QUFDakQ7O0FBRUE7QUFDQSxpQkFBaUIsdURBQUs7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTLE9BQU8sR0FBRywrQ0FBUTs7QUFFM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQzs7Ozs7Ozs7Ozs7O0FDM0RGLG1DOzs7Ozs7Ozs7OztBQ0FBLDBDOzs7Ozs7Ozs7OztBQ0FBLG1DOzs7Ozs7Ozs7OztBQ0FBLHFDOzs7Ozs7Ozs7OztBQ0FBLG1DOzs7Ozs7Ozs7OztBQ0FBLCtCOzs7Ozs7Ozs7OztBQ0FBLGlDOzs7Ozs7Ozs7OztBQ0FBLGtDOzs7Ozs7Ozs7OztBQ0FBLGdDOzs7Ozs7Ozs7OztBQ0FBLCtCOzs7Ozs7Ozs7OztBQ0FBLGlDOzs7Ozs7Ozs7OztBQ0FBLHFDOzs7Ozs7Ozs7OztBQ0FBLG1DOzs7Ozs7Ozs7OztBQ0FBLGdDOzs7Ozs7Ozs7OztBQ0FBLGdDOzs7Ozs7Ozs7OztBQ0FBLGlDOzs7Ozs7Ozs7OztBQ0FBLGlDIiwiZmlsZSI6Im1haW5fYnVuZGxlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuIFx0XHR9XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gXHR9O1xuXG4gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3RcbiBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3RcbiBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbiBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbiBcdFx0cmV0dXJuIG5zO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFwiLi9zcmMvbWFpbi5qc1wiKTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XHJcblx0aWYgKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XHJcblx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcclxuXHRcdG1vZHVsZS5wYXRocyA9IFtdO1xyXG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XHJcblx0XHRpZiAoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImxvYWRlZFwiLCB7XHJcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5sO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwiaWRcIiwge1xyXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiBtb2R1bGUuaTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcclxuXHR9XHJcblx0cmV0dXJuIG1vZHVsZTtcclxufTtcclxuIiwiLy8gQ29weXJpZ2h0IChjKSAyMDE1LTIwMTYgWXV5YSBPY2hpYWlcbi8vIENvcHlyaWdodCAoYykgMjAxNi1wcmVzZW50IE1hdHRlcm1vc3QsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vIFNlZSBMSUNFTlNFLnR4dCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbmltcG9ydCBmcyBmcm9tICdmcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEpzb25GaWxlTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKGZpbGUpIHtcbiAgICB0aGlzLmpzb25GaWxlID0gZmlsZTtcbiAgICB0cnkge1xuICAgICAgdGhpcy5qc29uID0gSlNPTi5wYXJzZShmcy5yZWFkRmlsZVN5bmMoZmlsZSwgJ3V0Zi04JykpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhpcy5qc29uID0ge307XG4gICAgfVxuICB9XG5cbiAgd3JpdGVUb0ZpbGUoKSB7XG4gICAgZnMud3JpdGVGaWxlKHRoaXMuanNvbkZpbGUsIEpTT04uc3RyaW5naWZ5KHRoaXMuanNvbiwgbnVsbCwgMiksIChlcnIpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgc2V0SnNvbihqc29uKSB7XG4gICAgdGhpcy5qc29uID0ganNvbjtcbiAgICB0aGlzLndyaXRlVG9GaWxlKCk7XG4gIH1cblxuICBzZXRWYWx1ZShrZXksIHZhbHVlKSB7XG4gICAgdGhpcy5qc29uW2tleV0gPSB2YWx1ZTtcbiAgICB0aGlzLndyaXRlVG9GaWxlKCk7XG4gIH1cblxuICBnZXRWYWx1ZShrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5qc29uW2tleV07XG4gIH1cbn1cbiIsIi8vIENvcHlyaWdodCAoYykgMjAxNS0yMDE2IFl1eWEgT2NoaWFpXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTYtcHJlc2VudCBNYXR0ZXJtb3N0LCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vLyBTZWUgTElDRU5TRS50eHQgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG5cbmltcG9ydCB7RXZlbnRFbWl0dGVyfSBmcm9tICdldmVudHMnO1xuXG5pbXBvcnQgV2luZG93c1JlZ2lzdHJ5IGZyb20gJ3dpbnJlZyc7XG5cbmNvbnN0IFJFR0lTVFJZX0hJVkVfTElTVCA9IFtXaW5kb3dzUmVnaXN0cnkuSEtMTSwgV2luZG93c1JlZ2lzdHJ5LkhLQ1VdO1xuY29uc3QgQkFTRV9SRUdJU1RSWV9LRVlfUEFUSCA9ICdcXFxcU29mdHdhcmVcXFxcUG9saWNpZXNcXFxcTWF0dGVybW9zdCc7XG5cbi8qKlxuICogSGFuZGxlcyBsb2FkaW5nIGNvbmZpZyBkYXRhIGZyb20gdGhlIFdpbmRvd3MgcmVnaXN0cnkgc2V0IG1hbnVhbGx5IG9yIGJ5IEdQT1xuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZWdpc3RyeUNvbmZpZyBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgIHRoaXMuZGF0YSA9IHtcbiAgICAgIHRlYW1zOiBbXSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFRyaWdnZXJzIGxvYWRpbmcgZGF0YSBmcm9tIFdpbmRvd3MgcmVnaXN0cnksIHN1cHBvcnRzIGFzeW5jL2F3YWl0XG4gICAqXG4gICAqIEBlbWl0cyB7dXBkYXRlfSBlbWl0dGVkIG9uY2UgYWxsIGRhdGEgaGFzIGJlZW4gbG9hZGVkIGZyb20gdGhlIHJlZ2lzdHJ5XG4gICAqL1xuICBhc3luYyBpbml0KCkge1xuICAgIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInKSB7XG4gICAgICAvLyBleHRyYWN0IERlZmF1bHRTZXJ2ZXJMaXN0IGZyb20gdGhlIHJlZ2lzdHJ5XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBzZXJ2ZXJzID0gYXdhaXQgdGhpcy5nZXRTZXJ2ZXJzTGlzdEZyb21SZWdpc3RyeSgpO1xuICAgICAgICBpZiAoc2VydmVycy5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLmRhdGEudGVhbXMucHVzaCguLi5zZXJ2ZXJzKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1tSZWdpc3RyeUNvbmZpZ10gTm90aGluZyByZXRyaWV2ZWQgZm9yIFxcJ0RlZmF1bHRTZXJ2ZXJMaXN0XFwnJywgZXJyb3IpO1xuICAgICAgfVxuXG4gICAgICAvLyBleHRyYWN0IEVuYWJsZVNlcnZlck1hbmFnZW1lbnQgZnJvbSB0aGUgcmVnaXN0cnlcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGVuYWJsZVNlcnZlck1hbmFnZW1lbnQgPSBhd2FpdCB0aGlzLmdldEVuYWJsZVNlcnZlck1hbmFnZW1lbnRGcm9tUmVnaXN0cnkoKTtcbiAgICAgICAgaWYgKGVuYWJsZVNlcnZlck1hbmFnZW1lbnQgIT09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLmRhdGEuZW5hYmxlU2VydmVyTWFuYWdlbWVudCA9IGVuYWJsZVNlcnZlck1hbmFnZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdbUmVnaXN0cnlDb25maWddIE5vdGhpbmcgcmV0cmlldmVkIGZvciBcXCdFbmFibGVTZXJ2ZXJNYW5hZ2VtZW50XFwnJywgZXJyb3IpO1xuICAgICAgfVxuXG4gICAgICAvLyBleHRyYWN0IEVuYWJsZUF1dG9VcGRhdGVyIGZyb20gdGhlIHJlZ2lzdHJ5XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBlbmFibGVBdXRvVXBkYXRlciA9IGF3YWl0IHRoaXMuZ2V0RW5hYmxlQXV0b1VwZGF0b3JGcm9tUmVnaXN0cnkoKTtcbiAgICAgICAgaWYgKGVuYWJsZUF1dG9VcGRhdGVyICE9PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5kYXRhLmVuYWJsZUF1dG9VcGRhdGVyID0gZW5hYmxlQXV0b1VwZGF0ZXI7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdbUmVnaXN0cnlDb25maWddIE5vdGhpbmcgcmV0cmlldmVkIGZvciBcXCdFbmFibGVBdXRvVXBkYXRlclxcJycsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgdGhpcy5lbWl0KCd1cGRhdGUnLCB0aGlzLmRhdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4dHJhY3RzIGEgbGlzdCBvZiBzZXJ2ZXJzXG4gICAqL1xuICBhc3luYyBnZXRTZXJ2ZXJzTGlzdEZyb21SZWdpc3RyeSgpIHtcbiAgICBjb25zdCBkZWZhdWx0VGVhbXMgPSBhd2FpdCB0aGlzLmdldFJlZ2lzdHJ5RW50cnkoYCR7QkFTRV9SRUdJU1RSWV9LRVlfUEFUSH1cXFxcRGVmYXVsdFNlcnZlckxpc3RgKTtcbiAgICByZXR1cm4gZGVmYXVsdFRlYW1zLmZsYXQoMikucmVkdWNlKCh0ZWFtcywgdGVhbSkgPT4ge1xuICAgICAgaWYgKHRlYW0pIHtcbiAgICAgICAgdGVhbXMucHVzaCh7XG4gICAgICAgICAgbmFtZTogdGVhbS5uYW1lLFxuICAgICAgICAgIHVybDogdGVhbS52YWx1ZSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGVhbXM7XG4gICAgfSwgW10pO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgd2hldGhlciBzZXJ2ZXIgbWFuYWdlbWVudCBoYXMgYmVlbiBlbmFibGVkLCBkaXNhYmxlZCBvciBpc24ndCBjb25maWd1cmVkXG4gICAqL1xuICBhc3luYyBnZXRFbmFibGVTZXJ2ZXJNYW5hZ2VtZW50RnJvbVJlZ2lzdHJ5KCkge1xuICAgIGNvbnN0IGVudHJpZXMgPSAoYXdhaXQgdGhpcy5nZXRSZWdpc3RyeUVudHJ5KEJBU0VfUkVHSVNUUllfS0VZX1BBVEgsICdFbmFibGVTZXJ2ZXJNYW5hZ2VtZW50JykpO1xuICAgIGNvbnN0IGVudHJ5ID0gZW50cmllcy5wb3AoKTtcbiAgICByZXR1cm4gZW50cnkgPyBlbnRyeSA9PT0gJzB4MScgOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgd2hldGhlciB0aGUgYXV0byB1cGRhdGVkIGhhcyBiZWVuIGVuYWJsZWQsIGRpc2FibGVkIG9yIGlzbid0IGNvbmZpZ3VyZWRcbiAgICovXG4gIGFzeW5jIGdldEVuYWJsZUF1dG9VcGRhdG9yRnJvbVJlZ2lzdHJ5KCkge1xuICAgIGNvbnN0IGVudHJpZXMgPSAoYXdhaXQgdGhpcy5nZXRSZWdpc3RyeUVudHJ5KEJBU0VfUkVHSVNUUllfS0VZX1BBVEgsICdFbmFibGVBdXRvVXBkYXRlcicpKTtcbiAgICBjb25zdCBlbnRyeSA9IGVudHJpZXMucG9wKCk7XG4gICAgcmV0dXJuIGVudHJ5ID8gZW50cnkgPT09ICcweDEnIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWF0ZXMgcmV0cmlldmFsIG9mIGEgc3BlY2lmaWMga2V5IGluIHRoZSBXaW5kb3dzIHJlZ2lzdHJ5XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgUGF0aCB0byB0aGUgcmVnaXN0cnkga2V5IHRvIHJldHVyblxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lIG9mIHNwZWNpZmljIGVudHJ5IGluIHRoZSByZWdpc3RyeSBrZXkgdG8gcmV0cmlldmUgKG9wdGlvbmFsKVxuICAgKi9cbiAgYXN5bmMgZ2V0UmVnaXN0cnlFbnRyeShrZXksIG5hbWUpIHtcbiAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgZm9yIChjb25zdCBoaXZlIG9mIFJFR0lTVFJZX0hJVkVfTElTVCkge1xuICAgICAgcmVzdWx0cy5wdXNoKHRoaXMuZ2V0UmVnaXN0cnlFbnRyeVZhbHVlcyhuZXcgV2luZG93c1JlZ2lzdHJ5KHtoaXZlLCBrZXl9KSwgbmFtZSkpO1xuICAgIH1cbiAgICBjb25zdCBlbnRyeVZhbHVlcyA9IGF3YWl0IFByb21pc2UuYWxsKHJlc3VsdHMpO1xuICAgIHJldHVybiBlbnRyeVZhbHVlcy5maWx0ZXIoKHZhbHVlKSA9PiB2YWx1ZSk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBhY3R1YWwgcmV0cmlldmFsIG9mIGVudHJpZXMgZnJvbSBhIGNvbmZpZ3VyZWQgV2luZG93c1JlZ2lzdHJ5IGluc3RhbmNlXG4gICAqXG4gICAqIEBwYXJhbSB7V2luZG93c1JlZ2lzdHJ5fSByZWdLZXkgQSBjb25maWd1cmVkIGluc3RhbmNlIG9mIHRoZSBXaW5kb3dzUmVnaXN0cnkgY2xhc3NcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTmFtZSBvZiB0aGUgc3BlY2lmaWMgZW50cnkgdG8gcmV0cmlldmUgKG9wdGlvbmFsKVxuICAgKi9cbiAgZ2V0UmVnaXN0cnlFbnRyeVZhbHVlcyhyZWdLZXksIG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIHJlZ0tleS52YWx1ZXMoKGVycm9yLCBpdGVtcykgPT4ge1xuICAgICAgICBpZiAoZXJyb3IgfHwgIWl0ZW1zIHx8ICFpdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lKSB7IC8vIGxvb2tpbmcgZm9yIGEgc2luZ2xlIGVudHJ5IHZhbHVlXG4gICAgICAgICAgY29uc3QgcmVnaXN0cnlJdGVtID0gaXRlbXMuZmluZCgoaXRlbSkgPT4gaXRlbS5uYW1lID09PSBuYW1lKTtcbiAgICAgICAgICByZXNvbHZlKHJlZ2lzdHJ5SXRlbSAmJiByZWdpc3RyeUl0ZW0udmFsdWUgPyByZWdpc3RyeUl0ZW0udmFsdWUgOiBudWxsKTtcbiAgICAgICAgfSBlbHNlIHsgLy8gbG9va2luZyBmb3IgYW4gZW50cnkgbGlzdFxuICAgICAgICAgIHJlc29sdmUoaXRlbXMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufVxuIiwiLy8gQ29weXJpZ2h0IChjKSAyMDE1LTIwMTYgWXV5YSBPY2hpYWlcbi8vIENvcHlyaWdodCAoYykgMjAxNi1wcmVzZW50IE1hdHRlcm1vc3QsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vIFNlZSBMSUNFTlNFLnR4dCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cblxuLy8gRm9yIGRldGFpbGVkIGd1aWRlcywgcGxlYXNlIHJlZmVyIHRvIGh0dHBzOi8vZG9jcy5tYXR0ZXJtb3N0LmNvbS9kZXBsb3ltZW50L2Rlc2t0b3AtYXBwLWRlcGxveW1lbnQuaHRtbFxuXG4vKipcbiAqIEJ1aWxkLXRpbWUgY29uZmlndXJhdGlvbi4gRW5kLXVzZXJzIGNhbid0IGNoYW5nZSB0aGVzZSBwYXJhbWV0ZXJzLlxuICogQHByb3Age09iamVjdFtdfSBkZWZhdWx0VGVhbXNcbiAqIEBwcm9wIHtzdHJpbmd9IGRlZmF1bHRUZWFtc1tdLm5hbWUgLSBUaGUgdGFiIG5hbWUgZm9yIGRlZmF1bHQgdGVhbS5cbiAqIEBwcm9wIHtzdHJpbmd9IGRlZmF1bHRUZWFtc1tdLnVybCAtIFRoZSBVUkwgZm9yIGRlZmF1bHQgdGVhbS5cbiAqIEBwcm9wIHtzdHJpbmd9IGhlbHBMaW5rIC0gVGhlIFVSTCBmb3IgXCJIZWxwLT5MZWFybiBNb3JlLi4uXCIgbWVudSBpdGVtLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICBJZiBudWxsIGlzIHNwZWNpZmllZCwgdGhlIG1lbnUgZGlzYXBwZWFycy5cbiAqIEBwcm9wIHtib29sZWFufSBlbmFibGVTZXJ2ZXJNYW5hZ2VtZW50IC0gV2hldGhlciB1c2VycyBjYW4gZWRpdCBzZXJ2ZXJzIGNvbmZpZ3VyYXRpb24uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNwZWNpZnkgYXQgbGVhc3Qgb25lIHNlcnZlciBmb3IgXCJkZWZhdWx0VGVhbXNcIlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGVuIFwiZW5hYmxlU2VydmVyTWFuYWdlbWVudCBpcyBzZXQgdG8gZmFsc2VcbiAqL1xuY29uc3QgYnVpbGRDb25maWcgPSB7XG4gIGRlZmF1bHRUZWFtczogWy8qXG4gICAge1xuICAgICAgbmFtZTogJ2V4YW1wbGUnLFxuICAgICAgdXJsOiAnaHR0cHM6Ly9leGFtcGxlLmNvbSdcbiAgICB9Ki9cbiAgXSxcbiAgaGVscExpbms6ICdodHRwczovL2Fib3V0Lm1hdHRlcm1vc3QuY29tL2RlZmF1bHQtZGVza3RvcC1hcHAtZG9jdW1lbnRhdGlvbi8nLFxuICBlbmFibGVTZXJ2ZXJNYW5hZ2VtZW50OiB0cnVlLFxuICBlbmFibGVBdXRvVXBkYXRlcjogdHJ1ZSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGJ1aWxkQ29uZmlnO1xuIiwiLy8gQ29weXJpZ2h0IChjKSAyMDE1LTIwMTYgWXV5YSBPY2hpYWlcbi8vIENvcHlyaWdodCAoYykgMjAxNi1wcmVzZW50IE1hdHRlcm1vc3QsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vIFNlZSBMSUNFTlNFLnR4dCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cblxuLyoqXG4gKiBEZWZhdWx0IHVzZXIgcHJlZmVyZW5jZXMuIEVuZC11c2VycyBjYW4gY2hhbmdlIHRoZXNlIHBhcmFtZXRlcnMgYnkgZWRpdGluZyBjb25maWcuanNvblxuICogQHBhcmFtIHtudW1iZXJ9IHZlcnNpb24gLSBTY2hlbWUgdmVyc2lvbi4gKE5vdCBhcHBsaWNhdGlvbiB2ZXJzaW9uKVxuICovXG5jb25zdCBkZWZhdWx0UHJlZmVyZW5jZXMgPSB7XG4gIHZlcnNpb246IDEsXG4gIHRlYW1zOiBbXSxcbiAgc2hvd1RyYXlJY29uOiBmYWxzZSxcbiAgdHJheUljb25UaGVtZTogJ2xpZ2h0JyxcbiAgbWluaW1pemVUb1RyYXk6IGZhbHNlLFxuICBub3RpZmljYXRpb25zOiB7XG4gICAgZmxhc2hXaW5kb3c6IDAsXG4gICAgYm91bmNlSWNvbjogZmFsc2UsXG4gICAgYm91bmNlSWNvblR5cGU6ICdpbmZvcm1hdGlvbmFsJyxcbiAgfSxcbiAgc2hvd1VucmVhZEJhZGdlOiB0cnVlLFxuICB1c2VTcGVsbENoZWNrZXI6IHRydWUsXG4gIGVuYWJsZUhhcmR3YXJlQWNjZWxlcmF0aW9uOiB0cnVlLFxuICBhdXRvc3RhcnQ6IHRydWUsXG4gIHNwZWxsQ2hlY2tlckxvY2FsZTogJ2VuLVVTJyxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGRlZmF1bHRQcmVmZXJlbmNlcztcbiIsIi8vIENvcHlyaWdodCAoYykgMjAxNS0yMDE2IFl1eWEgT2NoaWFpXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTYtcHJlc2VudCBNYXR0ZXJtb3N0LCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vLyBTZWUgTElDRU5TRS50eHQgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG5cbmltcG9ydCBmcyBmcm9tICdmcyc7XG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcblxuaW1wb3J0IHtFdmVudEVtaXR0ZXJ9IGZyb20gJ2V2ZW50cyc7XG5cbmltcG9ydCAqIGFzIFZhbGlkYXRvciBmcm9tICcuLi8uLi9tYWluL1ZhbGlkYXRvcic7XG5cbmltcG9ydCBkZWZhdWx0UHJlZmVyZW5jZXMgZnJvbSAnLi9kZWZhdWx0UHJlZmVyZW5jZXMnO1xuaW1wb3J0IHVwZ3JhZGVDb25maWdEYXRhIGZyb20gJy4vdXBncmFkZVByZWZlcmVuY2VzJztcbmltcG9ydCBidWlsZENvbmZpZyBmcm9tICcuL2J1aWxkQ29uZmlnJztcblxuLyoqXG4gKiBIYW5kbGVzIGxvYWRpbmcgYW5kIG1lcmdpbmcgYWxsIHNvdXJjZXMgb2YgY29uZmlndXJhdGlvbiBhcyB3ZWxsIGFzIHNhdmluZyB1c2VyIHByb3ZpZGVkIGNvbmZpZ1xuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb25maWcgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3Rvcihjb25maWdGaWxlUGF0aCwgcmVnaXN0cnlDb25maWdEYXRhID0ge3RlYW1zOiBbXX0pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuY29uZmlnRmlsZVBhdGggPSBjb25maWdGaWxlUGF0aDtcbiAgICB0aGlzLnJlZ2lzdHJ5Q29uZmlnRGF0YSA9IHJlZ2lzdHJ5Q29uZmlnRGF0YTtcbiAgICB0aGlzLnJlbG9hZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbG9hZCBhbGwgc291cmNlcyBvZiBjb25maWcgZGF0YVxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHN5bmNocm9uaXplIGRldGVybWluZXMgd2hldGhlciBvciBub3QgdG8gZW1pdCBhIHN5bmNocm9uaXplIGV2ZW50IG9uY2UgY29uZmlnIGhhcyBiZWVuIHJlbG9hZGVkXG4gICAqIEBlbWl0cyB7dXBkYXRlfSBlbWl0dGVkIG9uY2UgYWxsIGRhdGEgaGFzIGJlZW4gbG9hZGVkIGFuZCBtZXJnZWRcbiAgICogQGVtaXRzIHtzeW5jaHJvbml6ZX0gZW1pdHRlZCB3aGVuIHJlcXVlc3RlZCBieSBhIGNhbGwgdG8gbWV0aG9kOyB1c2VkIHRvIG5vdGlmeSBvdGhlciBjb25maWcgaW5zdGFuY2VzIG9mIGNoYW5nZXNcbiAgICovXG4gIHJlbG9hZChzeW5jaHJvbml6ZSA9IGZhbHNlKSB7XG4gICAgdGhpcy5kZWZhdWx0Q29uZmlnRGF0YSA9IHRoaXMubG9hZERlZmF1bHRDb25maWdEYXRhKCk7XG4gICAgdGhpcy5idWlsZENvbmZpZ0RhdGEgPSB0aGlzLmxvYWRCdWlsZENvbmZpZ0RhdGEoKTtcblxuICAgIHRoaXMubG9jYWxDb25maWdEYXRhID0gdGhpcy5sb2FkTG9jYWxDb25maWdGaWxlKCk7XG4gICAgdGhpcy5sb2NhbENvbmZpZ0RhdGEgPSB0aGlzLmNoZWNrRm9yQ29uZmlnVXBkYXRlcyh0aGlzLmxvY2FsQ29uZmlnRGF0YSk7XG5cbiAgICB0aGlzLnJlZ2VuZXJhdGVDb21iaW5lZENvbmZpZ0RhdGEoKTtcblxuICAgIHRoaXMuZW1pdCgndXBkYXRlJywgdGhpcy5jb21iaW5lZERhdGEpO1xuXG4gICAgaWYgKHN5bmNocm9uaXplKSB7XG4gICAgICB0aGlzLmVtaXQoJ3N5bmNocm9uaXplJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gc2F2ZSBhIHNpbmdsZSBjb25maWcgcHJvcGVydHlcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBuYW1lIG9mIGNvbmZpZyBwcm9wZXJ0eSB0byBiZSBzYXZlZFxuICAgKiBAcGFyYW0geyp9IGRhdGEgdmFsdWUgdG8gc2F2ZSBmb3IgcHJvdmlkZWQga2V5XG4gICAqL1xuICBzZXQoa2V5LCBkYXRhKSB7XG4gICAgaWYgKGtleSkge1xuICAgICAgdGhpcy5sb2NhbENvbmZpZ0RhdGFba2V5XSA9IGRhdGE7XG4gICAgICB0aGlzLnJlZ2VuZXJhdGVDb21iaW5lZENvbmZpZ0RhdGEoKTtcbiAgICAgIHRoaXMuc2F2ZUxvY2FsQ29uZmlnRGF0YSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIHRvIHNhdmUgYW4gYXJyYXkgb2YgY29uZmlnIHByb3BlcnRpZXMgaW4gb25lIGdvXG4gICAqXG4gICAqIEBwYXJhbSB7YXJyYXl9IHByb3BlcnRpZXMgYW4gYXJyYXkgb2YgY29uZmlnIHByb3BlcnRpZXMgdG8gc2F2ZVxuICAgKi9cbiAgc2V0TXVsdGlwbGUocHJvcGVydGllcyA9IFtdKSB7XG4gICAgaWYgKHByb3BlcnRpZXMubGVuZ3RoKSB7XG4gICAgICBwcm9wZXJ0aWVzLmZvckVhY2goKHtrZXksIGRhdGF9KSA9PiB7XG4gICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICB0aGlzLmxvY2FsQ29uZmlnRGF0YVtrZXldID0gZGF0YTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLnJlZ2VuZXJhdGVDb21iaW5lZENvbmZpZ0RhdGEoKTtcbiAgICAgIHRoaXMuc2F2ZUxvY2FsQ29uZmlnRGF0YSgpO1xuICAgIH1cbiAgfVxuXG4gIHNldFJlZ2lzdHJ5Q29uZmlnRGF0YShyZWdpc3RyeUNvbmZpZ0RhdGEgPSB7dGVhbXM6IFtdfSkge1xuICAgIHRoaXMucmVnaXN0cnlDb25maWdEYXRhID0gT2JqZWN0LmFzc2lnbih7fSwgcmVnaXN0cnlDb25maWdEYXRhKTtcbiAgICB0aGlzLnJlbG9hZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gcmVwbGFjZSB0aGUgZXhpc3RpbmcgY29uZmlnIGRhdGEgd2l0aCBuZXcgY29uZmlnIGRhdGFcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZ0RhdGEgYSBuZXcsIGNvbmZpZyBkYXRhIG9iamVjdCB0byBjb21wbGV0ZWx5IHJlcGxhY2UgdGhlIGV4aXN0aW5nIGNvbmZpZyBkYXRhXG4gICAqL1xuICByZXBsYWNlKGNvbmZpZ0RhdGEpIHtcbiAgICBjb25zdCBuZXdDb25maWdEYXRhID0gY29uZmlnRGF0YTtcblxuICAgIHRoaXMubG9jYWxDb25maWdEYXRhID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2NhbENvbmZpZ0RhdGEsIG5ld0NvbmZpZ0RhdGEpO1xuXG4gICAgdGhpcy5yZWdlbmVyYXRlQ29tYmluZWRDb25maWdEYXRhKCk7XG4gICAgdGhpcy5zYXZlTG9jYWxDb25maWdEYXRhKCk7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCB0byBzYXZlIHRoZSBjdXJyZW50IHNldCBvZiBsb2NhbCBjb25maWcgZGF0YSB0byBkaXNrXG4gICAqXG4gICAqIEBlbWl0cyB7dXBkYXRlfSBlbWl0dGVkIG9uY2UgYWxsIGRhdGEgaGFzIGJlZW4gc2F2ZWRcbiAgICogQGVtaXRzIHtzeW5jaHJvbml6ZX0gZW1pdHRlZCBvbmNlIGFsbCBkYXRhIGhhcyBiZWVuIHNhdmVkOyB1c2VkIHRvIG5vdGlmeSBvdGhlciBjb25maWcgaW5zdGFuY2VzIG9mIGNoYW5nZXNcbiAgICogQGVtaXRzIHtlcnJvcn0gZW1pdHRlZCBpZiBzYXZpbmcgbG9jYWwgY29uZmlnIGRhdGEgdG8gZmlsZSBmYWlsc1xuICAgKi9cbiAgc2F2ZUxvY2FsQ29uZmlnRGF0YSgpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy53cml0ZUZpbGUodGhpcy5jb25maWdGaWxlUGF0aCwgdGhpcy5sb2NhbENvbmZpZ0RhdGEsIChlcnJvcikgPT4ge1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdCgndXBkYXRlJywgdGhpcy5jb21iaW5lZERhdGEpO1xuICAgICAgICB0aGlzLmVtaXQoJ3N5bmNocm9uaXplJyk7XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgICB9XG4gIH1cblxuICAvLyBnZXR0ZXJzIGZvciBhY2Nlc3NpbmcgdGhlIHZhcmlvdXMgY29uZmlnIGRhdGEgaW5wdXRzXG5cbiAgZ2V0IGRhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29tYmluZWREYXRhO1xuICB9XG4gIGdldCBsb2NhbERhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMubG9jYWxDb25maWdEYXRhO1xuICB9XG4gIGdldCBkZWZhdWx0RGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5kZWZhdWx0Q29uZmlnRGF0YTtcbiAgfVxuICBnZXQgYnVpbGREYXRhKCkge1xuICAgIHJldHVybiB0aGlzLmJ1aWxkQ29uZmlnRGF0YTtcbiAgfVxuICBnZXQgcmVnaXN0cnlEYXRhKCkge1xuICAgIHJldHVybiB0aGlzLnJlZ2lzdHJ5Q29uZmlnRGF0YTtcbiAgfVxuXG4gIC8vIGNvbnZlbmllbmNlIGdldHRlcnNcblxuICBnZXQgdmVyc2lvbigpIHtcbiAgICByZXR1cm4gdGhpcy5jb21iaW5lZERhdGEudmVyc2lvbjtcbiAgfVxuICBnZXQgdGVhbXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29tYmluZWREYXRhLnRlYW1zO1xuICB9XG4gIGdldCBsb2NhbFRlYW1zKCkge1xuICAgIHJldHVybiB0aGlzLmxvY2FsQ29uZmlnRGF0YS50ZWFtcztcbiAgfVxuICBnZXQgcHJlZGVmaW5lZFRlYW1zKCkge1xuICAgIHJldHVybiBbLi4udGhpcy5idWlsZENvbmZpZ0RhdGEuZGVmYXVsdFRlYW1zLCAuLi50aGlzLnJlZ2lzdHJ5Q29uZmlnRGF0YS50ZWFtc107XG4gIH1cbiAgZ2V0IGVuYWJsZUhhcmR3YXJlQWNjZWxlcmF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmNvbWJpbmVkRGF0YS5lbmFibGVIYXJkd2FyZUFjY2VsZXJhdGlvbjtcbiAgfVxuICBnZXQgZW5hYmxlU2VydmVyTWFuYWdlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb21iaW5lZERhdGEuZW5hYmxlU2VydmVyTWFuYWdlbWVudDtcbiAgfVxuICBnZXQgZW5hYmxlQXV0b1VwZGF0ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29tYmluZWREYXRhLmVuYWJsZUF1dG9VcGRhdGVyO1xuICB9XG4gIGdldCBhdXRvc3RhcnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29tYmluZWREYXRhLmF1dG9zdGFydDtcbiAgfVxuICBnZXQgbm90aWZpY2F0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5jb21iaW5lZERhdGEubm90aWZpY2F0aW9ucztcbiAgfVxuICBnZXQgc2hvd1VucmVhZEJhZGdlKCkge1xuICAgIHJldHVybiB0aGlzLmNvbWJpbmVkRGF0YS5zaG93VW5yZWFkQmFkZ2U7XG4gIH1cbiAgZ2V0IHVzZVNwZWxsQ2hlY2tlcigpIHtcbiAgICByZXR1cm4gdGhpcy5jb21iaW5lZERhdGEudXNlU3BlbGxDaGVja2VyO1xuICB9XG4gIGdldCBzcGVsbENoZWNrZXJMb2NhbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29tYmluZWREYXRhLnNwZWxsQ2hlY2tlckxvY2FsZTtcbiAgfVxuICBnZXQgc2hvd1RyYXlJY29uKCkge1xuICAgIHJldHVybiB0aGlzLmNvbWJpbmVkRGF0YS5zaG93VHJheUljb247XG4gIH1cbiAgZ2V0IHRyYXlJY29uVGhlbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29tYmluZWREYXRhLnRyYXlJY29uVGhlbWU7XG4gIH1cbiAgZ2V0IGhlbHBMaW5rKCkge1xuICAgIHJldHVybiB0aGlzLmNvbWJpbmVkRGF0YS5oZWxwTGluaztcbiAgfVxuXG4gIC8vIGluaXRpYWxpemF0aW9uL3Byb2Nlc3NpbmcgbWV0aG9kc1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGUgYXBwJ3MgZGVmYXVsdCBjb25maWcgZGF0YVxuICAgKi9cbiAgbG9hZERlZmF1bHRDb25maWdEYXRhKCkge1xuICAgIHJldHVybiB0aGlzLmNvcHkoZGVmYXVsdFByZWZlcmVuY2VzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGUgYXBwJ3MgYnVpbGQgY29uZmlnIGRhdGFcbiAgICovXG4gIGxvYWRCdWlsZENvbmZpZ0RhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29weShidWlsZENvbmZpZyk7XG4gIH1cblxuICAvKipcbiAgICogTG9hZHMgYW5kIHJldHVybnMgbG9jYWxseSBzdG9yZWQgY29uZmlnIGRhdGEgZnJvbSB0aGUgZmlsZXN5c3RlbSBvciByZXR1cm5zIGFwcCBkZWZhdWx0cyBpZiBubyBmaWxlIGlzIGZvdW5kXG4gICAqL1xuICBsb2FkTG9jYWxDb25maWdGaWxlKCkge1xuICAgIGxldCBjb25maWdEYXRhID0ge307XG4gICAgdHJ5IHtcbiAgICAgIGNvbmZpZ0RhdGEgPSB0aGlzLnJlYWRGaWxlU3luYyh0aGlzLmNvbmZpZ0ZpbGVQYXRoKTtcblxuICAgICAgLy8gdmFsaWRhdGUgYmFzZWQgb24gY29uZmlnIGZpbGUgdmVyc2lvblxuICAgICAgaWYgKGNvbmZpZ0RhdGEudmVyc2lvbiA+IDApIHtcbiAgICAgICAgY29uZmlnRGF0YSA9IFZhbGlkYXRvci52YWxpZGF0ZVYxQ29uZmlnRGF0YShjb25maWdEYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbmZpZ0RhdGEgPSBWYWxpZGF0b3IudmFsaWRhdGVWMENvbmZpZ0RhdGEoY29uZmlnRGF0YSk7XG4gICAgICB9XG4gICAgICBpZiAoIWNvbmZpZ0RhdGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm92aWRlZCBjb25maWd1cmF0aW9uIGZpbGUgZG9lcyBub3QgdmFsaWRhdGUsIHVzaW5nIGRlZmF1bHRzIGluc3RlYWQuJyk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5sb2coJ0ZhaWxlZCB0byBsb2FkIGNvbmZpZ3VyYXRpb24gZmlsZSBmcm9tIHRoZSBmaWxlc3lzdGVtLiBVc2luZyBkZWZhdWx0cy4nKTtcbiAgICAgIGNvbmZpZ0RhdGEgPSB0aGlzLmNvcHkodGhpcy5kZWZhdWx0Q29uZmlnRGF0YSk7XG5cbiAgICAgIC8vIGFkZCBkZWZhdWx0IHRlYW0gdG8gdGVhbXMgaWYgb25lIGV4aXN0cyBhbmQgdGhlcmUgYXJlbnQgY3VycmVudGx5IGFueSB0ZWFtc1xuICAgICAgaWYgKCFjb25maWdEYXRhLnRlYW1zLmxlbmd0aCAmJiB0aGlzLmRlZmF1bHRDb25maWdEYXRhLmRlZmF1bHRUZWFtKSB7XG4gICAgICAgIGNvbmZpZ0RhdGEudGVhbXMucHVzaCh0aGlzLmRlZmF1bHRDb25maWdEYXRhLmRlZmF1bHRUZWFtKTtcbiAgICAgIH1cbiAgICAgIGRlbGV0ZSBjb25maWdEYXRhLmRlZmF1bHRUZWFtO1xuXG4gICAgICB0aGlzLndyaXRlRmlsZVN5bmModGhpcy5jb25maWdGaWxlUGF0aCwgY29uZmlnRGF0YSk7XG4gICAgfVxuICAgIHJldHVybiBjb25maWdEYXRhO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgaWYgbG9jYWxseSBzdG9yZWQgZGF0YSBuZWVkcyB0byBiZSB1cGRhdGVkIGFuZCB1cGdyYWRlcyBhcyBuZWVkZWRcbiAgICpcbiAgICogQHBhcmFtIHsqfSBkYXRhIGxvY2FsbHkgc3RvcmVkIGRhdGFcbiAgICovXG4gIGNoZWNrRm9yQ29uZmlnVXBkYXRlcyhkYXRhKSB7XG4gICAgbGV0IGNvbmZpZ0RhdGEgPSBkYXRhO1xuICAgIHRyeSB7XG4gICAgICBpZiAoY29uZmlnRGF0YS52ZXJzaW9uICE9PSB0aGlzLmRlZmF1bHRDb25maWdEYXRhLnZlcnNpb24pIHtcbiAgICAgICAgY29uZmlnRGF0YSA9IHVwZ3JhZGVDb25maWdEYXRhKGNvbmZpZ0RhdGEpO1xuICAgICAgICB0aGlzLndyaXRlRmlsZVN5bmModGhpcy5jb25maWdGaWxlUGF0aCwgY29uZmlnRGF0YSk7XG4gICAgICAgIGNvbnNvbGUubG9nKGBDb25maWd1cmF0aW9uIHVwZGF0ZWQgdG8gdmVyc2lvbiAke3RoaXMuZGVmYXVsdENvbmZpZ0RhdGEudmVyc2lvbn0gc3VjY2Vzc2Z1bGx5LmApO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmxvZyhgRmFpbGVkIHRvIHVwZGF0ZSBjb25maWd1cmF0aW9uIHRvIHZlcnNpb24gJHt0aGlzLmRlZmF1bHRDb25maWdEYXRhLnZlcnNpb259LmApO1xuICAgIH1cbiAgICByZXR1cm4gY29uZmlnRGF0YTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9wZXJseSBjb21iaW5lcyBhbGwgc291cmNlcyBvZiBkYXRhIGludG8gYSBzaW5nbGUsIG1hbmFnZWFibGUgc2V0IG9mIGFsbCBjb25maWcgZGF0YVxuICAgKi9cbiAgcmVnZW5lcmF0ZUNvbWJpbmVkQ29uZmlnRGF0YSgpIHtcbiAgICAvLyBjb21iaW5lIGFsbCBjb25maWcgZGF0YSBpbiB0aGUgY29ycmVjdCBvcmRlclxuICAgIHRoaXMuY29tYmluZWREYXRhID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5kZWZhdWx0Q29uZmlnRGF0YSwgdGhpcy5sb2NhbENvbmZpZ0RhdGEsIHRoaXMuYnVpbGRDb25maWdEYXRhLCB0aGlzLnJlZ2lzdHJ5Q29uZmlnRGF0YSk7XG5cbiAgICAvLyByZW1vdmUgdW5lY2Vzc2FyeSBkYXRhIHB1bGxlZCBmcm9tIGRlZmF1bHQgYW5kIGJ1aWxkIGNvbmZpZ1xuICAgIGRlbGV0ZSB0aGlzLmNvbWJpbmVkRGF0YS5kZWZhdWx0VGVhbTtcbiAgICBkZWxldGUgdGhpcy5jb21iaW5lZERhdGEuZGVmYXVsdFRlYW1zO1xuXG4gICAgLy8gSU1QT1JUQU5UOiBwcm9wZXJseSBjb21iaW5lIHRlYW1zIGZyb20gYWxsIHNvdXJjZXNcbiAgICBjb25zdCBjb21iaW5lZFRlYW1zID0gW107XG5cbiAgICAvLyAtIHN0YXJ0IGJ5IGFkZGluZyBkZWZhdWx0IHRlYW1zIGZyb20gYnVpbGRDb25maWcsIGlmIGFueVxuICAgIGlmICh0aGlzLmJ1aWxkQ29uZmlnRGF0YS5kZWZhdWx0VGVhbXMgJiYgdGhpcy5idWlsZENvbmZpZ0RhdGEuZGVmYXVsdFRlYW1zLmxlbmd0aCkge1xuICAgICAgY29tYmluZWRUZWFtcy5wdXNoKC4uLnRoaXMuYnVpbGRDb25maWdEYXRhLmRlZmF1bHRUZWFtcyk7XG4gICAgfVxuXG4gICAgLy8gLSBhZGQgcmVnaXN0cnkgZGVmaW5lZCB0ZWFtcywgaWYgYW55XG4gICAgaWYgKHRoaXMucmVnaXN0cnlDb25maWdEYXRhLnRlYW1zICYmIHRoaXMucmVnaXN0cnlDb25maWdEYXRhLnRlYW1zLmxlbmd0aCkge1xuICAgICAgY29tYmluZWRUZWFtcy5wdXNoKC4uLnRoaXMucmVnaXN0cnlDb25maWdEYXRhLnRlYW1zKTtcbiAgICB9XG5cbiAgICAvLyAtIGFkZCBsb2NhbGx5IGRlZmluZWQgdGVhbXMgb25seSBpZiBzZXJ2ZXIgbWFuYWdlbWVudCBpcyBlbmFibGVkXG4gICAgaWYgKHRoaXMuZW5hYmxlU2VydmVyTWFuYWdlbWVudCkge1xuICAgICAgY29tYmluZWRUZWFtcy5wdXNoKC4uLnRoaXMubG9jYWxDb25maWdEYXRhLnRlYW1zKTtcbiAgICB9XG5cbiAgICB0aGlzLmNvbWJpbmVkRGF0YS50ZWFtcyA9IGNvbWJpbmVkVGVhbXM7XG4gICAgdGhpcy5jb21iaW5lZERhdGEubG9jYWxUZWFtcyA9IHRoaXMubG9jYWxDb25maWdEYXRhLnRlYW1zO1xuICAgIHRoaXMuY29tYmluZWREYXRhLmJ1aWxkVGVhbXMgPSB0aGlzLmJ1aWxkQ29uZmlnRGF0YS5kZWZhdWx0VGVhbXM7XG4gICAgdGhpcy5jb21iaW5lZERhdGEucmVnaXN0cnlUZWFtcyA9IHRoaXMucmVnaXN0cnlDb25maWdEYXRhLnRlYW1zO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHByb3ZpZGVkIGxpc3Qgb2YgdGVhbXMgd2l0aCBkdXBsaWNhdGVzIGZpbHRlcmVkIG91dFxuICAgKlxuICAgKiBAcGFyYW0ge2FycmF5fSB0ZWFtcyBhcnJheSBvZiB0ZWFtcyB0byBjaGVjayBmb3IgZHVwbGljYXRlc1xuICAgKi9cbiAgZmlsdGVyT3V0RHVwbGljYXRlVGVhbXModGVhbXMpIHtcbiAgICBsZXQgbmV3VGVhbXMgPSB0ZWFtcztcbiAgICBjb25zdCB1bmlxdWVVUkxzID0gbmV3IFNldCgpO1xuICAgIG5ld1RlYW1zID0gbmV3VGVhbXMuZmlsdGVyKCh0ZWFtKSA9PiB7XG4gICAgICByZXR1cm4gdW5pcXVlVVJMcy5oYXModGVhbS51cmwpID8gZmFsc2UgOiB1bmlxdWVVUkxzLmFkZCh0ZWFtLnVybCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ld1RlYW1zO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHByb3ZpZGVkIGFycmF5IGZvIHRlYW1zIHdpdGggZXhpc3RpbmcgdGVhbXMgZmlsdGVyZWQgb3V0XG4gICAqIEBwYXJhbSB7YXJyYXl9IHRlYW1zIGFycmF5IG9mIHRlYW1zIHRvIGNoZWNrIGZvciBhbHJlYWR5IGRlZmluZWQgdGVhbXNcbiAgICovXG4gIGZpbHRlck91dFByZWRlZmluZWRUZWFtcyh0ZWFtcykge1xuICAgIGxldCBuZXdUZWFtcyA9IHRlYW1zO1xuXG4gICAgLy8gZmlsdGVyIG91dCBwcmVkZWZpbmVkIHRlYW1zXG4gICAgbmV3VGVhbXMgPSBuZXdUZWFtcy5maWx0ZXIoKG5ld1RlYW0pID0+IHtcbiAgICAgIHJldHVybiB0aGlzLnByZWRlZmluZWRUZWFtcy5maW5kSW5kZXgoKGV4aXN0aW5nVGVhbSkgPT4gbmV3VGVhbS51cmwgPT09IGV4aXN0aW5nVGVhbS51cmwpID09PSAtMTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBtYXgtbmVzdGVkLWNhbGxiYWNrc1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIG5ld1RlYW1zO1xuICB9XG5cbiAgLy8gaGVscGVyIGZ1bmN0aW9uc1xuXG4gIHJlYWRGaWxlU3luYyhmaWxlUGF0aCkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKGZzLnJlYWRGaWxlU3luYyhmaWxlUGF0aCwgJ3V0ZjgnKSk7XG4gIH1cblxuICB3cml0ZUZpbGUoZmlsZVBhdGgsIGNvbmZpZ0RhdGEsIGNhbGxiYWNrKSB7XG4gICAgaWYgKGNvbmZpZ0RhdGEudmVyc2lvbiAhPT0gdGhpcy5kZWZhdWx0Q29uZmlnRGF0YS52ZXJzaW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ZlcnNpb24gJyArIGNvbmZpZ0RhdGEudmVyc2lvbiArICcgaXMgbm90IGVxdWFsIHRvICcgKyB0aGlzLmRlZmF1bHRDb25maWdEYXRhLnZlcnNpb24pO1xuICAgIH1cbiAgICBjb25zdCBqc29uID0gSlNPTi5zdHJpbmdpZnkoY29uZmlnRGF0YSwgbnVsbCwgJyAgJyk7XG4gICAgZnMud3JpdGVGaWxlKGZpbGVQYXRoLCBqc29uLCAndXRmOCcsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIHdyaXRlRmlsZVN5bmMoZmlsZVBhdGgsIGNvbmZpZykge1xuICAgIGlmIChjb25maWcudmVyc2lvbiAhPT0gdGhpcy5kZWZhdWx0Q29uZmlnRGF0YS52ZXJzaW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ZlcnNpb24gJyArIGNvbmZpZy52ZXJzaW9uICsgJyBpcyBub3QgZXF1YWwgdG8gJyArIHRoaXMuZGVmYXVsdENvbmZpZ0RhdGEudmVyc2lvbik7XG4gICAgfVxuXG4gICAgY29uc3QgZGlyID0gcGF0aC5kaXJuYW1lKGZpbGVQYXRoKTtcbiAgICBpZiAoIWZzLmV4aXN0c1N5bmMoZGlyKSkge1xuICAgICAgZnMubWtkaXJTeW5jKGRpcik7XG4gICAgfVxuXG4gICAgY29uc3QganNvbiA9IEpTT04uc3RyaW5naWZ5KGNvbmZpZywgbnVsbCwgJyAgJyk7XG4gICAgZnMud3JpdGVGaWxlU3luYyhmaWxlUGF0aCwganNvbiwgJ3V0ZjgnKTtcbiAgfVxuXG4gIG1lcmdlKGJhc2UsIHRhcmdldCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBiYXNlLCB0YXJnZXQpO1xuICB9XG5cbiAgY29weShkYXRhKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGRhdGEpO1xuICB9XG59XG4iLCIvLyBDb3B5cmlnaHQgKGMpIDIwMTUtMjAxNiBZdXlhIE9jaGlhaVxuLy8gQ29weXJpZ2h0IChjKSAyMDE2LXByZXNlbnQgTWF0dGVybW9zdCwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy8gU2VlIExJQ0VOU0UudHh0IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuaW1wb3J0IGRlZmF1bHRQcmVmZXJlbmNlcyBmcm9tICcuL2RlZmF1bHRQcmVmZXJlbmNlcyc7XG5cbmNvbnN0IHBhc3REZWZhdWx0UHJlZmVyZW5jZXMgPSB7XG4gIDA6IHtcbiAgICB1cmw6ICcnLFxuICB9LFxufTtcblxucGFzdERlZmF1bHRQcmVmZXJlbmNlc1tgJHtkZWZhdWx0UHJlZmVyZW5jZXMudmVyc2lvbn1gXSA9IGRlZmF1bHRQcmVmZXJlbmNlcztcblxuZXhwb3J0IGRlZmF1bHQgcGFzdERlZmF1bHRQcmVmZXJlbmNlcztcbiIsIi8vIENvcHlyaWdodCAoYykgMjAxNS0yMDE2IFl1eWEgT2NoaWFpXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTYtcHJlc2VudCBNYXR0ZXJtb3N0LCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vLyBTZWUgTElDRU5TRS50eHQgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG5pbXBvcnQgcGFzdERlZmF1bHRQcmVmZXJlbmNlcyBmcm9tICcuL3Bhc3REZWZhdWx0UHJlZmVyZW5jZXMnO1xuXG5mdW5jdGlvbiBkZWVwQ29weShvYmplY3QpIHtcbiAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqZWN0KSk7XG59XG5cbmZ1bmN0aW9uIHVwZ3JhZGVWMHRvVjEoY29uZmlnVjApIHtcbiAgY29uc3QgY29uZmlnID0gZGVlcENvcHkocGFzdERlZmF1bHRQcmVmZXJlbmNlc1snMSddKTtcbiAgaWYgKGNvbmZpZy52ZXJzaW9uICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwYXN0RGVmYXVsdFByZWZlcmVuY2VzW1xcJzFcXCddLnZlcnNpb24gaXMgbm90IGVxdWFsIHRvIDEnKTtcbiAgfVxuICBjb25maWcudGVhbXMucHVzaCh7XG4gICAgbmFtZTogJ1ByaW1hcnkgdGVhbScsXG4gICAgdXJsOiBjb25maWdWMC51cmwsXG4gIH0pO1xuICByZXR1cm4gY29uZmlnO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB1cGdyYWRlVG9MYXRlc3QoY29uZmlnKSB7XG4gIGNvbnN0IGNvbmZpZ1ZlcnNpb24gPSBjb25maWcudmVyc2lvbiA/IGNvbmZpZy52ZXJzaW9uIDogMDtcbiAgc3dpdGNoIChjb25maWdWZXJzaW9uKSB7XG4gIGNhc2UgMDpcbiAgICByZXR1cm4gdXBncmFkZVRvTGF0ZXN0KHVwZ3JhZGVWMHRvVjEoY29uZmlnKSk7XG4gIGRlZmF1bHQ6XG4gICAgcmV0dXJuIGNvbmZpZztcbiAgfVxufVxuIiwiLy8gQ29weXJpZ2h0IChjKSAyMDE1LTIwMTYgWXV5YSBPY2hpYWlcbi8vIENvcHlyaWdodCAoYykgMjAxNi1wcmVzZW50IE1hdHRlcm1vc3QsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vIFNlZSBMSUNFTlNFLnR4dCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cblxuaW1wb3J0IG9zIGZyb20gJ29zJztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuXG5pbXBvcnQge1VSTH0gZnJvbSAndXJsJztcblxuaW1wb3J0IGVsZWN0cm9uIGZyb20gJ2VsZWN0cm9uJztcbmltcG9ydCBpc0RldiBmcm9tICdlbGVjdHJvbi1pcy1kZXYnO1xuaW1wb3J0IGluc3RhbGxFeHRlbnNpb24sIHtSRUFDVF9ERVZFTE9QRVJfVE9PTFN9IGZyb20gJ2VsZWN0cm9uLWRldnRvb2xzLWluc3RhbGxlcic7XG5pbXBvcnQgbG9nIGZyb20gJ2VsZWN0cm9uLWxvZyc7XG5cbmltcG9ydCB7cHJvdG9jb2xzfSBmcm9tICcuLi9lbGVjdHJvbi1idWlsZGVyLmpzb24nO1xuXG5pbXBvcnQgQXV0b0xhdW5jaGVyIGZyb20gJy4vbWFpbi9BdXRvTGF1bmNoZXInO1xuaW1wb3J0IENyaXRpY2FsRXJyb3JIYW5kbGVyIGZyb20gJy4vbWFpbi9Dcml0aWNhbEVycm9ySGFuZGxlcic7XG5pbXBvcnQgdXBncmFkZUF1dG9MYXVuY2ggZnJvbSAnLi9tYWluL2F1dG9MYXVuY2gnO1xuXG5pbXBvcnQgUmVnaXN0cnlDb25maWcgZnJvbSAnLi9jb21tb24vY29uZmlnL1JlZ2lzdHJ5Q29uZmlnJztcbmltcG9ydCBDb25maWcgZnJvbSAnLi9jb21tb24vY29uZmlnJztcbmltcG9ydCBDZXJ0aWZpY2F0ZVN0b3JlIGZyb20gJy4vbWFpbi9jZXJ0aWZpY2F0ZVN0b3JlJztcbmltcG9ydCBjcmVhdGVNYWluV2luZG93IGZyb20gJy4vbWFpbi9tYWluV2luZG93JztcbmltcG9ydCBhcHBNZW51IGZyb20gJy4vbWFpbi9tZW51cy9hcHAnO1xuaW1wb3J0IHRyYXlNZW51IGZyb20gJy4vbWFpbi9tZW51cy90cmF5JztcbmltcG9ydCBkb3dubG9hZFVSTCBmcm9tICcuL21haW4vZG93bmxvYWRVUkwnO1xuaW1wb3J0IGFsbG93UHJvdG9jb2xEaWFsb2cgZnJvbSAnLi9tYWluL2FsbG93UHJvdG9jb2xEaWFsb2cnO1xuaW1wb3J0IEFwcFN0YXRlTWFuYWdlciBmcm9tICcuL21haW4vQXBwU3RhdGVNYW5hZ2VyJztcbmltcG9ydCBpbml0Q29va2llTWFuYWdlciBmcm9tICcuL21haW4vY29va2llTWFuYWdlcic7XG5pbXBvcnQge3Nob3VsZEJlSGlkZGVuT25TdGFydHVwfSBmcm9tICcuL21haW4vdXRpbHMnO1xuaW1wb3J0IFNwZWxsQ2hlY2tlciBmcm9tICcuL21haW4vU3BlbGxDaGVja2VyJztcbmltcG9ydCBVc2VyQWN0aXZpdHlNb25pdG9yIGZyb20gJy4vbWFpbi9Vc2VyQWN0aXZpdHlNb25pdG9yJztcbmltcG9ydCBVdGlscyBmcm9tICcuL3V0aWxzL3V0aWwnO1xuaW1wb3J0IHBhcnNlQXJncyBmcm9tICcuL21haW4vUGFyc2VBcmdzJztcblxuLy8gcHVsbCBvdXQgcmVxdWlyZWQgZWxlY3Ryb24gY29tcG9uZW50cyBsaWtlIHRoaXNcbi8vIGFzIG5vdCBhbGwgY29tcG9uZW50cyBjYW4gYmUgcmVmZXJlbmNlZCBiZWZvcmUgdGhlIGFwcCBpcyByZWFkeVxuY29uc3Qge1xuICBhcHAsXG4gIE1lbnUsXG4gIFRyYXksXG4gIGlwY01haW4sXG4gIG5hdGl2ZUltYWdlLFxuICBkaWFsb2csXG4gIHN5c3RlbVByZWZlcmVuY2VzLFxuICBzZXNzaW9uLFxuICBCcm93c2VyV2luZG93LFxufSA9IGVsZWN0cm9uO1xuY29uc3QgY3JpdGljYWxFcnJvckhhbmRsZXIgPSBuZXcgQ3JpdGljYWxFcnJvckhhbmRsZXIoKTtcbmNvbnN0IGFzc2V0c0RpciA9IHBhdGgucmVzb2x2ZShhcHAuZ2V0QXBwUGF0aCgpLCAnYXNzZXRzJyk7XG5jb25zdCBsb2dpbkNhbGxiYWNrTWFwID0gbmV3IE1hcCgpO1xuY29uc3QgdXNlckFjdGl2aXR5TW9uaXRvciA9IG5ldyBVc2VyQWN0aXZpdHlNb25pdG9yKCk7XG5cbi8vIEtlZXAgYSBnbG9iYWwgcmVmZXJlbmNlIG9mIHRoZSB3aW5kb3cgb2JqZWN0LCBpZiB5b3UgZG9uJ3QsIHRoZSB3aW5kb3cgd2lsbFxuLy8gYmUgY2xvc2VkIGF1dG9tYXRpY2FsbHkgd2hlbiB0aGUgSmF2YVNjcmlwdCBvYmplY3QgaXMgZ2FyYmFnZSBjb2xsZWN0ZWQuXG5sZXQgbWFpbldpbmRvdyA9IG51bGw7XG5sZXQgcG9wdXBXaW5kb3cgPSBudWxsO1xubGV0IGhpZGVPblN0YXJ0dXAgPSBudWxsO1xubGV0IGNlcnRpZmljYXRlU3RvcmUgPSBudWxsO1xubGV0IHNwZWxsQ2hlY2tlciA9IG51bGw7XG5sZXQgZGVlcGxpbmtpbmdVcmwgPSBudWxsO1xubGV0IHNjaGVtZSA9IG51bGw7XG5sZXQgYXBwU3RhdGUgPSBudWxsO1xubGV0IHJlZ2lzdHJ5Q29uZmlnID0gbnVsbDtcbmxldCBjb25maWcgPSBudWxsO1xubGV0IHRyYXlJY29uID0gbnVsbDtcbmxldCB0cmF5SW1hZ2VzID0gbnVsbDtcblxuLy8gc3VwcG9ydGVkIGN1c3RvbSBsb2dpbiBwYXRocyAob2F0aCwgc2FtbClcbmNvbnN0IGN1c3RvbUxvZ2luUmVnZXhQYXRocyA9IFtcbiAgL15cXC9vYXV0aFxcL2F1dGhvcml6ZSQvaSxcbiAgL15cXC9vYXV0aFxcL2RlYXV0aG9yaXplJC9pLFxuICAvXlxcL29hdXRoXFwvYWNjZXNzX3Rva2VuJC9pLFxuICAvXlxcL29hdXRoXFwvW0EtWmEtejAtOV0rXFwvY29tcGxldGUkL2ksXG4gIC9eXFwvb2F1dGhcXC9bQS1aYS16MC05XStcXC9sb2dpbiQvaSxcbiAgL15cXC9vYXV0aFxcL1tBLVphLXowLTldK1xcL3NpZ251cCQvaSxcbiAgL15cXC9hcGlcXC92M1xcL29hdXRoXFwvW0EtWmEtejAtOV0rXFwvY29tcGxldGUkL2ksXG4gIC9eXFwvc2lnbnVwXFwvW0EtWmEtejAtOV0rXFwvY29tcGxldGUkL2ksXG4gIC9eXFwvbG9naW5cXC9bQS1aYS16MC05XStcXC9jb21wbGV0ZSQvaSxcbiAgL15cXC9sb2dpblxcL3Nzb1xcL3NhbWwkL2ksXG5dO1xuXG4vLyB0cmFja2luZyBpbiBwcm9ncmVzcyBjdXN0b20gbG9naW5zXG5jb25zdCBjdXN0b21Mb2dpbnMgPSB7fTtcblxuLyoqXG4gKiBNYWluIGVudHJ5IHBvaW50IGZvciB0aGUgYXBwbGljYXRpb24sIGVuc3VyZXMgdGhhdCBldmVyeXRoaW5nIGluaXRpYWxpemVzIGluIHRoZSBwcm9wZXIgb3JkZXJcbiAqL1xuYXN5bmMgZnVuY3Rpb24gaW5pdGlhbGl6ZSgpIHtcbiAgcHJvY2Vzcy5vbigndW5jYXVnaHRFeGNlcHRpb24nLCBjcml0aWNhbEVycm9ySGFuZGxlci5wcm9jZXNzVW5jYXVnaHRFeGNlcHRpb25IYW5kbGVyLmJpbmQoY3JpdGljYWxFcnJvckhhbmRsZXIpKTtcbiAgZ2xvYmFsLndpbGxBcHBRdWl0ID0gZmFsc2U7XG5cbiAgLy8gaW5pdGlhbGl6YXRpb24gdGhhdCBjYW4gcnVuIGJlZm9yZSB0aGUgYXBwIGlzIHJlYWR5XG4gIGluaXRpYWxpemVBcmdzKCk7XG4gIGluaXRpYWxpemVDb25maWcoKTtcbiAgaW5pdGlhbGl6ZUFwcEV2ZW50TGlzdGVuZXJzKCk7XG4gIGluaXRpYWxpemVCZWZvcmVBcHBSZWFkeSgpO1xuXG4gIC8vIHdhaXQgZm9yIHJlZ2lzdHJ5IGNvbmZpZyBkYXRhIHRvIGxvYWQgYW5kIGFwcCByZWFkeSBldmVudFxuICBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgcmVnaXN0cnlDb25maWcuaW5pdCgpLFxuICAgIGFwcC53aGVuUmVhZHkoKSxcbiAgXSk7XG5cbiAgLy8gbm8gbmVlZCB0byBjb250aW51ZSBpbml0aWFsaXppbmcgaWYgYXBwIGlzIHF1aXR0aW5nXG4gIGlmIChnbG9iYWwud2lsbEFwcFF1aXQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBpbml0aWFsaXphdGlvbiB0aGF0IHNob3VsZCBydW4gb25jZSB0aGUgYXBwIGlzIHJlYWR5XG4gIGluaXRpYWxpemVJbnRlckNvbW11bmljYXRpb25FdmVudExpc3RlbmVycygpO1xuICBpbml0aWFsaXplQWZ0ZXJBcHBSZWFkeSgpO1xuICBpbml0aWFsaXplTWFpbldpbmRvd0xpc3RlbmVycygpO1xufVxuXG4vLyBhdHRlbXB0IHRvIGluaXRpYWxpemUgdGhlIGFwcGxpY2F0aW9uXG50cnkge1xuICBpbml0aWFsaXplKCk7XG59IGNhdGNoIChlcnJvcikge1xuICB0aHJvdyBuZXcgRXJyb3IoYEFwcCBpbml0aWFsaXphdGlvbiBmYWlsZWQ6ICR7ZXJyb3IudG9TdHJpbmcoKX1gKTtcbn1cblxuLy9cbi8vIGluaXRpYWxpemF0aW9uIHN1YiBmdW5jdGlvbnNcbi8vXG5cbmZ1bmN0aW9uIGluaXRpYWxpemVBcmdzKCkge1xuICBnbG9iYWwuYXJncyA9IHBhcnNlQXJncyhwcm9jZXNzLmFyZ3Yuc2xpY2UoMSkpO1xuXG4gIC8vIG91dHB1dCB0aGUgYXBwbGljYXRpb24gdmVyc2lvbiB2aWEgY2xpIHdoZW4gcmVxdWVzdGVkICgtdiBvciAtLXZlcnNpb24pXG4gIGlmIChnbG9iYWwuYXJncy52ZXJzaW9uKSB7XG4gICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoYHYuJHthcHAuZ2V0VmVyc2lvbigpfVxcbmApO1xuICAgIHByb2Nlc3MuZXhpdCgwKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wcm9jZXNzLWV4aXRcbiAgfVxuXG4gIGhpZGVPblN0YXJ0dXAgPSBzaG91bGRCZUhpZGRlbk9uU3RhcnR1cChnbG9iYWwuYXJncyk7XG5cbiAgZ2xvYmFsLmlzRGV2ID0gaXNEZXYgJiYgIWdsb2JhbC5hcmdzLmRpc2FibGVEZXZNb2RlOyAvLyB0aGlzIGRvZXNuJ3Qgc2VlbSB0byBiZSByaWdodCBhbmQgaXNuJ3QgdXNlZCBhcyB0aGUgc2luZ2xlIHNvdXJjZSBvZiB0cnV0aFxuXG4gIGlmIChnbG9iYWwuYXJnc1snZGF0YS1kaXInXSkge1xuICAgIGFwcC5zZXRQYXRoKCd1c2VyRGF0YScsIHBhdGgucmVzb2x2ZShnbG9iYWwuYXJnc1snZGF0YS1kaXInXSkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRpYWxpemVDb25maWcoKSB7XG4gIHJlZ2lzdHJ5Q29uZmlnID0gbmV3IFJlZ2lzdHJ5Q29uZmlnKCk7XG4gIGNvbmZpZyA9IG5ldyBDb25maWcoYXBwLmdldFBhdGgoJ3VzZXJEYXRhJykgKyAnL2NvbmZpZy5qc29uJyk7XG4gIGNvbmZpZy5vbigndXBkYXRlJywgaGFuZGxlQ29uZmlnVXBkYXRlKTtcbiAgY29uZmlnLm9uKCdzeW5jaHJvbml6ZScsIGhhbmRsZUNvbmZpZ1N5bmNocm9uaXplKTtcbn1cblxuZnVuY3Rpb24gaW5pdGlhbGl6ZUFwcEV2ZW50TGlzdGVuZXJzKCkge1xuICBhcHAub24oJ3NlY29uZC1pbnN0YW5jZScsIGhhbmRsZUFwcFNlY29uZEluc3RhbmNlKTtcbiAgYXBwLm9uKCd3aW5kb3ctYWxsLWNsb3NlZCcsIGhhbmRsZUFwcFdpbmRvd0FsbENsb3NlZCk7XG4gIGFwcC5vbignYnJvd3Nlci13aW5kb3ctY3JlYXRlZCcsIGhhbmRsZUFwcEJyb3dzZXJXaW5kb3dDcmVhdGVkKTtcbiAgYXBwLm9uKCdhY3RpdmF0ZScsIGhhbmRsZUFwcEFjdGl2YXRlKTtcbiAgYXBwLm9uKCdiZWZvcmUtcXVpdCcsIGhhbmRsZUFwcEJlZm9yZVF1aXQpO1xuICBhcHAub24oJ2NlcnRpZmljYXRlLWVycm9yJywgaGFuZGxlQXBwQ2VydGlmaWNhdGVFcnJvcik7XG4gIGFwcC5vbignZ3B1LXByb2Nlc3MtY3Jhc2hlZCcsIGhhbmRsZUFwcEdQVVByb2Nlc3NDcmFzaGVkKTtcbiAgYXBwLm9uKCdsb2dpbicsIGhhbmRsZUFwcExvZ2luKTtcbiAgYXBwLm9uKCd3aWxsLWZpbmlzaC1sYXVuY2hpbmcnLCBoYW5kbGVBcHBXaWxsRmluaXNoTGF1bmNoaW5nKTtcbiAgYXBwLm9uKCd3ZWItY29udGVudHMtY3JlYXRlZCcsIGhhbmRsZUFwcFdlYkNvbnRlbnRzQ3JlYXRlZCk7XG59XG5cbmZ1bmN0aW9uIGluaXRpYWxpemVCZWZvcmVBcHBSZWFkeSgpIHtcbiAgY2VydGlmaWNhdGVTdG9yZSA9IENlcnRpZmljYXRlU3RvcmUubG9hZChwYXRoLnJlc29sdmUoYXBwLmdldFBhdGgoJ3VzZXJEYXRhJyksICdjZXJ0aWZpY2F0ZS5qc29uJykpO1xuXG4gIC8vIHByZXZlbnQgdXNpbmcgYSBkaWZmZXJlbnQgd29ya2luZyBkaXJlY3RvcnksIHdoaWNoIGhhcHBlbnMgb24gd2luZG93cyBydW5uaW5nIGFmdGVyIGluc3RhbGxhdGlvbi5cbiAgY29uc3QgZXhwZWN0ZWRQYXRoID0gcGF0aC5kaXJuYW1lKHByb2Nlc3MuZXhlY1BhdGgpO1xuICBpZiAocHJvY2Vzcy5jd2QoKSAhPT0gZXhwZWN0ZWRQYXRoICYmICFpc0Rldikge1xuICAgIGNvbnNvbGUud2FybihgQ3VycmVudCB3b3JraW5nIGRpcmVjdG9yeSBpcyAke3Byb2Nlc3MuY3dkKCl9LCBjaGFuZ2luZyBpbnRvICR7ZXhwZWN0ZWRQYXRofWApO1xuICAgIHByb2Nlc3MuY2hkaXIoZXhwZWN0ZWRQYXRoKTtcbiAgfVxuXG4gIC8vIGNhbiBvbmx5IGNhbGwgdGhpcyBiZWZvcmUgdGhlIGFwcCBpcyByZWFkeVxuICBpZiAoY29uZmlnLmVuYWJsZUhhcmR3YXJlQWNjZWxlcmF0aW9uID09PSBmYWxzZSkge1xuICAgIGFwcC5kaXNhYmxlSGFyZHdhcmVBY2NlbGVyYXRpb24oKTtcbiAgfVxuXG4gIHRyYXlJbWFnZXMgPSBnZXRUcmF5SW1hZ2VzKCk7XG5cbiAgLy8gSWYgdGhlcmUgaXMgYWxyZWFkeSBhbiBpbnN0YW5jZSwgcXVpdCB0aGlzIG9uZVxuICBjb25zdCBnb3RUaGVMb2NrID0gYXBwLnJlcXVlc3RTaW5nbGVJbnN0YW5jZUxvY2soKTtcbiAgaWYgKCFnb3RUaGVMb2NrKSB7XG4gICAgYXBwLmV4aXQoKTtcbiAgICBnbG9iYWwud2lsbEFwcFF1aXQgPSB0cnVlO1xuICB9XG5cbiAgaWYgKCFjb25maWcuc3BlbGxDaGVja2VyTG9jYWxlKSB7XG4gICAgY29uZmlnLnNldCgnc3BlbGxDaGVja2VyTG9jYWxlJywgU3BlbGxDaGVja2VyLmdldFNwZWxsQ2hlY2tlckxvY2FsZShhcHAuZ2V0TG9jYWxlKCkpKTtcbiAgfVxuXG4gIGFsbG93UHJvdG9jb2xEaWFsb2cuaW5pdChtYWluV2luZG93KTtcblxuICBpZiAoaXNEZXYpIHtcbiAgICBjb25zb2xlLmxvZygnSW4gZGV2ZWxvcG1lbnQgbW9kZSwgZGVlcGxpbmtpbmcgaXMgZGlzYWJsZWQnKTtcbiAgfSBlbHNlIGlmIChwcm90b2NvbHMgJiYgcHJvdG9jb2xzWzBdICYmIHByb3RvY29sc1swXS5zY2hlbWVzICYmIHByb3RvY29sc1swXS5zY2hlbWVzWzBdKSB7XG4gICAgc2NoZW1lID0gcHJvdG9jb2xzWzBdLnNjaGVtZXNbMF07XG4gICAgYXBwLnNldEFzRGVmYXVsdFByb3RvY29sQ2xpZW50KHNjaGVtZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdGlhbGl6ZUludGVyQ29tbXVuaWNhdGlvbkV2ZW50TGlzdGVuZXJzKCkge1xuICBpcGNNYWluLm9uKCdyZWxvYWQtY29uZmlnJywgaGFuZGxlUmVsb2FkQ29uZmlnKTtcbiAgaXBjTWFpbi5vbignbG9naW4tY3JlZGVudGlhbHMnLCBoYW5kbGVMb2dpbkNyZWRlbnRpYWxzRXZlbnQpO1xuICBpcGNNYWluLm9uKCdkb3dubG9hZC11cmwnLCBoYW5kbGVEb3dubG9hZFVSTEV2ZW50KTtcbiAgaXBjTWFpbi5vbignbm90aWZpZWQnLCBoYW5kbGVOb3RpZmllZEV2ZW50KTtcbiAgaXBjTWFpbi5vbigndXBkYXRlLXRpdGxlJywgaGFuZGxlVXBkYXRlVGl0bGVFdmVudCk7XG4gIGlwY01haW4ub24oJ3VwZGF0ZS1tZW51JywgaGFuZGxlVXBkYXRlTWVudUV2ZW50KTtcbiAgaXBjTWFpbi5vbigndXBkYXRlLWRpY3QnLCBoYW5kbGVVcGRhdGVEaWN0aW9uYXJ5RXZlbnQpO1xuICBpcGNNYWluLm9uKCdjaGVja3NwZWxsJywgaGFuZGxlQ2hlY2tTcGVsbGluZ0V2ZW50KTtcbiAgaXBjTWFpbi5vbignZ2V0LXNwZWxsaW5nLXN1Z2dlc3Rpb25zJywgaGFuZGxlR2V0U3BlbGxpbmdTdWdnZXN0aW9uc0V2ZW50KTtcbiAgaXBjTWFpbi5vbignZ2V0LXNwZWxsY2hlY2tlci1sb2NhbGUnLCBoYW5kbGVHZXRTcGVsbGNoZWNrZXJMb2NhbGVFdmVudCk7XG4gIGlwY01haW4ub24oJ3JlcGx5LW9uLXNwZWxsY2hlY2tlci1pcy1yZWFkeScsIGhhbmRsZVJlcGx5T25TcGVsbGNoZWNrZXJJc1JlYWR5RXZlbnQpO1xuICBpZiAoc2hvdWxkU2hvd1RyYXlJY29uKCkpIHtcbiAgICBpcGNNYWluLm9uKCd1cGRhdGUtdW5yZWFkJywgaGFuZGxlVXBkYXRlVW5yZWFkRXZlbnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRpYWxpemVNYWluV2luZG93TGlzdGVuZXJzKCkge1xuICBtYWluV2luZG93Lm9uKCdjbG9zZWQnLCBoYW5kbGVNYWluV2luZG93Q2xvc2VkKTtcbiAgbWFpbldpbmRvdy5vbigndW5yZXNwb25zaXZlJywgY3JpdGljYWxFcnJvckhhbmRsZXIud2luZG93VW5yZXNwb25zaXZlSGFuZGxlci5iaW5kKGNyaXRpY2FsRXJyb3JIYW5kbGVyKSk7XG4gIG1haW5XaW5kb3cud2ViQ29udGVudHMub24oJ2NyYXNoZWQnLCBoYW5kbGVNYWluV2luZG93V2ViQ29udGVudHNDcmFzaGVkKTtcbn1cblxuLy9cbi8vIGNvbmZpZyBldmVudCBoYW5kbGVyc1xuLy9cblxuZnVuY3Rpb24gaGFuZGxlQ29uZmlnVXBkYXRlKGNvbmZpZ0RhdGEpIHtcbiAgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicgfHwgcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ2xpbnV4Jykge1xuICAgIGNvbnN0IGFwcExhdW5jaGVyID0gbmV3IEF1dG9MYXVuY2hlcigpO1xuICAgIGNvbnN0IGF1dG9TdGFydFRhc2sgPSBjb25maWcuYXV0b3N0YXJ0ID8gYXBwTGF1bmNoZXIuZW5hYmxlKCkgOiBhcHBMYXVuY2hlci5kaXNhYmxlKCk7XG4gICAgYXV0b1N0YXJ0VGFzay50aGVuKCgpID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKCdjb25maWcuYXV0b3N0YXJ0IGhhcyBiZWVuIGNvbmZpZ3VyZWQ6JywgY29uZmlnLmF1dG9zdGFydCk7XG4gICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgY29uc29sZS5sb2coJ2Vycm9yOicsIGVycik7XG4gICAgfSk7XG4gIH1cblxuICBpcGNNYWluLmVtaXQoJ3VwZGF0ZS1tZW51JywgdHJ1ZSwgY29uZmlnRGF0YSk7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUNvbmZpZ1N5bmNocm9uaXplKCkge1xuICBpZiAobWFpbldpbmRvdykge1xuICAgIG1haW5XaW5kb3cud2ViQ29udGVudHMuc2VuZCgncmVsb2FkLWNvbmZpZycpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZVJlbG9hZENvbmZpZygpIHtcbiAgY29uZmlnLnJlbG9hZCgpO1xufVxuXG4vL1xuLy8gYXBwIGV2ZW50IGhhbmRsZXJzXG4vL1xuXG4vLyBhY3RpdmF0ZSBmaXJzdCBhcHAgaW5zdGFuY2UsIHN1YnNlcXVlbnQgaW5zdGFuY2VzIHdpbGwgcXVpdCB0aGVtc2VsdmVzXG5mdW5jdGlvbiBoYW5kbGVBcHBTZWNvbmRJbnN0YW5jZShldmVudCwgYXJndikge1xuICAvLyBQcm90b2NvbCBoYW5kbGVyIGZvciB3aW4zMlxuICAvLyBhcmd2OiBBbiBhcnJheSBvZiB0aGUgc2Vjb25kIGluc3RhbmNl4oCZcyAoY29tbWFuZCBsaW5lIC8gZGVlcCBsaW5rZWQpIGFyZ3VtZW50c1xuICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJykge1xuICAgIGRlZXBsaW5raW5nVXJsID0gZ2V0RGVlcGxpbmtpbmdVUkwoYXJndik7XG4gICAgaWYgKGRlZXBsaW5raW5nVXJsKSB7XG4gICAgICBtYWluV2luZG93LndlYkNvbnRlbnRzLnNlbmQoJ3Byb3RvY29sLWRlZXBsaW5rJywgZGVlcGxpbmtpbmdVcmwpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFNvbWVvbmUgdHJpZWQgdG8gcnVuIGEgc2Vjb25kIGluc3RhbmNlLCB3ZSBzaG91bGQgZm9jdXMgb3VyIHdpbmRvdy5cbiAgaWYgKG1haW5XaW5kb3cpIHtcbiAgICBpZiAobWFpbldpbmRvdy5pc01pbmltaXplZCgpKSB7XG4gICAgICBtYWluV2luZG93LnJlc3RvcmUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWFpbldpbmRvdy5zaG93KCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUFwcFdpbmRvd0FsbENsb3NlZCgpIHtcbiAgLy8gT24gT1MgWCBpdCBpcyBjb21tb24gZm9yIGFwcGxpY2F0aW9ucyBhbmQgdGhlaXIgbWVudSBiYXJcbiAgLy8gdG8gc3RheSBhY3RpdmUgdW50aWwgdGhlIHVzZXIgcXVpdHMgZXhwbGljaXRseSB3aXRoIENtZCArIFFcbiAgaWYgKHByb2Nlc3MucGxhdGZvcm0gIT09ICdkYXJ3aW4nKSB7XG4gICAgYXBwLnF1aXQoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVBcHBCcm93c2VyV2luZG93Q3JlYXRlZChlcnJvciwgbmV3V2luZG93KSB7XG4gIC8vIFNjcmVlbiBjYW5ub3QgYmUgcmVxdWlyZWQgYmVmb3JlIGFwcCBpcyByZWFkeVxuICBjb25zdCB7c2NyZWVufSA9IGVsZWN0cm9uO1xuICByZXNpemVTY3JlZW4oc2NyZWVuLCBuZXdXaW5kb3cpO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVBcHBBY3RpdmF0ZSgpIHtcbiAgbWFpbldpbmRvdy5zaG93KCk7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUFwcEJlZm9yZVF1aXQoKSB7XG4gIC8vIE1ha2Ugc3VyZSB0cmF5IGljb24gZ2V0cyByZW1vdmVkIGlmIHRoZSB1c2VyIGV4aXRzIHZpYSBDVFJMLVFcbiAgaWYgKHRyYXlJY29uICYmIHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicpIHtcbiAgICB0cmF5SWNvbi5kZXN0cm95KCk7XG4gIH1cbiAgZ2xvYmFsLndpbGxBcHBRdWl0ID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlQXBwQ2VydGlmaWNhdGVFcnJvcihldmVudCwgd2ViQ29udGVudHMsIHVybCwgZXJyb3IsIGNlcnRpZmljYXRlLCBjYWxsYmFjaykge1xuICBpZiAoY2VydGlmaWNhdGVTdG9yZS5pc1RydXN0ZWQodXJsLCBjZXJ0aWZpY2F0ZSkpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGNhbGxiYWNrKHRydWUpO1xuICB9IGVsc2Uge1xuICAgIGxldCBkZXRhaWwgPSBgVVJMOiAke3VybH1cXG5FcnJvcjogJHtlcnJvcn1gO1xuICAgIGlmIChjZXJ0aWZpY2F0ZVN0b3JlLmlzRXhpc3RpbmcodXJsKSkge1xuICAgICAgZGV0YWlsID0gJ0NlcnRpZmljYXRlIGlzIGRpZmZlcmVudCBmcm9tIHByZXZpb3VzIG9uZS5cXG5cXG4nICsgZGV0YWlsO1xuICAgIH1cbiAgICBkaWFsb2cuc2hvd01lc3NhZ2VCb3gobWFpbldpbmRvdywge1xuICAgICAgdGl0bGU6ICdDZXJ0aWZpY2F0ZSBFcnJvcicsXG4gICAgICBtZXNzYWdlOiAnVGhlcmUgaXMgYSBjb25maWd1cmF0aW9uIGlzc3VlIHdpdGggdGhpcyBNYXR0ZXJtb3N0IHNlcnZlciwgb3Igc29tZW9uZSBpcyB0cnlpbmcgdG8gaW50ZXJjZXB0IHlvdXIgY29ubmVjdGlvbi4gWW91IGFsc28gbWF5IG5lZWQgdG8gc2lnbiBpbnRvIHRoZSBXaS1GaSB5b3UgYXJlIGNvbm5lY3RlZCB0byB1c2luZyB5b3VyIHdlYiBicm93c2VyLicsXG4gICAgICB0eXBlOiAnZXJyb3InLFxuICAgICAgYnV0dG9uczogW1xuICAgICAgICAnTW9yZSBEZXRhaWxzJyxcbiAgICAgICAgJ0NhbmNlbCBDb25uZWN0aW9uJyxcbiAgICAgIF0sXG4gICAgICBjYW5jZWxJZDogMSxcbiAgICB9LCAocmVzcG9uc2UpID0+IHtcbiAgICAgIGlmIChyZXNwb25zZSA9PT0gMCkge1xuICAgICAgICBkaWFsb2cuc2hvd01lc3NhZ2VCb3gobWFpbldpbmRvdywge1xuICAgICAgICAgIHRpdGxlOiAnQ2VydGlmaWNhdGUgRXJyb3InLFxuICAgICAgICAgIG1lc3NhZ2U6IGBDZXJ0aWZpY2F0ZSBmcm9tIFwiJHtjZXJ0aWZpY2F0ZS5pc3N1ZXJOYW1lfVwiIGlzIG5vdCB0cnVzdGVkLmAsXG4gICAgICAgICAgZGV0YWlsLFxuICAgICAgICAgIHR5cGU6ICdlcnJvcicsXG4gICAgICAgICAgYnV0dG9uczogW1xuICAgICAgICAgICAgJ1RydXN0IEluc2VjdXJlIENlcnRpZmljYXRlJyxcbiAgICAgICAgICAgICdDYW5jZWwgQ29ubmVjdGlvbicsXG4gICAgICAgICAgXSxcbiAgICAgICAgICBjYW5jZWxJZDogMSxcbiAgICAgICAgfSwgKHJlc3BvbnNlVHdvKSA9PiB7IC8vZXNsaW50LWRpc2FibGUtbGluZSBtYXgtbmVzdGVkLWNhbGxiYWNrc1xuICAgICAgICAgIGlmIChyZXNwb25zZVR3byA9PT0gMCkge1xuICAgICAgICAgICAgY2VydGlmaWNhdGVTdG9yZS5hZGQodXJsLCBjZXJ0aWZpY2F0ZSk7XG4gICAgICAgICAgICBjZXJ0aWZpY2F0ZVN0b3JlLnNhdmUoKTtcbiAgICAgICAgICAgIHdlYkNvbnRlbnRzLmxvYWRVUkwodXJsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNhbGxiYWNrKGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVBcHBHUFVQcm9jZXNzQ3Jhc2hlZChldmVudCwga2lsbGVkKSB7XG4gIGNvbnNvbGUubG9nKGBUaGUgR1BVIHByb2Nlc3MgaGFzIGNyYXNoZWQgKGtpbGxlZCA9ICR7a2lsbGVkfSlgKTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlQXBwTG9naW4oZXZlbnQsIHdlYkNvbnRlbnRzLCByZXF1ZXN0LCBhdXRoSW5mbywgY2FsbGJhY2spIHtcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgbG9naW5DYWxsYmFja01hcC5zZXQoSlNPTi5zdHJpbmdpZnkocmVxdWVzdCksIGNhbGxiYWNrKTtcbiAgbWFpbldpbmRvdy53ZWJDb250ZW50cy5zZW5kKCdsb2dpbi1yZXF1ZXN0JywgcmVxdWVzdCwgYXV0aEluZm8pO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVBcHBXaWxsRmluaXNoTGF1bmNoaW5nKCkge1xuICAvLyBQcm90b2NvbCBoYW5kbGVyIGZvciBvc3hcbiAgYXBwLm9uKCdvcGVuLXVybCcsIChldmVudCwgdXJsKSA9PiB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBkZWVwbGlua2luZ1VybCA9IGdldERlZXBsaW5raW5nVVJMKFt1cmxdKTtcbiAgICBpZiAoYXBwLmlzUmVhZHkoKSkge1xuICAgICAgZnVuY3Rpb24gb3BlbkRlZXBMaW5rKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChkZWVwbGlua2luZ1VybCkge1xuICAgICAgICAgICAgbWFpbldpbmRvdy53ZWJDb250ZW50cy5zZW5kKCdwcm90b2NvbC1kZWVwbGluaycsIGRlZXBsaW5raW5nVXJsKTtcbiAgICAgICAgICAgIG1haW5XaW5kb3cuc2hvdygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgc2V0VGltZW91dChvcGVuRGVlcExpbmssIDEwMDApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBvcGVuRGVlcExpbmsoKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVBcHBXZWJDb250ZW50c0NyZWF0ZWQoZGMsIGNvbnRlbnRzKSB7XG4gIC8vIGluaXRpYWxpemUgY3VzdG9tIGxvZ2luIHRyYWNraW5nXG4gIGN1c3RvbUxvZ2luc1tjb250ZW50cy5pZF0gPSB7XG4gICAgaW5Qcm9ncmVzczogZmFsc2UsXG4gIH07XG5cbiAgY29udGVudHMub24oJ3dpbGwtYXR0YWNoLXdlYnZpZXcnLCAoZXZlbnQsIHdlYlByZWZlcmVuY2VzKSA9PiB7XG4gICAgd2ViUHJlZmVyZW5jZXMubm9kZUludGVncmF0aW9uID0gZmFsc2U7XG4gICAgd2ViUHJlZmVyZW5jZXMuY29udGV4dElzb2xhdGlvbiA9IHRydWU7XG4gIH0pO1xuXG4gIGNvbnRlbnRzLm9uKCd3aWxsLW5hdmlnYXRlJywgKGV2ZW50LCB1cmwpID0+IHtcbiAgICBjb25zdCBjb250ZW50SUQgPSBldmVudC5zZW5kZXIuaWQ7XG4gICAgY29uc3QgcGFyc2VkVVJMID0gcGFyc2VVUkwodXJsKTtcblxuICAgIGlmIChpc1RydXN0ZWRVUkwocGFyc2VkVVJMKSB8fCBpc1RydXN0ZWRQb3B1cFdpbmRvdyhldmVudC5zZW5kZXIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChwYXJzZWRVUkwucHJvdG9jb2wgPT09ICdtYWlsdG86Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY3VzdG9tTG9naW5zW2NvbnRlbnRJRF0uaW5Qcm9ncmVzcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxvZy5pbmZvKGBVbnRydXN0ZWQgVVJMIGJsb2NrZWQ6ICR7dXJsfWApO1xuICAgIC8vZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfSk7XG5cbiAgLy8gaGFuZGxlIGN1c3RvbSBsb2dpbiByZXF1ZXN0cyAob2F0aCwgc2FtbCk6XG4gIC8vIDEuIGFyZSB3ZSBuYXZpZ2F0aW5nIHRvIGEgc3VwcG9ydGVkIGxvY2FsIGN1c3RvbSBsb2dpbiBwYXRoIGZyb20gdGhlIGAvbG9naW5gIHBhZ2U/XG4gIC8vICAgIC0gaW5kaWNhdGUgY3VzdG9tIGxvZ2luIGlzIGluIHByb2dyZXNzXG4gIC8vIDIuIGFyZSB3ZSBmaW5pc2hlZCB3aXRoIHRoZSBjdXN0b20gbG9naW4gcHJvY2Vzcz9cbiAgLy8gICAgLSBpbmRpY2F0ZSBjdXN0b20gbG9naW4gaXMgTk9UIGluIHByb2dyZXNzXG4gIGNvbnRlbnRzLm9uKCdkaWQtc3RhcnQtbmF2aWdhdGlvbicsIChldmVudCwgdXJsKSA9PiB7XG4gICAgY29uc3QgY29udGVudElEID0gZXZlbnQuc2VuZGVyLmlkO1xuICAgIGNvbnN0IHBhcnNlZFVSTCA9IHBhcnNlVVJMKHVybCk7XG5cbiAgICBpZiAoIWlzVHJ1c3RlZFVSTChwYXJzZWRVUkwpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGlzQ3VzdG9tTG9naW5VUkwocGFyc2VkVVJMKSkge1xuICAgICAgY3VzdG9tTG9naW5zW2NvbnRlbnRJRF0uaW5Qcm9ncmVzcyA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChjdXN0b21Mb2dpbnNbY29udGVudElEXS5pblByb2dyZXNzKSB7XG4gICAgICBjdXN0b21Mb2dpbnNbY29udGVudElEXS5pblByb2dyZXNzID0gZmFsc2U7XG4gICAgfVxuICB9KTtcblxuICBjb250ZW50cy5vbignbmV3LXdpbmRvdycsIChldmVudCwgdXJsKSA9PiB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBpZiAoIWlzVHJ1c3RlZFVSTCh1cmwpKSB7XG4gICAgICBsb2cuaW5mbyhgVW50cnVzdGVkIHBvcHVwIHdpbmRvdyBibG9ja2VkOiAke3VybH1gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGlzVGVhbVVybCh1cmwpID09PSB0cnVlKSB7XG4gICAgICBsb2cuaW5mbyhgJHt1cmx9IGlzIGEga25vd24gdGVhbSwgcHJldmVudGluZyB0byBvcGVuIGEgbmV3IHdpbmRvd2ApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocG9wdXBXaW5kb3cgJiYgcG9wdXBXaW5kb3cuZ2V0VVJMKCkgPT09IHVybCkge1xuICAgICAgbG9nLmluZm8oYFBvcHVwIHdpbmRvdyBhbHJlYWR5IG9wZW4gYXQgcHJvdmlkZWQgdXJsOiAke3VybH1gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFwb3B1cFdpbmRvdykge1xuICAgICAgcG9wdXBXaW5kb3cgPSBuZXcgQnJvd3NlcldpbmRvdyh7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogJyNmZmYnLCAvLyBwcmV2ZW50cyBibHVycnkgdGV4dDogaHR0cHM6Ly9lbGVjdHJvbmpzLm9yZy9kb2NzL2ZhcSN0aGUtZm9udC1sb29rcy1ibHVycnktd2hhdC1pcy10aGlzLWFuZC13aGF0LWNhbi1pLWRvXG4gICAgICAgIHBhcmVudDogbWFpbldpbmRvdyxcbiAgICAgICAgc2hvdzogZmFsc2UsXG4gICAgICAgIHdlYlByZWZlcmVuY2VzOiB7XG4gICAgICAgICAgbm9kZUludGVncmF0aW9uOiBmYWxzZSxcbiAgICAgICAgICBjb250ZXh0SXNvbGF0aW9uOiB0cnVlLFxuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgICBwb3B1cFdpbmRvdy5vbmNlKCdyZWFkeS10by1zaG93JywgKCkgPT4ge1xuICAgICAgICBwb3B1cFdpbmRvdy5zaG93KCk7XG4gICAgICB9KTtcbiAgICAgIHBvcHVwV2luZG93Lm9uY2UoJ2Nsb3NlZCcsICgpID0+IHtcbiAgICAgICAgcG9wdXBXaW5kb3cgPSBudWxsO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHBvcHVwV2luZG93LmxvYWRVUkwodXJsKTtcbiAgfSk7XG5cbiAgLy8gaW1wbGVtZW50ZWQgdG8gdGVtcG9yYXJpbHkgaGVscCBzb2x2ZSBmb3IgaHR0cHM6Ly9jb21tdW5pdHktZGFpbHkubWF0dGVybW9zdC5jb20vY29yZS9wbC9iOTViaTQ0cjRiYm51ZXF6amp4c2k0NnFpd1xuICBjb250ZW50cy5vbignYmVmb3JlLWlucHV0LWV2ZW50JywgKGV2ZW50LCBpbnB1dCkgPT4ge1xuICAgIGlmICghaW5wdXQuc2hpZnQgJiYgIWlucHV0LmNvbnRyb2wgJiYgIWlucHV0LmFsdCAmJiAhaW5wdXQubWV0YSkge1xuICAgICAgLy8gaGFja3kgZml4IGZvciBodHRwczovL21hdHRlcm1vc3QuYXRsYXNzaWFuLm5ldC9icm93c2UvTU0tMTkyMjZcbiAgICAgIGlmICgoaW5wdXQua2V5ID09PSAnRXNjYXBlJyB8fCBpbnB1dC5rZXkgPT09ICdmJykgJiYgaW5wdXQudHlwZSA9PT0gJ2tleURvd24nKSB7XG4gICAgICAgIC8vIG9ubHkgZG8gdGhpcyB3aGVuIGluIGZ1bGxzY3JlZW4gb24gYSBtYWNcbiAgICAgICAgaWYgKG1haW5XaW5kb3cuaXNGdWxsU2NyZWVuKCkgJiYgcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ2RhcndpbicpIHtcbiAgICAgICAgICBtYWluV2luZG93LndlYkNvbnRlbnRzLnNlbmQoJ2V4aXQtZnVsbHNjcmVlbicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKChwcm9jZXNzLnBsYXRmb3JtID09PSAnZGFyd2luJyAmJiAhaW5wdXQubWV0YSkgfHwgKHByb2Nlc3MucGxhdGZvcm0gIT09ICdkYXJ3aW4nICYmICFpbnB1dC5jb250cm9sKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGhhbmRsZSBjZXJ0YWluIGtleWJvYXJkIHNob3J0Y3V0cyBtYW51YWxseVxuICAgIHN3aXRjaCAoaW5wdXQua2V5KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcGFkZGVkLWJsb2Nrc1xuXG4gICAgLy8gTWFudWFsbHkgaGFuZGxlIHpvb20taW4vb3V0L3Jlc2V0IGtleWJvYXJkIHNob3J0Y3V0c1xuICAgIC8vIC0gdGVtcG9yYXJ5IGZpeCBmb3IgaHR0cHM6Ly9tYXR0ZXJtb3N0LmF0bGFzc2lhbi5uZXQvYnJvd3NlL01NLTE5MDMxIGFuZCBodHRwczovL21hdHRlcm1vc3QuYXRsYXNzaWFuLm5ldC9icm93c2UvTU0tMTkwMzJcbiAgICBjYXNlICctJzpcbiAgICAgIG1haW5XaW5kb3cud2ViQ29udGVudHMuc2VuZCgnem9vbS1vdXQnKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJz0nOlxuICAgICAgbWFpbldpbmRvdy53ZWJDb250ZW50cy5zZW5kKCd6b29tLWluJyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICcwJzpcbiAgICAgIG1haW5XaW5kb3cud2ViQ29udGVudHMuc2VuZCgnem9vbS1yZXNldCcpO1xuICAgICAgYnJlYWs7XG5cbiAgICAvLyBNYW51YWxseSBoYW5kbGUgdW5kby9yZWRvIGtleWJvYXJkIHNob3J0Y3V0c1xuICAgIC8vIC0gdGVtcG9yYXJ5IGZpeCBmb3IgaHR0cHM6Ly9tYXR0ZXJtb3N0LmF0bGFzc2lhbi5uZXQvYnJvd3NlL01NLTE5MTk4XG4gICAgY2FzZSAneic6XG4gICAgICBpZiAoaW5wdXQuc2hpZnQpIHtcbiAgICAgICAgbWFpbldpbmRvdy53ZWJDb250ZW50cy5zZW5kKCdyZWRvJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYWluV2luZG93LndlYkNvbnRlbnRzLnNlbmQoJ3VuZG8nKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuXG4gICAgLy8gTWFudWFsbHkgaGFuZGxlIGNvcHkvY3V0L3Bhc3RlIGtleWJvYXJkIHNob3J0Y3V0c1xuICAgIGNhc2UgJ2MnOlxuICAgICAgbWFpbldpbmRvdy53ZWJDb250ZW50cy5zZW5kKCdjb3B5Jyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd4JzpcbiAgICAgIG1haW5XaW5kb3cud2ViQ29udGVudHMuc2VuZCgnY3V0Jyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd2JzpcbiAgICAgIGlmIChpbnB1dC5zaGlmdCkge1xuICAgICAgICBtYWluV2luZG93LndlYkNvbnRlbnRzLnNlbmQoJ3Bhc3RlLWFuZC1tYXRjaCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWFpbldpbmRvdy53ZWJDb250ZW50cy5zZW5kKCdwYXN0ZScpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIGFsbG93cyB0aGUgaW5wdXQgZXZlbnQgdG8gcHJvY2VlZCBpZiBub3QgaGFuZGxlZCBieSBhIGNhc2UgYWJvdmVcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGluaXRpYWxpemVBZnRlckFwcFJlYWR5KCkge1xuICBhcHAuc2V0QXBwVXNlck1vZGVsSWQoJ01hdHRlcm1vc3QuRGVza3RvcCcpOyAvLyBVc2UgZXhwbGljaXQgQXBwVXNlck1vZGVsSURcblxuICBjb25zdCBhcHBTdGF0ZUpzb24gPSBwYXRoLmpvaW4oYXBwLmdldFBhdGgoJ3VzZXJEYXRhJyksICdhcHAtc3RhdGUuanNvbicpO1xuICBhcHBTdGF0ZSA9IG5ldyBBcHBTdGF0ZU1hbmFnZXIoYXBwU3RhdGVKc29uKTtcbiAgaWYgKHdhc1VwZGF0ZWQoYXBwU3RhdGUubGFzdEFwcFZlcnNpb24pKSB7XG4gICAgY2xlYXJBcHBDYWNoZSgpO1xuICB9XG4gIGFwcFN0YXRlLmxhc3RBcHBWZXJzaW9uID0gYXBwLmdldFZlcnNpb24oKTtcblxuICBpZiAoIWdsb2JhbC5pc0Rldikge1xuICAgIHVwZ3JhZGVBdXRvTGF1bmNoKCk7XG4gIH1cblxuICBpZiAoZ2xvYmFsLmlzRGV2KSB7XG4gICAgaW5zdGFsbEV4dGVuc2lvbihSRUFDVF9ERVZFTE9QRVJfVE9PTFMpLlxuICAgICAgdGhlbigobmFtZSkgPT4gY29uc29sZS5sb2coYEFkZGVkIEV4dGVuc2lvbjogICR7bmFtZX1gKSkuXG4gICAgICBjYXRjaCgoZXJyKSA9PiBjb25zb2xlLmxvZygnQW4gZXJyb3Igb2NjdXJyZWQ6ICcsIGVycikpO1xuICB9XG5cbiAgLy8gUHJvdG9jb2wgaGFuZGxlciBmb3Igd2luMzJcbiAgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicpIHtcbiAgICBjb25zdCBhcmdzID0gcHJvY2Vzcy5hcmd2LnNsaWNlKDEpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFyZ3MpICYmIGFyZ3MubGVuZ3RoID4gMCkge1xuICAgICAgZGVlcGxpbmtpbmdVcmwgPSBnZXREZWVwbGlua2luZ1VSTChhcmdzKTtcbiAgICB9XG4gIH1cblxuICBpbml0Q29va2llTWFuYWdlcihzZXNzaW9uLmRlZmF1bHRTZXNzaW9uKTtcblxuICBtYWluV2luZG93ID0gY3JlYXRlTWFpbldpbmRvdyhjb25maWcuZGF0YSwge1xuICAgIGhpZGVPblN0YXJ0dXAsXG4gICAgdHJheUljb25TaG93bjogcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJyB8fCBjb25maWcuc2hvd1RyYXlJY29uLFxuICAgIGxpbnV4QXBwSWNvbjogcGF0aC5qb2luKGFzc2V0c0RpciwgJ2FwcGljb24ucG5nJyksXG4gICAgZGVlcGxpbmtpbmdVcmwsXG4gIH0pO1xuXG4gIGNyaXRpY2FsRXJyb3JIYW5kbGVyLnNldE1haW5XaW5kb3cobWFpbldpbmRvdyk7XG5cbiAgY29uZmlnLnNldFJlZ2lzdHJ5Q29uZmlnRGF0YShyZWdpc3RyeUNvbmZpZy5kYXRhKTtcbiAgbWFpbldpbmRvdy5yZWdpc3RyeUNvbmZpZ0RhdGEgPSByZWdpc3RyeUNvbmZpZy5kYXRhO1xuXG4gIC8vIGxpc3RlbiBmb3Igc3RhdHVzIHVwZGF0ZXMgYW5kIHBhc3Mgb24gdG8gcmVuZGVyZXJcbiAgdXNlckFjdGl2aXR5TW9uaXRvci5vbignc3RhdHVzJywgKHN0YXR1cykgPT4ge1xuICAgIG1haW5XaW5kb3cud2ViQ29udGVudHMuc2VuZCgndXNlci1hY3Rpdml0eS11cGRhdGUnLCBzdGF0dXMpO1xuICB9KTtcblxuICAvLyBzdGFydCBtb25pdG9yaW5nIHVzZXIgYWN0aXZpdHkgKG5lZWRzIHRvIGJlIHN0YXJ0ZWQgYWZ0ZXIgdGhlIGFwcCBpcyByZWFkeSlcbiAgdXNlckFjdGl2aXR5TW9uaXRvci5zdGFydE1vbml0b3JpbmcoKTtcblxuICBpZiAoc2hvdWxkU2hvd1RyYXlJY29uKCkpIHtcbiAgICAvLyBzZXQgdXAgdHJheSBpY29uXG4gICAgdHJheUljb24gPSBuZXcgVHJheSh0cmF5SW1hZ2VzLm5vcm1hbCk7XG4gICAgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICdkYXJ3aW4nKSB7XG4gICAgICB0cmF5SWNvbi5zZXRQcmVzc2VkSW1hZ2UodHJheUltYWdlcy5jbGlja2VkLm5vcm1hbCk7XG4gICAgICBzeXN0ZW1QcmVmZXJlbmNlcy5zdWJzY3JpYmVOb3RpZmljYXRpb24oJ0FwcGxlSW50ZXJmYWNlVGhlbWVDaGFuZ2VkTm90aWZpY2F0aW9uJywgKCkgPT4ge1xuICAgICAgICBzd2l0Y2hNZW51SWNvbkltYWdlcyh0cmF5SW1hZ2VzLCBzeXN0ZW1QcmVmZXJlbmNlcy5pc0RhcmtNb2RlKCkpO1xuICAgICAgICB0cmF5SWNvbi5zZXRJbWFnZSh0cmF5SW1hZ2VzLm5vcm1hbCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0cmF5SWNvbi5zZXRUb29sVGlwKGFwcC5nZXROYW1lKCkpO1xuICAgIHRyYXlJY29uLm9uKCdjbGljaycsICgpID0+IHtcbiAgICAgIGlmICghbWFpbldpbmRvdy5pc1Zpc2libGUoKSB8fCBtYWluV2luZG93LmlzTWluaW1pemVkKCkpIHtcbiAgICAgICAgaWYgKG1haW5XaW5kb3cuaXNNaW5pbWl6ZWQoKSkge1xuICAgICAgICAgIG1haW5XaW5kb3cucmVzdG9yZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1haW5XaW5kb3cuc2hvdygpO1xuICAgICAgICB9XG4gICAgICAgIG1haW5XaW5kb3cuZm9jdXMoKTtcbiAgICAgICAgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICdkYXJ3aW4nKSB7XG4gICAgICAgICAgYXBwLmRvY2suc2hvdygpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYWluV2luZG93LmZvY3VzKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0cmF5SWNvbi5vbigncmlnaHQtY2xpY2snLCAoKSA9PiB7XG4gICAgICB0cmF5SWNvbi5wb3BVcENvbnRleHRNZW51KCk7XG4gICAgfSk7XG4gICAgdHJheUljb24ub24oJ2JhbGxvb24tY2xpY2snLCAoKSA9PiB7XG4gICAgICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJyB8fCBwcm9jZXNzLnBsYXRmb3JtID09PSAnZGFyd2luJykge1xuICAgICAgICBpZiAobWFpbldpbmRvdy5pc01pbmltaXplZCgpKSB7XG4gICAgICAgICAgbWFpbldpbmRvdy5yZXN0b3JlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWFpbldpbmRvdy5zaG93KCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICdkYXJ3aW4nKSB7XG4gICAgICAgIGFwcC5kb2NrLnNob3coKTtcbiAgICAgIH1cblxuICAgICAgbWFpbldpbmRvdy5mb2N1cygpO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICdkYXJ3aW4nKSB7XG4gICAgc2Vzc2lvbi5kZWZhdWx0U2Vzc2lvbi5vbignd2lsbC1kb3dubG9hZCcsIChldmVudCwgaXRlbSkgPT4ge1xuICAgICAgY29uc3QgZmlsZW5hbWUgPSBpdGVtLmdldEZpbGVuYW1lKCk7XG4gICAgICBjb25zdCBzYXZlUGF0aCA9IGRpYWxvZy5zaG93U2F2ZURpYWxvZyh7XG4gICAgICAgIHRpdGxlOiBmaWxlbmFtZSxcbiAgICAgICAgZGVmYXVsdFBhdGg6IG9zLmhvbWVkaXIoKSArICcvRG93bmxvYWRzLycgKyBmaWxlbmFtZSxcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoc2F2ZVBhdGgpIHtcbiAgICAgICAgaXRlbS5zZXRTYXZlUGF0aChzYXZlUGF0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpdGVtLmNhbmNlbCgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaXBjTWFpbi5lbWl0KCd1cGRhdGUtbWVudScsIHRydWUsIGNvbmZpZy5kYXRhKTtcblxuICBpcGNNYWluLmVtaXQoJ3VwZGF0ZS1kaWN0Jyk7XG5cbiAgLy8gc3VwcG9ydGVkIHBlcm1pc3Npb24gdHlwZXNcbiAgY29uc3Qgc3VwcG9ydGVkUGVybWlzc2lvblR5cGVzID0gW1xuICAgICdtZWRpYScsXG4gICAgJ2dlb2xvY2F0aW9uJyxcbiAgICAnbm90aWZpY2F0aW9ucycsXG4gICAgJ2Z1bGxzY3JlZW4nLFxuICAgICdvcGVuRXh0ZXJuYWwnLFxuICBdO1xuXG4gIC8vIGhhbmRsZSBwZXJtaXNzaW9uIHJlcXVlc3RzXG4gIC8vIC0gYXBwcm92ZSBpZiBhIHN1cHBvcnRlZCBwZXJtaXNzaW9uIHR5cGUgYW5kIHRoZSByZXF1ZXN0IGNvbWVzIGZyb20gdGhlIHJlbmRlcmVyIG9yIG9uZSBvZiB0aGUgZGVmaW5lZCBzZXJ2ZXJzXG4gIHNlc3Npb24uZGVmYXVsdFNlc3Npb24uc2V0UGVybWlzc2lvblJlcXVlc3RIYW5kbGVyKCh3ZWJDb250ZW50cywgcGVybWlzc2lvbiwgY2FsbGJhY2spID0+IHtcbiAgICAvLyBpcyB0aGUgcmVxdWVzdGVkIHBlcm1pc3Npb24gdHlwZSBzdXBwb3J0ZWQ/XG4gICAgaWYgKCFzdXBwb3J0ZWRQZXJtaXNzaW9uVHlwZXMuaW5jbHVkZXMocGVybWlzc2lvbikpIHtcbiAgICAgIGNhbGxiYWNrKGZhbHNlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBpcyB0aGUgcmVxdWVzdCBjb21pbmcgZnJvbSB0aGUgcmVuZGVyZXI/XG4gICAgaWYgKHdlYkNvbnRlbnRzLmlkID09PSBtYWluV2luZG93LndlYkNvbnRlbnRzLmlkKSB7XG4gICAgICBjYWxsYmFjayh0cnVlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBnZXQgdGhlIHJlcXVlc3Rpbmcgd2ViQ29udGVudHMgdXJsXG4gICAgY29uc3QgcmVxdWVzdGluZ1VSTCA9IHdlYkNvbnRlbnRzLmdldFVSTCgpO1xuXG4gICAgLy8gaXMgdGhlIHRhcmdldCB1cmwgdHJ1c3RlZD9cbiAgICBjb25zdCBtYXRjaGluZ1RlYW1JbmRleCA9IGNvbmZpZy50ZWFtcy5maW5kSW5kZXgoKHRlYW0pID0+IHtcbiAgICAgIHJldHVybiByZXF1ZXN0aW5nVVJMLnN0YXJ0c1dpdGgodGVhbS51cmwpO1xuICAgIH0pO1xuXG4gICAgY2FsbGJhY2sobWF0Y2hpbmdUZWFtSW5kZXggPj0gMCk7XG4gIH0pO1xufVxuXG4vL1xuLy8gaXBjIGNvbW11bmljYXRpb24gZXZlbnQgaGFuZGxlcnNcbi8vXG5cbmZ1bmN0aW9uIGhhbmRsZUxvZ2luQ3JlZGVudGlhbHNFdmVudChldmVudCwgcmVxdWVzdCwgdXNlciwgcGFzc3dvcmQpIHtcbiAgY29uc3QgY2FsbGJhY2sgPSBsb2dpbkNhbGxiYWNrTWFwLmdldChKU09OLnN0cmluZ2lmeShyZXF1ZXN0KSk7XG4gIGlmIChjYWxsYmFjayAhPSBudWxsKSB7XG4gICAgY2FsbGJhY2sodXNlciwgcGFzc3dvcmQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZURvd25sb2FkVVJMRXZlbnQoZXZlbnQsIHVybCkge1xuICBkb3dubG9hZFVSTChtYWluV2luZG93LCB1cmwsIChlcnIpID0+IHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBkaWFsb2cuc2hvd01lc3NhZ2VCb3gobWFpbldpbmRvdywge1xuICAgICAgICB0eXBlOiAnZXJyb3InLFxuICAgICAgICBtZXNzYWdlOiBlcnIudG9TdHJpbmcoKSxcbiAgICAgIH0pO1xuICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVOb3RpZmllZEV2ZW50KCkge1xuICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJyB8fCBwcm9jZXNzLnBsYXRmb3JtID09PSAnbGludXgnKSB7XG4gICAgaWYgKGNvbmZpZy5ub3RpZmljYXRpb25zLmZsYXNoV2luZG93ID09PSAyKSB7XG4gICAgICBtYWluV2luZG93LmZsYXNoRnJhbWUodHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICdkYXJ3aW4nICYmIGNvbmZpZy5ub3RpZmljYXRpb25zLmJvdW5jZUljb24pIHtcbiAgICBhcHAuZG9jay5ib3VuY2UoY29uZmlnLm5vdGlmaWNhdGlvbnMuYm91bmNlSWNvblR5cGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZVVwZGF0ZVRpdGxlRXZlbnQoZXZlbnQsIGFyZykge1xuICBtYWluV2luZG93LnNldFRpdGxlKGFyZy50aXRsZSk7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZVVwZGF0ZVVucmVhZEV2ZW50KGV2ZW50LCBhcmcpIHtcbiAgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicpIHtcbiAgICBjb25zdCBvdmVybGF5ID0gYXJnLm92ZXJsYXlEYXRhVVJMID8gbmF0aXZlSW1hZ2UuY3JlYXRlRnJvbURhdGFVUkwoYXJnLm92ZXJsYXlEYXRhVVJMKSA6IG51bGw7XG4gICAgaWYgKG1haW5XaW5kb3cpIHtcbiAgICAgIG1haW5XaW5kb3cuc2V0T3ZlcmxheUljb24ob3ZlcmxheSwgYXJnLmRlc2NyaXB0aW9uKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHJheUljb24gJiYgIXRyYXlJY29uLmlzRGVzdHJveWVkKCkpIHtcbiAgICBpZiAoYXJnLnNlc3Npb25FeHBpcmVkKSB7XG4gICAgICAvLyByZXVzZSB0aGUgbWVudGlvbiBpY29uIHdoZW4gdGhlIHNlc3Npb24gaXMgZXhwaXJlZFxuICAgICAgdHJheUljb24uc2V0SW1hZ2UodHJheUltYWdlcy5tZW50aW9uKTtcbiAgICAgIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnZGFyd2luJykge1xuICAgICAgICB0cmF5SWNvbi5zZXRQcmVzc2VkSW1hZ2UodHJheUltYWdlcy5jbGlja2VkLm1lbnRpb24pO1xuICAgICAgfVxuICAgICAgdHJheUljb24uc2V0VG9vbFRpcCgnU2Vzc2lvbiBFeHBpcmVkOiBQbGVhc2Ugc2lnbiBpbiB0byBjb250aW51ZSByZWNlaXZpbmcgbm90aWZpY2F0aW9ucy4nKTtcbiAgICB9IGVsc2UgaWYgKGFyZy5tZW50aW9uQ291bnQgPiAwKSB7XG4gICAgICB0cmF5SWNvbi5zZXRJbWFnZSh0cmF5SW1hZ2VzLm1lbnRpb24pO1xuICAgICAgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICdkYXJ3aW4nKSB7XG4gICAgICAgIHRyYXlJY29uLnNldFByZXNzZWRJbWFnZSh0cmF5SW1hZ2VzLmNsaWNrZWQubWVudGlvbik7XG4gICAgICB9XG4gICAgICB0cmF5SWNvbi5zZXRUb29sVGlwKGFyZy5tZW50aW9uQ291bnQgKyAnIHVucmVhZCBtZW50aW9ucycpO1xuICAgIH0gZWxzZSBpZiAoYXJnLnVucmVhZENvdW50ID4gMCkge1xuICAgICAgdHJheUljb24uc2V0SW1hZ2UodHJheUltYWdlcy51bnJlYWQpO1xuICAgICAgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICdkYXJ3aW4nKSB7XG4gICAgICAgIHRyYXlJY29uLnNldFByZXNzZWRJbWFnZSh0cmF5SW1hZ2VzLmNsaWNrZWQudW5yZWFkKTtcbiAgICAgIH1cbiAgICAgIHRyYXlJY29uLnNldFRvb2xUaXAoYXJnLnVucmVhZENvdW50ICsgJyB1bnJlYWQgY2hhbm5lbHMnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJheUljb24uc2V0SW1hZ2UodHJheUltYWdlcy5ub3JtYWwpO1xuICAgICAgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICdkYXJ3aW4nKSB7XG4gICAgICAgIHRyYXlJY29uLnNldFByZXNzZWRJbWFnZSh0cmF5SW1hZ2VzLmNsaWNrZWQubm9ybWFsKTtcbiAgICAgIH1cbiAgICAgIHRyYXlJY29uLnNldFRvb2xUaXAoYXBwLmdldE5hbWUoKSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZVVwZGF0ZU1lbnVFdmVudChldmVudCwgY29uZmlnRGF0YSkge1xuICBjb25zdCBhTWVudSA9IGFwcE1lbnUuY3JlYXRlTWVudShtYWluV2luZG93LCBjb25maWdEYXRhLCBnbG9iYWwuaXNEZXYpO1xuICBNZW51LnNldEFwcGxpY2F0aW9uTWVudShhTWVudSk7XG5cbiAgLy8gc2V0IHVwIGNvbnRleHQgbWVudSBmb3IgdHJheSBpY29uXG4gIGlmIChzaG91bGRTaG93VHJheUljb24oKSkge1xuICAgIGNvbnN0IHRNZW51ID0gdHJheU1lbnUuY3JlYXRlTWVudShtYWluV2luZG93LCBjb25maWdEYXRhLCBnbG9iYWwuaXNEZXYpO1xuICAgIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnZGFyd2luJyB8fCBwcm9jZXNzLnBsYXRmb3JtID09PSAnbGludXgnKSB7XG4gICAgICAvLyBzdG9yZSB0aGUgaW5mb3JtYXRpb24sIGlmIHRoZSB0cmF5IHdhcyBpbml0aWFsaXplZCwgZm9yIGNoZWNraW5nIGluIHRoZSBzZXR0aW5ncywgaWYgdGhlIGFwcGxpY2F0aW9uXG4gICAgICAvLyB3YXMgcmVzdGFydGVkIGFmdGVyIHNldHRpbmcgXCJTaG93IGljb24gb24gbWVudSBiYXJcIlxuICAgICAgaWYgKHRyYXlJY29uKSB7XG4gICAgICAgIHRyYXlJY29uLnNldENvbnRleHRNZW51KHRNZW51KTtcbiAgICAgICAgbWFpbldpbmRvdy50cmF5V2FzVmlzaWJsZSA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYWluV2luZG93LnRyYXlXYXNWaXNpYmxlID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0cmF5SWNvbikge1xuICAgICAgdHJheUljb24uc2V0Q29udGV4dE1lbnUodE1lbnUpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBsb2NhbGVTZWxlY3RlZCBtaWdodCBiZSBudWxsLCBpZiB0aGF0J3MgdGhlIGNhc2UsIHVzZSBjb25maWcncyBsb2NhbGVcbmZ1bmN0aW9uIGhhbmRsZVVwZGF0ZURpY3Rpb25hcnlFdmVudChfLCBsb2NhbGVTZWxlY3RlZCkge1xuICBpZiAoY29uZmlnLnVzZVNwZWxsQ2hlY2tlcikge1xuICAgIGNvbnN0IGxvY2FsZSA9IGxvY2FsZVNlbGVjdGVkIHx8IGNvbmZpZy5zcGVsbENoZWNrZXJMb2NhbGU7XG4gICAgdHJ5IHtcbiAgICAgIHNwZWxsQ2hlY2tlciA9IG5ldyBTcGVsbENoZWNrZXIoXG4gICAgICAgIGxvY2FsZSxcbiAgICAgICAgcGF0aC5yZXNvbHZlKGFwcC5nZXRBcHBQYXRoKCksICdub2RlX21vZHVsZXMvc2ltcGxlLXNwZWxsY2hlY2tlci9kaWN0JyksXG4gICAgICAgIChlcnIpID0+IHtcbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdjb3VsZG5cXCd0IGxvYWQgYSBzcGVsbGNoZWNrZXIgZm9yIGxvY2FsZScpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVDaGVja1NwZWxsaW5nRXZlbnQoZXZlbnQsIHdvcmQpIHtcbiAgbGV0IHJlcyA9IG51bGw7XG4gIGlmIChjb25maWcudXNlU3BlbGxDaGVja2VyICYmIHNwZWxsQ2hlY2tlci5pc1JlYWR5KCkgJiYgd29yZCAhPT0gbnVsbCkge1xuICAgIHJlcyA9IHNwZWxsQ2hlY2tlci5zcGVsbENoZWNrKHdvcmQpO1xuICB9XG4gIGV2ZW50LnJldHVyblZhbHVlID0gcmVzO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVHZXRTcGVsbGluZ1N1Z2dlc3Rpb25zRXZlbnQoZXZlbnQsIHdvcmQpIHtcbiAgaWYgKGNvbmZpZy51c2VTcGVsbENoZWNrZXIgJiYgc3BlbGxDaGVja2VyLmlzUmVhZHkoKSAmJiB3b3JkICE9PSBudWxsKSB7XG4gICAgZXZlbnQucmV0dXJuVmFsdWUgPSBzcGVsbENoZWNrZXIuZ2V0U3VnZ2VzdGlvbnMod29yZCwgMTApO1xuICB9IGVsc2Uge1xuICAgIGV2ZW50LnJldHVyblZhbHVlID0gW107XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlR2V0U3BlbGxjaGVja2VyTG9jYWxlRXZlbnQoZXZlbnQpIHtcbiAgZXZlbnQucmV0dXJuVmFsdWUgPSBjb25maWcuc3BlbGxDaGVja2VyTG9jYWxlO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVSZXBseU9uU3BlbGxjaGVja2VySXNSZWFkeUV2ZW50KGV2ZW50KSB7XG4gIGlmICghc3BlbGxDaGVja2VyKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHNwZWxsQ2hlY2tlci5pc1JlYWR5KCkpIHtcbiAgICBldmVudC5zZW5kZXIuc2VuZCgnc3BlbGxjaGVja2VyLWlzLXJlYWR5Jyk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHNwZWxsQ2hlY2tlci5vbmNlKCdyZWFkeScsICgpID0+IHtcbiAgICBldmVudC5zZW5kZXIuc2VuZCgnc3BlbGxjaGVja2VyLWlzLXJlYWR5Jyk7XG4gIH0pO1xufVxuXG4vL1xuLy8gbWFpbldpbmRvdyBldmVudCBoYW5kbGVyc1xuLy9cblxuZnVuY3Rpb24gaGFuZGxlTWFpbldpbmRvd0Nsb3NlZCgpIHtcbiAgLy8gRGVyZWZlcmVuY2UgdGhlIHdpbmRvdyBvYmplY3QsIHVzdWFsbHkgeW91IHdvdWxkIHN0b3JlIHdpbmRvd3NcbiAgLy8gaW4gYW4gYXJyYXkgaWYgeW91ciBhcHAgc3VwcG9ydHMgbXVsdGkgd2luZG93cywgdGhpcyBpcyB0aGUgdGltZVxuICAvLyB3aGVuIHlvdSBzaG91bGQgZGVsZXRlIHRoZSBjb3JyZXNwb25kaW5nIGVsZW1lbnQuXG4gIG1haW5XaW5kb3cgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVNYWluV2luZG93V2ViQ29udGVudHNDcmFzaGVkKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ3dlYkNvbnRlbnRzIFxcJ2NyYXNoZWRcXCcgZXZlbnQgaGFzIGJlZW4gZW1pdHRlZCcpO1xufVxuXG4vL1xuLy8gaGVscGVyIGZ1bmN0aW9uc1xuLy9cblxuZnVuY3Rpb24gcGFyc2VVUkwodXJsKSB7XG4gIGlmICghdXJsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKHVybCBpbnN0YW5jZW9mIFVSTCkge1xuICAgIHJldHVybiB1cmw7XG4gIH1cbiAgdHJ5IHtcbiAgICByZXR1cm4gbmV3IFVSTCh1cmwpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNUZWFtVXJsKHVybCkge1xuICBjb25zdCBwYXJzZWRVUkwgPSBwYXJzZVVSTCh1cmwpO1xuICBpZiAoIXBhcnNlZFVSTCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChpc0N1c3RvbUxvZ2luVVJMKHBhcnNlZFVSTCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3Qgbm9uVGVhbVVybFBhdGhzID0gWydwbHVnaW5zJywgJ3NpZ251cCcsICdsb2dpbicsICdhZG1pbicsICdjaGFubmVsJywgJ3Bvc3QnLCAnYXBpJywgJ29hdXRoJ107XG4gIHJldHVybiAhKG5vblRlYW1VcmxQYXRocy5zb21lKCh0ZXN0UGF0aCkgPT4gcGFyc2VkVVJMLnBhdGhuYW1lLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aChgLyR7dGVzdFBhdGh9L2ApKSk7XG59XG5cbmZ1bmN0aW9uIGlzVHJ1c3RlZFVSTCh1cmwpIHtcbiAgY29uc3QgcGFyc2VkVVJMID0gcGFyc2VVUkwodXJsKTtcbiAgaWYgKCFwYXJzZWRVUkwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgdGVhbVVSTHMgPSBjb25maWcudGVhbXMucmVkdWNlKCh1cmxzLCB0ZWFtKSA9PiB7XG4gICAgY29uc3QgcGFyc2VkVGVhbVVSTCA9IHBhcnNlVVJMKHRlYW0udXJsKTtcbiAgICBpZiAocGFyc2VkVGVhbVVSTCkge1xuICAgICAgcmV0dXJuIHVybHMuY29uY2F0KHBhcnNlZFRlYW1VUkwpO1xuICAgIH1cbiAgICByZXR1cm4gdXJscztcbiAgfSwgW10pO1xuICBmb3IgKGNvbnN0IHRlYW1VUkwgb2YgdGVhbVVSTHMpIHtcbiAgICBpZiAocGFyc2VkVVJMLm9yaWdpbiA9PT0gdGVhbVVSTC5vcmlnaW4pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVHJ1c3RlZFBvcHVwV2luZG93KHdlYkNvbnRlbnRzKSB7XG4gIGlmICghd2ViQ29udGVudHMpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKCFwb3B1cFdpbmRvdykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gQnJvd3NlcldpbmRvdy5mcm9tV2ViQ29udGVudHMod2ViQ29udGVudHMpID09PSBwb3B1cFdpbmRvdztcbn1cblxuZnVuY3Rpb24gaXNDdXN0b21Mb2dpblVSTCh1cmwpIHtcbiAgY29uc3QgcGFyc2VkVVJMID0gcGFyc2VVUkwodXJsKTtcbiAgaWYgKCFwYXJzZWRVUkwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKCFpc1RydXN0ZWRVUkwocGFyc2VkVVJMKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCB1cmxQYXRoID0gcGFyc2VkVVJMLnBhdGhuYW1lO1xuICBmb3IgKGNvbnN0IHJlZ2V4UGF0aCBvZiBjdXN0b21Mb2dpblJlZ2V4UGF0aHMpIHtcbiAgICBpZiAodXJsUGF0aC5tYXRjaChyZWdleFBhdGgpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRUcmF5SW1hZ2VzKCkge1xuICBzd2l0Y2ggKHByb2Nlc3MucGxhdGZvcm0pIHtcbiAgY2FzZSAnd2luMzInOlxuICAgIHJldHVybiB7XG4gICAgICBub3JtYWw6IG5hdGl2ZUltYWdlLmNyZWF0ZUZyb21QYXRoKHBhdGgucmVzb2x2ZShhc3NldHNEaXIsICd3aW5kb3dzL3RyYXkuaWNvJykpLFxuICAgICAgdW5yZWFkOiBuYXRpdmVJbWFnZS5jcmVhdGVGcm9tUGF0aChwYXRoLnJlc29sdmUoYXNzZXRzRGlyLCAnd2luZG93cy90cmF5X3VucmVhZC5pY28nKSksXG4gICAgICBtZW50aW9uOiBuYXRpdmVJbWFnZS5jcmVhdGVGcm9tUGF0aChwYXRoLnJlc29sdmUoYXNzZXRzRGlyLCAnd2luZG93cy90cmF5X21lbnRpb24uaWNvJykpLFxuICAgIH07XG4gIGNhc2UgJ2Rhcndpbic6XG4gIHtcbiAgICBjb25zdCBpY29ucyA9IHtcbiAgICAgIGxpZ2h0OiB7XG4gICAgICAgIG5vcm1hbDogbmF0aXZlSW1hZ2UuY3JlYXRlRnJvbVBhdGgocGF0aC5yZXNvbHZlKGFzc2V0c0RpciwgJ29zeC9NZW51SWNvbi5wbmcnKSksXG4gICAgICAgIHVucmVhZDogbmF0aXZlSW1hZ2UuY3JlYXRlRnJvbVBhdGgocGF0aC5yZXNvbHZlKGFzc2V0c0RpciwgJ29zeC9NZW51SWNvblVucmVhZC5wbmcnKSksXG4gICAgICAgIG1lbnRpb246IG5hdGl2ZUltYWdlLmNyZWF0ZUZyb21QYXRoKHBhdGgucmVzb2x2ZShhc3NldHNEaXIsICdvc3gvTWVudUljb25NZW50aW9uLnBuZycpKSxcbiAgICAgIH0sXG4gICAgICBjbGlja2VkOiB7XG4gICAgICAgIG5vcm1hbDogbmF0aXZlSW1hZ2UuY3JlYXRlRnJvbVBhdGgocGF0aC5yZXNvbHZlKGFzc2V0c0RpciwgJ29zeC9DbGlja2VkTWVudUljb24ucG5nJykpLFxuICAgICAgICB1bnJlYWQ6IG5hdGl2ZUltYWdlLmNyZWF0ZUZyb21QYXRoKHBhdGgucmVzb2x2ZShhc3NldHNEaXIsICdvc3gvQ2xpY2tlZE1lbnVJY29uVW5yZWFkLnBuZycpKSxcbiAgICAgICAgbWVudGlvbjogbmF0aXZlSW1hZ2UuY3JlYXRlRnJvbVBhdGgocGF0aC5yZXNvbHZlKGFzc2V0c0RpciwgJ29zeC9DbGlja2VkTWVudUljb25NZW50aW9uLnBuZycpKSxcbiAgICAgIH0sXG4gICAgfTtcbiAgICBzd2l0Y2hNZW51SWNvbkltYWdlcyhpY29ucywgc3lzdGVtUHJlZmVyZW5jZXMuaXNEYXJrTW9kZSgpKTtcbiAgICByZXR1cm4gaWNvbnM7XG4gIH1cbiAgY2FzZSAnbGludXgnOlxuICB7XG4gICAgY29uc3QgdGhlbWUgPSBjb25maWcudHJheUljb25UaGVtZTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbm9ybWFsOiBuYXRpdmVJbWFnZS5jcmVhdGVGcm9tUGF0aChwYXRoLnJlc29sdmUoYXNzZXRzRGlyLCAnbGludXgnLCB0aGVtZSwgJ01lbnVJY29uVGVtcGxhdGUucG5nJykpLFxuICAgICAgICB1bnJlYWQ6IG5hdGl2ZUltYWdlLmNyZWF0ZUZyb21QYXRoKHBhdGgucmVzb2x2ZShhc3NldHNEaXIsICdsaW51eCcsIHRoZW1lLCAnTWVudUljb25VbnJlYWRUZW1wbGF0ZS5wbmcnKSksXG4gICAgICAgIG1lbnRpb246IG5hdGl2ZUltYWdlLmNyZWF0ZUZyb21QYXRoKHBhdGgucmVzb2x2ZShhc3NldHNEaXIsICdsaW51eCcsIHRoZW1lLCAnTWVudUljb25NZW50aW9uVGVtcGxhdGUucG5nJykpLFxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvL0ZhbGxiYWNrIGZvciBpbnZhbGlkIHRoZW1lIHNldHRpbmdcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5vcm1hbDogbmF0aXZlSW1hZ2UuY3JlYXRlRnJvbVBhdGgocGF0aC5yZXNvbHZlKGFzc2V0c0RpciwgJ2xpbnV4JywgJ2xpZ2h0JywgJ01lbnVJY29uVGVtcGxhdGUucG5nJykpLFxuICAgICAgICB1bnJlYWQ6IG5hdGl2ZUltYWdlLmNyZWF0ZUZyb21QYXRoKHBhdGgucmVzb2x2ZShhc3NldHNEaXIsICdsaW51eCcsICdsaWdodCcsICdNZW51SWNvblVucmVhZFRlbXBsYXRlLnBuZycpKSxcbiAgICAgICAgbWVudGlvbjogbmF0aXZlSW1hZ2UuY3JlYXRlRnJvbVBhdGgocGF0aC5yZXNvbHZlKGFzc2V0c0RpciwgJ2xpbnV4JywgJ2xpZ2h0JywgJ01lbnVJY29uTWVudGlvblRlbXBsYXRlLnBuZycpKSxcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIGRlZmF1bHQ6XG4gICAgcmV0dXJuIHt9O1xuICB9XG59XG5cbmZ1bmN0aW9uIHN3aXRjaE1lbnVJY29uSW1hZ2VzKGljb25zLCBpc0RhcmtNb2RlKSB7XG4gIGlmIChpc0RhcmtNb2RlKSB7XG4gICAgaWNvbnMubm9ybWFsID0gaWNvbnMuY2xpY2tlZC5ub3JtYWw7XG4gICAgaWNvbnMudW5yZWFkID0gaWNvbnMuY2xpY2tlZC51bnJlYWQ7XG4gICAgaWNvbnMubWVudGlvbiA9IGljb25zLmNsaWNrZWQubWVudGlvbjtcbiAgfSBlbHNlIHtcbiAgICBpY29ucy5ub3JtYWwgPSBpY29ucy5saWdodC5ub3JtYWw7XG4gICAgaWNvbnMudW5yZWFkID0gaWNvbnMubGlnaHQudW5yZWFkO1xuICAgIGljb25zLm1lbnRpb24gPSBpY29ucy5saWdodC5tZW50aW9uO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldERlZXBsaW5raW5nVVJMKGFyZ3MpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJncykgJiYgYXJncy5sZW5ndGgpIHtcbiAgICAvLyBkZWVwbGluayB1cmxzIHNob3VsZCBhbHdheXMgYmUgdGhlIGxhc3QgYXJndW1lbnQsIGJ1dCBtYXkgbm90IGJlIHRoZSBmaXJzdCAoaS5lLiBXaW5kb3dzIHdpdGggdGhlIGFwcCBhbHJlYWR5IHJ1bm5pbmcpXG4gICAgY29uc3QgdXJsID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdO1xuICAgIGlmICh1cmwgJiYgc2NoZW1lICYmIHVybC5zdGFydHNXaXRoKHNjaGVtZSkgJiYgVXRpbHMuaXNWYWxpZFVSSSh1cmwpKSB7XG4gICAgICByZXR1cm4gdXJsO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gc2hvdWxkU2hvd1RyYXlJY29uKCkge1xuICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChbJ2RhcndpbicsICdsaW51eCddLmluY2x1ZGVzKHByb2Nlc3MucGxhdGZvcm0pICYmIGNvbmZpZy5zaG93VHJheUljb24gPT09IHRydWUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHdhc1VwZGF0ZWQobGFzdEFwcFZlcnNpb24pIHtcbiAgcmV0dXJuIGxhc3RBcHBWZXJzaW9uICE9PSBhcHAuZ2V0VmVyc2lvbigpO1xufVxuXG5mdW5jdGlvbiBjbGVhckFwcENhY2hlKCkge1xuICBpZiAobWFpbldpbmRvdykge1xuICAgIGNvbnNvbGUubG9nKCdDbGVhciBjYWNoZSBhZnRlciB1cGRhdGUnKTtcbiAgICBtYWluV2luZG93LndlYkNvbnRlbnRzLnNlc3Npb24uY2xlYXJDYWNoZSgoKSA9PiB7XG4gICAgICAvL1Jlc3RhcnQgYWZ0ZXIgY2FjaGUgY2xlYXJcbiAgICAgIG1haW5XaW5kb3cucmVsb2FkKCk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgLy9XYWl0IGZvciBtYWluV2luZG93XG4gICAgc2V0VGltZW91dChjbGVhckFwcENhY2hlLCAxMDApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzV2l0aGluRGlzcGxheShzdGF0ZSwgZGlzcGxheSkge1xuICAvLyBnaXZlbiBhIGRpc3BsYXksIGNoZWNrIGlmIHdpbmRvdyBpcyB3aXRoaW4gaXRcbiAgcmV0dXJuIChzdGF0ZS54ID4gZGlzcGxheS5tYXhYIHx8IHN0YXRlLnkgPiBkaXNwbGF5Lm1heFkgfHwgc3RhdGUueCA8IGRpc3BsYXkubWluWCB8fCBzdGF0ZS55IDwgZGlzcGxheS5taW5ZKTtcbn1cblxuZnVuY3Rpb24gZ2V0VmFsaWRXaW5kb3dQb3NpdGlvbihzdGF0ZSkge1xuICAvLyBDaGVjayBpZiB0aGUgcHJldmlvdXMgcG9zaXRpb24gaXMgb3V0IG9mIHRoZSB2aWV3YWJsZSBhcmVhXG4gIC8vIChlLmcuIGJlY2F1c2UgdGhlIHNjcmVlbiBoYXMgYmVlbiBwbHVnZ2VkIG9mZilcbiAgY29uc3QgYm91bmRhcmllcyA9IFV0aWxzLmdldERpc3BsYXlCb3VuZGFyaWVzKCk7XG4gIGNvbnN0IGlzRGlzcGxheWVkID0gYm91bmRhcmllcy5yZWR1Y2UoXG4gICAgKHByZXYsIGRpc3BsYXkpID0+IHtcbiAgICAgIHJldHVybiBwcmV2IHx8IGlzV2l0aGluRGlzcGxheShzdGF0ZSwgZGlzcGxheSk7XG4gICAgfSxcbiAgICBmYWxzZSk7XG5cbiAgaWYgKGlzRGlzcGxheWVkKSB7XG4gICAgUmVmbGVjdC5kZWxldGVQcm9wZXJ0eShzdGF0ZSwgJ3gnKTtcbiAgICBSZWZsZWN0LmRlbGV0ZVByb3BlcnR5KHN0YXRlLCAneScpO1xuICAgIFJlZmxlY3QuZGVsZXRlUHJvcGVydHkoc3RhdGUsICd3aWR0aCcpO1xuICAgIFJlZmxlY3QuZGVsZXRlUHJvcGVydHkoc3RhdGUsICdoZWlnaHQnKTtcbiAgfVxuXG4gIHJldHVybiBzdGF0ZTtcbn1cblxuZnVuY3Rpb24gcmVzaXplU2NyZWVuKHNjcmVlbiwgYnJvd3NlcldpbmRvdykge1xuICBmdW5jdGlvbiBoYW5kbGUoKSB7XG4gICAgY29uc3QgcG9zaXRpb24gPSBicm93c2VyV2luZG93LmdldFBvc2l0aW9uKCk7XG4gICAgY29uc3Qgc2l6ZSA9IGJyb3dzZXJXaW5kb3cuZ2V0U2l6ZSgpO1xuICAgIGNvbnN0IHZhbGlkUG9zaXRpb24gPSBnZXRWYWxpZFdpbmRvd1Bvc2l0aW9uKHtcbiAgICAgIHg6IHBvc2l0aW9uWzBdLFxuICAgICAgeTogcG9zaXRpb25bMV0sXG4gICAgICB3aWR0aDogc2l6ZVswXSxcbiAgICAgIGhlaWdodDogc2l6ZVsxXSxcbiAgICB9KTtcbiAgICBicm93c2VyV2luZG93LnNldFBvc2l0aW9uKHZhbGlkUG9zaXRpb24ueCB8fCAwLCB2YWxpZFBvc2l0aW9uLnkgfHwgMCk7XG4gIH1cblxuICBicm93c2VyV2luZG93Lm9uKCdyZXN0b3JlJywgaGFuZGxlKTtcbiAgaGFuZGxlKCk7XG59XG4iLCIvLyBDb3B5cmlnaHQgKGMpIDIwMTUtMjAxNiBZdXlhIE9jaGlhaVxuLy8gQ29weXJpZ2h0IChjKSAyMDE2LXByZXNlbnQgTWF0dGVybW9zdCwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy8gU2VlIExJQ0VOU0UudHh0IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuaW1wb3J0IEpzb25GaWxlTWFuYWdlciBmcm9tICcuLi9jb21tb24vSnNvbkZpbGVNYW5hZ2VyJztcblxuaW1wb3J0ICogYXMgVmFsaWRhdG9yIGZyb20gJy4vVmFsaWRhdG9yJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXBwU3RhdGVNYW5hZ2VyIGV4dGVuZHMgSnNvbkZpbGVNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoZmlsZSkge1xuICAgIHN1cGVyKGZpbGUpO1xuXG4gICAgLy8gZW5zdXJlIGRhdGEgbG9hZGVkIGZyb20gZmlsZSBpcyB2YWxpZFxuICAgIGNvbnN0IHZhbGlkYXRlZEpTT04gPSBWYWxpZGF0b3IudmFsaWRhdGVBcHBTdGF0ZSh0aGlzLmpzb24pO1xuICAgIGlmICghdmFsaWRhdGVkSlNPTikge1xuICAgICAgdGhpcy5zZXRKc29uKHt9KTtcbiAgICB9XG4gIH1cbiAgc2V0IGxhc3RBcHBWZXJzaW9uKHZlcnNpb24pIHtcbiAgICB0aGlzLnNldFZhbHVlKCdsYXN0QXBwVmVyc2lvbicsIHZlcnNpb24pO1xuICB9XG5cbiAgZ2V0IGxhc3RBcHBWZXJzaW9uKCkge1xuICAgIHJldHVybiB0aGlzLmdldFZhbHVlKCdsYXN0QXBwVmVyc2lvbicpO1xuICB9XG5cbiAgc2V0IHNraXBwZWRWZXJzaW9uKHZlcnNpb24pIHtcbiAgICB0aGlzLnNldFZhbHVlKCdza2lwcGVkVmVyc2lvbicsIHZlcnNpb24pO1xuICB9XG5cbiAgZ2V0IHNraXBwZWRWZXJzaW9uKCkge1xuICAgIHJldHVybiB0aGlzLmdldFZhbHVlKCdza2lwcGVkVmVyc2lvbicpO1xuICB9XG5cbiAgc2V0IHVwZGF0ZUNoZWNrZWREYXRlKGRhdGUpIHtcbiAgICB0aGlzLnNldFZhbHVlKCd1cGRhdGVDaGVja2VkRGF0ZScsIGRhdGUudG9JU09TdHJpbmcoKSk7XG4gIH1cblxuICBnZXQgdXBkYXRlQ2hlY2tlZERhdGUoKSB7XG4gICAgY29uc3QgZGF0ZSA9IHRoaXMuZ2V0VmFsdWUoJ3VwZGF0ZUNoZWNrZWREYXRlJyk7XG4gICAgaWYgKGRhdGUpIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZShkYXRlKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbiIsIi8vIENvcHlyaWdodCAoYykgMjAxNS0yMDE2IFl1eWEgT2NoaWFpXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTYtcHJlc2VudCBNYXR0ZXJtb3N0LCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vLyBTZWUgTElDRU5TRS50eHQgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG5cbmltcG9ydCBBdXRvTGF1bmNoIGZyb20gJ2F1dG8tbGF1bmNoJztcbmltcG9ydCB7YXBwfSBmcm9tICdlbGVjdHJvbic7XG5pbXBvcnQgaXNEZXYgZnJvbSAnZWxlY3Ryb24taXMtZGV2JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXV0b0xhdW5jaGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5hcHBMYXVuY2hlciA9IG5ldyBBdXRvTGF1bmNoKHtcbiAgICAgIG5hbWU6IGFwcC5nZXROYW1lKCksXG4gICAgICBpc0hpZGRlbjogdHJ1ZSxcbiAgICB9KTtcbiAgfVxuXG4gIGlzRW5hYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5hcHBMYXVuY2hlci5pc0VuYWJsZWQoKTtcbiAgfVxuXG4gIGFzeW5jIGJsYW5rUHJvbWlzZSgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGFzeW5jIGVuYWJsZSgpIHtcbiAgICBpZiAoaXNEZXYpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdJbiBkZXZlbG9wbWVudCBtb2RlLCBhdXRvc3RhcnQgY29uZmlnIG5ldmVyIGVmZmVjdHMnKTtcbiAgICAgIHJldHVybiB0aGlzLmJsYW5rUHJvbWlzZSgpO1xuICAgIH1cbiAgICBjb25zdCBlbmFibGVkID0gYXdhaXQgdGhpcy5pc0VuYWJsZWQoKTtcbiAgICBpZiAoIWVuYWJsZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmFwcExhdW5jaGVyLmVuYWJsZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5ibGFua1Byb21pc2UoKTtcbiAgfVxuXG4gIGFzeW5jIGRpc2FibGUoKSB7XG4gICAgaWYgKGlzRGV2KSB7XG4gICAgICBjb25zb2xlLmxvZygnSW4gZGV2ZWxvcG1lbnQgbW9kZSwgYXV0b3N0YXJ0IGNvbmZpZyBuZXZlciBlZmZlY3RzJyk7XG4gICAgICByZXR1cm4gdGhpcy5ibGFua1Byb21pc2UoKTtcbiAgICB9XG4gICAgY29uc3QgZW5hYmxlZCA9IGF3YWl0IHRoaXMuaXNFbmFibGVkKCk7XG4gICAgaWYgKGVuYWJsZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmFwcExhdW5jaGVyLmRpc2FibGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuYmxhbmtQcm9taXNlKCk7XG4gIH1cbn1cbiIsIi8vIENvcHlyaWdodCAoYykgMjAxNS0yMDE2IFl1eWEgT2NoaWFpXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTYtcHJlc2VudCBNYXR0ZXJtb3N0LCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vLyBTZWUgTElDRU5TRS50eHQgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG5pbXBvcnQge3NwYXdufSBmcm9tICdjaGlsZF9wcm9jZXNzJztcbmltcG9ydCBmcyBmcm9tICdmcyc7XG5pbXBvcnQgb3MgZnJvbSAnb3MnO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5cbmltcG9ydCB7YXBwLCBkaWFsb2d9IGZyb20gJ2VsZWN0cm9uJztcblxuY29uc3QgQlVUVE9OX09LID0gJ09LJztcbmNvbnN0IEJVVFRPTl9TSE9XX0RFVEFJTFMgPSAnU2hvdyBEZXRhaWxzJztcbmNvbnN0IEJVVFRPTl9SRU9QRU4gPSAnUmVvcGVuJztcblxuZnVuY3Rpb24gY3JlYXRlRXJyb3JSZXBvcnQoZXJyKSB7XG4gIHJldHVybiBgQXBwbGljYXRpb246ICR7YXBwLmdldE5hbWUoKX0gJHthcHAuZ2V0VmVyc2lvbigpfVxcbmAgK1xuICAgICAgICAgYFBsYXRmb3JtOiAke29zLnR5cGUoKX0gJHtvcy5yZWxlYXNlKCl9ICR7b3MuYXJjaCgpfVxcbmAgK1xuICAgICAgICAgYCR7ZXJyLnN0YWNrfWA7XG59XG5cbmZ1bmN0aW9uIG9wZW5EZXRhY2hlZEV4dGVybmFsKHVybCkge1xuICBjb25zdCBzcGF3bk9wdGlvbiA9IHtkZXRhY2hlZDogdHJ1ZSwgc3RkaW86ICdpZ25vcmUnfTtcbiAgc3dpdGNoIChwcm9jZXNzLnBsYXRmb3JtKSB7XG4gIGNhc2UgJ3dpbjMyJzpcbiAgICByZXR1cm4gc3Bhd24oJ2NtZCcsIFsnL0MnLCAnc3RhcnQnLCB1cmxdLCBzcGF3bk9wdGlvbik7XG4gIGNhc2UgJ2Rhcndpbic6XG4gICAgcmV0dXJuIHNwYXduKCdvcGVuJywgW3VybF0sIHNwYXduT3B0aW9uKTtcbiAgY2FzZSAnbGludXgnOlxuICAgIHJldHVybiBzcGF3bigneGRnLW9wZW4nLCBbdXJsXSwgc3Bhd25PcHRpb24pO1xuICBkZWZhdWx0OlxuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIGJpbmRXaW5kb3dUb1Nob3dNZXNzYWdlQm94KHdpbikge1xuICBpZiAod2luICYmIHdpbi5pc1Zpc2libGUoKSkge1xuICAgIHJldHVybiBkaWFsb2cuc2hvd01lc3NhZ2VCb3guYmluZChudWxsLCB3aW4pO1xuICB9XG4gIHJldHVybiBkaWFsb2cuc2hvd01lc3NhZ2VCb3g7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENyaXRpY2FsRXJyb3JIYW5kbGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5tYWluV2luZG93ID0gbnVsbDtcbiAgfVxuXG4gIHNldE1haW5XaW5kb3cobWFpbldpbmRvdykge1xuICAgIHRoaXMubWFpbldpbmRvdyA9IG1haW5XaW5kb3c7XG4gIH1cblxuICB3aW5kb3dVbnJlc3BvbnNpdmVIYW5kbGVyKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGRpYWxvZy5zaG93TWVzc2FnZUJveCh0aGlzLm1haW5XaW5kb3csIHtcbiAgICAgIHR5cGU6ICd3YXJuaW5nJyxcbiAgICAgIHRpdGxlOiBhcHAuZ2V0TmFtZSgpLFxuICAgICAgbWVzc2FnZTogJ1RoZSB3aW5kb3cgaXMgbm8gbG9uZ2VyIHJlc3BvbnNpdmUuXFxuRG8geW91IHdhaXQgdW50aWwgdGhlIHdpbmRvdyBiZWNvbWVzIHJlc3BvbnNpdmUgYWdhaW4/JyxcbiAgICAgIGJ1dHRvbnM6IFsnTm8nLCAnWWVzJ10sXG4gICAgICBkZWZhdWx0SWQ6IDAsXG4gICAgfSk7XG4gICAgaWYgKHJlc3VsdCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdCcm93c2VyV2luZG93IFxcJ3VucmVzcG9uc2l2ZVxcJyBldmVudCBoYXMgYmVlbiBlbWl0dGVkJyk7XG4gICAgfVxuICB9XG5cbiAgcHJvY2Vzc1VuY2F1Z2h0RXhjZXB0aW9uSGFuZGxlcihlcnIpIHtcbiAgICBjb25zdCBmaWxlID0gcGF0aC5qb2luKGFwcC5nZXRQYXRoKCd1c2VyRGF0YScpLCBgdW5jYXVnaHRFeGNlcHRpb24tJHtEYXRlLm5vdygpfS50eHRgKTtcbiAgICBjb25zdCByZXBvcnQgPSBjcmVhdGVFcnJvclJlcG9ydChlcnIpO1xuICAgIGZzLndyaXRlRmlsZVN5bmMoZmlsZSwgcmVwb3J0LnJlcGxhY2UobmV3IFJlZ0V4cCgnXFxcXG4nLCAnZycpLCBvcy5FT0wpKTtcblxuICAgIGlmIChhcHAuaXNSZWFkeSgpKSB7XG4gICAgICBjb25zdCBidXR0b25zID0gW0JVVFRPTl9TSE9XX0RFVEFJTFMsIEJVVFRPTl9PSywgQlVUVE9OX1JFT1BFTl07XG4gICAgICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ2RhcndpbicpIHtcbiAgICAgICAgYnV0dG9ucy5yZXZlcnNlKCk7XG4gICAgICB9XG4gICAgICBjb25zdCBzaG93TWVzc2FnZUJveCA9IGJpbmRXaW5kb3dUb1Nob3dNZXNzYWdlQm94KHRoaXMubWFpbldpbmRvdyk7XG4gICAgICBjb25zdCByZXN1bHQgPSBzaG93TWVzc2FnZUJveCh7XG4gICAgICAgIHR5cGU6ICdlcnJvcicsXG4gICAgICAgIHRpdGxlOiBhcHAuZ2V0TmFtZSgpLFxuICAgICAgICBtZXNzYWdlOiBgVGhlICR7YXBwLmdldE5hbWUoKX0gYXBwIHF1aXQgdW5leHBlY3RlZGx5LiBDbGljayBcIlNob3cgRGV0YWlsc1wiIHRvIGxlYXJuIG1vcmUgb3IgXCJSZW9wZW5cIiB0byBvcGVuIHRoZSBhcHBsaWNhdGlvbiBhZ2Fpbi5cXG5cXG5JbnRlcm5hbCBlcnJvcjogJHtlcnIubWVzc2FnZX1gLFxuICAgICAgICBidXR0b25zLFxuICAgICAgICBkZWZhdWx0SWQ6IGJ1dHRvbnMuaW5kZXhPZihCVVRUT05fUkVPUEVOKSxcbiAgICAgICAgbm9MaW5rOiB0cnVlLFxuICAgICAgfSk7XG4gICAgICBzd2l0Y2ggKHJlc3VsdCkge1xuICAgICAgY2FzZSBidXR0b25zLmluZGV4T2YoQlVUVE9OX1NIT1dfREVUQUlMUyk6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBjaGlsZCA9IG9wZW5EZXRhY2hlZEV4dGVybmFsKGZpbGUpO1xuICAgICAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICAgICAgY2hpbGQub24oJ2Vycm9yJywgKHNwYXduRXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coc3Bhd25FcnJvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNoaWxkLnVucmVmKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBidXR0b25zLmluZGV4T2YoQlVUVE9OX1JFT1BFTik6XG4gICAgICAgIGFwcC5yZWxhdW5jaCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgZXJyO1xuICB9XG59XG4iLCIvLyBDb3B5cmlnaHQgKGMpIDIwMTYtcHJlc2VudCBNYXR0ZXJtb3N0LCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vLyBTZWUgTElDRU5TRS50eHQgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG5cbmltcG9ydCB5YXJncyBmcm9tICd5YXJncyc7XG5cbmltcG9ydCB7cHJvdG9jb2xzfSBmcm9tICcuLi8uLi9lbGVjdHJvbi1idWlsZGVyLmpzb24nO1xuXG5pbXBvcnQgKiBhcyBWYWxpZGF0b3IgZnJvbSAnLi9WYWxpZGF0b3InO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBwYXJzZShhcmdzKSB7XG4gIHJldHVybiB2YWxpZGF0ZUFyZ3MocGFyc2VBcmdzKHRyaWFnZUFyZ3MoYXJncykpKTtcbn1cblxuZnVuY3Rpb24gdHJpYWdlQXJncyhhcmdzKSB7XG4gIC8vIGVuc3VyZSBhbnkgYXJncyBmb2xsb3dpbmcgYSBwb3NzaWJsZSBkZWVwbGluayBhcmUgZGlzY2FyZGVkXG4gIGlmIChwcm90b2NvbHMgJiYgcHJvdG9jb2xzWzBdICYmIHByb3RvY29sc1swXS5zY2hlbWVzICYmIHByb3RvY29sc1swXS5zY2hlbWVzWzBdKSB7XG4gICAgY29uc3Qgc2NoZW1lID0gcHJvdG9jb2xzWzBdLnNjaGVtZXNbMF0udG9Mb3dlckNhc2UoKTtcbiAgICBjb25zdCBkZWVwbGlua0luZGV4ID0gYXJncy5maW5kSW5kZXgoKGFyZykgPT4gYXJnLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoYCR7c2NoZW1lfTpgKSk7XG4gICAgaWYgKGRlZXBsaW5rSW5kZXggIT09IC0xKSB7XG4gICAgICByZXR1cm4gYXJncy5zbGljZSgwLCBkZWVwbGlua0luZGV4ICsgMSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBhcmdzO1xufVxuXG5mdW5jdGlvbiBwYXJzZUFyZ3MoYXJncykge1xuICByZXR1cm4geWFyZ3MuXG4gICAgYm9vbGVhbignaGlkZGVuJykuZGVzY3JpYmUoJ2hpZGRlbicsICdMYXVuY2ggdGhlIGFwcCBpbiBoaWRkZW4gbW9kZS4nKS5cbiAgICBhbGlhcygnZGlzYWJsZS1kZXYtbW9kZScsICdkaXNhYmxlRGV2TW9kZScpLmJvb2xlYW4oJ2Rpc2FibGUtZGV2LW1vZGUnKS5kZXNjcmliZSgnZGlzYWJsZS1kZXYtbW9kZScsICdEaXNhYmxlIGRldiBtb2RlLicpLlxuICAgIGFsaWFzKCdkYXRhLWRpcicsICdkYXRhRGlyJykuc3RyaW5nKCdkYXRhLWRpcicpLmRlc2NyaWJlKCdkYXRhLWRpcicsICdTZXQgdGhlIHBhdGggdG8gd2hlcmUgdXNlciBkYXRhIGlzIHN0b3JlZC4nKS5cbiAgICBhbGlhcygndicsICd2ZXJzaW9uJykuYm9vbGVhbigndicpLmRlc2NyaWJlKCd2ZXJzaW9uJywgJ1ByaW50cyB0aGUgYXBwbGljYXRpb24gdmVyc2lvbi4nKS5cbiAgICBwYXJzZShhcmdzKTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVBcmdzKGFyZ3MpIHtcbiAgcmV0dXJuIFZhbGlkYXRvci52YWxpZGF0ZUFyZ3MoYXJncykgfHwge307XG59XG4iLCIvLyBDb3B5cmlnaHQgKGMpIDIwMTUtMjAxNiBZdXlhIE9jaGlhaVxuLy8gQ29weXJpZ2h0IChjKSAyMDE2LXByZXNlbnQgTWF0dGVybW9zdCwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy8gU2VlIExJQ0VOU0UudHh0IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJ2V2ZW50cyc7XG5cbmltcG9ydCBzaW1wbGVTcGVsbENoZWNrZXIgZnJvbSAnc2ltcGxlLXNwZWxsY2hlY2tlcic7XG5cbi8vLyBGb2xsb3dpbmcgYXBwcm9hY2ggZm9yIGNvbnRyYWN0aW9ucyBpcyBkZXJpdmVkIGZyb20gZWxlY3Ryb24tc3BlbGxjaGVja2VyLlxuXG4vLyBOQjogVGhpcyBpcyB0byB3b3JrIGFyb3VuZCBlbGVjdHJvbi9lbGVjdHJvbiMxMDA1LCB3aGVyZSBjb250cmFjdGlvbnNcbi8vIGFyZSBpbmNvcnJlY3RseSBtYXJrZWQgYXMgc3BlbGxpbmcgZXJyb3JzLiBUaGlzIGxldHMgcGVvcGxlIGdldCBhd2F5IHdpdGhcbi8vIGluY29ycmVjdGx5IHNwZWxsZWQgY29udHJhY3RlZCB3b3JkcywgYnV0IGl0J3MgdGhlIGJlc3Qgd2UgY2FuIGRvIGZvciBub3cuXG5jb25zdCBjb250cmFjdGlvbnMgPSBbXG4gIFwiYWluJ3RcIiwgXCJhcmVuJ3RcIiwgXCJjYW4ndFwiLCBcImNvdWxkJ3ZlXCIsIFwiY291bGRuJ3RcIiwgXCJjb3VsZG4ndCd2ZVwiLCBcImRpZG4ndFwiLCBcImRvZXNuJ3RcIiwgXCJkb24ndFwiLCBcImhhZG4ndFwiLFxuICBcImhhZG4ndCd2ZVwiLCBcImhhc24ndFwiLCBcImhhdmVuJ3RcIiwgXCJoZSdkXCIsIFwiaGUnZCd2ZVwiLCBcImhlJ2xsXCIsIFwiaGUnc1wiLCBcImhvdydkXCIsIFwiaG93J2xsXCIsIFwiaG93J3NcIiwgXCJJJ2RcIixcbiAgXCJJJ2QndmVcIiwgXCJJJ2xsXCIsIFwiSSdtXCIsIFwiSSd2ZVwiLCBcImlzbid0XCIsIFwiaXQnZFwiLCBcIml0J2QndmVcIiwgXCJpdCdsbFwiLCBcIml0J3NcIiwgXCJsZXQnc1wiLCBcIm1hJ2FtXCIsIFwibWlnaHRuJ3RcIixcbiAgXCJtaWdodG4ndCd2ZVwiLCBcIm1pZ2h0J3ZlXCIsIFwibXVzdG4ndFwiLCBcIm11c3QndmVcIiwgXCJuZWVkbid0XCIsIFwibm90J3ZlXCIsIFwibydjbG9ja1wiLCBcInNoYW4ndFwiLCBcInNoZSdkXCIsIFwic2hlJ2QndmVcIixcbiAgXCJzaGUnbGxcIiwgXCJzaGUnc1wiLCBcInNob3VsZCd2ZVwiLCBcInNob3VsZG4ndFwiLCBcInNob3VsZG4ndCd2ZVwiLCBcInRoYXQnbGxcIiwgXCJ0aGF0J3NcIiwgXCJ0aGVyZSdkXCIsIFwidGhlcmUnZCd2ZVwiLFxuICBcInRoZXJlJ3JlXCIsIFwidGhlcmUnc1wiLCBcInRoZXknZFwiLCBcInRoZXknZCd2ZVwiLCBcInRoZXknbGxcIiwgXCJ0aGV5J3JlXCIsIFwidGhleSd2ZVwiLCBcIndhc24ndFwiLCBcIndlJ2RcIiwgXCJ3ZSdkJ3ZlXCIsXG4gIFwid2UnbGxcIiwgXCJ3ZSdyZVwiLCBcIndlJ3ZlXCIsIFwid2VyZW4ndFwiLCBcIndoYXQnbGxcIiwgXCJ3aGF0J3JlXCIsIFwid2hhdCdzXCIsIFwid2hhdCd2ZVwiLCBcIndoZW4nc1wiLCBcIndoZXJlJ2RcIixcbiAgXCJ3aGVyZSdzXCIsIFwid2hlcmUndmVcIiwgXCJ3aG8nZFwiLCBcIndobydsbFwiLCBcIndobydyZVwiLCBcIndobydzXCIsIFwid2hvJ3ZlXCIsIFwid2h5J2xsXCIsIFwid2h5J3JlXCIsIFwid2h5J3NcIiwgXCJ3b24ndFwiLFxuICBcIndvdWxkJ3ZlXCIsIFwid291bGRuJ3RcIiwgXCJ3b3VsZG4ndCd2ZVwiLCBcInknYWxsXCIsIFwieSdhbGwnZCd2ZVwiLCBcInlvdSdkXCIsIFwieW91J2QndmVcIiwgXCJ5b3UnbGxcIiwgXCJ5b3UncmVcIiwgXCJ5b3UndmVcIixcbl07XG5cbmNvbnN0IGNvbnRyYWN0aW9uTWFwID0gY29udHJhY3Rpb25zLnJlZHVjZSgoYWNjLCB3b3JkKSA9PiB7XG4gIGFjY1t3b3JkLnJlcGxhY2UoLycuKi8sICcnKV0gPSB0cnVlO1xuICByZXR1cm4gYWNjO1xufSwge30pO1xuXG4vLy8gRW5kOiBkZXJpdmVkIGZyb20gZWxlY3Ryb24tc3BlbGxjaGVja2VyLlxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTcGVsbENoZWNrZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3Rvcihsb2NhbGUsIGRpY3REaXIsIGNhbGxiYWNrKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmRpY3QgPSBudWxsO1xuICAgIHRoaXMubG9jYWxlID0gbG9jYWxlO1xuICAgIHNpbXBsZVNwZWxsQ2hlY2tlci5nZXREaWN0aW9uYXJ5KGxvY2FsZSwgZGljdERpciwgKGVyciwgZGljdCkgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kaWN0ID0gZGljdDtcbiAgICAgICAgdGhpcy5lbWl0KCdyZWFkeScpO1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICBjYWxsYmFjayhudWxsLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaXNSZWFkeSgpIHtcbiAgICByZXR1cm4gdGhpcy5kaWN0ICE9PSBudWxsO1xuICB9XG5cbiAgc3BlbGxDaGVjayh3b3JkKSB7XG4gICAgaWYgKHdvcmQudG9Mb3dlckNhc2UoKSA9PT0gJ21hdHRlcm1vc3QnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGlzRmluaXRlKHdvcmQpKSB7IC8vIE51bWVyYWxzIGFyZSBub3QgaW5jbHVkZWQgaW4gdGhlIGRpY3Rpb25hcnlcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAodGhpcy5sb2NhbGUubWF0Y2goL15lbi0/LykgJiYgY29udHJhY3Rpb25NYXBbd29yZF0pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5kaWN0LnNwZWxsQ2hlY2sod29yZCk7XG4gIH1cblxuICBnZXRTdWdnZXN0aW9ucyh3b3JkLCBtYXhTdWdnZXN0aW9ucykge1xuICAgIGNvbnN0IHN1Z2dlc3Rpb25zID0gdGhpcy5kaWN0LmdldFN1Z2dlc3Rpb25zKHdvcmQsIG1heFN1Z2dlc3Rpb25zKTtcblxuICAgIGNvbnN0IGZpcnN0Q2hhcldvcmQgPSB3b3JkLmNoYXJBdCgwKTtcbiAgICBsZXQgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgc3VnZ2VzdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChzdWdnZXN0aW9uc1tpXS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSA9PT0gZmlyc3RDaGFyV29yZC50b1VwcGVyQ2FzZSgpKSB7XG4gICAgICAgIHN1Z2dlc3Rpb25zW2ldID0gZmlyc3RDaGFyV29yZCArIHN1Z2dlc3Rpb25zW2ldLnNsaWNlKDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHVuaXF1ZVN1Z2dlc3Rpb25zID0gc3VnZ2VzdGlvbnMucmVkdWNlKChhLCBiKSA9PiB7XG4gICAgICBpZiAoYS5pbmRleE9mKGIpIDwgMCkge1xuICAgICAgICBhLnB1c2goYik7XG4gICAgICB9XG4gICAgICByZXR1cm4gYTtcbiAgICB9LCBbXSk7XG5cbiAgICByZXR1cm4gdW5pcXVlU3VnZ2VzdGlvbnM7XG4gIH1cbn1cblxuU3BlbGxDaGVja2VyLmdldFNwZWxsQ2hlY2tlckxvY2FsZSA9IChlbGVjdHJvbkxvY2FsZSkgPT4ge1xuICBpZiAoZWxlY3Ryb25Mb2NhbGUubWF0Y2goL15lbi0/LykpIHtcbiAgICByZXR1cm4gJ2VuLVVTJztcbiAgfVxuICBpZiAoZWxlY3Ryb25Mb2NhbGUubWF0Y2goL15mci0/LykpIHtcbiAgICByZXR1cm4gJ2ZyLUZSJztcbiAgfVxuICBpZiAoZWxlY3Ryb25Mb2NhbGUubWF0Y2goL15kZS0/LykpIHtcbiAgICByZXR1cm4gJ2RlLURFJztcbiAgfVxuICBpZiAoZWxlY3Ryb25Mb2NhbGUubWF0Y2goL15lcy0/LykpIHtcbiAgICByZXR1cm4gJ2VzLUVTJztcbiAgfVxuICBpZiAoZWxlY3Ryb25Mb2NhbGUubWF0Y2goL15ubC0/LykpIHtcbiAgICByZXR1cm4gJ25sLU5MJztcbiAgfVxuICBpZiAoZWxlY3Ryb25Mb2NhbGUubWF0Y2goL15wdC0/LykpIHtcbiAgICByZXR1cm4gJ3B0LUJSJztcbiAgfVxuICByZXR1cm4gJ2VuLVVTJztcbn07XG4iLCIvLyBDb3B5cmlnaHQgKGMpIDIwMTYtcHJlc2VudCBNYXR0ZXJtb3N0LCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vLyBTZWUgTElDRU5TRS50eHQgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG5cbmltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnZXZlbnRzJztcblxuaW1wb3J0IGVsZWN0cm9uIGZyb20gJ2VsZWN0cm9uJztcblxuY29uc3Qge2FwcH0gPSBlbGVjdHJvbjtcblxuLyoqXG4gKiBNb25pdG9ycyBzeXN0ZW0gaWRsZSB0aW1lLCBsaXN0ZW5zIGZvciBzeXN0ZW0gZXZlbnRzIGFuZCBmaXJlcyBzdGF0dXMgdXBkYXRlcyBhcyBuZWVkZWRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVXNlckFjdGl2aXR5TW9uaXRvciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLmlzQWN0aXZlID0gdHJ1ZTtcbiAgICB0aGlzLmlkbGVUaW1lID0gMDtcbiAgICB0aGlzLmxhc3RTZXRBY3RpdmUgPSBudWxsO1xuICAgIHRoaXMuc3lzdGVtSWRsZVRpbWVJbnRlcnZhbElEID0gLTE7XG5cbiAgICB0aGlzLmNvbmZpZyA9IHtcbiAgICAgIHVwZGF0ZUZyZXF1ZW5jeU1zOiAxICogMTAwMCwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1tYWdpYy1udW1iZXJzXG4gICAgICBpbmFjdGl2ZVRocmVzaG9sZE1zOiA2MCAqIDEwMDAsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbWFnaWMtbnVtYmVyc1xuICAgICAgc3RhdHVzVXBkYXRlVGhyZXNob2xkTXM6IDYwICogMTAwMCwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1tYWdpYy1udW1iZXJzXG4gICAgfTtcbiAgfVxuXG4gIGdldCB1c2VySXNBY3RpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNBY3RpdmU7XG4gIH1cblxuICBnZXQgdXNlcklkbGVUaW1lKCkge1xuICAgIHJldHVybiB0aGlzLmlkbGVUaW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIEJlZ2luIG1vbml0b3Jpbmcgc3lzdGVtIGV2ZW50cyBhbmQgaWRsZSB0aW1lIGF0IGRlZmluZWQgZnJlcXVlbmN5XG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgLSBvdmVyaWRlIGludGVybmFsIGNvbmZpZ3VyYXRpb24gZGVmYXVsdHNcbiAgICogQHBhcmFtIHtudW1iZXJ9IGNvbmZpZy51cGRhdGVGcmVxdWVuY3lNcyAtIGludGVybmFsIHVwZGF0ZSBjbG9jayBmcmVxdWVuY3kgZm9yIG1vbml0b3JpbmcgaWRsZVRpbWVcbiAgICogQHBhcmFtIHtudW1iZXJ9IGNvbmZpZy5pbmFjdGl2ZVRocmVzaG9sZE1zIC0gdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdGhhdCBpZGxlVGltZSBuZWVkcyB0byByZWFjaCB0byBpbnRlcm5hbGx5IGJlIGNvbnNpZGVyZWQgaW5hY3RpdmVcbiAgICogQHBhcmFtIHtudW1iZXJ9IGNvbmZpZy5zdGF0dXNVcGRhdGVUaHJlc2hvbGRNcyAtIG1pbmltdW0gYW1vdW50IG9mIHRpbWUgYmVmb3JlIHNlbmRpbmcgYSBuZXcgc3RhdHVzIHVwZGF0ZVxuICAgKiBAZW1pdHMge2Vycm9yfSBlbWl0dGVkIHdoZW4gbWV0aG9kIGlzIGNhbGxlZCBiZWZvcmUgdGhlIGFwcCBpcyByZWFkeVxuICAgKiBAZW1pdHMge2Vycm9yfSBlbWl0dGVkIHdoZW4gdGhpcyBtZXRob2QgaGFzIHByZXZpb3VzbHkgYmVlbiBjYWxsZWQgYnV0IG5vdCBzdWJzZXF1ZW50bHkgc3RvcHBlZFxuICAgKi9cbiAgc3RhcnRNb25pdG9yaW5nKGNvbmZpZyA9IHt9KSB7XG4gICAgaWYgKCFhcHAuaXNSZWFkeSgpKSB7XG4gICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdVc2VyQWN0aXZpdHlNb25pdG9yLnN0YXJ0TW9uaXRvcmluZyBjYW4gb25seSBiZSBjYWxsZWQgYWZ0ZXIgYXBwIGlzIHJlYWR5JykpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnN5c3RlbUlkbGVUaW1lSW50ZXJ2YWxJRCA+PSAwKSB7XG4gICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdVc2VyIGFjdGl2aXR5IG1vbml0b3JpbmcgaXMgYWxyZWFkeSBpbiBwcm9ncmVzcycpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmNvbmZpZyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuY29uZmlnLCBjb25maWcpO1xuXG4gICAgdGhpcy5zeXN0ZW1JZGxlVGltZUludGVydmFsSUQgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBlbGVjdHJvbi5wb3dlck1vbml0b3IucXVlcnlTeXN0ZW1JZGxlVGltZSgoaWRsZVRpbWUpID0+IHtcbiAgICAgICAgICB0aGlzLnVwZGF0ZUlkbGVUaW1lKGlkbGVUaW1lKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ0Vycm9yIGdldHRpbmcgc3lzdGVtIGlkbGUgdGltZTonLCBlcnIpO1xuICAgICAgfVxuICAgIH0sIHRoaXMuY29uZmlnLnVwZGF0ZUZyZXF1ZW5jeU1zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wIG1vbml0b3Jpbmcgc3lzdGVtIGV2ZW50cyBhbmQgaWRsZSB0aW1lXG4gICAqL1xuICBzdG9wTW9uaXRvcmluZygpIHtcbiAgICBjbGVhckludGVydmFsKHRoaXMuc3lzdGVtSWRsZVRpbWVJbnRlcnZhbElEKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGludGVybmFsIGlkbGUgdGltZSBhbmQgc2V0cyBpbnRlcm5hbCB1c2VyIGFjdGl2aXR5IHN0YXRlXG4gICAqXG4gICAqIEBwYXJhbSB7aW50ZWdlcn0gaWRsZVRpbWVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHVwZGF0ZUlkbGVUaW1lKGlkbGVUaW1lKSB7XG4gICAgdGhpcy5pZGxlVGltZSA9IGlkbGVUaW1lO1xuICAgIGlmIChpZGxlVGltZSAqIDEwMDAgPiB0aGlzLmNvbmZpZy5pbmFjdGl2ZVRocmVzaG9sZE1zKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbWFnaWMtbnVtYmVyc1xuICAgICAgdGhpcy5zZXRBY3Rpdml0eVN0YXRlKGZhbHNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRBY3Rpdml0eVN0YXRlKHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHVzZXIgYWN0aXZlIHN0YXRlIGFuZCBjb25kaXRpb25hbGx5IHRyaWdnZXJzIGEgc3RhdHVzIHVwZGF0ZVxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzQWN0aXZlXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNTeXN0ZW1FdmVudCDigJMgaW5kaWNhdGVzIHdoZXRoZXIgdGhlIHVwZGF0ZSB3YXMgdHJpZ2dlcmVkIGJ5IGEgc3lzdGVtIGV2ZW50IChsb2cgaW4vb3V0LCBzY3JlZXNhdmVyIG9uL29mZiBldGMpXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzZXRBY3Rpdml0eVN0YXRlKGlzQWN0aXZlID0gZmFsc2UsIGlzU3lzdGVtRXZlbnQgPSBmYWxzZSkge1xuICAgIHRoaXMuaXNBY3RpdmUgPSBpc0FjdGl2ZTtcblxuICAgIGlmIChpc1N5c3RlbUV2ZW50KSB7XG4gICAgICB0aGlzLnNlbmRTdGF0dXNVcGRhdGUodHJ1ZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcblxuICAgIGlmIChpc0FjdGl2ZSAmJiAodGhpcy5sYXN0U2V0QWN0aXZlID09IG51bGwgfHwgbm93IC0gdGhpcy5sYXN0U2V0QWN0aXZlID49IHRoaXMuY29uZmlnLnN0YXR1c1VwZGF0ZVRocmVzaG9sZE1zKSkge1xuICAgICAgdGhpcy5zZW5kU3RhdHVzVXBkYXRlKGZhbHNlKTtcbiAgICAgIHRoaXMubGFzdFNldEFjdGl2ZSA9IG5vdztcbiAgICB9IGVsc2UgaWYgKCFpc0FjdGl2ZSkge1xuICAgICAgdGhpcy5sYXN0U2V0QWN0aXZlID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2VuZHMgYW4gdXBkYXRlIHdpdGggdXNlciBhY3Rpdml0eSBzdGF0dXMgYW5kIGN1cnJlbnQgc3lzdGVtIGlkbGUgdGltZVxuICAgKlxuICAgKiBAZW1pdHMge3N0YXR1c30gZW1pdHRlZCBhdCByZWd1bGFyLCBkZWZpbmFibGUgaW50ZXJ2YWxzIHByb3ZpZGluZyBhbiB1cGRhdGUgb24gdXNlciBhY3RpdmUgc3RhdHVzIGFuZCBpZGxlIHRpbWVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHNlbmRTdGF0dXNVcGRhdGUoaXNTeXN0ZW1FdmVudCA9IGZhbHNlKSB7XG4gICAgdGhpcy5lbWl0KCdzdGF0dXMnLCB7XG4gICAgICB1c2VySXNBY3RpdmU6IHRoaXMuaXNBY3RpdmUsXG4gICAgICBpZGxlVGltZTogdGhpcy5pZGxlVGltZSxcbiAgICAgIGlzU3lzdGVtRXZlbnQsXG4gICAgfSk7XG4gIH1cbn1cbiIsIi8vIENvcHlyaWdodCAoYykgMjAxNi1wcmVzZW50IE1hdHRlcm1vc3QsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vIFNlZSBMSUNFTlNFLnR4dCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbmltcG9ydCBKb2kgZnJvbSAnQGhhcGkvam9pJztcblxuaW1wb3J0IFV0aWxzIGZyb20gJy4uL3V0aWxzL3V0aWwnO1xuXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgc3RyaXBVbmtub3duOiB0cnVlLFxufTtcbmNvbnN0IGRlZmF1bHRXaW5kb3dXaWR0aCA9IDEwMDA7XG5jb25zdCBkZWZhdWx0V2luZG93SGVpZ2h0ID0gNzAwO1xuY29uc3QgbWluV2luZG93V2lkdGggPSA0MDA7XG5jb25zdCBtaW5XaW5kb3dIZWlnaHQgPSAyNDA7XG5cbmNvbnN0IGFyZ3NTY2hlbWEgPSBKb2kub2JqZWN0KHtcbiAgaGlkZGVuOiBKb2kuYm9vbGVhbigpLFxuICAnZGlzYWJsZS1kZXYtbW9kZSc6IEpvaS5ib29sZWFuKCksXG4gIGRpc2FibGVEZXZNb2RlOiBKb2kuYm9vbGVhbigpLFxuICAnZGF0YS1kaXInOiBKb2kuc3RyaW5nKCksXG4gIGRhdGFEaXI6IEpvaS5hcnJheSgpLml0ZW1zKEpvaS5zdHJpbmcoKSksXG4gIHZlcnNpb246IEpvaS5ib29sZWFuKCksXG59KTtcblxuY29uc3QgYm91bmRzSW5mb1NjaGVtYSA9IEpvaS5vYmplY3Qoe1xuICB4OiBKb2kubnVtYmVyKCkuaW50ZWdlcigpLmRlZmF1bHQoMCksXG4gIHk6IEpvaS5udW1iZXIoKS5pbnRlZ2VyKCkuZGVmYXVsdCgwKSxcbiAgd2lkdGg6IEpvaS5udW1iZXIoKS5pbnRlZ2VyKCkubWluKG1pbldpbmRvd1dpZHRoKS5yZXF1aXJlZCgpLmRlZmF1bHQoZGVmYXVsdFdpbmRvd1dpZHRoKSxcbiAgaGVpZ2h0OiBKb2kubnVtYmVyKCkuaW50ZWdlcigpLm1pbihtaW5XaW5kb3dIZWlnaHQpLnJlcXVpcmVkKCkuZGVmYXVsdChkZWZhdWx0V2luZG93SGVpZ2h0KSxcbiAgbWF4aW1pemVkOiBKb2kuYm9vbGVhbigpLmRlZmF1bHQoZmFsc2UpLFxuICBmdWxsc2NyZWVuOiBKb2kuYm9vbGVhbigpLmRlZmF1bHQoZmFsc2UpLFxufSk7XG5cbmNvbnN0IGFwcFN0YXRlU2NoZW1hID0gSm9pLm9iamVjdCh7XG4gIGxhc3RBcHBWZXJzaW9uOiBKb2kuc3RyaW5nKCksXG4gIHNraXBwZWRWZXJzaW9uOiBKb2kuc3RyaW5nKCksXG4gIHVwZGF0ZUNoZWNrZWREYXRlOiBKb2kuc3RyaW5nKCksXG59KTtcblxuY29uc3QgY29uZmlnRGF0YVNjaGVtYVYwID0gSm9pLm9iamVjdCh7XG4gIHVybDogSm9pLnN0cmluZygpLnJlcXVpcmVkKCksXG59KTtcblxuY29uc3QgY29uZmlnRGF0YVNjaGVtYVYxID0gSm9pLm9iamVjdCh7XG4gIHZlcnNpb246IEpvaS5udW1iZXIoKS5taW4oMSkuZGVmYXVsdCgxKSxcbiAgdGVhbXM6IEpvaS5hcnJheSgpLml0ZW1zKEpvaS5vYmplY3Qoe1xuICAgIG5hbWU6IEpvaS5zdHJpbmcoKS5yZXF1aXJlZCgpLFxuICAgIHVybDogSm9pLnN0cmluZygpLnJlcXVpcmVkKCksXG4gIH0pKS5kZWZhdWx0KFtdKSxcbiAgc2hvd1RyYXlJY29uOiBKb2kuYm9vbGVhbigpLmRlZmF1bHQoZmFsc2UpLFxuICB0cmF5SWNvblRoZW1lOiBKb2kuYW55KCkuYWxsb3coJycpLnZhbGlkKCdsaWdodCcsICdkYXJrJykuZGVmYXVsdCgnbGlnaHQnKSxcbiAgbWluaW1pemVUb1RyYXk6IEpvaS5ib29sZWFuKCkuZGVmYXVsdChmYWxzZSksXG4gIG5vdGlmaWNhdGlvbnM6IEpvaS5vYmplY3Qoe1xuICAgIGZsYXNoV2luZG93OiBKb2kuYW55KCkudmFsaWQoMCwgMikuZGVmYXVsdCgwKSxcbiAgICBib3VuY2VJY29uOiBKb2kuYm9vbGVhbigpLmRlZmF1bHQoZmFsc2UpLFxuICAgIGJvdW5jZUljb25UeXBlOiBKb2kuYW55KCkuYWxsb3coJycpLnZhbGlkKCdpbmZvcm1hdGlvbmFsJywgJ2NyaXRpY2FsJykuZGVmYXVsdCgnaW5mb3JtYXRpb25hbCcpLFxuICB9KSxcbiAgc2hvd1VucmVhZEJhZGdlOiBKb2kuYm9vbGVhbigpLmRlZmF1bHQodHJ1ZSksXG4gIHVzZVNwZWxsQ2hlY2tlcjogSm9pLmJvb2xlYW4oKS5kZWZhdWx0KHRydWUpLFxuICBlbmFibGVIYXJkd2FyZUFjY2VsZXJhdGlvbjogSm9pLmJvb2xlYW4oKS5kZWZhdWx0KHRydWUpLFxuICBhdXRvc3RhcnQ6IEpvaS5ib29sZWFuKCkuZGVmYXVsdCh0cnVlKSxcbiAgc3BlbGxDaGVja2VyTG9jYWxlOiBKb2kuc3RyaW5nKCkucmVnZXgoL15bYS16XXsyfS1bQS1aXXsyfSQvKS5kZWZhdWx0KCdlbi1VUycpLFxufSk7XG5cbi8vIGVnLiBkYXRhWydjb21tdW5pdHkubWF0dGVybW9zdC5jb20nXSA9IHsgZGF0YTogJ2NlcnRpZmljYXRlIGRhdGEnLCBpc3N1ZXJOYW1lOiAnQ09NT0RPIFJTQSBEb21haW4gVmFsaWRhdGlvbiBTZWN1cmUgU2VydmVyIENBJ307XG5jb25zdCBjZXJ0aWZpY2F0ZVN0b3JlU2NoZW1hID0gSm9pLm9iamVjdCgpLnBhdHRlcm4oXG4gIEpvaS5zdHJpbmcoKS51cmkoKSxcbiAgSm9pLm9iamVjdCh7XG4gICAgZGF0YTogSm9pLnN0cmluZygpLFxuICAgIGlzc3Vlck5hbWU6IEpvaS5zdHJpbmcoKSxcbiAgfSlcbik7XG5cbmNvbnN0IGFsbG93ZWRQcm90b2NvbHNTY2hlbWEgPSBKb2kuYXJyYXkoKS5pdGVtcyhKb2kuc3RyaW5nKCkucmVnZXgoL15bYS16LV0rOiQvaSkpO1xuXG4vLyB2YWxpZGF0ZSBib3VuZHNfaW5mby5qc29uXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVBcmdzKGRhdGEpIHtcbiAgcmV0dXJuIHZhbGlkYXRlQWdhaW5zdFNjaGVtYShkYXRhLCBhcmdzU2NoZW1hKTtcbn1cblxuLy8gdmFsaWRhdGUgYm91bmRzX2luZm8uanNvblxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlQm91bmRzSW5mbyhkYXRhKSB7XG4gIHJldHVybiB2YWxpZGF0ZUFnYWluc3RTY2hlbWEoZGF0YSwgYm91bmRzSW5mb1NjaGVtYSk7XG59XG5cbi8vIHZhbGlkYXRlIGFwcF9zdGF0ZS5qc29uXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVBcHBTdGF0ZShkYXRhKSB7XG4gIHJldHVybiB2YWxpZGF0ZUFnYWluc3RTY2hlbWEoZGF0YSwgYXBwU3RhdGVTY2hlbWEpO1xufVxuXG4vLyB2YWxpZGF0ZSB2LjAgY29uZmlnLmpzb25cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZVYwQ29uZmlnRGF0YShkYXRhKSB7XG4gIHJldHVybiB2YWxpZGF0ZUFnYWluc3RTY2hlbWEoZGF0YSwgY29uZmlnRGF0YVNjaGVtYVYwKTtcbn1cblxuLy8gdmFsaWRhdGUgdi4xIGNvbmZpZy5qc29uXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVWMUNvbmZpZ0RhdGEoZGF0YSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShkYXRhLnRlYW1zKSAmJiBkYXRhLnRlYW1zLmxlbmd0aCkge1xuICAgIC8vIGZpcnN0IHJlcGxhY2UgcG9zc2libGUgYmFja3NsYXNoZXMgd2l0aCBmb3J3YXJkIHNsYXNoZXNcbiAgICBsZXQgdGVhbXMgPSBkYXRhLnRlYW1zLm1hcCgoe25hbWUsIHVybH0pID0+IHtcbiAgICAgIGxldCB1cGRhdGVkVVJMID0gdXJsO1xuICAgICAgaWYgKHVwZGF0ZWRVUkwuaW5jbHVkZXMoJ1xcXFwnKSkge1xuICAgICAgICB1cGRhdGVkVVJMID0gdXBkYXRlZFVSTC50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1xcXFwvZ2ksICcvJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge25hbWUsIHVybDogdXBkYXRlZFVSTH07XG4gICAgfSk7XG5cbiAgICAvLyBuZXh0IGZpbHRlciBvdXQgdXJscyB0aGF0IGFyZSBzdGlsbCBpbnZhbGlkIHNvIGFsbCBpcyBub3QgbG9zdFxuICAgIHRlYW1zID0gdGVhbXMuZmlsdGVyKCh7dXJsfSkgPT4gVXRpbHMuaXNWYWxpZFVSTCh1cmwpKTtcblxuICAgIC8vIHJlcGxhY2Ugb3JpZ2luYWwgdGVhbXNcbiAgICBkYXRhLnRlYW1zID0gdGVhbXM7XG4gIH1cbiAgcmV0dXJuIHZhbGlkYXRlQWdhaW5zdFNjaGVtYShkYXRhLCBjb25maWdEYXRhU2NoZW1hVjEpO1xufVxuXG4vLyB2YWxpZGF0ZSBjZXJ0aWZpY2F0ZS5qc29uXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVDZXJ0aWZpY2F0ZVN0b3JlKGRhdGEpIHtcbiAgcmV0dXJuIHZhbGlkYXRlQWdhaW5zdFNjaGVtYShkYXRhLCBjZXJ0aWZpY2F0ZVN0b3JlU2NoZW1hKTtcbn1cblxuLy8gdmFsaWRhdGUgYWxsb3dlZFByb3RvY29scy5qc29uXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVBbGxvd2VkUHJvdG9jb2xzKGRhdGEpIHtcbiAgcmV0dXJuIHZhbGlkYXRlQWdhaW5zdFNjaGVtYShkYXRhLCBhbGxvd2VkUHJvdG9jb2xzU2NoZW1hKTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVBZ2FpbnN0U2NoZW1hKGRhdGEsIHNjaGVtYSkge1xuICBpZiAodHlwZW9mIGRhdGEgIT09ICdvYmplY3QnIHx8ICFzY2hlbWEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3Qge2Vycm9yLCB2YWx1ZX0gPSBKb2kudmFsaWRhdGUoZGF0YSwgc2NoZW1hLCBkZWZhdWx0T3B0aW9ucyk7XG4gIGlmIChlcnJvcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG4iLCIvLyBDb3B5cmlnaHQgKGMpIDIwMTUtMjAxNiBZdXlhIE9jaGlhaVxuLy8gQ29weXJpZ2h0IChjKSAyMDE2LXByZXNlbnQgTWF0dGVybW9zdCwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy8gU2VlIExJQ0VOU0UudHh0IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCBmcyBmcm9tICdmcyc7XG5cbmltcG9ydCB7YXBwLCBkaWFsb2csIGlwY01haW4sIHNoZWxsfSBmcm9tICdlbGVjdHJvbic7XG5cbmltcG9ydCAqIGFzIFZhbGlkYXRvciBmcm9tICcuL1ZhbGlkYXRvcic7XG5cbmNvbnN0IGFsbG93ZWRQcm90b2NvbEZpbGUgPSBwYXRoLnJlc29sdmUoYXBwLmdldFBhdGgoJ3VzZXJEYXRhJyksICdhbGxvd2VkUHJvdG9jb2xzLmpzb24nKTtcbmxldCBhbGxvd2VkUHJvdG9jb2xzID0gW107XG5cbmZ1bmN0aW9uIGluaXQobWFpbldpbmRvdykge1xuICBmcy5yZWFkRmlsZShhbGxvd2VkUHJvdG9jb2xGaWxlLCAndXRmLTgnLCAoZXJyLCBkYXRhKSA9PiB7XG4gICAgaWYgKCFlcnIpIHtcbiAgICAgIGFsbG93ZWRQcm90b2NvbHMgPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgYWxsb3dlZFByb3RvY29scyA9IFZhbGlkYXRvci52YWxpZGF0ZUFsbG93ZWRQcm90b2NvbHMoYWxsb3dlZFByb3RvY29scykgfHwgW107XG4gICAgfVxuICAgIGluaXREaWFsb2dFdmVudChtYWluV2luZG93KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGluaXREaWFsb2dFdmVudChtYWluV2luZG93KSB7XG4gIGlwY01haW4ub24oJ2NvbmZpcm0tcHJvdG9jb2wnLCAoZXZlbnQsIHByb3RvY29sLCBVUkwpID0+IHtcbiAgICBpZiAoYWxsb3dlZFByb3RvY29scy5pbmRleE9mKHByb3RvY29sKSAhPT0gLTEpIHtcbiAgICAgIHNoZWxsLm9wZW5FeHRlcm5hbChVUkwpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkaWFsb2cuc2hvd01lc3NhZ2VCb3gobWFpbldpbmRvdywge1xuICAgICAgdGl0bGU6ICdOb24gaHR0cChzKSBwcm90b2NvbCcsXG4gICAgICBtZXNzYWdlOiBgJHtwcm90b2NvbH0gbGluayByZXF1aXJlcyBhbiBleHRlcm5hbCBhcHBsaWNhdGlvbi5gLFxuICAgICAgZGV0YWlsOiBgVGhlIHJlcXVlc3RlZCBsaW5rIGlzICR7VVJMfSAuIERvIHlvdSB3YW50IHRvIGNvbnRpbnVlP2AsXG4gICAgICB0eXBlOiAnd2FybmluZycsXG4gICAgICBidXR0b25zOiBbXG4gICAgICAgICdZZXMnLFxuICAgICAgICBgWWVzIChTYXZlICR7cHJvdG9jb2x9IGFzIGFsbG93ZWQpYCxcbiAgICAgICAgJ05vJyxcbiAgICAgIF0sXG4gICAgICBjYW5jZWxJZDogMixcbiAgICAgIG5vTGluazogdHJ1ZSxcbiAgICB9LCAocmVzcG9uc2UpID0+IHtcbiAgICAgIHN3aXRjaCAocmVzcG9uc2UpIHtcbiAgICAgIGNhc2UgMToge1xuICAgICAgICBhbGxvd2VkUHJvdG9jb2xzLnB1c2gocHJvdG9jb2wpO1xuICAgICAgICBmdW5jdGlvbiBoYW5kbGVFcnJvcihlcnIpIHtcbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZzLndyaXRlRmlsZShhbGxvd2VkUHJvdG9jb2xGaWxlLCBKU09OLnN0cmluZ2lmeShhbGxvd2VkUHJvdG9jb2xzKSwgaGFuZGxlRXJyb3IpO1xuICAgICAgICBzaGVsbC5vcGVuRXh0ZXJuYWwoVVJMKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHNoZWxsLm9wZW5FeHRlcm5hbChVUkwpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBpbml0LFxufTtcbiIsIi8vIENvcHlyaWdodCAoYykgMjAxNS0yMDE2IFl1eWEgT2NoaWFpXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTYtcHJlc2VudCBNYXR0ZXJtb3N0LCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vLyBTZWUgTElDRU5TRS50eHQgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG5pbXBvcnQgQXV0b0xhdW5jaCBmcm9tICdhdXRvLWxhdW5jaCc7XG5cbmFzeW5jIGZ1bmN0aW9uIHVwZ3JhZGVBdXRvTGF1bmNoKCkge1xuICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ2RhcndpbicpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgYXBwTGF1bmNoZXIgPSBuZXcgQXV0b0xhdW5jaCh7XG4gICAgbmFtZTogJ01hdHRlcm1vc3QnLFxuICAgIGlzSGlkZGVuOiB0cnVlLFxuICB9KTtcbiAgY29uc3QgZW5hYmxlZCA9IGF3YWl0IGFwcExhdW5jaGVyLmlzRW5hYmxlZCgpO1xuICBpZiAoZW5hYmxlZCkge1xuICAgIGF3YWl0IGFwcExhdW5jaGVyLmVuYWJsZSgpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IHVwZ3JhZGVBdXRvTGF1bmNoO1xuIiwiLy8gQ29weXJpZ2h0IChjKSAyMDE1LTIwMTYgWXV5YSBPY2hpYWlcbi8vIENvcHlyaWdodCAoYykgMjAxNi1wcmVzZW50IE1hdHRlcm1vc3QsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vIFNlZSBMSUNFTlNFLnR4dCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IGZzIGZyb20gJ2ZzJztcbmltcG9ydCB1cmwgZnJvbSAndXJsJztcblxuaW1wb3J0ICogYXMgVmFsaWRhdG9yIGZyb20gJy4vVmFsaWRhdG9yJztcblxuZnVuY3Rpb24gY29tcGFyYWJsZUNlcnRpZmljYXRlKGNlcnRpZmljYXRlKSB7XG4gIHJldHVybiB7XG4gICAgZGF0YTogY2VydGlmaWNhdGUuZGF0YS50b1N0cmluZygpLFxuICAgIGlzc3Vlck5hbWU6IGNlcnRpZmljYXRlLmlzc3Vlck5hbWUsXG4gIH07XG59XG5cbmZ1bmN0aW9uIGFyZUVxdWFsKGNlcnRpZmljYXRlMCwgY2VydGlmaWNhdGUxKSB7XG4gIGlmIChjZXJ0aWZpY2F0ZTAuZGF0YSAhPT0gY2VydGlmaWNhdGUxLmRhdGEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGNlcnRpZmljYXRlMC5pc3N1ZXJOYW1lICE9PSBjZXJ0aWZpY2F0ZTEuaXNzdWVyTmFtZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gZ2V0SG9zdCh0YXJnZXRVUkwpIHtcbiAgcmV0dXJuIHVybC5wYXJzZSh0YXJnZXRVUkwpLmhvc3Q7XG59XG5cbmZ1bmN0aW9uIENlcnRpZmljYXRlU3RvcmUoc3RvcmVGaWxlKSB7XG4gIHRoaXMuc3RvcmVGaWxlID0gc3RvcmVGaWxlO1xuICBsZXQgc3RvcmVTdHI7XG4gIHRyeSB7XG4gICAgc3RvcmVTdHIgPSBmcy5yZWFkRmlsZVN5bmMoc3RvcmVGaWxlLCAndXRmLTgnKTtcbiAgICBzdG9yZVN0ciA9IFZhbGlkYXRvci52YWxpZGF0ZUNlcnRpZmljYXRlU3RvcmUoc3RvcmVTdHIpO1xuICAgIGlmICghc3RvcmVTdHIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUHJvdmlkZWQgY2VydGlmaWNhdGUgc3RvcmUgZmlsZSBkb2VzIG5vdCB2YWxpZGF0ZSwgdXNpbmcgZGVmYXVsdHMgaW5zdGVhZC4nKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBzdG9yZVN0ciA9ICd7fSc7XG4gIH1cbiAgdHJ5IHtcbiAgICB0aGlzLmRhdGEgPSBKU09OLnBhcnNlKHN0b3JlU3RyKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNvbnNvbGUubG9nKCdFcnJvciB3aGVuIHBhcnNpbmcnLCBzdG9yZUZpbGUsICc6JywgZSk7XG4gICAgdGhpcy5kYXRhID0ge307XG4gIH1cbn1cblxuQ2VydGlmaWNhdGVTdG9yZS5wcm90b3R5cGUuc2F2ZSA9IGZ1bmN0aW9uIHNhdmUoKSB7XG4gIGZzLndyaXRlRmlsZVN5bmModGhpcy5zdG9yZUZpbGUsIEpTT04uc3RyaW5naWZ5KHRoaXMuZGF0YSwgbnVsbCwgJyAgJykpO1xufTtcblxuQ2VydGlmaWNhdGVTdG9yZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkKHRhcmdldFVSTCwgY2VydGlmaWNhdGUpIHtcbiAgdGhpcy5kYXRhW2dldEhvc3QodGFyZ2V0VVJMKV0gPSBjb21wYXJhYmxlQ2VydGlmaWNhdGUoY2VydGlmaWNhdGUpO1xufTtcblxuQ2VydGlmaWNhdGVTdG9yZS5wcm90b3R5cGUuaXNFeGlzdGluZyA9IGZ1bmN0aW9uIGlzRXhpc3RpbmcodGFyZ2V0VVJMKSB7XG4gIHJldHVybiB0aGlzLmRhdGEuaGFzT3duUHJvcGVydHkoZ2V0SG9zdCh0YXJnZXRVUkwpKTtcbn07XG5cbkNlcnRpZmljYXRlU3RvcmUucHJvdG90eXBlLmlzVHJ1c3RlZCA9IGZ1bmN0aW9uIGlzVHJ1c3RlZCh0YXJnZXRVUkwsIGNlcnRpZmljYXRlKSB7XG4gIGNvbnN0IGhvc3QgPSBnZXRIb3N0KHRhcmdldFVSTCk7XG4gIGlmICghdGhpcy5pc0V4aXN0aW5nKHRhcmdldFVSTCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGFyZUVxdWFsKHRoaXMuZGF0YVtob3N0XSwgY29tcGFyYWJsZUNlcnRpZmljYXRlKGNlcnRpZmljYXRlKSk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGxvYWQoc3RvcmVGaWxlKSB7XG4gICAgcmV0dXJuIG5ldyBDZXJ0aWZpY2F0ZVN0b3JlKHN0b3JlRmlsZSk7XG4gIH0sXG59O1xuIiwiLy8gQ29weXJpZ2h0IChjKSAyMDE1LTIwMTYgWXV5YSBPY2hpYWlcbi8vIENvcHlyaWdodCAoYykgMjAxNi1wcmVzZW50IE1hdHRlcm1vc3QsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vIFNlZSBMSUNFTlNFLnR4dCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbmltcG9ydCB7YXBwfSBmcm9tICdlbGVjdHJvbic7XG5cbmZ1bmN0aW9uIGZsdXNoQ29va2llc1N0b3JlKHNlc3Npb24pIHtcbiAgc2Vzc2lvbi5jb29raWVzLmZsdXNoU3RvcmUoKGVycikgPT4ge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gICAgfVxuICB9KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaW5pdENvb2tpZU1hbmFnZXIoc2Vzc2lvbikge1xuICAvLyBTb21laG93IGNvb2tpZXMgYXJlIG5vdCBpbW1lZGlhdGVseSBzYXZlZCB0byBkaXNrLlxuICAvLyBTbyBtYW51YWxseSBmbHVzaCBjb29raWUgc3RvcmUgdG8gZGlzayBvbiBjbG9zaW5nIHRoZSBhcHAuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9lbGVjdHJvbi9lbGVjdHJvbi9pc3N1ZXMvODQxNlxuICBhcHAub24oJ2JlZm9yZS1xdWl0JywgKCkgPT4ge1xuICAgIGZsdXNoQ29va2llc1N0b3JlKHNlc3Npb24pO1xuICB9KTtcblxuICBhcHAub24oJ2Jyb3dzZXItd2luZG93LWJsdXInLCAoKSA9PiB7XG4gICAgZmx1c2hDb29raWVzU3RvcmUoc2Vzc2lvbik7XG4gIH0pO1xufVxuIiwiLy8gQ29weXJpZ2h0IChjKSAyMDE1LTIwMTYgWXV5YSBPY2hpYWlcbi8vIENvcHlyaWdodCAoYykgMjAxNi1wcmVzZW50IE1hdHRlcm1vc3QsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vIFNlZSBMSUNFTlNFLnR4dCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbmltcG9ydCBmcyBmcm9tICdmcyc7XG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCB6bGliIGZyb20gJ3psaWInO1xuXG5pbXBvcnQgZWxlY3Ryb24gZnJvbSAnZWxlY3Ryb24nO1xuY29uc3Qge2FwcCwgZGlhbG9nfSA9IGVsZWN0cm9uO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBkb3dubG9hZFVSTChicm93c2VyV2luZG93LCBVUkwsIGNhbGxiYWNrKSB7XG4gIGNvbnN0IHtuZXR9ID0gZWxlY3Ryb247XG4gIGNvbnN0IHJlcXVlc3QgPSBuZXQucmVxdWVzdChVUkwpO1xuICByZXF1ZXN0LnNldEhlYWRlcignQWNjZXB0LUVuY29kaW5nJywgJ2d6aXAsZGVmbGF0ZScpO1xuICByZXF1ZXN0Lm9uKCdyZXNwb25zZScsIChyZXNwb25zZSkgPT4ge1xuICAgIGNvbnN0IGZpbGUgPSBnZXRBdHRhY2htZW50TmFtZShyZXNwb25zZS5oZWFkZXJzKTtcbiAgICBjb25zdCBkaWFsb2dPcHRpb25zID0ge1xuICAgICAgZGVmYXVsdFBhdGg6IHBhdGguam9pbihhcHAuZ2V0UGF0aCgnZG93bmxvYWRzJyksIGZpbGUpLFxuICAgIH07XG4gICAgZGlhbG9nLnNob3dTYXZlRGlhbG9nKGJyb3dzZXJXaW5kb3csIGRpYWxvZ09wdGlvbnMsIChmaWxlbmFtZSkgPT4ge1xuICAgICAgaWYgKGZpbGVuYW1lKSB7XG4gICAgICAgIHNhdmVSZXNwb25zZUJvZHkocmVzcG9uc2UsIGZpbGVuYW1lLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pLm9uKCdlcnJvcicsIGNhbGxiYWNrKTtcbiAgcmVxdWVzdC5lbmQoKTtcbn1cblxuZnVuY3Rpb24gZ2V0QXR0YWNobWVudE5hbWUoaGVhZGVycykge1xuICBpZiAoaGVhZGVyc1snY29udGVudC1kaXNwb3NpdGlvbiddKSB7XG4gICAgY29uc3QgY29udGVudERpc3Bvc2l0aW9uID0gaGVhZGVyc1snY29udGVudC1kaXNwb3NpdGlvbiddWzBdO1xuICAgIGNvbnN0IG1hdGNoZWQgPSBjb250ZW50RGlzcG9zaXRpb24ubWF0Y2goL2ZpbGVuYW1lPVwiKC4qKVwiLyk7XG4gICAgaWYgKG1hdGNoZWQpIHtcbiAgICAgIHJldHVybiBwYXRoLmJhc2VuYW1lKG1hdGNoZWRbMV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbmZ1bmN0aW9uIHNhdmVSZXNwb25zZUJvZHkocmVzcG9uc2UsIGZpbGVuYW1lLCBjYWxsYmFjaykge1xuICBjb25zdCBvdXRwdXQgPSBmcy5jcmVhdGVXcml0ZVN0cmVhbShmaWxlbmFtZSk7XG4gIG91dHB1dC5vbignY2xvc2UnLCBjYWxsYmFjayk7XG4gIHN3aXRjaCAocmVzcG9uc2UuaGVhZGVyc1snY29udGVudC1lbmNvZGluZyddKSB7XG4gIGNhc2UgJ2d6aXAnOlxuICAgIHJlc3BvbnNlLnBpcGUoemxpYi5jcmVhdGVHdW56aXAoKSkucGlwZShvdXRwdXQpLm9uKCdlcnJvcicsIGNhbGxiYWNrKTtcbiAgICBicmVhaztcbiAgY2FzZSAnZGVmbGF0ZSc6XG4gICAgcmVzcG9uc2UucGlwZSh6bGliLmNyZWF0ZUluZmxhdGUoKSkucGlwZShvdXRwdXQpLm9uKCdlcnJvcicsIGNhbGxiYWNrKTtcbiAgICBicmVhaztcbiAgZGVmYXVsdDpcbiAgICByZXNwb25zZS5waXBlKG91dHB1dCkub24oJ2Vycm9yJywgY2FsbGJhY2spO1xuICAgIGJyZWFrO1xuICB9XG59XG4iLCIvLyBDb3B5cmlnaHQgKGMpIDIwMTUtMjAxNiBZdXlhIE9jaGlhaVxuLy8gQ29weXJpZ2h0IChjKSAyMDE2LXByZXNlbnQgTWF0dGVybW9zdCwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy8gU2VlIExJQ0VOU0UudHh0IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuaW1wb3J0IGZzIGZyb20gJ2ZzJztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuXG5pbXBvcnQge2FwcCwgQnJvd3NlcldpbmRvd30gZnJvbSAnZWxlY3Ryb24nO1xuXG5pbXBvcnQgKiBhcyBWYWxpZGF0b3IgZnJvbSAnLi9WYWxpZGF0b3InO1xuXG5mdW5jdGlvbiBzYXZlV2luZG93U3RhdGUoZmlsZSwgd2luZG93KSB7XG4gIGNvbnN0IHdpbmRvd1N0YXRlID0gd2luZG93LmdldEJvdW5kcygpO1xuICB3aW5kb3dTdGF0ZS5tYXhpbWl6ZWQgPSB3aW5kb3cuaXNNYXhpbWl6ZWQoKTtcbiAgdHJ5IHtcbiAgICBmcy53cml0ZUZpbGVTeW5jKGZpbGUsIEpTT04uc3RyaW5naWZ5KHdpbmRvd1N0YXRlKSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBbTGludXhdIGVycm9yIGhhcHBlbnMgb25seSB3aGVuIHRoZSB3aW5kb3cgc3RhdGUgaXMgY2hhbmdlZCBiZWZvcmUgdGhlIGNvbmZpZyBkaXIgaXMgY3JlYXRlZC5cbiAgICBjb25zb2xlLmxvZyhlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVNYWluV2luZG93KGNvbmZpZywgb3B0aW9ucykge1xuICBjb25zdCBkZWZhdWx0V2luZG93V2lkdGggPSAxMDAwO1xuICBjb25zdCBkZWZhdWx0V2luZG93SGVpZ2h0ID0gNzAwO1xuICBjb25zdCBtaW5pbXVtV2luZG93V2lkdGggPSA0MDA7XG4gIGNvbnN0IG1pbmltdW1XaW5kb3dIZWlnaHQgPSAyNDA7XG5cbiAgLy8gQ3JlYXRlIHRoZSBicm93c2VyIHdpbmRvdy5cbiAgY29uc3QgYm91bmRzSW5mb1BhdGggPSBwYXRoLmpvaW4oYXBwLmdldFBhdGgoJ3VzZXJEYXRhJyksICdib3VuZHMtaW5mby5qc29uJyk7XG4gIGxldCB3aW5kb3dPcHRpb25zO1xuICB0cnkge1xuICAgIHdpbmRvd09wdGlvbnMgPSBKU09OLnBhcnNlKGZzLnJlYWRGaWxlU3luYyhib3VuZHNJbmZvUGF0aCwgJ3V0Zi04JykpO1xuICAgIHdpbmRvd09wdGlvbnMgPSBWYWxpZGF0b3IudmFsaWRhdGVCb3VuZHNJbmZvKHdpbmRvd09wdGlvbnMpO1xuICAgIGlmICghd2luZG93T3B0aW9ucykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm92aWRlZCBib3VuZHMgaW5mbyBmaWxlIGRvZXMgbm90IHZhbGlkYXRlLCB1c2luZyBkZWZhdWx0cyBpbnN0ZWFkLicpO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIEZvbGxvdyBFbGVjdHJvbidzIGRlZmF1bHRzLCBleGNlcHQgZm9yIHdpbmRvdyBkaW1lbnNpb25zIHdoaWNoIHRhcmdldHMgMTAyNHg3Njggc2NyZWVuIHJlc29sdXRpb24uXG4gICAgd2luZG93T3B0aW9ucyA9IHt3aWR0aDogZGVmYXVsdFdpbmRvd1dpZHRoLCBoZWlnaHQ6IGRlZmF1bHRXaW5kb3dIZWlnaHR9O1xuICB9XG5cbiAgY29uc3Qge2hpZGVPblN0YXJ0dXAsIHRyYXlJY29uU2hvd259ID0gb3B0aW9ucztcbiAgY29uc3Qge21heGltaXplZDogd2luZG93SXNNYXhpbWl6ZWR9ID0gd2luZG93T3B0aW9ucztcblxuICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ2xpbnV4Jykge1xuICAgIHdpbmRvd09wdGlvbnMuaWNvbiA9IG9wdGlvbnMubGludXhBcHBJY29uO1xuICB9XG4gIE9iamVjdC5hc3NpZ24od2luZG93T3B0aW9ucywge1xuICAgIHRpdGxlOiBhcHAuZ2V0TmFtZSgpLFxuICAgIGZ1bGxzY3JlZW5hYmxlOiB0cnVlLFxuICAgIHNob3c6IGhpZGVPblN0YXJ0dXAgfHwgZmFsc2UsXG4gICAgbWluV2lkdGg6IG1pbmltdW1XaW5kb3dXaWR0aCxcbiAgICBtaW5IZWlnaHQ6IG1pbmltdW1XaW5kb3dIZWlnaHQsXG4gICAgZnVsbHNjcmVlbjogZmFsc2UsXG4gICAgYmFja2dyb3VuZENvbG9yOiAnI2ZmZicsIC8vIHByZXZlbnRzIGJsdXJyeSB0ZXh0OiBodHRwczovL2VsZWN0cm9uanMub3JnL2RvY3MvZmFxI3RoZS1mb250LWxvb2tzLWJsdXJyeS13aGF0LWlzLXRoaXMtYW5kLXdoYXQtY2FuLWktZG9cbiAgICB3ZWJQcmVmZXJlbmNlczoge1xuICAgICAgbm9kZUludGVncmF0aW9uOiB0cnVlLFxuICAgICAgY29udGV4dElzb2xhdGlvbjogZmFsc2UsXG4gICAgICB3ZWJ2aWV3VGFnOiB0cnVlLFxuICAgICAgZGlzYWJsZUJsaW5rRmVhdHVyZXM6ICdBdXhjbGljaycsXG4gICAgfSxcbiAgfSk7XG5cbiAgY29uc3QgbWFpbldpbmRvdyA9IG5ldyBCcm93c2VyV2luZG93KHdpbmRvd09wdGlvbnMpO1xuICBtYWluV2luZG93LmRlZXBsaW5raW5nVXJsID0gb3B0aW9ucy5kZWVwbGlua2luZ1VybDtcblxuICBjb25zdCBpbmRleFVSTCA9IGdsb2JhbC5pc0RldiA/ICdodHRwOi8vbG9jYWxob3N0OjgwODAvYnJvd3Nlci9pbmRleC5odG1sJyA6IGBmaWxlOi8vJHthcHAuZ2V0QXBwUGF0aCgpfS9icm93c2VyL2luZGV4Lmh0bWxgO1xuICBtYWluV2luZG93LmxvYWRVUkwoaW5kZXhVUkwpO1xuXG4gIC8vIGhhbmRsZSBoaWRpbmcgdGhlIGFwcCB3aGVuIGxhdW5jaGVkIGJ5IGF1dG8tc3RhcnRcbiAgaWYgKGhpZGVPblN0YXJ0dXApIHtcbiAgICBpZiAodHJheUljb25TaG93biAmJiBwcm9jZXNzLnBsYXRmb3JtICE9PSAnZGFyd2luJykge1xuICAgICAgbWFpbldpbmRvdy5oaWRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1haW5XaW5kb3cubWluaW1pemUoKTtcbiAgICB9XG4gIH1cblxuICBtYWluV2luZG93Lm9uY2UoJ3JlYWR5LXRvLXNob3cnLCAoKSA9PiB7XG4gICAgbWFpbldpbmRvdy53ZWJDb250ZW50cy5zZXRab29tTGV2ZWwoMCk7XG5cbiAgICAvLyBoYW5kbGUgc2hvd2luZyB0aGUgd2luZG93IHdoZW4gbm90IGxhdW5jaGVkIGJ5IGF1dG8tc3RhcnRcbiAgICAvLyAtIHdoZW4gbm90IGNvbmZpZ3VyZWQgdG8gYXV0by1zdGFydCwgaW1tZWRpYXRlbHkgc2hvdyBjb250ZW50cyBhbmQgb3B0aW9uYWxseSBtYXhpbWl6ZSBhcyBuZWVkZWRcbiAgICBpZiAoIWhpZGVPblN0YXJ0dXApIHtcbiAgICAgIG1haW5XaW5kb3cuc2hvdygpO1xuICAgICAgaWYgKHdpbmRvd0lzTWF4aW1pemVkKSB7XG4gICAgICAgIG1haW5XaW5kb3cubWF4aW1pemUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIG1haW5XaW5kb3cub25jZSgnc2hvdycsICgpID0+IHtcbiAgICAvLyBoYW5kbGUgc2hvd2luZyB0aGUgYXBwIHdoZW4gaGlkZGVuIHRvIHRoZSB0cmF5IGljb24gYnkgYXV0by1zdGFydFxuICAgIC8vIC0gb3B0aW9uYWxseSBtYXhpbWl6ZSB0aGUgd2luZG93IGFzIG5lZWRlZFxuICAgIGlmIChoaWRlT25TdGFydHVwICYmIHdpbmRvd0lzTWF4aW1pemVkKSB7XG4gICAgICBtYWluV2luZG93Lm1heGltaXplKCk7XG4gICAgfVxuICB9KTtcblxuICBtYWluV2luZG93Lm9uY2UoJ3Jlc3RvcmUnLCAoKSA9PiB7XG4gICAgLy8gaGFuZGxlIHJlc3RvcmluZyB0aGUgd2luZG93IHdoZW4gbWluaW1pemVkIHRvIHRoZSBhcHAgaWNvbiBieSBhdXRvLXN0YXJ0XG4gICAgLy8gLSBvcHRpb25hbGx5IG1heGltaXplIHRoZSB3aW5kb3cgYXMgbmVlZGVkXG4gICAgaWYgKGhpZGVPblN0YXJ0dXAgJiYgd2luZG93SXNNYXhpbWl6ZWQpIHtcbiAgICAgIG1haW5XaW5kb3cubWF4aW1pemUoKTtcbiAgICB9XG4gIH0pO1xuXG4gIG1haW5XaW5kb3cud2ViQ29udGVudHMub24oJ3dpbGwtYXR0YWNoLXdlYnZpZXcnLCAoZXZlbnQsIHdlYlByZWZlcmVuY2VzKSA9PiB7XG4gICAgd2ViUHJlZmVyZW5jZXMubm9kZUludGVncmF0aW9uID0gZmFsc2U7XG4gICAgd2ViUHJlZmVyZW5jZXMuY29udGV4dElzb2xhdGlvbiA9IHRydWU7XG4gIH0pO1xuXG4gIC8vIEFwcCBzaG91bGQgc2F2ZSBib3VuZHMgd2hlbiBhIHdpbmRvdyBpcyBjbG9zZWQuXG4gIC8vIEhvd2V2ZXIsICdjbG9zZScgaXMgbm90IGZpcmVkIGluIHNvbWUgc2l0dWF0aW9ucyhzaHV0ZG93biwgY3RybCtjKVxuICAvLyBiZWNhdXNlIG1haW4gcHJvY2VzcyBpcyBraWxsZWQgaW4gc3VjaCBzaXR1YXRpb25zLlxuICAvLyAnYmx1cicgZXZlbnQgd2FzIGVmZmVjdGl2ZSBpbiBvcmRlciB0byBhdm9pZCB0aGlzLlxuICAvLyBJZGVhbGx5LCBhcHAgc2hvdWxkIGRldGVjdCB0aGF0IE9TIGlzIHNodXR0aW5nIGRvd24uXG4gIG1haW5XaW5kb3cub24oJ2JsdXInLCAoKSA9PiB7XG4gICAgc2F2ZVdpbmRvd1N0YXRlKGJvdW5kc0luZm9QYXRoLCBtYWluV2luZG93KTtcbiAgICBtYWluV2luZG93LmJsdXJXZWJWaWV3KCk7XG4gIH0pO1xuXG4gIG1haW5XaW5kb3cub24oJ2Nsb3NlJywgKGV2ZW50KSA9PiB7XG4gICAgaWYgKGdsb2JhbC53aWxsQXBwUXVpdCkgeyAvLyB3aGVuIFtDdHJsfENtZF0rUVxuICAgICAgc2F2ZVdpbmRvd1N0YXRlKGJvdW5kc0luZm9QYXRoLCBtYWluV2luZG93KTtcbiAgICB9IGVsc2UgeyAvLyBNaW5pbWl6ZSBvciBoaWRlIHRoZSB3aW5kb3cgZm9yIGNsb3NlIGJ1dHRvbi5cbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBmdW5jdGlvbiBoaWRlV2luZG93KHdpbmRvdykge1xuICAgICAgICB3aW5kb3cuYmx1cigpOyAvLyBUbyBtb3ZlIGZvY3VzIHRvIHRoZSBuZXh0IHRvcC1sZXZlbCB3aW5kb3cgaW4gV2luZG93c1xuICAgICAgICB3aW5kb3cuaGlkZSgpO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChwcm9jZXNzLnBsYXRmb3JtKSB7XG4gICAgICBjYXNlICd3aW4zMic6XG4gICAgICAgIGhpZGVXaW5kb3cobWFpbldpbmRvdyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbGludXgnOlxuICAgICAgICBpZiAoY29uZmlnLm1pbmltaXplVG9UcmF5KSB7XG4gICAgICAgICAgaGlkZVdpbmRvdyhtYWluV2luZG93KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYWluV2luZG93Lm1pbmltaXplKCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdkYXJ3aW4nOlxuICAgICAgICAvLyBuZWVkIHRvIGxlYXZlIGZ1bGxzY3JlZW4gZmlyc3QsIHRoZW4gaGlkZSB0aGUgd2luZG93XG4gICAgICAgIGlmIChtYWluV2luZG93LmlzRnVsbFNjcmVlbigpKSB7XG4gICAgICAgICAgbWFpbldpbmRvdy5vbmNlKCdsZWF2ZS1mdWxsLXNjcmVlbicsICgpID0+IHtcbiAgICAgICAgICAgIGhpZGVXaW5kb3cobWFpbldpbmRvdyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbWFpbldpbmRvdy5zZXRGdWxsU2NyZWVuKGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoaWRlV2luZG93KG1haW5XaW5kb3cpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIG1haW5XaW5kb3cub24oJ3NoZWV0LWVuZCcsICgpID0+IHtcbiAgICBtYWluV2luZG93LndlYkNvbnRlbnRzLnNlbmQoJ2ZvY3VzLW9uLXdlYnZpZXcnKTtcbiAgfSk7XG5cbiAgLy8gUmVnaXN0ZXIga2V5Ym9hcmQgc2hvcnRjdXRzXG4gIG1haW5XaW5kb3cud2ViQ29udGVudHMub24oJ2JlZm9yZS1pbnB1dC1ldmVudCcsIChldmVudCwgaW5wdXQpID0+IHtcbiAgICAvLyBBZGQgQWx0K0NtZCsoUmlnaHR8TGVmdCkgYXMgYWx0ZXJuYXRpdmUgdG8gc3dpdGNoIGJldHdlZW4gc2VydmVyc1xuICAgIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnZGFyd2luJykge1xuICAgICAgaWYgKGlucHV0LmFsdCAmJiBpbnB1dC5tZXRhKSB7XG4gICAgICAgIGlmIChpbnB1dC5rZXkgPT09ICdBcnJvd1JpZ2h0Jykge1xuICAgICAgICAgIG1haW5XaW5kb3cud2ViQ29udGVudHMuc2VuZCgnc2VsZWN0LW5leHQtdGFiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlucHV0LmtleSA9PT0gJ0Fycm93TGVmdCcpIHtcbiAgICAgICAgICBtYWluV2luZG93LndlYkNvbnRlbnRzLnNlbmQoJ3NlbGVjdC1wcmV2aW91cy10YWInKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIG1haW5XaW5kb3c7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZU1haW5XaW5kb3c7XG4iLCIvLyBDb3B5cmlnaHQgKGMpIDIwMTUtMjAxNiBZdXlhIE9jaGlhaVxuLy8gQ29weXJpZ2h0IChjKSAyMDE2LXByZXNlbnQgTWF0dGVybW9zdCwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy8gU2VlIExJQ0VOU0UudHh0IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQge2FwcCwgZGlhbG9nLCBNZW51LCBzaGVsbH0gZnJvbSAnZWxlY3Ryb24nO1xuXG5mdW5jdGlvbiBjcmVhdGVUZW1wbGF0ZShtYWluV2luZG93LCBjb25maWcsIGlzRGV2KSB7XG4gIGNvbnN0IHNldHRpbmdzVVJMID0gaXNEZXYgPyAnaHR0cDovL2xvY2FsaG9zdDo4MDgwL2Jyb3dzZXIvc2V0dGluZ3MuaHRtbCcgOiBgZmlsZTovLyR7YXBwLmdldEFwcFBhdGgoKX0vYnJvd3Nlci9zZXR0aW5ncy5odG1sYDtcblxuICBjb25zdCBzZXBhcmF0b3JJdGVtID0ge1xuICAgIHR5cGU6ICdzZXBhcmF0b3InLFxuICB9O1xuXG4gIGNvbnN0IGFwcE5hbWUgPSBhcHAuZ2V0TmFtZSgpO1xuICBjb25zdCBmaXJzdE1lbnVOYW1lID0gKHByb2Nlc3MucGxhdGZvcm0gPT09ICdkYXJ3aW4nKSA/IGFwcE5hbWUgOiAnRmlsZSc7XG4gIGNvbnN0IHRlbXBsYXRlID0gW107XG5cbiAgbGV0IHBsYXRmb3JtQXBwTWVudSA9IHByb2Nlc3MucGxhdGZvcm0gPT09ICdkYXJ3aW4nID8gW3tcbiAgICBsYWJlbDogJ0Fib3V0ICcgKyBhcHBOYW1lLFxuICAgIHJvbGU6ICdhYm91dCcsXG4gICAgY2xpY2soKSB7XG4gICAgICBkaWFsb2cuc2hvd01lc3NhZ2VCb3gobWFpbldpbmRvdywge1xuICAgICAgICBidXR0b25zOiBbJ09LJ10sXG4gICAgICAgIG1lc3NhZ2U6IGAke2FwcE5hbWV9IERlc2t0b3AgJHthcHAuZ2V0VmVyc2lvbigpfWAsXG4gICAgICB9KTtcbiAgICB9LFxuICB9LCBzZXBhcmF0b3JJdGVtLCB7XG4gICAgbGFiZWw6ICdQcmVmZXJlbmNlcy4uLicsXG4gICAgYWNjZWxlcmF0b3I6ICdDbWRPckN0cmwrLCcsXG4gICAgY2xpY2soKSB7XG4gICAgICBtYWluV2luZG93LmxvYWRVUkwoc2V0dGluZ3NVUkwpO1xuICAgIH0sXG4gIH1dIDogW3tcbiAgICBsYWJlbDogJ1NldHRpbmdzLi4uJyxcbiAgICBhY2NlbGVyYXRvcjogJ0NtZE9yQ3RybCssJyxcbiAgICBjbGljaygpIHtcbiAgICAgIG1haW5XaW5kb3cubG9hZFVSTChzZXR0aW5nc1VSTCk7XG4gICAgfSxcbiAgfV07XG5cbiAgaWYgKGNvbmZpZy5lbmFibGVTZXJ2ZXJNYW5hZ2VtZW50ID09PSB0cnVlKSB7XG4gICAgcGxhdGZvcm1BcHBNZW51LnB1c2goe1xuICAgICAgbGFiZWw6ICdTaWduIGluIHRvIEFub3RoZXIgU2VydmVyJyxcbiAgICAgIGNsaWNrKCkge1xuICAgICAgICBtYWluV2luZG93LndlYkNvbnRlbnRzLnNlbmQoJ2FkZC1zZXJ2ZXInKTtcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cblxuICBwbGF0Zm9ybUFwcE1lbnUgPSBwbGF0Zm9ybUFwcE1lbnUuY29uY2F0KHByb2Nlc3MucGxhdGZvcm0gPT09ICdkYXJ3aW4nID8gW1xuICAgIHNlcGFyYXRvckl0ZW0sIHtcbiAgICAgIHJvbGU6ICdoaWRlJyxcbiAgICB9LCB7XG4gICAgICByb2xlOiAnaGlkZW90aGVycycsXG4gICAgfSwge1xuICAgICAgcm9sZTogJ3VuaGlkZScsXG4gICAgfSwgc2VwYXJhdG9ySXRlbSwge1xuICAgICAgcm9sZTogJ3F1aXQnLFxuICAgIH1dIDogW1xuICAgIHNlcGFyYXRvckl0ZW0sIHtcbiAgICAgIHJvbGU6ICdxdWl0JyxcbiAgICAgIGFjY2VsZXJhdG9yOiAnQ21kT3JDdHJsK1EnLFxuICAgICAgY2xpY2soKSB7XG4gICAgICAgIGFwcC5xdWl0KCk7XG4gICAgICB9LFxuICAgIH1dXG4gICk7XG5cbiAgdGVtcGxhdGUucHVzaCh7XG4gICAgbGFiZWw6ICcmJyArIGZpcnN0TWVudU5hbWUsXG4gICAgc3VibWVudTogW1xuICAgICAgLi4ucGxhdGZvcm1BcHBNZW51LFxuICAgIF0sXG4gIH0pO1xuICB0ZW1wbGF0ZS5wdXNoKHtcbiAgICBsYWJlbDogJyZFZGl0JyxcbiAgICBzdWJtZW51OiBbe1xuICAgICAgbGFiZWw6ICdVbmRvJyxcbiAgICAgIGFjY2VsZXJhdG9yOiAnQ21kT3JDdHJsK1onLFxuICAgICAgY2xpY2soKSB7XG4gICAgICAgIG1haW5XaW5kb3cud2ViQ29udGVudHMuc2VuZCgndW5kbycpO1xuICAgICAgfSxcbiAgICB9LCB7XG4gICAgICBsYWJlbDogJ1JlZG8nLFxuICAgICAgYWNjZWxlcmF0b3I6ICdDbWRPckN0cmwrU0hJRlQrWicsXG4gICAgICBjbGljaygpIHtcbiAgICAgICAgbWFpbldpbmRvdy53ZWJDb250ZW50cy5zZW5kKCdyZWRvJyk7XG4gICAgICB9LFxuICAgIH0sIHNlcGFyYXRvckl0ZW0sIHtcbiAgICAgIGxhYmVsOiAnQ3V0JyxcbiAgICAgIGFjY2VsZXJhdG9yOiAnQ21kT3JDdHJsK1gnLFxuICAgICAgY2xpY2soKSB7XG4gICAgICAgIG1haW5XaW5kb3cud2ViQ29udGVudHMuc2VuZCgnY3V0Jyk7XG4gICAgICB9LFxuICAgIH0sIHtcbiAgICAgIGxhYmVsOiAnQ29weScsXG4gICAgICBhY2NlbGVyYXRvcjogJ0NtZE9yQ3RybCtDJyxcbiAgICAgIGNsaWNrKCkge1xuICAgICAgICBtYWluV2luZG93LndlYkNvbnRlbnRzLnNlbmQoJ2NvcHknKTtcbiAgICAgIH0sXG4gICAgfSwge1xuICAgICAgbGFiZWw6ICdQYXN0ZScsXG4gICAgICBhY2NlbGVyYXRvcjogJ0NtZE9yQ3RybCtWJyxcbiAgICAgIGNsaWNrKCkge1xuICAgICAgICBtYWluV2luZG93LndlYkNvbnRlbnRzLnNlbmQoJ3Bhc3RlJyk7XG4gICAgICB9LFxuICAgIH0sIHtcbiAgICAgIGxhYmVsOiAnUGFzdGUgYW5kIE1hdGNoIFN0eWxlJyxcbiAgICAgIGFjY2VsZXJhdG9yOiAnQ21kT3JDdHJsK1NISUZUK1YnLFxuICAgICAgdmlzaWJsZTogcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ2RhcndpbicsXG4gICAgICBjbGljaygpIHtcbiAgICAgICAgbWFpbldpbmRvdy53ZWJDb250ZW50cy5zZW5kKCdwYXN0ZS1hbmQtbWF0Y2gnKTtcbiAgICAgIH0sXG4gICAgfSwge1xuICAgICAgcm9sZTogJ3NlbGVjdGFsbCcsXG4gICAgfV0sXG4gIH0pO1xuICB0ZW1wbGF0ZS5wdXNoKHtcbiAgICBsYWJlbDogJyZWaWV3JyxcbiAgICBzdWJtZW51OiBbe1xuICAgICAgbGFiZWw6ICdGaW5kLi4nLFxuICAgICAgYWNjZWxlcmF0b3I6ICdDbWRPckN0cmwrRicsXG4gICAgICBjbGljayhpdGVtLCBmb2N1c2VkV2luZG93KSB7XG4gICAgICAgIGZvY3VzZWRXaW5kb3cud2ViQ29udGVudHMuc2VuZCgndG9nZ2xlLWZpbmQnKTtcbiAgICAgIH0sXG4gICAgfSwge1xuICAgICAgbGFiZWw6ICdSZWxvYWQnLFxuICAgICAgYWNjZWxlcmF0b3I6ICdDbWRPckN0cmwrUicsXG4gICAgICBjbGljayhpdGVtLCBmb2N1c2VkV2luZG93KSB7XG4gICAgICAgIGlmIChmb2N1c2VkV2luZG93KSB7XG4gICAgICAgICAgaWYgKGZvY3VzZWRXaW5kb3cgPT09IG1haW5XaW5kb3cpIHtcbiAgICAgICAgICAgIG1haW5XaW5kb3cud2ViQ29udGVudHMuc2VuZCgncmVsb2FkLXRhYicpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb2N1c2VkV2luZG93LnJlbG9hZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICB9LCB7XG4gICAgICBsYWJlbDogJ0NsZWFyIENhY2hlIGFuZCBSZWxvYWQnLFxuICAgICAgYWNjZWxlcmF0b3I6ICdTaGlmdCtDbWRPckN0cmwrUicsXG4gICAgICBjbGljayhpdGVtLCBmb2N1c2VkV2luZG93KSB7XG4gICAgICAgIGlmIChmb2N1c2VkV2luZG93KSB7XG4gICAgICAgICAgaWYgKGZvY3VzZWRXaW5kb3cgPT09IG1haW5XaW5kb3cpIHtcbiAgICAgICAgICAgIG1haW5XaW5kb3cud2ViQ29udGVudHMuc2VuZCgnY2xlYXItY2FjaGUtYW5kLXJlbG9hZC10YWInKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9jdXNlZFdpbmRvdy53ZWJDb250ZW50cy5zZXNzaW9uLmNsZWFyQ2FjaGUoKCkgPT4ge1xuICAgICAgICAgICAgICBmb2N1c2VkV2luZG93LnJlbG9hZCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgIH0sIHtcbiAgICAgIHJvbGU6ICd0b2dnbGVmdWxsc2NyZWVuJyxcbiAgICB9LCBzZXBhcmF0b3JJdGVtLCB7XG4gICAgICBsYWJlbDogJ0FjdHVhbCBTaXplJyxcbiAgICAgIGFjY2VsZXJhdG9yOiAnQ21kT3JDdHJsKzAnLFxuICAgICAgY2xpY2soKSB7XG4gICAgICAgIG1haW5XaW5kb3cud2ViQ29udGVudHMuc2VuZCgnem9vbS1yZXNldCcpO1xuICAgICAgfSxcbiAgICB9LCB7XG4gICAgICBsYWJlbDogJ1pvb20gSW4nLFxuICAgICAgYWNjZWxlcmF0b3I6ICdDbWRPckN0cmwrU0hJRlQrPScsXG4gICAgICBjbGljaygpIHtcbiAgICAgICAgbWFpbldpbmRvdy53ZWJDb250ZW50cy5zZW5kKCd6b29tLWluJyk7XG4gICAgICB9LFxuICAgIH0sIHtcbiAgICAgIGxhYmVsOiAnWm9vbSBPdXQnLFxuICAgICAgYWNjZWxlcmF0b3I6ICdDbWRPckN0cmwrLScsXG4gICAgICBjbGljaygpIHtcbiAgICAgICAgbWFpbldpbmRvdy53ZWJDb250ZW50cy5zZW5kKCd6b29tLW91dCcpO1xuICAgICAgfSxcbiAgICB9LCBzZXBhcmF0b3JJdGVtLCB7XG4gICAgICBsYWJlbDogJ0RldmVsb3BlciBUb29scyBmb3IgQXBwbGljYXRpb24gV3JhcHBlcicsXG4gICAgICBhY2NlbGVyYXRvcjogKCgpID0+IHtcbiAgICAgICAgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICdkYXJ3aW4nKSB7XG4gICAgICAgICAgcmV0dXJuICdBbHQrQ29tbWFuZCtJJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ0N0cmwrU2hpZnQrSSc7XG4gICAgICB9KSgpLFxuICAgICAgY2xpY2soaXRlbSwgZm9jdXNlZFdpbmRvdykge1xuICAgICAgICBpZiAoZm9jdXNlZFdpbmRvdykge1xuICAgICAgICAgIGZvY3VzZWRXaW5kb3cudG9nZ2xlRGV2VG9vbHMoKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICB9LCB7XG4gICAgICBsYWJlbDogJ0RldmVsb3BlciBUb29scyBmb3IgQ3VycmVudCBTZXJ2ZXInLFxuICAgICAgY2xpY2soKSB7XG4gICAgICAgIG1haW5XaW5kb3cud2ViQ29udGVudHMuc2VuZCgnb3Blbi1kZXZ0b29sJyk7XG4gICAgICB9LFxuICAgIH1dLFxuICB9KTtcbiAgdGVtcGxhdGUucHVzaCh7XG4gICAgbGFiZWw6ICcmSGlzdG9yeScsXG4gICAgc3VibWVudTogW3tcbiAgICAgIGxhYmVsOiAnQmFjaycsXG4gICAgICBhY2NlbGVyYXRvcjogcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ2RhcndpbicgPyAnQ21kK1snIDogJ0FsdCtMZWZ0JyxcbiAgICAgIGNsaWNrOiAoaXRlbSwgZm9jdXNlZFdpbmRvdykgPT4ge1xuICAgICAgICBpZiAoZm9jdXNlZFdpbmRvdyA9PT0gbWFpbldpbmRvdykge1xuICAgICAgICAgIG1haW5XaW5kb3cud2ViQ29udGVudHMuc2VuZCgnZ28tYmFjaycpO1xuICAgICAgICB9IGVsc2UgaWYgKGZvY3VzZWRXaW5kb3cud2ViQ29udGVudHMuY2FuR29CYWNrKCkpIHtcbiAgICAgICAgICBmb2N1c2VkV2luZG93LmdvQmFjaygpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgIH0sIHtcbiAgICAgIGxhYmVsOiAnRm9yd2FyZCcsXG4gICAgICBhY2NlbGVyYXRvcjogcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ2RhcndpbicgPyAnQ21kK10nIDogJ0FsdCtSaWdodCcsXG4gICAgICBjbGljazogKGl0ZW0sIGZvY3VzZWRXaW5kb3cpID0+IHtcbiAgICAgICAgaWYgKGZvY3VzZWRXaW5kb3cgPT09IG1haW5XaW5kb3cpIHtcbiAgICAgICAgICBtYWluV2luZG93LndlYkNvbnRlbnRzLnNlbmQoJ2dvLWZvcndhcmQnKTtcbiAgICAgICAgfSBlbHNlIGlmIChmb2N1c2VkV2luZG93LndlYkNvbnRlbnRzLmNhbkdvRm9yd2FyZCgpKSB7XG4gICAgICAgICAgZm9jdXNlZFdpbmRvdy5nb0ZvcndhcmQoKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICB9XSxcbiAgfSk7XG5cbiAgY29uc3QgdGVhbXMgPSBjb25maWcudGVhbXM7XG4gIGNvbnN0IHdpbmRvd01lbnUgPSB7XG4gICAgbGFiZWw6ICcmV2luZG93JyxcbiAgICBzdWJtZW51OiBbe1xuICAgICAgcm9sZTogJ21pbmltaXplJyxcblxuICAgICAgLy8gZW1wdHkgc3RyaW5nIHJlbW92ZXMgc2hvcnRjdXQgb24gV2luZG93czsgbnVsbCB3aWxsIGRlZmF1bHQgYnkgT1NcbiAgICAgIGFjY2VsZXJhdG9yOiBwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInID8gJycgOiBudWxsLFxuICAgIH0sIHtcbiAgICAgIHJvbGU6ICdjbG9zZScsXG4gICAgfSwgc2VwYXJhdG9ySXRlbSwgLi4udGVhbXMuc2xpY2UoMCwgOSkubWFwKCh0ZWFtLCBpKSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsYWJlbDogdGVhbS5uYW1lLFxuICAgICAgICBhY2NlbGVyYXRvcjogYENtZE9yQ3RybCske2kgKyAxfWAsXG4gICAgICAgIGNsaWNrKCkge1xuICAgICAgICAgIG1haW5XaW5kb3cuc2hvdygpOyAvLyBmb3IgT1MgWFxuICAgICAgICAgIG1haW5XaW5kb3cud2ViQ29udGVudHMuc2VuZCgnc3dpdGNoLXRhYicsIGkpO1xuICAgICAgICB9LFxuICAgICAgfTtcbiAgICB9KSwgc2VwYXJhdG9ySXRlbSwge1xuICAgICAgbGFiZWw6ICdTZWxlY3QgTmV4dCBTZXJ2ZXInLFxuICAgICAgYWNjZWxlcmF0b3I6ICdDdHJsK1RhYicsXG4gICAgICBjbGljaygpIHtcbiAgICAgICAgbWFpbldpbmRvdy53ZWJDb250ZW50cy5zZW5kKCdzZWxlY3QtbmV4dC10YWInKTtcbiAgICAgIH0sXG4gICAgICBlbmFibGVkOiAodGVhbXMubGVuZ3RoID4gMSksXG4gICAgfSwge1xuICAgICAgbGFiZWw6ICdTZWxlY3QgUHJldmlvdXMgU2VydmVyJyxcbiAgICAgIGFjY2VsZXJhdG9yOiAnQ3RybCtTaGlmdCtUYWInLFxuICAgICAgY2xpY2soKSB7XG4gICAgICAgIG1haW5XaW5kb3cud2ViQ29udGVudHMuc2VuZCgnc2VsZWN0LXByZXZpb3VzLXRhYicpO1xuICAgICAgfSxcbiAgICAgIGVuYWJsZWQ6ICh0ZWFtcy5sZW5ndGggPiAxKSxcbiAgICB9XSxcbiAgfTtcbiAgdGVtcGxhdGUucHVzaCh3aW5kb3dNZW51KTtcbiAgY29uc3Qgc3VibWVudSA9IFtdO1xuICBpZiAoY29uZmlnLmhlbHBMaW5rKSB7XG4gICAgc3VibWVudS5wdXNoKHtcbiAgICAgIGxhYmVsOiAnTGVhcm4gTW9yZS4uLicsXG4gICAgICBjbGljaygpIHtcbiAgICAgICAgc2hlbGwub3BlbkV4dGVybmFsKGNvbmZpZy5oZWxwTGluayk7XG4gICAgICB9LFxuICAgIH0pO1xuICAgIHN1Ym1lbnUucHVzaChzZXBhcmF0b3JJdGVtKTtcbiAgfVxuICBzdWJtZW51LnB1c2goe1xuICAgIGxhYmVsOiBgVmVyc2lvbiAke2FwcC5nZXRWZXJzaW9uKCl9YCxcbiAgICBlbmFibGVkOiBmYWxzZSxcbiAgfSk7XG5cbiAgdGVtcGxhdGUucHVzaCh7bGFiZWw6ICdIZWwmcCcsIHN1Ym1lbnV9KTtcbiAgcmV0dXJuIHRlbXBsYXRlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVNZW51KG1haW5XaW5kb3csIGNvbmZpZywgaXNEZXYpIHtcbiAgcmV0dXJuIE1lbnUuYnVpbGRGcm9tVGVtcGxhdGUoY3JlYXRlVGVtcGxhdGUobWFpbldpbmRvdywgY29uZmlnLCBpc0RldikpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGNyZWF0ZU1lbnUsXG59O1xuIiwiLy8gQ29weXJpZ2h0IChjKSAyMDE1LTIwMTYgWXV5YSBPY2hpYWlcbi8vIENvcHlyaWdodCAoYykgMjAxNi1wcmVzZW50IE1hdHRlcm1vc3QsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vIFNlZSBMSUNFTlNFLnR4dCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHthcHAsIE1lbnV9IGZyb20gJ2VsZWN0cm9uJztcblxuZnVuY3Rpb24gY3JlYXRlVGVtcGxhdGUobWFpbldpbmRvdywgY29uZmlnLCBpc0Rldikge1xuICBjb25zdCBzZXR0aW5nc1VSTCA9IGlzRGV2ID8gJ2h0dHA6Ly9sb2NhbGhvc3Q6ODA4MC9icm93c2VyL3NldHRpbmdzLmh0bWwnIDogYGZpbGU6Ly8ke2FwcC5nZXRBcHBQYXRoKCl9L2Jyb3dzZXIvc2V0dGluZ3MuaHRtbGA7XG4gIGNvbnN0IHRlYW1zID0gY29uZmlnLnRlYW1zO1xuICBjb25zdCB0ZW1wbGF0ZSA9IFtcbiAgICAuLi50ZWFtcy5zbGljZSgwLCA5KS5tYXAoKHRlYW0sIGkpID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxhYmVsOiB0ZWFtLm5hbWUsXG4gICAgICAgIGNsaWNrOiAoKSA9PiB7XG4gICAgICAgICAgc2hvd09yUmVzdG9yZShtYWluV2luZG93KTtcbiAgICAgICAgICBtYWluV2luZG93LndlYkNvbnRlbnRzLnNlbmQoJ3N3aXRjaC10YWInLCBpKTtcblxuICAgICAgICAgIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnZGFyd2luJykge1xuICAgICAgICAgICAgYXBwLmRvY2suc2hvdygpO1xuICAgICAgICAgICAgbWFpbldpbmRvdy5mb2N1cygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgfSksIHtcbiAgICAgIHR5cGU6ICdzZXBhcmF0b3InLFxuICAgIH0sIHtcbiAgICAgIGxhYmVsOiBwcm9jZXNzLnBsYXRmb3JtID09PSAnZGFyd2luJyA/ICdQcmVmZXJlbmNlcy4uLicgOiAnU2V0dGluZ3MnLFxuICAgICAgY2xpY2s6ICgpID0+IHtcbiAgICAgICAgbWFpbldpbmRvdy5sb2FkVVJMKHNldHRpbmdzVVJMKTtcbiAgICAgICAgc2hvd09yUmVzdG9yZShtYWluV2luZG93KTtcblxuICAgICAgICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ2RhcndpbicpIHtcbiAgICAgICAgICBhcHAuZG9jay5zaG93KCk7XG4gICAgICAgICAgbWFpbldpbmRvdy5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgIH0sIHtcbiAgICAgIHR5cGU6ICdzZXBhcmF0b3InLFxuICAgIH0sIHtcbiAgICAgIHJvbGU6ICdxdWl0JyxcbiAgICB9LFxuICBdO1xuICByZXR1cm4gdGVtcGxhdGU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU1lbnUobWFpbldpbmRvdywgY29uZmlnLCBpc0Rldikge1xuICByZXR1cm4gTWVudS5idWlsZEZyb21UZW1wbGF0ZShjcmVhdGVUZW1wbGF0ZShtYWluV2luZG93LCBjb25maWcsIGlzRGV2KSk7XG59XG5cbmZ1bmN0aW9uIHNob3dPclJlc3RvcmUod2luZG93KSB7XG4gIGlmICh3aW5kb3cuaXNNaW5pbWl6ZWQoKSkge1xuICAgIHdpbmRvdy5yZXN0b3JlKCk7XG4gIH0gZWxzZSB7XG4gICAgd2luZG93LnNob3coKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGNyZWF0ZU1lbnUsXG59O1xuIiwiLy8gQ29weXJpZ2h0IChjKSAyMDE1LTIwMTYgWXV5YSBPY2hpYWlcbi8vIENvcHlyaWdodCAoYykgMjAxNi1wcmVzZW50IE1hdHRlcm1vc3QsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vIFNlZSBMSUNFTlNFLnR4dCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cblxuaW1wb3J0IHthcHB9IGZyb20gJ2VsZWN0cm9uJztcblxuZXhwb3J0IGZ1bmN0aW9uIHNob3VsZEJlSGlkZGVuT25TdGFydHVwKHBhcnNlZEFyZ3YpIHtcbiAgaWYgKHBhcnNlZEFyZ3YuaGlkZGVuKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICdkYXJ3aW4nKSB7XG4gICAgaWYgKGFwcC5nZXRMb2dpbkl0ZW1TZXR0aW5ncygpLndhc09wZW5lZEFzSGlkZGVuKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuIiwidmFyIHJlc29sdmUgPSByZXF1aXJlKCdwYXRoJykucmVzb2x2ZVxudmFyIGJpbiA9IHJlcXVpcmUoJy4vcGFja2FnZScpLmJpblxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcF9vYmooYmluLCBmdW5jdGlvbih2KXtcbiAgcmV0dXJuIHJlc29sdmUoX19kaXJuYW1lLCB2KVxufSlcblxuZnVuY3Rpb24gbWFwX29iaihvYmosIGZuKXtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikucmVkdWNlKGZ1bmN0aW9uKG0sIGspe1xuICAgIG1ba10gPSBmbihvYmpba10pXG4gICAgcmV0dXJuIG1cbiAgfSwge30pXG59XG4iLCIndXNlIHN0cmljdCc7XHJcblxyXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcclxuXHJcblxyXG4vKlxyXG4gICAgRnJvbSBSRkMgNTMyMTpcclxuXHJcbiAgICAgICAgTWFpbGJveCAgICAgICAgID0gICBMb2NhbC1wYXJ0IFwiQFwiICggRG9tYWluIC8gYWRkcmVzcy1saXRlcmFsIClcclxuXHJcbiAgICAgICAgTG9jYWwtcGFydCAgICAgID0gICBEb3Qtc3RyaW5nIC8gUXVvdGVkLXN0cmluZ1xyXG4gICAgICAgIERvdC1zdHJpbmcgICAgICA9ICAgQXRvbSAqKFwiLlwiICBBdG9tKVxyXG4gICAgICAgIEF0b20gICAgICAgICAgICA9ICAgMSphdGV4dFxyXG4gICAgICAgIGF0ZXh0ICAgICAgICAgICA9ICAgQUxQSEEgLyBESUdJVCAvIFwiIVwiIC8gXCIjXCIgLyBcIiRcIiAvIFwiJVwiIC8gXCImXCIgLyBcIidcIiAvIFwiKlwiIC8gXCIrXCIgLyBcIi1cIiAvIFwiL1wiIC8gXCI9XCIgLyBcIj9cIiAvIFwiXlwiIC8gXCJfXCIgLyBcImBcIiAvIFwie1wiIC8gXCJ8XCIgLyBcIn1cIiAvIFwiflwiXHJcblxyXG4gICAgICAgIERvbWFpbiAgICAgICAgICA9ICAgc3ViLWRvbWFpbiAqKFwiLlwiIHN1Yi1kb21haW4pXHJcbiAgICAgICAgc3ViLWRvbWFpbiAgICAgID0gICBMZXQtZGlnIFtMZGgtc3RyXVxyXG4gICAgICAgIExldC1kaWcgICAgICAgICA9ICAgQUxQSEEgLyBESUdJVFxyXG4gICAgICAgIExkaC1zdHIgICAgICAgICA9ICAgKiggQUxQSEEgLyBESUdJVCAvIFwiLVwiICkgTGV0LWRpZ1xyXG5cclxuICAgICAgICBBTFBIQSAgICAgICAgICAgPSAgICV4NDEtNUEgLyAleDYxLTdBICAgICAgICA7IGEteiwgQS1aXHJcbiAgICAgICAgRElHSVQgICAgICAgICAgID0gICAleDMwLTM5ICAgICAgICAgICAgICAgICAgOyAwLTlcclxuXHJcbiAgICBGcm9tIFJGQyA2NTMxOlxyXG5cclxuICAgICAgICBzdWItZG9tYWluICAgICAgPS8gIFUtbGFiZWxcclxuICAgICAgICBhdGV4dCAgICAgICAgICAgPS8gIFVURjgtbm9uLWFzY2lpXHJcblxyXG4gICAgICAgIFVURjgtbm9uLWFzY2lpICA9ICAgVVRGOC0yIC8gVVRGOC0zIC8gVVRGOC00XHJcblxyXG4gICAgICAgIFVURjgtMiAgICAgICAgICA9ICAgJXhDMi1ERiBVVEY4LXRhaWxcclxuICAgICAgICBVVEY4LTMgICAgICAgICAgPSAgICV4RTAgJXhBMC1CRiBVVEY4LXRhaWwgL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJXhFMS1FQyAyKCBVVEY4LXRhaWwgKSAvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAleEVEICV4ODAtOUYgVVRGOC10YWlsIC9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICV4RUUtRUYgMiggVVRGOC10YWlsIClcclxuICAgICAgICBVVEY4LTQgICAgICAgICAgPSAgICV4RjAgJXg5MC1CRiAyKCBVVEY4LXRhaWwgKSAvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAleEYxLUYzIDMoIFVURjgtdGFpbCApIC9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICV4RjQgJXg4MC04RiAyKCBVVEY4LXRhaWwgKVxyXG5cclxuICAgICAgICBVVEY4LXRhaWwgICAgICAgPSAgICV4ODAtQkZcclxuXHJcbiAgICBOb3RlOiBUaGUgZm9sbG93aW5nIGFyZSBub3Qgc3VwcG9ydGVkOlxyXG5cclxuICAgICAgICBSRkMgNTMyMTogYWRkcmVzcy1saXRlcmFsLCBRdW90ZWQtc3RyaW5nXHJcbiAgICAgICAgUkZDIDUzMjI6IG9icy0qLCBDRldTXHJcbiovXHJcblxyXG5cclxuaW50ZXJuYWxzLmF0ZXh0ID0gJ1tcXFxcdyEjXFxcXCQlJlxcJ1xcXFwqXFxcXCtcXFxcLS89XFxcXD9cXFxcXmBcXFxce1xcXFx8XFxcXH1+XSc7ICAgICAgICAgICAgICAgICAvLyBfIGluY2x1ZGVkIGluIFxcd1xyXG5cclxuXHJcbmV4cG9ydHMuYXRleHRSeCA9IG5ldyBSZWdFeHAoYF4ke2ludGVybmFscy5hdGV4dH0rJGApO1xyXG5cclxuXHJcbmV4cG9ydHMuYXRvbVJ4ID0gbmV3IFJlZ0V4cChbXHJcblxyXG4gICAgaW50ZXJuYWxzLmF0ZXh0LFxyXG5cclxuICAgIC8vICAleEMyLURGIFVURjgtdGFpbFxyXG4gICAgJyg/OltcXFxceGMyLVxcXFx4ZGZdW1xcXFx4ODAtXFxcXHhiZl0pJyxcclxuXHJcbiAgICAvLyAgJXhFMCAleEEwLUJGIFVURjgtdGFpbCAgICAgICAgICAgICAgJXhFMS1FQyAyKCBVVEY4LXRhaWwgKSAgICAgICAgICAgICV4RUQgJXg4MC05RiBVVEY4LXRhaWwgICAgICAgICAgICAgICV4RUUtRUYgMiggVVRGOC10YWlsIClcclxuICAgICcoPzpcXFxceGUwW1xcXFx4YTAtXFxcXHhiZl1bXFxcXHg4MC1cXFxceGJmXSl8KD86W1xcXFx4ZTEtXFxcXHhlY11bXFxcXHg4MC1cXFxceGJmXXsyfSl8KD86XFxcXHhlZFtcXFxceDgwLVxcXFx4OWZdW1xcXFx4ODAtXFxcXHhiZl0pfCg/OltcXFxceGVlLVxcXFx4ZWZdW1xcXFx4ODAtXFxcXHhiZl17Mn0pJyxcclxuXHJcbiAgICAvLyAgJXhGMCAleDkwLUJGIDIoIFVURjgtdGFpbCApICAgICAgICAgICAgJXhGMS1GMyAzKCBVVEY4LXRhaWwgKSAgICAgICAgICAgICV4RjQgJXg4MC04RiAyKCBVVEY4LXRhaWwgKVxyXG4gICAgJyg/OlxcXFx4ZjBbXFxcXHg5MC1cXFxceGJmXVtcXFxceDgwLVxcXFx4YmZdezJ9KXwoPzpbXFxcXHhmMS1cXFxceGYzXVtcXFxceDgwLVxcXFx4YmZdezN9KXwoPzpcXFxceGY0W1xcXFx4ODAtXFxcXHg4Zl1bXFxcXHg4MC1cXFxceGJmXXsyfSknXHJcblxyXG5dLmpvaW4oJ3wnKSk7XHJcbiIsIid1c2Ugc3RyaWN0JztcclxuXHJcbmNvbnN0IFB1bnljb2RlID0gcmVxdWlyZSgncHVueWNvZGUnKTtcclxuXHJcbmNvbnN0IEFibmYgPSByZXF1aXJlKCcuL2FibmYnKTtcclxuY29uc3QgVGxkcyA9IHJlcXVpcmUoJy4vdGxkcycpO1xyXG5cclxuXHJcbmNvbnN0IGludGVybmFscyA9IHtcclxuICAgIG5vbkFzY2lpUng6IC9bXlxceDAwLVxceDdmXS8sXHJcbiAgICBtaW5Eb21haW5TZWdtZW50czogMixcclxuICAgIGRlZmF1bHRUbGRzOiB7IGFsbG93OiBUbGRzLCBkZW55OiBudWxsIH1cclxufTtcclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIGVtYWlsOiB7XHJcbiAgICAgICAgYW5hbHl6ZTogZnVuY3Rpb24gKGVtYWlsLCBvcHRpb25zKSB7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmVtYWlsKGVtYWlsLCBvcHRpb25zKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGlzVmFsaWQ6IGZ1bmN0aW9uIChlbWFpbCwgb3B0aW9ucykge1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuICFpbnRlcm5hbHMuZW1haWwoZW1haWwsIG9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBkb21haW46IHtcclxuICAgICAgICBhbmFseXplOiBmdW5jdGlvbiAoZG9tYWluLCBvcHRpb25zID0ge30pIHtcclxuXHJcbiAgICAgICAgICAgIGludGVybmFscy5vcHRpb25zKGRvbWFpbiwgb3B0aW9ucyk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIWRvbWFpbikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5lcnJvcignRG9tYWluIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChkb21haW4ubGVuZ3RoID4gMjU2KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmVycm9yKCdEb21haW4gdG9vIGxvbmcnKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY29uc3QgYXNjaWkgPSAhaW50ZXJuYWxzLm5vbkFzY2lpUngudGVzdChkb21haW4pO1xyXG4gICAgICAgICAgICBpZiAoIWFzY2lpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5hbGxvd1VuaWNvZGUgPT09IGZhbHNlKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlZmF1bHRzIHRvIHRydWVcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmVycm9yKCdEb21haW4gY29udGFpbnMgZm9yYmlkZGVuIFVuaWNvZGUgY2hhcmFjdGVycycpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBkb21haW4ubm9ybWFsaXplKCdORkMnKTtcclxuICAgICAgICAgICAgICAgIGRvbWFpbiA9IFB1bnljb2RlLnRvQVNDSUkobm9ybWFsaXplZCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMuZG9tYWluKGRvbWFpbiwgb3B0aW9ucyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBpc1ZhbGlkOiBmdW5jdGlvbiAoZG9tYWluLCBvcHRpb25zKSB7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gIW1vZHVsZS5leHBvcnRzLmRvbWFpbi5hbmFseXplKGRvbWFpbiwgb3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcbmludGVybmFscy5lbWFpbCA9IGZ1bmN0aW9uIChlbWFpbCwgb3B0aW9ucyA9IHt9KSB7XHJcblxyXG4gICAgaW50ZXJuYWxzLm9wdGlvbnMoZW1haWwsIG9wdGlvbnMpO1xyXG5cclxuICAgIGlmICghZW1haWwpIHtcclxuICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmVycm9yKCdBZGRyZXNzIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVW5pY29kZVxyXG5cclxuICAgIGNvbnN0IGFzY2lpID0gIWludGVybmFscy5ub25Bc2NpaVJ4LnRlc3QoZW1haWwpO1xyXG4gICAgaWYgKCFhc2NpaSkge1xyXG4gICAgICAgIGlmIChvcHRpb25zLmFsbG93VW5pY29kZSA9PT0gZmFsc2UpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEZWZhdWx0cyB0byB0cnVlXHJcbiAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMuZXJyb3IoJ0FkZHJlc3MgY29udGFpbnMgZm9yYmlkZGVuIFVuaWNvZGUgY2hhcmFjdGVycycpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IGVtYWlsLm5vcm1hbGl6ZSgnTkZDJyk7XHJcbiAgICAgICAgZW1haWwgPSBQdW55Y29kZS50b0FTQ0lJKG5vcm1hbGl6ZWQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEJhc2ljIHN0cnVjdHVyZVxyXG5cclxuICAgIGNvbnN0IHBhcnRzID0gZW1haWwuc3BsaXQoJ0AnKTtcclxuICAgIGlmIChwYXJ0cy5sZW5ndGggIT09IDIpIHtcclxuICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmVycm9yKHBhcnRzLmxlbmd0aCA+IDIgPyAnQWRkcmVzcyBjYW5ub3QgY29udGFpbiBtb3JlIHRoYW4gb25lIEAgY2hhcmFjdGVyJyA6ICdBZGRyZXNzIG11c3QgY29udGFpbiBvbmUgQCBjaGFyYWN0ZXInKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBsb2NhbCA9IHBhcnRzWzBdO1xyXG4gICAgY29uc3QgZG9tYWluID0gcGFydHNbMV07XHJcblxyXG4gICAgaWYgKCFsb2NhbCkge1xyXG4gICAgICAgIHJldHVybiBpbnRlcm5hbHMuZXJyb3IoJ0FkZHJlc3MgbG9jYWwgcGFydCBjYW5ub3QgYmUgZW1wdHknKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWRvbWFpbikge1xyXG4gICAgICAgIHJldHVybiBpbnRlcm5hbHMuZXJyb3IoJ0RvbWFpbiBjYW5ub3QgYmUgZW1wdHknKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoZW1haWwubGVuZ3RoID4gMjU0KSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNTMyMSNzZWN0aW9uLTQuNS4zLjEuM1xyXG4gICAgICAgIHJldHVybiBpbnRlcm5hbHMuZXJyb3IoJ0FkZHJlc3MgdG9vIGxvbmcnKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoQnVmZmVyLmJ5dGVMZW5ndGgobG9jYWwsICd1dGYtOCcpID4gNjQpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNTMyMSNzZWN0aW9uLTQuNS4zLjEuMVxyXG4gICAgICAgIHJldHVybiBpbnRlcm5hbHMuZXJyb3IoJ0FkZHJlc3MgbG9jYWwgcGFydCB0b28gbG9uZycpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFZhbGlkYXRlIHBhcnRzXHJcblxyXG4gICAgcmV0dXJuIGludGVybmFscy5sb2NhbChsb2NhbCwgYXNjaWkpIHx8IGludGVybmFscy5kb21haW4oZG9tYWluLCBvcHRpb25zKTtcclxufTtcclxuXHJcblxyXG5pbnRlcm5hbHMub3B0aW9ucyA9IGZ1bmN0aW9uICh2YWx1ZSwgb3B0aW9ucykge1xyXG5cclxuICAgIC8vIE9wdGlvbnMgdmFsaWRhdGlvblxyXG5cclxuICAgIGlmIChvcHRpb25zLnRsZHMgJiZcclxuICAgICAgICBvcHRpb25zLnRsZHMgIT09IHRydWUpIHtcclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnRsZHMgIT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBvcHRpb25zOiB0bGRzIG11c3QgYmUgYSBib29sZWFuIG9yIGFuIG9iamVjdCcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG9wdGlvbnMudGxkcy5hbGxvdyAhPT0gdW5kZWZpbmVkICYmXHJcbiAgICAgICAgICAgIG9wdGlvbnMudGxkcy5hbGxvdyAhPT0gdHJ1ZSAmJlxyXG4gICAgICAgICAgICBvcHRpb25zLnRsZHMuYWxsb3cgaW5zdGFuY2VvZiBTZXQgPT09IGZhbHNlKSB7XHJcblxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgb3B0aW9uczogdGxkcy5hbGxvdyBtdXN0IGJlIGEgU2V0IG9iamVjdCBvciB0cnVlJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAob3B0aW9ucy50bGRzLmRlbnkpIHtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMudGxkcy5kZW55IGluc3RhbmNlb2YgU2V0ID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG9wdGlvbnM6IHRsZHMuZGVueSBtdXN0IGJlIGEgU2V0IG9iamVjdCcpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy50bGRzLmFsbG93IGluc3RhbmNlb2YgU2V0KSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgb3B0aW9uczogY2Fubm90IHNwZWNpZnkgYm90aCB0bGRzLmFsbG93IGFuZCB0bGRzLmRlbnkgbGlzdHMnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBJbnB1dCB2YWxpZGF0aW9uXHJcblxyXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5wdXQ6IHZhbHVlIG11c3QgYmUgYSBzdHJpbmcnKTtcclxuICAgIH1cclxufTtcclxuXHJcblxyXG5pbnRlcm5hbHMubG9jYWwgPSBmdW5jdGlvbiAobG9jYWwsIGFzY2lpKSB7XHJcblxyXG4gICAgY29uc3Qgc2VnbWVudHMgPSBsb2NhbC5zcGxpdCgnLicpO1xyXG4gICAgZm9yIChjb25zdCBzZWdtZW50IG9mIHNlZ21lbnRzKSB7XHJcbiAgICAgICAgaWYgKCFzZWdtZW50Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmVycm9yKCdBZGRyZXNzIGxvY2FsIHBhcnQgY29udGFpbnMgZW1wdHkgZG90LXNlcGFyYXRlZCBzZWdtZW50Jyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoYXNjaWkpIHtcclxuICAgICAgICAgICAgaWYgKCFBYm5mLmF0ZXh0UngudGVzdChzZWdtZW50KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5lcnJvcignQWRkcmVzcyBsb2NhbCBwYXJ0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVyJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgY2hhciBvZiBzZWdtZW50KSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBiaW5hcnkgPSBCdWZmZXIuZnJvbShjaGFyKS50b1N0cmluZygnYmluYXJ5Jyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIUFibmYuYXRvbVJ4LnRlc3QoYmluYXJ5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMuZXJyb3IoJ0FkZHJlc3MgbG9jYWwgcGFydCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcicpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcbmludGVybmFscy50bGRTZWdtZW50UnggPSAvXlthLXpBLVpdKD86W2EtekEtWjAtOVxcLV0qW2EtekEtWjAtOV0pPyQvO1xyXG5cclxuXHJcbmludGVybmFscy5kb21haW5TZWdtZW50UnggPSAvXlthLXpBLVowLTldKD86W2EtekEtWjAtOVxcLV0qW2EtekEtWjAtOV0pPyQvO1xyXG5cclxuXHJcbmludGVybmFscy5kb21haW4gPSBmdW5jdGlvbiAoZG9tYWluLCBvcHRpb25zKSB7XHJcblxyXG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzEwMzUgc2VjdGlvbiAyLjMuMVxyXG5cclxuICAgIGNvbnN0IG1pbkRvbWFpblNlZ21lbnRzID0gKG9wdGlvbnMubWluRG9tYWluU2VnbWVudHMgfHwgaW50ZXJuYWxzLm1pbkRvbWFpblNlZ21lbnRzKTtcclxuXHJcbiAgICBjb25zdCBzZWdtZW50cyA9IGRvbWFpbi5zcGxpdCgnLicpO1xyXG4gICAgaWYgKHNlZ21lbnRzLmxlbmd0aCA8IG1pbkRvbWFpblNlZ21lbnRzKSB7XHJcbiAgICAgICAgcmV0dXJuIGludGVybmFscy5lcnJvcignRG9tYWluIGxhY2tzIHRoZSBtaW5pbXVtIHJlcXVpcmVkIG51bWJlciBvZiBzZWdtZW50cycpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHRsZHMgPSBpbnRlcm5hbHMudGxkcyhvcHRpb25zKTtcclxuICAgIGlmICh0bGRzKSB7XHJcbiAgICAgICAgY29uc3QgdGxkID0gc2VnbWVudHNbc2VnbWVudHMubGVuZ3RoIC0gMV0udG9Mb3dlckNhc2UoKTtcclxuICAgICAgICBpZiAodGxkcy5kZW55ICYmIHRsZHMuZGVueS5oYXModGxkKSB8fFxyXG4gICAgICAgICAgICB0bGRzLmFsbG93ICYmICF0bGRzLmFsbG93Lmhhcyh0bGQpKSB7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmVycm9yKCdEb21haW4gdXNlcyBmb3JiaWRkZW4gVExEJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICBjb25zdCBzZWdtZW50ID0gc2VnbWVudHNbaV07XHJcblxyXG4gICAgICAgIGlmICghc2VnbWVudC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5lcnJvcignRG9tYWluIGNvbnRhaW5zIGVtcHR5IGRvdC1zZXBhcmF0ZWQgc2VnbWVudCcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHNlZ21lbnQubGVuZ3RoID4gNjMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5lcnJvcignRG9tYWluIGNvbnRhaW5zIGRvdC1zZXBhcmF0ZWQgc2VnbWVudCB0aGF0IGlzIHRvbyBsb25nJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoaSA8IHNlZ21lbnRzLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgaWYgKCFpbnRlcm5hbHMuZG9tYWluU2VnbWVudFJ4LnRlc3Qoc2VnbWVudCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMuZXJyb3IoJ0RvbWFpbiBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoIWludGVybmFscy50bGRTZWdtZW50UngudGVzdChzZWdtZW50KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5lcnJvcignRG9tYWluIGNvbnRhaW5zIGludmFsaWQgdGxkIGNoYXJhY3RlcicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcbmludGVybmFscy50bGRzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHJcbiAgICBpZiAob3B0aW9ucy50bGRzID09PSBmYWxzZSkgeyAgICAgICAgICAgICAgICAvLyBEZWZhdWx0cyB0byB0cnVlXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFvcHRpb25zLnRsZHMgfHxcclxuICAgICAgICBvcHRpb25zLnRsZHMgPT09IHRydWUpIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIGludGVybmFscy5kZWZhdWx0VGxkcztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGFsbG93OiBvcHRpb25zLnRsZHMuYWxsb3cgPT09IHRydWUgPyBudWxsIDogb3B0aW9ucy50bGRzLmFsbG93IHx8IFRsZHMsXHJcbiAgICAgICAgZGVueTogb3B0aW9ucy50bGRzLmRlbnkgfHwgbnVsbFxyXG4gICAgfTtcclxufTtcclxuXHJcblxyXG5pbnRlcm5hbHMuZXJyb3IgPSBmdW5jdGlvbiAocmVhc29uKSB7XHJcblxyXG4gICAgcmV0dXJuIHsgZXJyb3I6IHJlYXNvbiB9O1xyXG59O1xyXG4iLCIndXNlIHN0cmljdCc7XHJcblxyXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcclxuXHJcblxyXG4vLyBodHRwOi8vZGF0YS5pYW5hLm9yZy9UTEQvdGxkcy1hbHBoYS1ieS1kb21haW4udHh0XHJcbi8vICMgVmVyc2lvbiAyMDE5MDMyMzAwLCBMYXN0IFVwZGF0ZWQgU2F0IE1hciAyMyAwNzowNzowMiAyMDE5IFVUQ1xyXG5cclxuXHJcbmludGVybmFscy50bGRzID0gW1xyXG4gICAgJ0FBQScsXHJcbiAgICAnQUFSUCcsXHJcbiAgICAnQUJBUlRIJyxcclxuICAgICdBQkInLFxyXG4gICAgJ0FCQk9UVCcsXHJcbiAgICAnQUJCVklFJyxcclxuICAgICdBQkMnLFxyXG4gICAgJ0FCTEUnLFxyXG4gICAgJ0FCT0dBRE8nLFxyXG4gICAgJ0FCVURIQUJJJyxcclxuICAgICdBQycsXHJcbiAgICAnQUNBREVNWScsXHJcbiAgICAnQUNDRU5UVVJFJyxcclxuICAgICdBQ0NPVU5UQU5UJyxcclxuICAgICdBQ0NPVU5UQU5UUycsXHJcbiAgICAnQUNPJyxcclxuICAgICdBQ1RPUicsXHJcbiAgICAnQUQnLFxyXG4gICAgJ0FEQUMnLFxyXG4gICAgJ0FEUycsXHJcbiAgICAnQURVTFQnLFxyXG4gICAgJ0FFJyxcclxuICAgICdBRUcnLFxyXG4gICAgJ0FFUk8nLFxyXG4gICAgJ0FFVE5BJyxcclxuICAgICdBRicsXHJcbiAgICAnQUZBTUlMWUNPTVBBTlknLFxyXG4gICAgJ0FGTCcsXHJcbiAgICAnQUZSSUNBJyxcclxuICAgICdBRycsXHJcbiAgICAnQUdBS0hBTicsXHJcbiAgICAnQUdFTkNZJyxcclxuICAgICdBSScsXHJcbiAgICAnQUlHJyxcclxuICAgICdBSUdPJyxcclxuICAgICdBSVJCVVMnLFxyXG4gICAgJ0FJUkZPUkNFJyxcclxuICAgICdBSVJURUwnLFxyXG4gICAgJ0FLRE4nLFxyXG4gICAgJ0FMJyxcclxuICAgICdBTEZBUk9NRU8nLFxyXG4gICAgJ0FMSUJBQkEnLFxyXG4gICAgJ0FMSVBBWScsXHJcbiAgICAnQUxMRklOQU5aJyxcclxuICAgICdBTExTVEFURScsXHJcbiAgICAnQUxMWScsXHJcbiAgICAnQUxTQUNFJyxcclxuICAgICdBTFNUT00nLFxyXG4gICAgJ0FNJyxcclxuICAgICdBTUVSSUNBTkVYUFJFU1MnLFxyXG4gICAgJ0FNRVJJQ0FORkFNSUxZJyxcclxuICAgICdBTUVYJyxcclxuICAgICdBTUZBTScsXHJcbiAgICAnQU1JQ0EnLFxyXG4gICAgJ0FNU1RFUkRBTScsXHJcbiAgICAnQU5BTFlUSUNTJyxcclxuICAgICdBTkRST0lEJyxcclxuICAgICdBTlFVQU4nLFxyXG4gICAgJ0FOWicsXHJcbiAgICAnQU8nLFxyXG4gICAgJ0FPTCcsXHJcbiAgICAnQVBBUlRNRU5UUycsXHJcbiAgICAnQVBQJyxcclxuICAgICdBUFBMRScsXHJcbiAgICAnQVEnLFxyXG4gICAgJ0FRVUFSRUxMRScsXHJcbiAgICAnQVInLFxyXG4gICAgJ0FSQUInLFxyXG4gICAgJ0FSQU1DTycsXHJcbiAgICAnQVJDSEknLFxyXG4gICAgJ0FSTVknLFxyXG4gICAgJ0FSUEEnLFxyXG4gICAgJ0FSVCcsXHJcbiAgICAnQVJURScsXHJcbiAgICAnQVMnLFxyXG4gICAgJ0FTREEnLFxyXG4gICAgJ0FTSUEnLFxyXG4gICAgJ0FTU09DSUFURVMnLFxyXG4gICAgJ0FUJyxcclxuICAgICdBVEhMRVRBJyxcclxuICAgICdBVFRPUk5FWScsXHJcbiAgICAnQVUnLFxyXG4gICAgJ0FVQ1RJT04nLFxyXG4gICAgJ0FVREknLFxyXG4gICAgJ0FVRElCTEUnLFxyXG4gICAgJ0FVRElPJyxcclxuICAgICdBVVNQT1NUJyxcclxuICAgICdBVVRIT1InLFxyXG4gICAgJ0FVVE8nLFxyXG4gICAgJ0FVVE9TJyxcclxuICAgICdBVklBTkNBJyxcclxuICAgICdBVycsXHJcbiAgICAnQVdTJyxcclxuICAgICdBWCcsXHJcbiAgICAnQVhBJyxcclxuICAgICdBWicsXHJcbiAgICAnQVpVUkUnLFxyXG4gICAgJ0JBJyxcclxuICAgICdCQUJZJyxcclxuICAgICdCQUlEVScsXHJcbiAgICAnQkFOQU1FWCcsXHJcbiAgICAnQkFOQU5BUkVQVUJMSUMnLFxyXG4gICAgJ0JBTkQnLFxyXG4gICAgJ0JBTksnLFxyXG4gICAgJ0JBUicsXHJcbiAgICAnQkFSQ0VMT05BJyxcclxuICAgICdCQVJDTEFZQ0FSRCcsXHJcbiAgICAnQkFSQ0xBWVMnLFxyXG4gICAgJ0JBUkVGT09UJyxcclxuICAgICdCQVJHQUlOUycsXHJcbiAgICAnQkFTRUJBTEwnLFxyXG4gICAgJ0JBU0tFVEJBTEwnLFxyXG4gICAgJ0JBVUhBVVMnLFxyXG4gICAgJ0JBWUVSTicsXHJcbiAgICAnQkInLFxyXG4gICAgJ0JCQycsXHJcbiAgICAnQkJUJyxcclxuICAgICdCQlZBJyxcclxuICAgICdCQ0cnLFxyXG4gICAgJ0JDTicsXHJcbiAgICAnQkQnLFxyXG4gICAgJ0JFJyxcclxuICAgICdCRUFUUycsXHJcbiAgICAnQkVBVVRZJyxcclxuICAgICdCRUVSJyxcclxuICAgICdCRU5UTEVZJyxcclxuICAgICdCRVJMSU4nLFxyXG4gICAgJ0JFU1QnLFxyXG4gICAgJ0JFU1RCVVknLFxyXG4gICAgJ0JFVCcsXHJcbiAgICAnQkYnLFxyXG4gICAgJ0JHJyxcclxuICAgICdCSCcsXHJcbiAgICAnQkhBUlRJJyxcclxuICAgICdCSScsXHJcbiAgICAnQklCTEUnLFxyXG4gICAgJ0JJRCcsXHJcbiAgICAnQklLRScsXHJcbiAgICAnQklORycsXHJcbiAgICAnQklOR08nLFxyXG4gICAgJ0JJTycsXHJcbiAgICAnQklaJyxcclxuICAgICdCSicsXHJcbiAgICAnQkxBQ0snLFxyXG4gICAgJ0JMQUNLRlJJREFZJyxcclxuICAgICdCTE9DS0JVU1RFUicsXHJcbiAgICAnQkxPRycsXHJcbiAgICAnQkxPT01CRVJHJyxcclxuICAgICdCTFVFJyxcclxuICAgICdCTScsXHJcbiAgICAnQk1TJyxcclxuICAgICdCTVcnLFxyXG4gICAgJ0JOJyxcclxuICAgICdCTkwnLFxyXG4gICAgJ0JOUFBBUklCQVMnLFxyXG4gICAgJ0JPJyxcclxuICAgICdCT0FUUycsXHJcbiAgICAnQk9FSFJJTkdFUicsXHJcbiAgICAnQk9GQScsXHJcbiAgICAnQk9NJyxcclxuICAgICdCT05EJyxcclxuICAgICdCT08nLFxyXG4gICAgJ0JPT0snLFxyXG4gICAgJ0JPT0tJTkcnLFxyXG4gICAgJ0JPU0NIJyxcclxuICAgICdCT1NUSUsnLFxyXG4gICAgJ0JPU1RPTicsXHJcbiAgICAnQk9UJyxcclxuICAgICdCT1VUSVFVRScsXHJcbiAgICAnQk9YJyxcclxuICAgICdCUicsXHJcbiAgICAnQlJBREVTQ08nLFxyXG4gICAgJ0JSSURHRVNUT05FJyxcclxuICAgICdCUk9BRFdBWScsXHJcbiAgICAnQlJPS0VSJyxcclxuICAgICdCUk9USEVSJyxcclxuICAgICdCUlVTU0VMUycsXHJcbiAgICAnQlMnLFxyXG4gICAgJ0JUJyxcclxuICAgICdCVURBUEVTVCcsXHJcbiAgICAnQlVHQVRUSScsXHJcbiAgICAnQlVJTEQnLFxyXG4gICAgJ0JVSUxERVJTJyxcclxuICAgICdCVVNJTkVTUycsXHJcbiAgICAnQlVZJyxcclxuICAgICdCVVpaJyxcclxuICAgICdCVicsXHJcbiAgICAnQlcnLFxyXG4gICAgJ0JZJyxcclxuICAgICdCWicsXHJcbiAgICAnQlpIJyxcclxuICAgICdDQScsXHJcbiAgICAnQ0FCJyxcclxuICAgICdDQUZFJyxcclxuICAgICdDQUwnLFxyXG4gICAgJ0NBTEwnLFxyXG4gICAgJ0NBTFZJTktMRUlOJyxcclxuICAgICdDQU0nLFxyXG4gICAgJ0NBTUVSQScsXHJcbiAgICAnQ0FNUCcsXHJcbiAgICAnQ0FOQ0VSUkVTRUFSQ0gnLFxyXG4gICAgJ0NBTk9OJyxcclxuICAgICdDQVBFVE9XTicsXHJcbiAgICAnQ0FQSVRBTCcsXHJcbiAgICAnQ0FQSVRBTE9ORScsXHJcbiAgICAnQ0FSJyxcclxuICAgICdDQVJBVkFOJyxcclxuICAgICdDQVJEUycsXHJcbiAgICAnQ0FSRScsXHJcbiAgICAnQ0FSRUVSJyxcclxuICAgICdDQVJFRVJTJyxcclxuICAgICdDQVJTJyxcclxuICAgICdDQVJUSUVSJyxcclxuICAgICdDQVNBJyxcclxuICAgICdDQVNFJyxcclxuICAgICdDQVNFSUgnLFxyXG4gICAgJ0NBU0gnLFxyXG4gICAgJ0NBU0lOTycsXHJcbiAgICAnQ0FUJyxcclxuICAgICdDQVRFUklORycsXHJcbiAgICAnQ0FUSE9MSUMnLFxyXG4gICAgJ0NCQScsXHJcbiAgICAnQ0JOJyxcclxuICAgICdDQlJFJyxcclxuICAgICdDQlMnLFxyXG4gICAgJ0NDJyxcclxuICAgICdDRCcsXHJcbiAgICAnQ0VCJyxcclxuICAgICdDRU5URVInLFxyXG4gICAgJ0NFTycsXHJcbiAgICAnQ0VSTicsXHJcbiAgICAnQ0YnLFxyXG4gICAgJ0NGQScsXHJcbiAgICAnQ0ZEJyxcclxuICAgICdDRycsXHJcbiAgICAnQ0gnLFxyXG4gICAgJ0NIQU5FTCcsXHJcbiAgICAnQ0hBTk5FTCcsXHJcbiAgICAnQ0hBUklUWScsXHJcbiAgICAnQ0hBU0UnLFxyXG4gICAgJ0NIQVQnLFxyXG4gICAgJ0NIRUFQJyxcclxuICAgICdDSElOVEFJJyxcclxuICAgICdDSFJJU1RNQVMnLFxyXG4gICAgJ0NIUk9NRScsXHJcbiAgICAnQ0hSWVNMRVInLFxyXG4gICAgJ0NIVVJDSCcsXHJcbiAgICAnQ0knLFxyXG4gICAgJ0NJUFJJQU5JJyxcclxuICAgICdDSVJDTEUnLFxyXG4gICAgJ0NJU0NPJyxcclxuICAgICdDSVRBREVMJyxcclxuICAgICdDSVRJJyxcclxuICAgICdDSVRJQycsXHJcbiAgICAnQ0lUWScsXHJcbiAgICAnQ0lUWUVBVFMnLFxyXG4gICAgJ0NLJyxcclxuICAgICdDTCcsXHJcbiAgICAnQ0xBSU1TJyxcclxuICAgICdDTEVBTklORycsXHJcbiAgICAnQ0xJQ0snLFxyXG4gICAgJ0NMSU5JQycsXHJcbiAgICAnQ0xJTklRVUUnLFxyXG4gICAgJ0NMT1RISU5HJyxcclxuICAgICdDTE9VRCcsXHJcbiAgICAnQ0xVQicsXHJcbiAgICAnQ0xVQk1FRCcsXHJcbiAgICAnQ00nLFxyXG4gICAgJ0NOJyxcclxuICAgICdDTycsXHJcbiAgICAnQ09BQ0gnLFxyXG4gICAgJ0NPREVTJyxcclxuICAgICdDT0ZGRUUnLFxyXG4gICAgJ0NPTExFR0UnLFxyXG4gICAgJ0NPTE9HTkUnLFxyXG4gICAgJ0NPTScsXHJcbiAgICAnQ09NQ0FTVCcsXHJcbiAgICAnQ09NTUJBTksnLFxyXG4gICAgJ0NPTU1VTklUWScsXHJcbiAgICAnQ09NUEFOWScsXHJcbiAgICAnQ09NUEFSRScsXHJcbiAgICAnQ09NUFVURVInLFxyXG4gICAgJ0NPTVNFQycsXHJcbiAgICAnQ09ORE9TJyxcclxuICAgICdDT05TVFJVQ1RJT04nLFxyXG4gICAgJ0NPTlNVTFRJTkcnLFxyXG4gICAgJ0NPTlRBQ1QnLFxyXG4gICAgJ0NPTlRSQUNUT1JTJyxcclxuICAgICdDT09LSU5HJyxcclxuICAgICdDT09LSU5HQ0hBTk5FTCcsXHJcbiAgICAnQ09PTCcsXHJcbiAgICAnQ09PUCcsXHJcbiAgICAnQ09SU0lDQScsXHJcbiAgICAnQ09VTlRSWScsXHJcbiAgICAnQ09VUE9OJyxcclxuICAgICdDT1VQT05TJyxcclxuICAgICdDT1VSU0VTJyxcclxuICAgICdDUicsXHJcbiAgICAnQ1JFRElUJyxcclxuICAgICdDUkVESVRDQVJEJyxcclxuICAgICdDUkVESVRVTklPTicsXHJcbiAgICAnQ1JJQ0tFVCcsXHJcbiAgICAnQ1JPV04nLFxyXG4gICAgJ0NSUycsXHJcbiAgICAnQ1JVSVNFJyxcclxuICAgICdDUlVJU0VTJyxcclxuICAgICdDU0MnLFxyXG4gICAgJ0NVJyxcclxuICAgICdDVUlTSU5FTExBJyxcclxuICAgICdDVicsXHJcbiAgICAnQ1cnLFxyXG4gICAgJ0NYJyxcclxuICAgICdDWScsXHJcbiAgICAnQ1lNUlUnLFxyXG4gICAgJ0NZT1UnLFxyXG4gICAgJ0NaJyxcclxuICAgICdEQUJVUicsXHJcbiAgICAnREFEJyxcclxuICAgICdEQU5DRScsXHJcbiAgICAnREFUQScsXHJcbiAgICAnREFURScsXHJcbiAgICAnREFUSU5HJyxcclxuICAgICdEQVRTVU4nLFxyXG4gICAgJ0RBWScsXHJcbiAgICAnRENMSycsXHJcbiAgICAnRERTJyxcclxuICAgICdERScsXHJcbiAgICAnREVBTCcsXHJcbiAgICAnREVBTEVSJyxcclxuICAgICdERUFMUycsXHJcbiAgICAnREVHUkVFJyxcclxuICAgICdERUxJVkVSWScsXHJcbiAgICAnREVMTCcsXHJcbiAgICAnREVMT0lUVEUnLFxyXG4gICAgJ0RFTFRBJyxcclxuICAgICdERU1PQ1JBVCcsXHJcbiAgICAnREVOVEFMJyxcclxuICAgICdERU5USVNUJyxcclxuICAgICdERVNJJyxcclxuICAgICdERVNJR04nLFxyXG4gICAgJ0RFVicsXHJcbiAgICAnREhMJyxcclxuICAgICdESUFNT05EUycsXHJcbiAgICAnRElFVCcsXHJcbiAgICAnRElHSVRBTCcsXHJcbiAgICAnRElSRUNUJyxcclxuICAgICdESVJFQ1RPUlknLFxyXG4gICAgJ0RJU0NPVU5UJyxcclxuICAgICdESVNDT1ZFUicsXHJcbiAgICAnRElTSCcsXHJcbiAgICAnRElZJyxcclxuICAgICdESicsXHJcbiAgICAnREsnLFxyXG4gICAgJ0RNJyxcclxuICAgICdETlAnLFxyXG4gICAgJ0RPJyxcclxuICAgICdET0NTJyxcclxuICAgICdET0NUT1InLFxyXG4gICAgJ0RPREdFJyxcclxuICAgICdET0cnLFxyXG4gICAgJ0RPSEEnLFxyXG4gICAgJ0RPTUFJTlMnLFxyXG4gICAgJ0RPVCcsXHJcbiAgICAnRE9XTkxPQUQnLFxyXG4gICAgJ0RSSVZFJyxcclxuICAgICdEVFYnLFxyXG4gICAgJ0RVQkFJJyxcclxuICAgICdEVUNLJyxcclxuICAgICdEVU5MT1AnLFxyXG4gICAgJ0RVTlMnLFxyXG4gICAgJ0RVUE9OVCcsXHJcbiAgICAnRFVSQkFOJyxcclxuICAgICdEVkFHJyxcclxuICAgICdEVlInLFxyXG4gICAgJ0RaJyxcclxuICAgICdFQVJUSCcsXHJcbiAgICAnRUFUJyxcclxuICAgICdFQycsXHJcbiAgICAnRUNPJyxcclxuICAgICdFREVLQScsXHJcbiAgICAnRURVJyxcclxuICAgICdFRFVDQVRJT04nLFxyXG4gICAgJ0VFJyxcclxuICAgICdFRycsXHJcbiAgICAnRU1BSUwnLFxyXG4gICAgJ0VNRVJDSycsXHJcbiAgICAnRU5FUkdZJyxcclxuICAgICdFTkdJTkVFUicsXHJcbiAgICAnRU5HSU5FRVJJTkcnLFxyXG4gICAgJ0VOVEVSUFJJU0VTJyxcclxuICAgICdFUFNPTicsXHJcbiAgICAnRVFVSVBNRU5UJyxcclxuICAgICdFUicsXHJcbiAgICAnRVJJQ1NTT04nLFxyXG4gICAgJ0VSTkknLFxyXG4gICAgJ0VTJyxcclxuICAgICdFU1EnLFxyXG4gICAgJ0VTVEFURScsXHJcbiAgICAnRVNVUkFOQ0UnLFxyXG4gICAgJ0VUJyxcclxuICAgICdFVElTQUxBVCcsXHJcbiAgICAnRVUnLFxyXG4gICAgJ0VVUk9WSVNJT04nLFxyXG4gICAgJ0VVUycsXHJcbiAgICAnRVZFTlRTJyxcclxuICAgICdFVkVSQkFOSycsXHJcbiAgICAnRVhDSEFOR0UnLFxyXG4gICAgJ0VYUEVSVCcsXHJcbiAgICAnRVhQT1NFRCcsXHJcbiAgICAnRVhQUkVTUycsXHJcbiAgICAnRVhUUkFTUEFDRScsXHJcbiAgICAnRkFHRScsXHJcbiAgICAnRkFJTCcsXHJcbiAgICAnRkFJUldJTkRTJyxcclxuICAgICdGQUlUSCcsXHJcbiAgICAnRkFNSUxZJyxcclxuICAgICdGQU4nLFxyXG4gICAgJ0ZBTlMnLFxyXG4gICAgJ0ZBUk0nLFxyXG4gICAgJ0ZBUk1FUlMnLFxyXG4gICAgJ0ZBU0hJT04nLFxyXG4gICAgJ0ZBU1QnLFxyXG4gICAgJ0ZFREVYJyxcclxuICAgICdGRUVEQkFDSycsXHJcbiAgICAnRkVSUkFSSScsXHJcbiAgICAnRkVSUkVSTycsXHJcbiAgICAnRkknLFxyXG4gICAgJ0ZJQVQnLFxyXG4gICAgJ0ZJREVMSVRZJyxcclxuICAgICdGSURPJyxcclxuICAgICdGSUxNJyxcclxuICAgICdGSU5BTCcsXHJcbiAgICAnRklOQU5DRScsXHJcbiAgICAnRklOQU5DSUFMJyxcclxuICAgICdGSVJFJyxcclxuICAgICdGSVJFU1RPTkUnLFxyXG4gICAgJ0ZJUk1EQUxFJyxcclxuICAgICdGSVNIJyxcclxuICAgICdGSVNISU5HJyxcclxuICAgICdGSVQnLFxyXG4gICAgJ0ZJVE5FU1MnLFxyXG4gICAgJ0ZKJyxcclxuICAgICdGSycsXHJcbiAgICAnRkxJQ0tSJyxcclxuICAgICdGTElHSFRTJyxcclxuICAgICdGTElSJyxcclxuICAgICdGTE9SSVNUJyxcclxuICAgICdGTE9XRVJTJyxcclxuICAgICdGTFknLFxyXG4gICAgJ0ZNJyxcclxuICAgICdGTycsXHJcbiAgICAnRk9PJyxcclxuICAgICdGT09EJyxcclxuICAgICdGT09ETkVUV09SSycsXHJcbiAgICAnRk9PVEJBTEwnLFxyXG4gICAgJ0ZPUkQnLFxyXG4gICAgJ0ZPUkVYJyxcclxuICAgICdGT1JTQUxFJyxcclxuICAgICdGT1JVTScsXHJcbiAgICAnRk9VTkRBVElPTicsXHJcbiAgICAnRk9YJyxcclxuICAgICdGUicsXHJcbiAgICAnRlJFRScsXHJcbiAgICAnRlJFU0VOSVVTJyxcclxuICAgICdGUkwnLFxyXG4gICAgJ0ZST0dBTlMnLFxyXG4gICAgJ0ZST05URE9PUicsXHJcbiAgICAnRlJPTlRJRVInLFxyXG4gICAgJ0ZUUicsXHJcbiAgICAnRlVKSVRTVScsXHJcbiAgICAnRlVKSVhFUk9YJyxcclxuICAgICdGVU4nLFxyXG4gICAgJ0ZVTkQnLFxyXG4gICAgJ0ZVUk5JVFVSRScsXHJcbiAgICAnRlVUQk9MJyxcclxuICAgICdGWUknLFxyXG4gICAgJ0dBJyxcclxuICAgICdHQUwnLFxyXG4gICAgJ0dBTExFUlknLFxyXG4gICAgJ0dBTExPJyxcclxuICAgICdHQUxMVVAnLFxyXG4gICAgJ0dBTUUnLFxyXG4gICAgJ0dBTUVTJyxcclxuICAgICdHQVAnLFxyXG4gICAgJ0dBUkRFTicsXHJcbiAgICAnR0InLFxyXG4gICAgJ0dCSVonLFxyXG4gICAgJ0dEJyxcclxuICAgICdHRE4nLFxyXG4gICAgJ0dFJyxcclxuICAgICdHRUEnLFxyXG4gICAgJ0dFTlQnLFxyXG4gICAgJ0dFTlRJTkcnLFxyXG4gICAgJ0dFT1JHRScsXHJcbiAgICAnR0YnLFxyXG4gICAgJ0dHJyxcclxuICAgICdHR0VFJyxcclxuICAgICdHSCcsXHJcbiAgICAnR0knLFxyXG4gICAgJ0dJRlQnLFxyXG4gICAgJ0dJRlRTJyxcclxuICAgICdHSVZFUycsXHJcbiAgICAnR0lWSU5HJyxcclxuICAgICdHTCcsXHJcbiAgICAnR0xBREUnLFxyXG4gICAgJ0dMQVNTJyxcclxuICAgICdHTEUnLFxyXG4gICAgJ0dMT0JBTCcsXHJcbiAgICAnR0xPQk8nLFxyXG4gICAgJ0dNJyxcclxuICAgICdHTUFJTCcsXHJcbiAgICAnR01CSCcsXHJcbiAgICAnR01PJyxcclxuICAgICdHTVgnLFxyXG4gICAgJ0dOJyxcclxuICAgICdHT0RBRERZJyxcclxuICAgICdHT0xEJyxcclxuICAgICdHT0xEUE9JTlQnLFxyXG4gICAgJ0dPTEYnLFxyXG4gICAgJ0dPTycsXHJcbiAgICAnR09PRFlFQVInLFxyXG4gICAgJ0dPT0cnLFxyXG4gICAgJ0dPT0dMRScsXHJcbiAgICAnR09QJyxcclxuICAgICdHT1QnLFxyXG4gICAgJ0dPVicsXHJcbiAgICAnR1AnLFxyXG4gICAgJ0dRJyxcclxuICAgICdHUicsXHJcbiAgICAnR1JBSU5HRVInLFxyXG4gICAgJ0dSQVBISUNTJyxcclxuICAgICdHUkFUSVMnLFxyXG4gICAgJ0dSRUVOJyxcclxuICAgICdHUklQRScsXHJcbiAgICAnR1JPQ0VSWScsXHJcbiAgICAnR1JPVVAnLFxyXG4gICAgJ0dTJyxcclxuICAgICdHVCcsXHJcbiAgICAnR1UnLFxyXG4gICAgJ0dVQVJESUFOJyxcclxuICAgICdHVUNDSScsXHJcbiAgICAnR1VHRScsXHJcbiAgICAnR1VJREUnLFxyXG4gICAgJ0dVSVRBUlMnLFxyXG4gICAgJ0dVUlUnLFxyXG4gICAgJ0dXJyxcclxuICAgICdHWScsXHJcbiAgICAnSEFJUicsXHJcbiAgICAnSEFNQlVSRycsXHJcbiAgICAnSEFOR09VVCcsXHJcbiAgICAnSEFVUycsXHJcbiAgICAnSEJPJyxcclxuICAgICdIREZDJyxcclxuICAgICdIREZDQkFOSycsXHJcbiAgICAnSEVBTFRIJyxcclxuICAgICdIRUFMVEhDQVJFJyxcclxuICAgICdIRUxQJyxcclxuICAgICdIRUxTSU5LSScsXHJcbiAgICAnSEVSRScsXHJcbiAgICAnSEVSTUVTJyxcclxuICAgICdIR1RWJyxcclxuICAgICdISVBIT1AnLFxyXG4gICAgJ0hJU0FNSVRTVScsXHJcbiAgICAnSElUQUNISScsXHJcbiAgICAnSElWJyxcclxuICAgICdISycsXHJcbiAgICAnSEtUJyxcclxuICAgICdITScsXHJcbiAgICAnSE4nLFxyXG4gICAgJ0hPQ0tFWScsXHJcbiAgICAnSE9MRElOR1MnLFxyXG4gICAgJ0hPTElEQVknLFxyXG4gICAgJ0hPTUVERVBPVCcsXHJcbiAgICAnSE9NRUdPT0RTJyxcclxuICAgICdIT01FUycsXHJcbiAgICAnSE9NRVNFTlNFJyxcclxuICAgICdIT05EQScsXHJcbiAgICAnSE9ORVlXRUxMJyxcclxuICAgICdIT1JTRScsXHJcbiAgICAnSE9TUElUQUwnLFxyXG4gICAgJ0hPU1QnLFxyXG4gICAgJ0hPU1RJTkcnLFxyXG4gICAgJ0hPVCcsXHJcbiAgICAnSE9URUxFUycsXHJcbiAgICAnSE9URUxTJyxcclxuICAgICdIT1RNQUlMJyxcclxuICAgICdIT1VTRScsXHJcbiAgICAnSE9XJyxcclxuICAgICdIUicsXHJcbiAgICAnSFNCQycsXHJcbiAgICAnSFQnLFxyXG4gICAgJ0hVJyxcclxuICAgICdIVUdIRVMnLFxyXG4gICAgJ0hZQVRUJyxcclxuICAgICdIWVVOREFJJyxcclxuICAgICdJQk0nLFxyXG4gICAgJ0lDQkMnLFxyXG4gICAgJ0lDRScsXHJcbiAgICAnSUNVJyxcclxuICAgICdJRCcsXHJcbiAgICAnSUUnLFxyXG4gICAgJ0lFRUUnLFxyXG4gICAgJ0lGTScsXHJcbiAgICAnSUtBTk8nLFxyXG4gICAgJ0lMJyxcclxuICAgICdJTScsXHJcbiAgICAnSU1BTUFUJyxcclxuICAgICdJTURCJyxcclxuICAgICdJTU1PJyxcclxuICAgICdJTU1PQklMSUVOJyxcclxuICAgICdJTicsXHJcbiAgICAnSU5DJyxcclxuICAgICdJTkRVU1RSSUVTJyxcclxuICAgICdJTkZJTklUSScsXHJcbiAgICAnSU5GTycsXHJcbiAgICAnSU5HJyxcclxuICAgICdJTksnLFxyXG4gICAgJ0lOU1RJVFVURScsXHJcbiAgICAnSU5TVVJBTkNFJyxcclxuICAgICdJTlNVUkUnLFxyXG4gICAgJ0lOVCcsXHJcbiAgICAnSU5URUwnLFxyXG4gICAgJ0lOVEVSTkFUSU9OQUwnLFxyXG4gICAgJ0lOVFVJVCcsXHJcbiAgICAnSU5WRVNUTUVOVFMnLFxyXG4gICAgJ0lPJyxcclxuICAgICdJUElSQU5HQScsXHJcbiAgICAnSVEnLFxyXG4gICAgJ0lSJyxcclxuICAgICdJUklTSCcsXHJcbiAgICAnSVMnLFxyXG4gICAgJ0lTRUxFQ1QnLFxyXG4gICAgJ0lTTUFJTEknLFxyXG4gICAgJ0lTVCcsXHJcbiAgICAnSVNUQU5CVUwnLFxyXG4gICAgJ0lUJyxcclxuICAgICdJVEFVJyxcclxuICAgICdJVFYnLFxyXG4gICAgJ0lWRUNPJyxcclxuICAgICdKQUdVQVInLFxyXG4gICAgJ0pBVkEnLFxyXG4gICAgJ0pDQicsXHJcbiAgICAnSkNQJyxcclxuICAgICdKRScsXHJcbiAgICAnSkVFUCcsXHJcbiAgICAnSkVUWlQnLFxyXG4gICAgJ0pFV0VMUlknLFxyXG4gICAgJ0pJTycsXHJcbiAgICAnSkxMJyxcclxuICAgICdKTScsXHJcbiAgICAnSk1QJyxcclxuICAgICdKTkonLFxyXG4gICAgJ0pPJyxcclxuICAgICdKT0JTJyxcclxuICAgICdKT0JVUkcnLFxyXG4gICAgJ0pPVCcsXHJcbiAgICAnSk9ZJyxcclxuICAgICdKUCcsXHJcbiAgICAnSlBNT1JHQU4nLFxyXG4gICAgJ0pQUlMnLFxyXG4gICAgJ0pVRUdPUycsXHJcbiAgICAnSlVOSVBFUicsXHJcbiAgICAnS0FVRkVOJyxcclxuICAgICdLRERJJyxcclxuICAgICdLRScsXHJcbiAgICAnS0VSUllIT1RFTFMnLFxyXG4gICAgJ0tFUlJZTE9HSVNUSUNTJyxcclxuICAgICdLRVJSWVBST1BFUlRJRVMnLFxyXG4gICAgJ0tGSCcsXHJcbiAgICAnS0cnLFxyXG4gICAgJ0tIJyxcclxuICAgICdLSScsXHJcbiAgICAnS0lBJyxcclxuICAgICdLSU0nLFxyXG4gICAgJ0tJTkRFUicsXHJcbiAgICAnS0lORExFJyxcclxuICAgICdLSVRDSEVOJyxcclxuICAgICdLSVdJJyxcclxuICAgICdLTScsXHJcbiAgICAnS04nLFxyXG4gICAgJ0tPRUxOJyxcclxuICAgICdLT01BVFNVJyxcclxuICAgICdLT1NIRVInLFxyXG4gICAgJ0tQJyxcclxuICAgICdLUE1HJyxcclxuICAgICdLUE4nLFxyXG4gICAgJ0tSJyxcclxuICAgICdLUkQnLFxyXG4gICAgJ0tSRUQnLFxyXG4gICAgJ0tVT0tHUk9VUCcsXHJcbiAgICAnS1cnLFxyXG4gICAgJ0tZJyxcclxuICAgICdLWU9UTycsXHJcbiAgICAnS1onLFxyXG4gICAgJ0xBJyxcclxuICAgICdMQUNBSVhBJyxcclxuICAgICdMQURCUk9LRVMnLFxyXG4gICAgJ0xBTUJPUkdISU5JJyxcclxuICAgICdMQU1FUicsXHJcbiAgICAnTEFOQ0FTVEVSJyxcclxuICAgICdMQU5DSUEnLFxyXG4gICAgJ0xBTkNPTUUnLFxyXG4gICAgJ0xBTkQnLFxyXG4gICAgJ0xBTkRST1ZFUicsXHJcbiAgICAnTEFOWEVTUycsXHJcbiAgICAnTEFTQUxMRScsXHJcbiAgICAnTEFUJyxcclxuICAgICdMQVRJTk8nLFxyXG4gICAgJ0xBVFJPQkUnLFxyXG4gICAgJ0xBVycsXHJcbiAgICAnTEFXWUVSJyxcclxuICAgICdMQicsXHJcbiAgICAnTEMnLFxyXG4gICAgJ0xEUycsXHJcbiAgICAnTEVBU0UnLFxyXG4gICAgJ0xFQ0xFUkMnLFxyXG4gICAgJ0xFRlJBSycsXHJcbiAgICAnTEVHQUwnLFxyXG4gICAgJ0xFR08nLFxyXG4gICAgJ0xFWFVTJyxcclxuICAgICdMR0JUJyxcclxuICAgICdMSScsXHJcbiAgICAnTElBSVNPTicsXHJcbiAgICAnTElETCcsXHJcbiAgICAnTElGRScsXHJcbiAgICAnTElGRUlOU1VSQU5DRScsXHJcbiAgICAnTElGRVNUWUxFJyxcclxuICAgICdMSUdIVElORycsXHJcbiAgICAnTElLRScsXHJcbiAgICAnTElMTFknLFxyXG4gICAgJ0xJTUlURUQnLFxyXG4gICAgJ0xJTU8nLFxyXG4gICAgJ0xJTkNPTE4nLFxyXG4gICAgJ0xJTkRFJyxcclxuICAgICdMSU5LJyxcclxuICAgICdMSVBTWScsXHJcbiAgICAnTElWRScsXHJcbiAgICAnTElWSU5HJyxcclxuICAgICdMSVhJTCcsXHJcbiAgICAnTEsnLFxyXG4gICAgJ0xMQycsXHJcbiAgICAnTE9BTicsXHJcbiAgICAnTE9BTlMnLFxyXG4gICAgJ0xPQ0tFUicsXHJcbiAgICAnTE9DVVMnLFxyXG4gICAgJ0xPRlQnLFxyXG4gICAgJ0xPTCcsXHJcbiAgICAnTE9ORE9OJyxcclxuICAgICdMT1RURScsXHJcbiAgICAnTE9UVE8nLFxyXG4gICAgJ0xPVkUnLFxyXG4gICAgJ0xQTCcsXHJcbiAgICAnTFBMRklOQU5DSUFMJyxcclxuICAgICdMUicsXHJcbiAgICAnTFMnLFxyXG4gICAgJ0xUJyxcclxuICAgICdMVEQnLFxyXG4gICAgJ0xUREEnLFxyXG4gICAgJ0xVJyxcclxuICAgICdMVU5EQkVDSycsXHJcbiAgICAnTFVQSU4nLFxyXG4gICAgJ0xVWEUnLFxyXG4gICAgJ0xVWFVSWScsXHJcbiAgICAnTFYnLFxyXG4gICAgJ0xZJyxcclxuICAgICdNQScsXHJcbiAgICAnTUFDWVMnLFxyXG4gICAgJ01BRFJJRCcsXHJcbiAgICAnTUFJRicsXHJcbiAgICAnTUFJU09OJyxcclxuICAgICdNQUtFVVAnLFxyXG4gICAgJ01BTicsXHJcbiAgICAnTUFOQUdFTUVOVCcsXHJcbiAgICAnTUFOR08nLFxyXG4gICAgJ01BUCcsXHJcbiAgICAnTUFSS0VUJyxcclxuICAgICdNQVJLRVRJTkcnLFxyXG4gICAgJ01BUktFVFMnLFxyXG4gICAgJ01BUlJJT1RUJyxcclxuICAgICdNQVJTSEFMTFMnLFxyXG4gICAgJ01BU0VSQVRJJyxcclxuICAgICdNQVRURUwnLFxyXG4gICAgJ01CQScsXHJcbiAgICAnTUMnLFxyXG4gICAgJ01DS0lOU0VZJyxcclxuICAgICdNRCcsXHJcbiAgICAnTUUnLFxyXG4gICAgJ01FRCcsXHJcbiAgICAnTUVESUEnLFxyXG4gICAgJ01FRVQnLFxyXG4gICAgJ01FTEJPVVJORScsXHJcbiAgICAnTUVNRScsXHJcbiAgICAnTUVNT1JJQUwnLFxyXG4gICAgJ01FTicsXHJcbiAgICAnTUVOVScsXHJcbiAgICAnTUVSQ0tNU0QnLFxyXG4gICAgJ01FVExJRkUnLFxyXG4gICAgJ01HJyxcclxuICAgICdNSCcsXHJcbiAgICAnTUlBTUknLFxyXG4gICAgJ01JQ1JPU09GVCcsXHJcbiAgICAnTUlMJyxcclxuICAgICdNSU5JJyxcclxuICAgICdNSU5UJyxcclxuICAgICdNSVQnLFxyXG4gICAgJ01JVFNVQklTSEknLFxyXG4gICAgJ01LJyxcclxuICAgICdNTCcsXHJcbiAgICAnTUxCJyxcclxuICAgICdNTFMnLFxyXG4gICAgJ01NJyxcclxuICAgICdNTUEnLFxyXG4gICAgJ01OJyxcclxuICAgICdNTycsXHJcbiAgICAnTU9CSScsXHJcbiAgICAnTU9CSUxFJyxcclxuICAgICdNT0JJTFknLFxyXG4gICAgJ01PREEnLFxyXG4gICAgJ01PRScsXHJcbiAgICAnTU9JJyxcclxuICAgICdNT00nLFxyXG4gICAgJ01PTkFTSCcsXHJcbiAgICAnTU9ORVknLFxyXG4gICAgJ01PTlNURVInLFxyXG4gICAgJ01PUEFSJyxcclxuICAgICdNT1JNT04nLFxyXG4gICAgJ01PUlRHQUdFJyxcclxuICAgICdNT1NDT1cnLFxyXG4gICAgJ01PVE8nLFxyXG4gICAgJ01PVE9SQ1lDTEVTJyxcclxuICAgICdNT1YnLFxyXG4gICAgJ01PVklFJyxcclxuICAgICdNT1ZJU1RBUicsXHJcbiAgICAnTVAnLFxyXG4gICAgJ01RJyxcclxuICAgICdNUicsXHJcbiAgICAnTVMnLFxyXG4gICAgJ01TRCcsXHJcbiAgICAnTVQnLFxyXG4gICAgJ01UTicsXHJcbiAgICAnTVRSJyxcclxuICAgICdNVScsXHJcbiAgICAnTVVTRVVNJyxcclxuICAgICdNVVRVQUwnLFxyXG4gICAgJ01WJyxcclxuICAgICdNVycsXHJcbiAgICAnTVgnLFxyXG4gICAgJ01ZJyxcclxuICAgICdNWicsXHJcbiAgICAnTkEnLFxyXG4gICAgJ05BQicsXHJcbiAgICAnTkFERVgnLFxyXG4gICAgJ05BR09ZQScsXHJcbiAgICAnTkFNRScsXHJcbiAgICAnTkFUSU9OV0lERScsXHJcbiAgICAnTkFUVVJBJyxcclxuICAgICdOQVZZJyxcclxuICAgICdOQkEnLFxyXG4gICAgJ05DJyxcclxuICAgICdORScsXHJcbiAgICAnTkVDJyxcclxuICAgICdORVQnLFxyXG4gICAgJ05FVEJBTksnLFxyXG4gICAgJ05FVEZMSVgnLFxyXG4gICAgJ05FVFdPUksnLFxyXG4gICAgJ05FVVNUQVInLFxyXG4gICAgJ05FVycsXHJcbiAgICAnTkVXSE9MTEFORCcsXHJcbiAgICAnTkVXUycsXHJcbiAgICAnTkVYVCcsXHJcbiAgICAnTkVYVERJUkVDVCcsXHJcbiAgICAnTkVYVVMnLFxyXG4gICAgJ05GJyxcclxuICAgICdORkwnLFxyXG4gICAgJ05HJyxcclxuICAgICdOR08nLFxyXG4gICAgJ05ISycsXHJcbiAgICAnTkknLFxyXG4gICAgJ05JQ08nLFxyXG4gICAgJ05JS0UnLFxyXG4gICAgJ05JS09OJyxcclxuICAgICdOSU5KQScsXHJcbiAgICAnTklTU0FOJyxcclxuICAgICdOSVNTQVknLFxyXG4gICAgJ05MJyxcclxuICAgICdOTycsXHJcbiAgICAnTk9LSUEnLFxyXG4gICAgJ05PUlRIV0VTVEVSTk1VVFVBTCcsXHJcbiAgICAnTk9SVE9OJyxcclxuICAgICdOT1cnLFxyXG4gICAgJ05PV1JVWicsXHJcbiAgICAnTk9XVFYnLFxyXG4gICAgJ05QJyxcclxuICAgICdOUicsXHJcbiAgICAnTlJBJyxcclxuICAgICdOUlcnLFxyXG4gICAgJ05UVCcsXHJcbiAgICAnTlUnLFxyXG4gICAgJ05ZQycsXHJcbiAgICAnTlonLFxyXG4gICAgJ09CSScsXHJcbiAgICAnT0JTRVJWRVInLFxyXG4gICAgJ09GRicsXHJcbiAgICAnT0ZGSUNFJyxcclxuICAgICdPS0lOQVdBJyxcclxuICAgICdPTEFZQU4nLFxyXG4gICAgJ09MQVlBTkdST1VQJyxcclxuICAgICdPTEROQVZZJyxcclxuICAgICdPTExPJyxcclxuICAgICdPTScsXHJcbiAgICAnT01FR0EnLFxyXG4gICAgJ09ORScsXHJcbiAgICAnT05HJyxcclxuICAgICdPTkwnLFxyXG4gICAgJ09OTElORScsXHJcbiAgICAnT05ZT1VSU0lERScsXHJcbiAgICAnT09PJyxcclxuICAgICdPUEVOJyxcclxuICAgICdPUkFDTEUnLFxyXG4gICAgJ09SQU5HRScsXHJcbiAgICAnT1JHJyxcclxuICAgICdPUkdBTklDJyxcclxuICAgICdPUklHSU5TJyxcclxuICAgICdPU0FLQScsXHJcbiAgICAnT1RTVUtBJyxcclxuICAgICdPVFQnLFxyXG4gICAgJ09WSCcsXHJcbiAgICAnUEEnLFxyXG4gICAgJ1BBR0UnLFxyXG4gICAgJ1BBTkFTT05JQycsXHJcbiAgICAnUEFSSVMnLFxyXG4gICAgJ1BBUlMnLFxyXG4gICAgJ1BBUlRORVJTJyxcclxuICAgICdQQVJUUycsXHJcbiAgICAnUEFSVFknLFxyXG4gICAgJ1BBU1NBR0VOUycsXHJcbiAgICAnUEFZJyxcclxuICAgICdQQ0NXJyxcclxuICAgICdQRScsXHJcbiAgICAnUEVUJyxcclxuICAgICdQRicsXHJcbiAgICAnUEZJWkVSJyxcclxuICAgICdQRycsXHJcbiAgICAnUEgnLFxyXG4gICAgJ1BIQVJNQUNZJyxcclxuICAgICdQSEQnLFxyXG4gICAgJ1BISUxJUFMnLFxyXG4gICAgJ1BIT05FJyxcclxuICAgICdQSE9UTycsXHJcbiAgICAnUEhPVE9HUkFQSFknLFxyXG4gICAgJ1BIT1RPUycsXHJcbiAgICAnUEhZU0lPJyxcclxuICAgICdQSUFHRVQnLFxyXG4gICAgJ1BJQ1MnLFxyXG4gICAgJ1BJQ1RFVCcsXHJcbiAgICAnUElDVFVSRVMnLFxyXG4gICAgJ1BJRCcsXHJcbiAgICAnUElOJyxcclxuICAgICdQSU5HJyxcclxuICAgICdQSU5LJyxcclxuICAgICdQSU9ORUVSJyxcclxuICAgICdQSVpaQScsXHJcbiAgICAnUEsnLFxyXG4gICAgJ1BMJyxcclxuICAgICdQTEFDRScsXHJcbiAgICAnUExBWScsXHJcbiAgICAnUExBWVNUQVRJT04nLFxyXG4gICAgJ1BMVU1CSU5HJyxcclxuICAgICdQTFVTJyxcclxuICAgICdQTScsXHJcbiAgICAnUE4nLFxyXG4gICAgJ1BOQycsXHJcbiAgICAnUE9ITCcsXHJcbiAgICAnUE9LRVInLFxyXG4gICAgJ1BPTElUSUUnLFxyXG4gICAgJ1BPUk4nLFxyXG4gICAgJ1BPU1QnLFxyXG4gICAgJ1BSJyxcclxuICAgICdQUkFNRVJJQ0EnLFxyXG4gICAgJ1BSQVhJJyxcclxuICAgICdQUkVTUycsXHJcbiAgICAnUFJJTUUnLFxyXG4gICAgJ1BSTycsXHJcbiAgICAnUFJPRCcsXHJcbiAgICAnUFJPRFVDVElPTlMnLFxyXG4gICAgJ1BST0YnLFxyXG4gICAgJ1BST0dSRVNTSVZFJyxcclxuICAgICdQUk9NTycsXHJcbiAgICAnUFJPUEVSVElFUycsXHJcbiAgICAnUFJPUEVSVFknLFxyXG4gICAgJ1BST1RFQ1RJT04nLFxyXG4gICAgJ1BSVScsXHJcbiAgICAnUFJVREVOVElBTCcsXHJcbiAgICAnUFMnLFxyXG4gICAgJ1BUJyxcclxuICAgICdQVUInLFxyXG4gICAgJ1BXJyxcclxuICAgICdQV0MnLFxyXG4gICAgJ1BZJyxcclxuICAgICdRQScsXHJcbiAgICAnUVBPTicsXHJcbiAgICAnUVVFQkVDJyxcclxuICAgICdRVUVTVCcsXHJcbiAgICAnUVZDJyxcclxuICAgICdSQUNJTkcnLFxyXG4gICAgJ1JBRElPJyxcclxuICAgICdSQUlEJyxcclxuICAgICdSRScsXHJcbiAgICAnUkVBRCcsXHJcbiAgICAnUkVBTEVTVEFURScsXHJcbiAgICAnUkVBTFRPUicsXHJcbiAgICAnUkVBTFRZJyxcclxuICAgICdSRUNJUEVTJyxcclxuICAgICdSRUQnLFxyXG4gICAgJ1JFRFNUT05FJyxcclxuICAgICdSRURVTUJSRUxMQScsXHJcbiAgICAnUkVIQUInLFxyXG4gICAgJ1JFSVNFJyxcclxuICAgICdSRUlTRU4nLFxyXG4gICAgJ1JFSVQnLFxyXG4gICAgJ1JFTElBTkNFJyxcclxuICAgICdSRU4nLFxyXG4gICAgJ1JFTlQnLFxyXG4gICAgJ1JFTlRBTFMnLFxyXG4gICAgJ1JFUEFJUicsXHJcbiAgICAnUkVQT1JUJyxcclxuICAgICdSRVBVQkxJQ0FOJyxcclxuICAgICdSRVNUJyxcclxuICAgICdSRVNUQVVSQU5UJyxcclxuICAgICdSRVZJRVcnLFxyXG4gICAgJ1JFVklFV1MnLFxyXG4gICAgJ1JFWFJPVEgnLFxyXG4gICAgJ1JJQ0gnLFxyXG4gICAgJ1JJQ0hBUkRMSScsXHJcbiAgICAnUklDT0gnLFxyXG4gICAgJ1JJR0hUQVRIT01FJyxcclxuICAgICdSSUwnLFxyXG4gICAgJ1JJTycsXHJcbiAgICAnUklQJyxcclxuICAgICdSTUlUJyxcclxuICAgICdSTycsXHJcbiAgICAnUk9DSEVSJyxcclxuICAgICdST0NLUycsXHJcbiAgICAnUk9ERU8nLFxyXG4gICAgJ1JPR0VSUycsXHJcbiAgICAnUk9PTScsXHJcbiAgICAnUlMnLFxyXG4gICAgJ1JTVlAnLFxyXG4gICAgJ1JVJyxcclxuICAgICdSVUdCWScsXHJcbiAgICAnUlVIUicsXHJcbiAgICAnUlVOJyxcclxuICAgICdSVycsXHJcbiAgICAnUldFJyxcclxuICAgICdSWVVLWVUnLFxyXG4gICAgJ1NBJyxcclxuICAgICdTQUFSTEFORCcsXHJcbiAgICAnU0FGRScsXHJcbiAgICAnU0FGRVRZJyxcclxuICAgICdTQUtVUkEnLFxyXG4gICAgJ1NBTEUnLFxyXG4gICAgJ1NBTE9OJyxcclxuICAgICdTQU1TQ0xVQicsXHJcbiAgICAnU0FNU1VORycsXHJcbiAgICAnU0FORFZJSycsXHJcbiAgICAnU0FORFZJS0NPUk9NQU5UJyxcclxuICAgICdTQU5PRkknLFxyXG4gICAgJ1NBUCcsXHJcbiAgICAnU0FSTCcsXHJcbiAgICAnU0FTJyxcclxuICAgICdTQVZFJyxcclxuICAgICdTQVhPJyxcclxuICAgICdTQicsXHJcbiAgICAnU0JJJyxcclxuICAgICdTQlMnLFxyXG4gICAgJ1NDJyxcclxuICAgICdTQ0EnLFxyXG4gICAgJ1NDQicsXHJcbiAgICAnU0NIQUVGRkxFUicsXHJcbiAgICAnU0NITUlEVCcsXHJcbiAgICAnU0NIT0xBUlNISVBTJyxcclxuICAgICdTQ0hPT0wnLFxyXG4gICAgJ1NDSFVMRScsXHJcbiAgICAnU0NIV0FSWicsXHJcbiAgICAnU0NJRU5DRScsXHJcbiAgICAnU0NKT0hOU09OJyxcclxuICAgICdTQ09SJyxcclxuICAgICdTQ09UJyxcclxuICAgICdTRCcsXHJcbiAgICAnU0UnLFxyXG4gICAgJ1NFQVJDSCcsXHJcbiAgICAnU0VBVCcsXHJcbiAgICAnU0VDVVJFJyxcclxuICAgICdTRUNVUklUWScsXHJcbiAgICAnU0VFSycsXHJcbiAgICAnU0VMRUNUJyxcclxuICAgICdTRU5FUicsXHJcbiAgICAnU0VSVklDRVMnLFxyXG4gICAgJ1NFUycsXHJcbiAgICAnU0VWRU4nLFxyXG4gICAgJ1NFVycsXHJcbiAgICAnU0VYJyxcclxuICAgICdTRVhZJyxcclxuICAgICdTRlInLFxyXG4gICAgJ1NHJyxcclxuICAgICdTSCcsXHJcbiAgICAnU0hBTkdSSUxBJyxcclxuICAgICdTSEFSUCcsXHJcbiAgICAnU0hBVycsXHJcbiAgICAnU0hFTEwnLFxyXG4gICAgJ1NISUEnLFxyXG4gICAgJ1NISUtTSEEnLFxyXG4gICAgJ1NIT0VTJyxcclxuICAgICdTSE9QJyxcclxuICAgICdTSE9QUElORycsXHJcbiAgICAnU0hPVUpJJyxcclxuICAgICdTSE9XJyxcclxuICAgICdTSE9XVElNRScsXHJcbiAgICAnU0hSSVJBTScsXHJcbiAgICAnU0knLFxyXG4gICAgJ1NJTEsnLFxyXG4gICAgJ1NJTkEnLFxyXG4gICAgJ1NJTkdMRVMnLFxyXG4gICAgJ1NJVEUnLFxyXG4gICAgJ1NKJyxcclxuICAgICdTSycsXHJcbiAgICAnU0tJJyxcclxuICAgICdTS0lOJyxcclxuICAgICdTS1knLFxyXG4gICAgJ1NLWVBFJyxcclxuICAgICdTTCcsXHJcbiAgICAnU0xJTkcnLFxyXG4gICAgJ1NNJyxcclxuICAgICdTTUFSVCcsXHJcbiAgICAnU01JTEUnLFxyXG4gICAgJ1NOJyxcclxuICAgICdTTkNGJyxcclxuICAgICdTTycsXHJcbiAgICAnU09DQ0VSJyxcclxuICAgICdTT0NJQUwnLFxyXG4gICAgJ1NPRlRCQU5LJyxcclxuICAgICdTT0ZUV0FSRScsXHJcbiAgICAnU09IVScsXHJcbiAgICAnU09MQVInLFxyXG4gICAgJ1NPTFVUSU9OUycsXHJcbiAgICAnU09ORycsXHJcbiAgICAnU09OWScsXHJcbiAgICAnU09ZJyxcclxuICAgICdTUEFDRScsXHJcbiAgICAnU1BPUlQnLFxyXG4gICAgJ1NQT1QnLFxyXG4gICAgJ1NQUkVBREJFVFRJTkcnLFxyXG4gICAgJ1NSJyxcclxuICAgICdTUkwnLFxyXG4gICAgJ1NSVCcsXHJcbiAgICAnU1MnLFxyXG4gICAgJ1NUJyxcclxuICAgICdTVEFEQScsXHJcbiAgICAnU1RBUExFUycsXHJcbiAgICAnU1RBUicsXHJcbiAgICAnU1RBUkhVQicsXHJcbiAgICAnU1RBVEVCQU5LJyxcclxuICAgICdTVEFURUZBUk0nLFxyXG4gICAgJ1NUQycsXHJcbiAgICAnU1RDR1JPVVAnLFxyXG4gICAgJ1NUT0NLSE9MTScsXHJcbiAgICAnU1RPUkFHRScsXHJcbiAgICAnU1RPUkUnLFxyXG4gICAgJ1NUUkVBTScsXHJcbiAgICAnU1RVRElPJyxcclxuICAgICdTVFVEWScsXHJcbiAgICAnU1RZTEUnLFxyXG4gICAgJ1NVJyxcclxuICAgICdTVUNLUycsXHJcbiAgICAnU1VQUExJRVMnLFxyXG4gICAgJ1NVUFBMWScsXHJcbiAgICAnU1VQUE9SVCcsXHJcbiAgICAnU1VSRicsXHJcbiAgICAnU1VSR0VSWScsXHJcbiAgICAnU1VaVUtJJyxcclxuICAgICdTVicsXHJcbiAgICAnU1dBVENIJyxcclxuICAgICdTV0lGVENPVkVSJyxcclxuICAgICdTV0lTUycsXHJcbiAgICAnU1gnLFxyXG4gICAgJ1NZJyxcclxuICAgICdTWURORVknLFxyXG4gICAgJ1NZTUFOVEVDJyxcclxuICAgICdTWVNURU1TJyxcclxuICAgICdTWicsXHJcbiAgICAnVEFCJyxcclxuICAgICdUQUlQRUknLFxyXG4gICAgJ1RBTEsnLFxyXG4gICAgJ1RBT0JBTycsXHJcbiAgICAnVEFSR0VUJyxcclxuICAgICdUQVRBTU9UT1JTJyxcclxuICAgICdUQVRBUicsXHJcbiAgICAnVEFUVE9PJyxcclxuICAgICdUQVgnLFxyXG4gICAgJ1RBWEknLFxyXG4gICAgJ1RDJyxcclxuICAgICdUQ0knLFxyXG4gICAgJ1REJyxcclxuICAgICdUREsnLFxyXG4gICAgJ1RFQU0nLFxyXG4gICAgJ1RFQ0gnLFxyXG4gICAgJ1RFQ0hOT0xPR1knLFxyXG4gICAgJ1RFTCcsXHJcbiAgICAnVEVMRUZPTklDQScsXHJcbiAgICAnVEVNQVNFSycsXHJcbiAgICAnVEVOTklTJyxcclxuICAgICdURVZBJyxcclxuICAgICdURicsXHJcbiAgICAnVEcnLFxyXG4gICAgJ1RIJyxcclxuICAgICdUSEQnLFxyXG4gICAgJ1RIRUFURVInLFxyXG4gICAgJ1RIRUFUUkUnLFxyXG4gICAgJ1RJQUEnLFxyXG4gICAgJ1RJQ0tFVFMnLFxyXG4gICAgJ1RJRU5EQScsXHJcbiAgICAnVElGRkFOWScsXHJcbiAgICAnVElQUycsXHJcbiAgICAnVElSRVMnLFxyXG4gICAgJ1RJUk9MJyxcclxuICAgICdUSicsXHJcbiAgICAnVEpNQVhYJyxcclxuICAgICdUSlgnLFxyXG4gICAgJ1RLJyxcclxuICAgICdUS01BWFgnLFxyXG4gICAgJ1RMJyxcclxuICAgICdUTScsXHJcbiAgICAnVE1BTEwnLFxyXG4gICAgJ1ROJyxcclxuICAgICdUTycsXHJcbiAgICAnVE9EQVknLFxyXG4gICAgJ1RPS1lPJyxcclxuICAgICdUT09MUycsXHJcbiAgICAnVE9QJyxcclxuICAgICdUT1JBWScsXHJcbiAgICAnVE9TSElCQScsXHJcbiAgICAnVE9UQUwnLFxyXG4gICAgJ1RPVVJTJyxcclxuICAgICdUT1dOJyxcclxuICAgICdUT1lPVEEnLFxyXG4gICAgJ1RPWVMnLFxyXG4gICAgJ1RSJyxcclxuICAgICdUUkFERScsXHJcbiAgICAnVFJBRElORycsXHJcbiAgICAnVFJBSU5JTkcnLFxyXG4gICAgJ1RSQVZFTCcsXHJcbiAgICAnVFJBVkVMQ0hBTk5FTCcsXHJcbiAgICAnVFJBVkVMRVJTJyxcclxuICAgICdUUkFWRUxFUlNJTlNVUkFOQ0UnLFxyXG4gICAgJ1RSVVNUJyxcclxuICAgICdUUlYnLFxyXG4gICAgJ1RUJyxcclxuICAgICdUVUJFJyxcclxuICAgICdUVUknLFxyXG4gICAgJ1RVTkVTJyxcclxuICAgICdUVVNIVScsXHJcbiAgICAnVFYnLFxyXG4gICAgJ1RWUycsXHJcbiAgICAnVFcnLFxyXG4gICAgJ1RaJyxcclxuICAgICdVQScsXHJcbiAgICAnVUJBTksnLFxyXG4gICAgJ1VCUycsXHJcbiAgICAnVUNPTk5FQ1QnLFxyXG4gICAgJ1VHJyxcclxuICAgICdVSycsXHJcbiAgICAnVU5JQ09NJyxcclxuICAgICdVTklWRVJTSVRZJyxcclxuICAgICdVTk8nLFxyXG4gICAgJ1VPTCcsXHJcbiAgICAnVVBTJyxcclxuICAgICdVUycsXHJcbiAgICAnVVknLFxyXG4gICAgJ1VaJyxcclxuICAgICdWQScsXHJcbiAgICAnVkFDQVRJT05TJyxcclxuICAgICdWQU5BJyxcclxuICAgICdWQU5HVUFSRCcsXHJcbiAgICAnVkMnLFxyXG4gICAgJ1ZFJyxcclxuICAgICdWRUdBUycsXHJcbiAgICAnVkVOVFVSRVMnLFxyXG4gICAgJ1ZFUklTSUdOJyxcclxuICAgICdWRVJTSUNIRVJVTkcnLFxyXG4gICAgJ1ZFVCcsXHJcbiAgICAnVkcnLFxyXG4gICAgJ1ZJJyxcclxuICAgICdWSUFKRVMnLFxyXG4gICAgJ1ZJREVPJyxcclxuICAgICdWSUcnLFxyXG4gICAgJ1ZJS0lORycsXHJcbiAgICAnVklMTEFTJyxcclxuICAgICdWSU4nLFxyXG4gICAgJ1ZJUCcsXHJcbiAgICAnVklSR0lOJyxcclxuICAgICdWSVNBJyxcclxuICAgICdWSVNJT04nLFxyXG4gICAgJ1ZJU1RBUFJJTlQnLFxyXG4gICAgJ1ZJVkEnLFxyXG4gICAgJ1ZJVk8nLFxyXG4gICAgJ1ZMQUFOREVSRU4nLFxyXG4gICAgJ1ZOJyxcclxuICAgICdWT0RLQScsXHJcbiAgICAnVk9MS1NXQUdFTicsXHJcbiAgICAnVk9MVk8nLFxyXG4gICAgJ1ZPVEUnLFxyXG4gICAgJ1ZPVElORycsXHJcbiAgICAnVk9UTycsXHJcbiAgICAnVk9ZQUdFJyxcclxuICAgICdWVScsXHJcbiAgICAnVlVFTE9TJyxcclxuICAgICdXQUxFUycsXHJcbiAgICAnV0FMTUFSVCcsXHJcbiAgICAnV0FMVEVSJyxcclxuICAgICdXQU5HJyxcclxuICAgICdXQU5HR09VJyxcclxuICAgICdXQVJNQU4nLFxyXG4gICAgJ1dBVENIJyxcclxuICAgICdXQVRDSEVTJyxcclxuICAgICdXRUFUSEVSJyxcclxuICAgICdXRUFUSEVSQ0hBTk5FTCcsXHJcbiAgICAnV0VCQ0FNJyxcclxuICAgICdXRUJFUicsXHJcbiAgICAnV0VCU0lURScsXHJcbiAgICAnV0VEJyxcclxuICAgICdXRURESU5HJyxcclxuICAgICdXRUlCTycsXHJcbiAgICAnV0VJUicsXHJcbiAgICAnV0YnLFxyXG4gICAgJ1dIT1NXSE8nLFxyXG4gICAgJ1dJRU4nLFxyXG4gICAgJ1dJS0knLFxyXG4gICAgJ1dJTExJQU1ISUxMJyxcclxuICAgICdXSU4nLFxyXG4gICAgJ1dJTkRPV1MnLFxyXG4gICAgJ1dJTkUnLFxyXG4gICAgJ1dJTk5FUlMnLFxyXG4gICAgJ1dNRScsXHJcbiAgICAnV09MVEVSU0tMVVdFUicsXHJcbiAgICAnV09PRFNJREUnLFxyXG4gICAgJ1dPUksnLFxyXG4gICAgJ1dPUktTJyxcclxuICAgICdXT1JMRCcsXHJcbiAgICAnV09XJyxcclxuICAgICdXUycsXHJcbiAgICAnV1RDJyxcclxuICAgICdXVEYnLFxyXG4gICAgJ1hCT1gnLFxyXG4gICAgJ1hFUk9YJyxcclxuICAgICdYRklOSVRZJyxcclxuICAgICdYSUhVQU4nLFxyXG4gICAgJ1hJTicsXHJcbiAgICAnWE4tLTExQjRDM0QnLFxyXG4gICAgJ1hOLS0xQ0syRTFCJyxcclxuICAgICdYTi0tMVFRVzIzQScsXHJcbiAgICAnWE4tLTJTQ1JKOUMnLFxyXG4gICAgJ1hOLS0zMFJSN1knLFxyXG4gICAgJ1hOLS0zQlNUMDBNJyxcclxuICAgICdYTi0tM0RTNDQzRycsXHJcbiAgICAnWE4tLTNFMEI3MDdFJyxcclxuICAgICdYTi0tM0hDUko5QycsXHJcbiAgICAnWE4tLTNPUTE4Vkw4UE4zNkEnLFxyXG4gICAgJ1hOLS0zUFhVOEsnLFxyXG4gICAgJ1hOLS00MkMyRDlBJyxcclxuICAgICdYTi0tNDVCUjVDWUwnLFxyXG4gICAgJ1hOLS00NUJSSjlDJyxcclxuICAgICdYTi0tNDVRMTFDJyxcclxuICAgICdYTi0tNEdCUklNJyxcclxuICAgICdYTi0tNTRCN0ZUQTBDQycsXHJcbiAgICAnWE4tLTU1UVc0MkcnLFxyXG4gICAgJ1hOLS01NVFYNUQnLFxyXG4gICAgJ1hOLS01U1UzNEo5MzZCR1NHJyxcclxuICAgICdYTi0tNVRaTTVHJyxcclxuICAgICdYTi0tNkZSWjgyRycsXHJcbiAgICAnWE4tLTZRUTk4NkIzWEwnLFxyXG4gICAgJ1hOLS04MEFEWEhLUycsXHJcbiAgICAnWE4tLTgwQU8yMUEnLFxyXG4gICAgJ1hOLS04MEFRRUNEUjFBJyxcclxuICAgICdYTi0tODBBU0VIREInLFxyXG4gICAgJ1hOLS04MEFTV0cnLFxyXG4gICAgJ1hOLS04WTBBMDYzQScsXHJcbiAgICAnWE4tLTkwQTNBQycsXHJcbiAgICAnWE4tLTkwQUUnLFxyXG4gICAgJ1hOLS05MEFJUycsXHJcbiAgICAnWE4tLTlEQlEyQScsXHJcbiAgICAnWE4tLTlFVDUyVScsXHJcbiAgICAnWE4tLTlLUlQwMEEnLFxyXG4gICAgJ1hOLS1CNFc2MDVGRVJEJyxcclxuICAgICdYTi0tQkNLMUI5QTVEUkU0QycsXHJcbiAgICAnWE4tLUMxQVZHJyxcclxuICAgICdYTi0tQzJCUjdHJyxcclxuICAgICdYTi0tQ0NLMkIzQicsXHJcbiAgICAnWE4tLUNHNEJLSScsXHJcbiAgICAnWE4tLUNMQ0hDMEVBMEIyRzJBOUdDRCcsXHJcbiAgICAnWE4tLUNaUjY5NEInLFxyXG4gICAgJ1hOLS1DWlJTMFQnLFxyXG4gICAgJ1hOLS1DWlJVMkQnLFxyXG4gICAgJ1hOLS1EMUFDSjNCJyxcclxuICAgICdYTi0tRDFBTEYnLFxyXG4gICAgJ1hOLS1FMUE0QycsXHJcbiAgICAnWE4tLUVDS1ZEVEM5RCcsXHJcbiAgICAnWE4tLUVGVlk4OEgnLFxyXG4gICAgJ1hOLS1FU1RWNzVHJyxcclxuICAgICdYTi0tRkNUNDI5SycsXHJcbiAgICAnWE4tLUZIQkVJJyxcclxuICAgICdYTi0tRklRMjI4QzVIUycsXHJcbiAgICAnWE4tLUZJUTY0QicsXHJcbiAgICAnWE4tLUZJUVM4UycsXHJcbiAgICAnWE4tLUZJUVo5UycsXHJcbiAgICAnWE4tLUZKUTcyMEEnLFxyXG4gICAgJ1hOLS1GTFczNTFFJyxcclxuICAgICdYTi0tRlBDUko5QzNEJyxcclxuICAgICdYTi0tRlpDMkM5RTJDJyxcclxuICAgICdYTi0tRlpZUzhENjlVVkdNJyxcclxuICAgICdYTi0tRzJYWDQ4QycsXHJcbiAgICAnWE4tLUdDS1IzRjBGJyxcclxuICAgICdYTi0tR0VDUko5QycsXHJcbiAgICAnWE4tLUdLM0FUMUUnLFxyXG4gICAgJ1hOLS1IMkJSRUczRVZFJyxcclxuICAgICdYTi0tSDJCUko5QycsXHJcbiAgICAnWE4tLUgyQlJKOUM4QycsXHJcbiAgICAnWE4tLUhYVDgxNEUnLFxyXG4gICAgJ1hOLS1JMUI2QjFBNkEyRScsXHJcbiAgICAnWE4tLUlNUjUxM04nLFxyXG4gICAgJ1hOLS1JTzBBN0knLFxyXG4gICAgJ1hOLS1KMUFFRicsXHJcbiAgICAnWE4tLUoxQU1IJyxcclxuICAgICdYTi0tSjZXMTkzRycsXHJcbiAgICAnWE4tLUpMUTYxVTlXN0InLFxyXG4gICAgJ1hOLS1KVlIxODlNJyxcclxuICAgICdYTi0tS0NSWDc3RDFYNEEnLFxyXG4gICAgJ1hOLS1LUFJXMTNEJyxcclxuICAgICdYTi0tS1BSWTU3RCcsXHJcbiAgICAnWE4tLUtQVTcxNkYnLFxyXG4gICAgJ1hOLS1LUFVUM0knLFxyXG4gICAgJ1hOLS1MMUFDQycsXHJcbiAgICAnWE4tLUxHQkJBVDFBRDhKJyxcclxuICAgICdYTi0tTUdCOUFXQkYnLFxyXG4gICAgJ1hOLS1NR0JBM0EzRUpUJyxcclxuICAgICdYTi0tTUdCQTNBNEYxNkEnLFxyXG4gICAgJ1hOLS1NR0JBN0MwQkJOMEEnLFxyXG4gICAgJ1hOLS1NR0JBQUtDN0RWRicsXHJcbiAgICAnWE4tLU1HQkFBTTdBOEgnLFxyXG4gICAgJ1hOLS1NR0JBQjJCRCcsXHJcbiAgICAnWE4tLU1HQkFIMUEzSEpLUkQnLFxyXG4gICAgJ1hOLS1NR0JBSTlBWkdRUDZKJyxcclxuICAgICdYTi0tTUdCQVlIN0dQQScsXHJcbiAgICAnWE4tLU1HQkI5RkJQT0InLFxyXG4gICAgJ1hOLS1NR0JCSDFBJyxcclxuICAgICdYTi0tTUdCQkgxQTcxRScsXHJcbiAgICAnWE4tLU1HQkMwQTlBWkNHJyxcclxuICAgICdYTi0tTUdCQ0E3RFpETycsXHJcbiAgICAnWE4tLU1HQkVSUDRBNUQ0QVInLFxyXG4gICAgJ1hOLS1NR0JHVTgyQScsXHJcbiAgICAnWE4tLU1HQkk0RUNFWFAnLFxyXG4gICAgJ1hOLS1NR0JQTDJGSCcsXHJcbiAgICAnWE4tLU1HQlQzREhEJyxcclxuICAgICdYTi0tTUdCVFgyQicsXHJcbiAgICAnWE4tLU1HQlg0Q0QwQUInLFxyXG4gICAgJ1hOLS1NSVg4OTFGJyxcclxuICAgICdYTi0tTUsxQlU0NEMnLFxyXG4gICAgJ1hOLS1NWFRRMU0nLFxyXG4gICAgJ1hOLS1OR0JDNUFaRCcsXHJcbiAgICAnWE4tLU5HQkU5RTBBJyxcclxuICAgICdYTi0tTkdCUlgnLFxyXG4gICAgJ1hOLS1OT0RFJyxcclxuICAgICdYTi0tTlFWN0YnLFxyXG4gICAgJ1hOLS1OUVY3RlMwMEVNQScsXHJcbiAgICAnWE4tLU5ZUVkyNkEnLFxyXG4gICAgJ1hOLS1PM0NXNEgnLFxyXG4gICAgJ1hOLS1PR0JQRjhGTCcsXHJcbiAgICAnWE4tLU9UVTc5NkQnLFxyXG4gICAgJ1hOLS1QMUFDRicsXHJcbiAgICAnWE4tLVAxQUknLFxyXG4gICAgJ1hOLS1QQlQ5NzdDJyxcclxuICAgICdYTi0tUEdCUzBESCcsXHJcbiAgICAnWE4tLVBTU1kyVScsXHJcbiAgICAnWE4tLVE5SllCNEMnLFxyXG4gICAgJ1hOLS1RQ0tBMVBNQycsXHJcbiAgICAnWE4tLVFYQU0nLFxyXG4gICAgJ1hOLS1SSFFWOTZHJyxcclxuICAgICdYTi0tUk9WVTg4QicsXHJcbiAgICAnWE4tLVJWQzFFMEFNM0UnLFxyXG4gICAgJ1hOLS1TOUJSSjlDJyxcclxuICAgICdYTi0tU0VTNTU0RycsXHJcbiAgICAnWE4tLVQ2MEI1NkEnLFxyXG4gICAgJ1hOLS1UQ0tXRScsXHJcbiAgICAnWE4tLVRJUTQ5WFFZSicsXHJcbiAgICAnWE4tLVVOVVA0WScsXHJcbiAgICAnWE4tLVZFUk1HRU5TQkVSQVRFUi1DVEInLFxyXG4gICAgJ1hOLS1WRVJNR0VOU0JFUkFUVU5HLVBXQicsXHJcbiAgICAnWE4tLVZIUVVWJyxcclxuICAgICdYTi0tVlVRODYxQicsXHJcbiAgICAnWE4tLVc0Ujg1RUw4RkhVNUROUkEnLFxyXG4gICAgJ1hOLS1XNFJTNDBMJyxcclxuICAgICdYTi0tV0dCSDFDJyxcclxuICAgICdYTi0tV0dCTDZBJyxcclxuICAgICdYTi0tWEhRNTIxQicsXHJcbiAgICAnWE4tLVhLQzJBTDNIWUUyQScsXHJcbiAgICAnWE4tLVhLQzJETDNBNUVFMEgnLFxyXG4gICAgJ1hOLS1ZOUEzQVEnLFxyXG4gICAgJ1hOLS1ZRlJPNEk2N08nLFxyXG4gICAgJ1hOLS1ZR0JJMkFNTVgnLFxyXG4gICAgJ1hOLS1aRlIxNjRCJyxcclxuICAgICdYWFgnLFxyXG4gICAgJ1hZWicsXHJcbiAgICAnWUFDSFRTJyxcclxuICAgICdZQUhPTycsXHJcbiAgICAnWUFNQVhVTicsXHJcbiAgICAnWUFOREVYJyxcclxuICAgICdZRScsXHJcbiAgICAnWU9ET0JBU0hJJyxcclxuICAgICdZT0dBJyxcclxuICAgICdZT0tPSEFNQScsXHJcbiAgICAnWU9VJyxcclxuICAgICdZT1VUVUJFJyxcclxuICAgICdZVCcsXHJcbiAgICAnWVVOJyxcclxuICAgICdaQScsXHJcbiAgICAnWkFQUE9TJyxcclxuICAgICdaQVJBJyxcclxuICAgICdaRVJPJyxcclxuICAgICdaSVAnLFxyXG4gICAgJ1pNJyxcclxuICAgICdaT05FJyxcclxuICAgICdaVUVSSUNIJyxcclxuICAgICdaVydcclxuXTtcclxuXHJcblxyXG4vLyBLZWVwIGFzIHVwcGVyLWNhc2UgdG8gbWFrZSB1cGRhdGluZyBmcm9tIHNvdXJjZSBlYXNpZXJcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gbmV3IFNldChpbnRlcm5hbHMudGxkcy5tYXAoKHRsZCkgPT4gdGxkLnRvTG93ZXJDYXNlKCkpKTtcclxuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBMb2FkIG1vZHVsZXNcblxuY29uc3QgVHlwZXMgPSByZXF1aXJlKCcuL3R5cGVzJyk7XG5cblxuLy8gRGVjbGFyZSBpbnRlcm5hbHNcblxuY29uc3QgaW50ZXJuYWxzID0ge1xuICAgIG1pc21hdGNoZWQ6IG51bGxcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqLCByZWYsIG9wdGlvbnMpIHtcblxuICAgIG9wdGlvbnMgPSB7IHByb3RvdHlwZTogdHJ1ZSwgLi4ub3B0aW9ucyB9O1xuXG4gICAgcmV0dXJuICEhaW50ZXJuYWxzLmlzRGVlcEVxdWFsKG9iaiwgcmVmLCBvcHRpb25zLCBbXSk7XG59O1xuXG5cbmludGVybmFscy5pc0RlZXBFcXVhbCA9IGZ1bmN0aW9uIChvYmosIHJlZiwgb3B0aW9ucywgc2Vlbikge1xuXG4gICAgaWYgKG9iaiA9PT0gcmVmKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDb3BpZWQgZnJvbSBEZWVwLWVxbCwgY29weXJpZ2h0KGMpIDIwMTMgSmFrZSBMdWVyLCBqYWtlQGFsb2dpY2FscGFyYWRveC5jb20sIE1JVCBMaWNlbnNlZCwgaHR0cHM6Ly9naXRodWIuY29tL2NoYWlqcy9kZWVwLWVxbFxuICAgICAgICByZXR1cm4gb2JqICE9PSAwIHx8IDEgLyBvYmogPT09IDEgLyByZWY7XG4gICAgfVxuXG4gICAgY29uc3QgdHlwZSA9IHR5cGVvZiBvYmo7XG5cbiAgICBpZiAodHlwZSAhPT0gdHlwZW9mIHJlZikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgIT09ICdvYmplY3QnIHx8XG4gICAgICAgIG9iaiA9PT0gbnVsbCB8fFxuICAgICAgICByZWYgPT09IG51bGwpIHtcblxuICAgICAgICByZXR1cm4gb2JqICE9PSBvYmogJiYgcmVmICE9PSByZWY7ICAgICAgICAgICAgICAgICAgLy8gTmFOXG4gICAgfVxuXG4gICAgY29uc3QgaW5zdGFuY2VUeXBlID0gaW50ZXJuYWxzLmdldFNoYXJlZFR5cGUob2JqLCByZWYsICEhb3B0aW9ucy5wcm90b3R5cGUpO1xuICAgIHN3aXRjaCAoaW5zdGFuY2VUeXBlKSB7XG4gICAgICAgIGNhc2UgVHlwZXMuYnVmZmVyOlxuICAgICAgICAgICAgcmV0dXJuIEJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzLmNhbGwob2JqLCByZWYpO1xuICAgICAgICBjYXNlIFR5cGVzLnByb21pc2U6XG4gICAgICAgICAgICByZXR1cm4gb2JqID09PSByZWY7XG4gICAgICAgIGNhc2UgVHlwZXMucmVnZXg6XG4gICAgICAgICAgICByZXR1cm4gb2JqLnRvU3RyaW5nKCkgPT09IHJlZi50b1N0cmluZygpO1xuICAgICAgICBjYXNlIGludGVybmFscy5taXNtYXRjaGVkOlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSBzZWVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIGlmIChzZWVuW2ldLmlzU2FtZShvYmosIHJlZikpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHByZXZpb3VzIGNvbXBhcmlzb24gZmFpbGVkLCBpdCB3b3VsZCBoYXZlIHN0b3BwZWQgZXhlY3V0aW9uXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZWVuLnB1c2gobmV3IGludGVybmFscy5TZWVuRW50cnkob2JqLCByZWYpKTtcblxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiAhIWludGVybmFscy5pc0RlZXBFcXVhbE9iaihpbnN0YW5jZVR5cGUsIG9iaiwgcmVmLCBvcHRpb25zLCBzZWVuKTtcbiAgICB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHNlZW4ucG9wKCk7XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMuZ2V0U2hhcmVkVHlwZSA9IGZ1bmN0aW9uIChvYmosIHJlZiwgY2hlY2tQcm90b3R5cGUpIHtcblxuICAgIGlmIChjaGVja1Byb3RvdHlwZSkge1xuICAgICAgICBpZiAoT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaikgIT09IE9iamVjdC5nZXRQcm90b3R5cGVPZihyZWYpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLm1pc21hdGNoZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gVHlwZXMuZ2V0SW50ZXJuYWxQcm90byhvYmopO1xuICAgIH1cblxuICAgIGNvbnN0IHR5cGUgPSBUeXBlcy5nZXRJbnRlcm5hbFByb3RvKG9iaik7XG4gICAgaWYgKHR5cGUgIT09IFR5cGVzLmdldEludGVybmFsUHJvdG8ocmVmKSkge1xuICAgICAgICByZXR1cm4gaW50ZXJuYWxzLm1pc21hdGNoZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHR5cGU7XG59O1xuXG5cbmludGVybmFscy52YWx1ZU9mID0gZnVuY3Rpb24gKG9iaikge1xuXG4gICAgY29uc3Qgb2JqVmFsdWVPZiA9IG9iai52YWx1ZU9mO1xuICAgIGlmIChvYmpWYWx1ZU9mID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gb2JqVmFsdWVPZi5jYWxsKG9iaik7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGVycjtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5oYXNPd25FbnVtZXJhYmxlUHJvcGVydHkgPSBmdW5jdGlvbiAob2JqLCBrZXkpIHtcblxuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob2JqLCBrZXkpO1xufTtcblxuXG5pbnRlcm5hbHMuaXNTZXRTaW1wbGVFcXVhbCA9IGZ1bmN0aW9uIChvYmosIHJlZikge1xuXG4gICAgZm9yIChjb25zdCBlbnRyeSBvZiBvYmopIHtcbiAgICAgICAgaWYgKCFyZWYuaGFzKGVudHJ5KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5cbmludGVybmFscy5pc0RlZXBFcXVhbE9iaiA9IGZ1bmN0aW9uIChpbnN0YW5jZVR5cGUsIG9iaiwgcmVmLCBvcHRpb25zLCBzZWVuKSB7XG5cbiAgICBjb25zdCB7IGlzRGVlcEVxdWFsLCB2YWx1ZU9mLCBoYXNPd25FbnVtZXJhYmxlUHJvcGVydHkgfSA9IGludGVybmFscztcbiAgICBjb25zdCB7IGtleXMsIGdldE93blByb3BlcnR5U3ltYm9scyB9ID0gT2JqZWN0O1xuXG4gICAgaWYgKGluc3RhbmNlVHlwZSA9PT0gVHlwZXMuYXJyYXkpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMucGFydCkge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgYW55IGluZGV4IG1hdGNoIGFueSBvdGhlciBpbmRleFxuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9iai5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9ialZhbHVlID0gb2JqW2ldO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcmVmLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0RlZXBFcXVhbChvYmpWYWx1ZSwgcmVmW2pdLCBvcHRpb25zLCBzZWVuKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAob2JqLmxlbmd0aCAhPT0gcmVmLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvYmoubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzRGVlcEVxdWFsKG9ialtpXSwgcmVmW2ldLCBvcHRpb25zLCBzZWVuKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChpbnN0YW5jZVR5cGUgPT09IFR5cGVzLnNldCkge1xuICAgICAgICBpZiAob2JqLnNpemUgIT09IHJlZi5zaXplKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWludGVybmFscy5pc1NldFNpbXBsZUVxdWFsKG9iaiwgcmVmKSkge1xuXG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgZGVlcCBlcXVhbGl0eVxuXG4gICAgICAgICAgICBjb25zdCByZWYyID0gbmV3IFNldChyZWYpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBvYmpFbnRyeSBvZiBvYmopIHtcbiAgICAgICAgICAgICAgICBpZiAocmVmMi5kZWxldGUob2JqRW50cnkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxldCBmb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcmVmRW50cnkgb2YgcmVmMikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNEZWVwRXF1YWwob2JqRW50cnksIHJlZkVudHJ5LCBvcHRpb25zLCBzZWVuKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVmMi5kZWxldGUocmVmRW50cnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIWZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoaW5zdGFuY2VUeXBlID09PSBUeXBlcy5tYXApIHtcbiAgICAgICAgaWYgKG9iai5zaXplICE9PSByZWYuc2l6ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2Ygb2JqKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhcmVmLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWlzRGVlcEVxdWFsKHZhbHVlLCByZWYuZ2V0KGtleSksIG9wdGlvbnMsIHNlZW4pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGluc3RhbmNlVHlwZSA9PT0gVHlwZXMuZXJyb3IpIHtcbiAgICAgICAgLy8gQWx3YXlzIGNoZWNrIG5hbWUgYW5kIG1lc3NhZ2VcblxuICAgICAgICBpZiAob2JqLm5hbWUgIT09IHJlZi5uYW1lIHx8IG9iai5tZXNzYWdlICE9PSByZWYubWVzc2FnZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgLnZhbHVlT2YoKVxuXG4gICAgY29uc3QgdmFsdWVPZk9iaiA9IHZhbHVlT2Yob2JqKTtcbiAgICBjb25zdCB2YWx1ZU9mUmVmID0gdmFsdWVPZihyZWYpO1xuICAgIGlmICghKG9iaiA9PT0gdmFsdWVPZk9iaiAmJiByZWYgPT09IHZhbHVlT2ZSZWYpICYmXG4gICAgICAgICFpc0RlZXBFcXVhbCh2YWx1ZU9mT2JqLCB2YWx1ZU9mUmVmLCBvcHRpb25zLCBzZWVuKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgcHJvcGVydGllc1xuXG4gICAgY29uc3Qgb2JqS2V5cyA9IGtleXMob2JqKTtcbiAgICBpZiAoIW9wdGlvbnMucGFydCAmJlxuICAgICAgICBvYmpLZXlzLmxlbmd0aCAhPT0ga2V5cyhyZWYpLmxlbmd0aCkge1xuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9iaktleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gb2JqS2V5c1tpXTtcblxuICAgICAgICBpZiAoIWhhc093bkVudW1lcmFibGVQcm9wZXJ0eShyZWYsIGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNEZWVwRXF1YWwob2JqW2tleV0sIHJlZltrZXldLCBvcHRpb25zLCBzZWVuKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgc3ltYm9sc1xuXG4gICAgaWYgKG9wdGlvbnMuc3ltYm9scykge1xuICAgICAgICBjb25zdCBvYmpTeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iaik7XG4gICAgICAgIGNvbnN0IHJlZlN5bWJvbHMgPSBuZXcgU2V0KGdldE93blByb3BlcnR5U3ltYm9scyhyZWYpKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9ialN5bWJvbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IG9ialN5bWJvbHNbaV07XG5cbiAgICAgICAgICAgIGlmIChoYXNPd25FbnVtZXJhYmxlUHJvcGVydHkob2JqLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFoYXNPd25FbnVtZXJhYmxlUHJvcGVydHkocmVmLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIWlzRGVlcEVxdWFsKG9ialtrZXldLCByZWZba2V5XSwgb3B0aW9ucywgc2VlbikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGhhc093bkVudW1lcmFibGVQcm9wZXJ0eShyZWYsIGtleSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlZlN5bWJvbHMuZGVsZXRlKGtleSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiByZWZTeW1ib2xzKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duRW51bWVyYWJsZVByb3BlcnR5KHJlZiwga2V5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufTtcblxuXG5pbnRlcm5hbHMuU2VlbkVudHJ5ID0gY2xhc3Mge1xuXG4gICAgY29uc3RydWN0b3Iob2JqLCByZWYpIHtcblxuICAgICAgICB0aGlzLm9iaiA9IG9iajtcbiAgICAgICAgdGhpcy5yZWYgPSByZWY7XG4gICAgfVxuXG4gICAgaXNTYW1lKG9iaiwgcmVmKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMub2JqID09PSBvYmogJiYgdGhpcy5yZWYgPT09IHJlZjtcbiAgICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBEZWNsYXJlIGludGVybmFsc1xuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5leHBvcnRzLmVzY2FwZUh0bWwgPSBmdW5jdGlvbiAoaW5wdXQpIHtcblxuICAgIGlmICghaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIGxldCBlc2NhcGVkID0gJyc7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgKytpKSB7XG5cbiAgICAgICAgY29uc3QgY2hhckNvZGUgPSBpbnB1dC5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICAgIGlmIChpbnRlcm5hbHMuaXNTYWZlKGNoYXJDb2RlKSkge1xuICAgICAgICAgICAgZXNjYXBlZCArPSBpbnB1dFtpXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVzY2FwZWQgKz0gaW50ZXJuYWxzLmVzY2FwZUh0bWxDaGFyKGNoYXJDb2RlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBlc2NhcGVkO1xufTtcblxuXG5leHBvcnRzLmVzY2FwZUpzb24gPSBmdW5jdGlvbiAoaW5wdXQpIHtcblxuICAgIGlmICghaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIGNvbnN0IGxlc3NUaGFuID0gMHgzQztcbiAgICBjb25zdCBncmVhdGVyVGhhbiA9IDB4M0U7XG4gICAgY29uc3QgYW5kU3ltYm9sID0gMHgyNjtcbiAgICBjb25zdCBsaW5lU2VwZXJhdG9yID0gMHgyMDI4O1xuXG4gICAgLy8gcmVwbGFjZSBtZXRob2RcbiAgICBsZXQgY2hhckNvZGU7XG4gICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoL1s8PiZcXHUyMDI4XFx1MjAyOV0vZywgKG1hdGNoKSA9PiB7XG5cbiAgICAgICAgY2hhckNvZGUgPSBtYXRjaC5jaGFyQ29kZUF0KDApO1xuXG4gICAgICAgIGlmIChjaGFyQ29kZSA9PT0gbGVzc1RoYW4pIHtcbiAgICAgICAgICAgIHJldHVybiAnXFxcXHUwMDNjJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjaGFyQ29kZSA9PT0gZ3JlYXRlclRoYW4pIHtcbiAgICAgICAgICAgIHJldHVybiAnXFxcXHUwMDNlJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjaGFyQ29kZSA9PT0gYW5kU3ltYm9sKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1xcXFx1MDAyNic7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2hhckNvZGUgPT09IGxpbmVTZXBlcmF0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiAnXFxcXHUyMDI4JztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAnXFxcXHUyMDI5JztcbiAgICB9KTtcbn07XG5cblxuaW50ZXJuYWxzLmVzY2FwZUh0bWxDaGFyID0gZnVuY3Rpb24gKGNoYXJDb2RlKSB7XG5cbiAgICBjb25zdCBuYW1lZEVzY2FwZSA9IGludGVybmFscy5uYW1lZEh0bWxbY2hhckNvZGVdO1xuICAgIGlmICh0eXBlb2YgbmFtZWRFc2NhcGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBuYW1lZEVzY2FwZTtcbiAgICB9XG5cbiAgICBpZiAoY2hhckNvZGUgPj0gMjU2KSB7XG4gICAgICAgIHJldHVybiAnJiMnICsgY2hhckNvZGUgKyAnOyc7XG4gICAgfVxuXG4gICAgY29uc3QgaGV4VmFsdWUgPSBCdWZmZXIuZnJvbShTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlKSwgJ2FzY2lpJykudG9TdHJpbmcoJ2hleCcpO1xuICAgIHJldHVybiBgJiN4JHtoZXhWYWx1ZX07YDtcbn07XG5cblxuaW50ZXJuYWxzLmlzU2FmZSA9IGZ1bmN0aW9uIChjaGFyQ29kZSkge1xuXG4gICAgcmV0dXJuICh0eXBlb2YgaW50ZXJuYWxzLnNhZmVDaGFyQ29kZXNbY2hhckNvZGVdICE9PSAndW5kZWZpbmVkJyk7XG59O1xuXG5cbmludGVybmFscy5uYW1lZEh0bWwgPSB7XG4gICAgJzM4JzogJyZhbXA7JyxcbiAgICAnNjAnOiAnJmx0OycsXG4gICAgJzYyJzogJyZndDsnLFxuICAgICczNCc6ICcmcXVvdDsnLFxuICAgICcxNjAnOiAnJm5ic3A7JyxcbiAgICAnMTYyJzogJyZjZW50OycsXG4gICAgJzE2Myc6ICcmcG91bmQ7JyxcbiAgICAnMTY0JzogJyZjdXJyZW47JyxcbiAgICAnMTY5JzogJyZjb3B5OycsXG4gICAgJzE3NCc6ICcmcmVnOydcbn07XG5cblxuaW50ZXJuYWxzLnNhZmVDaGFyQ29kZXMgPSAoZnVuY3Rpb24gKCkge1xuXG4gICAgY29uc3Qgc2FmZSA9IHt9O1xuXG4gICAgZm9yIChsZXQgaSA9IDMyOyBpIDwgMTIzOyArK2kpIHtcblxuICAgICAgICBpZiAoKGkgPj0gOTcpIHx8ICAgICAgICAgICAgICAgICAgICAvLyBhLXpcbiAgICAgICAgICAgIChpID49IDY1ICYmIGkgPD0gOTApIHx8ICAgICAgICAgLy8gQS1aXG4gICAgICAgICAgICAoaSA+PSA0OCAmJiBpIDw9IDU3KSB8fCAgICAgICAgIC8vIDAtOVxuICAgICAgICAgICAgaSA9PT0gMzIgfHwgICAgICAgICAgICAgICAgICAgICAvLyBzcGFjZVxuICAgICAgICAgICAgaSA9PT0gNDYgfHwgICAgICAgICAgICAgICAgICAgICAvLyAuXG4gICAgICAgICAgICBpID09PSA0NCB8fCAgICAgICAgICAgICAgICAgICAgIC8vICxcbiAgICAgICAgICAgIGkgPT09IDQ1IHx8ICAgICAgICAgICAgICAgICAgICAgLy8gLVxuICAgICAgICAgICAgaSA9PT0gNTggfHwgICAgICAgICAgICAgICAgICAgICAvLyA6XG4gICAgICAgICAgICBpID09PSA5NSkgeyAgICAgICAgICAgICAgICAgICAgIC8vIF9cblxuICAgICAgICAgICAgc2FmZVtpXSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc2FmZTtcbn0oKSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIExvYWQgbW9kdWxlc1xuXG5jb25zdCBBc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKTtcbmNvbnN0IENyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuY29uc3QgUGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcblxuY29uc3QgRGVlcEVxdWFsID0gcmVxdWlyZSgnLi9kZWVwLWVxdWFsJyk7XG5jb25zdCBFc2NhcGUgPSByZXF1aXJlKCcuL2VzY2FwZScpO1xuY29uc3QgVHlwZXMgPSByZXF1aXJlKCcuL3R5cGVzJyk7XG5cblxuLy8gRGVjbGFyZSBpbnRlcm5hbHNcblxuY29uc3QgaW50ZXJuYWxzID0ge1xuICAgIG5lZWRzUHJvdG9IYWNrOiBuZXcgU2V0KFtUeXBlcy5zZXQsIFR5cGVzLm1hcCwgVHlwZXMud2Vha1NldCwgVHlwZXMud2Vha01hcF0pXG59O1xuXG5cbi8vIERlZXAgb2JqZWN0IG9yIGFycmF5IGNvbXBhcmlzb25cblxuZXhwb3J0cy5kZWVwRXF1YWwgPSBEZWVwRXF1YWw7XG5cblxuLy8gQ2xvbmUgb2JqZWN0IG9yIGFycmF5XG5cbmV4cG9ydHMuY2xvbmUgPSBmdW5jdGlvbiAob2JqLCBvcHRpb25zID0ge30sIF9zZWVuID0gbnVsbCkge1xuXG4gICAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnIHx8XG4gICAgICAgIG9iaiA9PT0gbnVsbCkge1xuXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgY29uc3Qgc2VlbiA9IF9zZWVuIHx8IG5ldyBNYXAoKTtcblxuICAgIGNvbnN0IGxvb2t1cCA9IHNlZW4uZ2V0KG9iaik7XG4gICAgaWYgKGxvb2t1cCkge1xuICAgICAgICByZXR1cm4gbG9va3VwO1xuICAgIH1cblxuICAgIGNvbnN0IGJhc2VQcm90byA9IFR5cGVzLmdldEludGVybmFsUHJvdG8ob2JqKTtcbiAgICBsZXQgbmV3T2JqO1xuXG4gICAgc3dpdGNoIChiYXNlUHJvdG8pIHtcbiAgICAgICAgY2FzZSBUeXBlcy5idWZmZXI6XG4gICAgICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20ob2JqKTtcblxuICAgICAgICBjYXNlIFR5cGVzLmRhdGU6XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUob2JqLmdldFRpbWUoKSk7XG5cbiAgICAgICAgY2FzZSBUeXBlcy5yZWdleDpcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKG9iaik7XG5cbiAgICAgICAgY2FzZSBUeXBlcy5hcnJheTpcbiAgICAgICAgICAgIG5ld09iaiA9IFtdO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnByb3RvdHlwZSAhPT0gZmFsc2UpIHsgICAgICAgICAgICAgIC8vIERlZmF1bHRzIHRvIHRydWVcbiAgICAgICAgICAgICAgICBjb25zdCBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopO1xuICAgICAgICAgICAgICAgIGlmIChwcm90byAmJlxuICAgICAgICAgICAgICAgICAgICBwcm90by5pc0ltbXV0YWJsZSkge1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGludGVybmFscy5uZWVkc1Byb3RvSGFjay5oYXMoYmFzZVByb3RvKSkge1xuICAgICAgICAgICAgICAgICAgICBuZXdPYmogPSBuZXcgcHJvdG8uY29uc3RydWN0b3IoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3RvICE9PSBiYXNlUHJvdG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihuZXdPYmosIHByb3RvKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3T2JqID0gT2JqZWN0LmNyZWF0ZShwcm90byk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaW50ZXJuYWxzLm5lZWRzUHJvdG9IYWNrLmhhcyhiYXNlUHJvdG8pKSB7XG4gICAgICAgICAgICAgICAgbmV3T2JqID0gbmV3IGJhc2VQcm90by5jb25zdHJ1Y3RvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3T2JqID0ge307XG4gICAgICAgICAgICB9XG4gICAgfVxuXG4gICAgc2Vlbi5zZXQob2JqLCBuZXdPYmopOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTZXQgc2Vlbiwgc2luY2Ugb2JqIGNvdWxkIHJlY3Vyc2VcblxuICAgIGlmIChiYXNlUHJvdG8gPT09IFR5cGVzLnNldCkge1xuICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIG9iaikge1xuICAgICAgICAgICAgbmV3T2JqLmFkZChleHBvcnRzLmNsb25lKHZhbHVlLCBvcHRpb25zLCBzZWVuKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoYmFzZVByb3RvID09PSBUeXBlcy5tYXApIHtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2Ygb2JqKSB7XG4gICAgICAgICAgICBuZXdPYmouc2V0KGtleSwgZXhwb3J0cy5jbG9uZSh2YWx1ZSwgb3B0aW9ucywgc2VlbikpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qga2V5cyA9IGludGVybmFscy5rZXlzKG9iaiwgb3B0aW9ucyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgaWYgKGJhc2VQcm90byA9PT0gVHlwZXMuYXJyYXkgJiZcbiAgICAgICAgICAgIGtleSA9PT0gJ2xlbmd0aCcpIHtcblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSk7XG4gICAgICAgIGlmIChkZXNjcmlwdG9yICYmXG4gICAgICAgICAgICAoZGVzY3JpcHRvci5nZXQgfHxcbiAgICAgICAgICAgICAgICBkZXNjcmlwdG9yLnNldCkpIHtcblxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjcmlwdG9yKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGRlc2NyaXB0b3IgPyBkZXNjcmlwdG9yLmVudW1lcmFibGUgOiB0cnVlLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogZXhwb3J0cy5jbG9uZShvYmpba2V5XSwgb3B0aW9ucywgc2VlbilcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGJhc2VQcm90byA9PT0gVHlwZXMuYXJyYXkpIHtcbiAgICAgICAgbmV3T2JqLmxlbmd0aCA9IG9iai5sZW5ndGg7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld09iajtcbn07XG5cblxuaW50ZXJuYWxzLmtleXMgPSBmdW5jdGlvbiAob2JqLCBvcHRpb25zID0ge30pIHtcblxuICAgIHJldHVybiBvcHRpb25zLnN5bWJvbHMgPyBSZWZsZWN0Lm93bktleXMob2JqKSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaik7XG59O1xuXG5cbi8vIE1lcmdlIGFsbCB0aGUgcHJvcGVydGllcyBvZiBzb3VyY2UgaW50byB0YXJnZXQsIHNvdXJjZSB3aW5zIGluIGNvbmZsaWN0LCBhbmQgYnkgZGVmYXVsdCBudWxsIGFuZCB1bmRlZmluZWQgZnJvbSBzb3VyY2UgYXJlIGFwcGxpZWRcblxuZXhwb3J0cy5tZXJnZSA9IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSwgaXNOdWxsT3ZlcnJpZGUgPSB0cnVlLCBpc01lcmdlQXJyYXlzID0gdHJ1ZSkge1xuXG4gICAgZXhwb3J0cy5hc3NlcnQodGFyZ2V0ICYmIHR5cGVvZiB0YXJnZXQgPT09ICdvYmplY3QnLCAnSW52YWxpZCB0YXJnZXQgdmFsdWU6IG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gICAgZXhwb3J0cy5hc3NlcnQoc291cmNlID09PSBudWxsIHx8IHNvdXJjZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBzb3VyY2UgPT09ICdvYmplY3QnLCAnSW52YWxpZCBzb3VyY2UgdmFsdWU6IG11c3QgYmUgbnVsbCwgdW5kZWZpbmVkLCBvciBhbiBvYmplY3QnKTtcblxuICAgIGlmICghc291cmNlKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc291cmNlKSkge1xuICAgICAgICBleHBvcnRzLmFzc2VydChBcnJheS5pc0FycmF5KHRhcmdldCksICdDYW5ub3QgbWVyZ2UgYXJyYXkgb250byBhbiBvYmplY3QnKTtcbiAgICAgICAgaWYgKCFpc01lcmdlQXJyYXlzKSB7XG4gICAgICAgICAgICB0YXJnZXQubGVuZ3RoID0gMDsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTXVzdCBub3QgY2hhbmdlIHRhcmdldCBhc3NpZ25tZW50XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNvdXJjZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdGFyZ2V0LnB1c2goZXhwb3J0cy5jbG9uZShzb3VyY2VbaV0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgY29uc3Qga2V5cyA9IGludGVybmFscy5rZXlzKHNvdXJjZSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICAgIGlmIChrZXkgPT09ICdfX3Byb3RvX18nIHx8XG4gICAgICAgICAgICAhT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkge1xuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHZhbHVlID0gc291cmNlW2tleV07XG4gICAgICAgIGlmICh2YWx1ZSAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuXG4gICAgICAgICAgICBpZiAoIXRhcmdldFtrZXldIHx8XG4gICAgICAgICAgICAgICAgdHlwZW9mIHRhcmdldFtrZXldICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICAgICAgICAgIChBcnJheS5pc0FycmF5KHRhcmdldFtrZXldKSAhPT0gQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHx8XG4gICAgICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBEYXRlIHx8XG4gICAgICAgICAgICAgICAgQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSB8fFxuICAgICAgICAgICAgICAgIHZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG5cbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IGV4cG9ydHMuY2xvbmUodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZXhwb3J0cy5tZXJnZSh0YXJnZXRba2V5XSwgdmFsdWUsIGlzTnVsbE92ZXJyaWRlLCBpc01lcmdlQXJyYXlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgIHZhbHVlICE9PSB1bmRlZmluZWQpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFeHBsaWNpdCB0byBwcmVzZXJ2ZSBlbXB0eSBzdHJpbmdzXG5cbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNOdWxsT3ZlcnJpZGUpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbn07XG5cblxuLy8gQXBwbHkgb3B0aW9ucyB0byBhIGNvcHkgb2YgdGhlIGRlZmF1bHRzXG5cbmV4cG9ydHMuYXBwbHlUb0RlZmF1bHRzID0gZnVuY3Rpb24gKGRlZmF1bHRzLCBvcHRpb25zLCBpc051bGxPdmVycmlkZSA9IGZhbHNlKSB7XG5cbiAgICBleHBvcnRzLmFzc2VydChkZWZhdWx0cyAmJiB0eXBlb2YgZGVmYXVsdHMgPT09ICdvYmplY3QnLCAnSW52YWxpZCBkZWZhdWx0cyB2YWx1ZTogbXVzdCBiZSBhbiBvYmplY3QnKTtcbiAgICBleHBvcnRzLmFzc2VydCghb3B0aW9ucyB8fCBvcHRpb25zID09PSB0cnVlIHx8IHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0JywgJ0ludmFsaWQgb3B0aW9ucyB2YWx1ZTogbXVzdCBiZSB0cnVlLCBmYWxzeSBvciBhbiBvYmplY3QnKTtcblxuICAgIGlmICghb3B0aW9ucykgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBubyBvcHRpb25zLCByZXR1cm4gbnVsbFxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBjb3B5ID0gZXhwb3J0cy5jbG9uZShkZWZhdWx0cyk7XG5cbiAgICBpZiAob3B0aW9ucyA9PT0gdHJ1ZSkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgb3B0aW9ucyBpcyBzZXQgdG8gdHJ1ZSwgdXNlIGRlZmF1bHRzXG4gICAgICAgIHJldHVybiBjb3B5O1xuICAgIH1cblxuICAgIHJldHVybiBleHBvcnRzLm1lcmdlKGNvcHksIG9wdGlvbnMsIGlzTnVsbE92ZXJyaWRlLCBmYWxzZSk7XG59O1xuXG5cbi8vIENsb25lIGFuIG9iamVjdCBleGNlcHQgZm9yIHRoZSBsaXN0ZWQga2V5cyB3aGljaCBhcmUgc2hhbGxvdyBjb3BpZWRcblxuZXhwb3J0cy5jbG9uZVdpdGhTaGFsbG93ID0gZnVuY3Rpb24gKHNvdXJjZSwga2V5cywgb3B0aW9ucykge1xuXG4gICAgaWYgKCFzb3VyY2UgfHxcbiAgICAgICAgdHlwZW9mIHNvdXJjZSAhPT0gJ29iamVjdCcpIHtcblxuICAgICAgICByZXR1cm4gc291cmNlO1xuICAgIH1cblxuICAgIGNvbnN0IHN0b3JhZ2UgPSBpbnRlcm5hbHMuc3RvcmUoc291cmNlLCBrZXlzKTsgICAgLy8gTW92ZSBzaGFsbG93IGNvcHkgaXRlbXMgdG8gc3RvcmFnZVxuICAgIGNvbnN0IGNvcHkgPSBleHBvcnRzLmNsb25lKHNvdXJjZSwgb3B0aW9ucyk7ICAgICAgLy8gRGVlcCBjb3B5IHRoZSByZXN0XG4gICAgaW50ZXJuYWxzLnJlc3RvcmUoY29weSwgc291cmNlLCBzdG9yYWdlKTsgICAgICAgICAvLyBTaGFsbG93IGNvcHkgdGhlIHN0b3JlZCBpdGVtcyBhbmQgcmVzdG9yZVxuICAgIHJldHVybiBjb3B5O1xufTtcblxuXG5pbnRlcm5hbHMuc3RvcmUgPSBmdW5jdGlvbiAoc291cmNlLCBrZXlzKSB7XG5cbiAgICBjb25zdCBzdG9yYWdlID0gbmV3IE1hcCgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGV4cG9ydHMucmVhY2goc291cmNlLCBrZXkpO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyB8fFxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG5cbiAgICAgICAgICAgIHN0b3JhZ2Uuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgaW50ZXJuYWxzLnJlYWNoU2V0KHNvdXJjZSwga2V5LCB1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0b3JhZ2U7XG59O1xuXG5cbmludGVybmFscy5yZXN0b3JlID0gZnVuY3Rpb24gKGNvcHksIHNvdXJjZSwgc3RvcmFnZSkge1xuXG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2Ygc3RvcmFnZSkge1xuICAgICAgICBpbnRlcm5hbHMucmVhY2hTZXQoY29weSwga2V5LCB2YWx1ZSk7XG4gICAgICAgIGludGVybmFscy5yZWFjaFNldChzb3VyY2UsIGtleSwgdmFsdWUpO1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLnJlYWNoU2V0ID0gZnVuY3Rpb24gKG9iaiwga2V5LCB2YWx1ZSkge1xuXG4gICAgY29uc3QgcGF0aCA9IEFycmF5LmlzQXJyYXkoa2V5KSA/IGtleSA6IGtleS5zcGxpdCgnLicpO1xuICAgIGxldCByZWYgPSBvYmo7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IHNlZ21lbnQgPSBwYXRoW2ldO1xuICAgICAgICBpZiAoaSArIDEgPT09IHBhdGgubGVuZ3RoKSB7XG4gICAgICAgICAgICByZWZbc2VnbWVudF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlZiA9IHJlZltzZWdtZW50XTtcbiAgICB9XG59O1xuXG5cbi8vIEFwcGx5IG9wdGlvbnMgdG8gZGVmYXVsdHMgZXhjZXB0IGZvciB0aGUgbGlzdGVkIGtleXMgd2hpY2ggYXJlIHNoYWxsb3cgY29waWVkIGZyb20gb3B0aW9uIHdpdGhvdXQgbWVyZ2luZ1xuXG5leHBvcnRzLmFwcGx5VG9EZWZhdWx0c1dpdGhTaGFsbG93ID0gZnVuY3Rpb24gKGRlZmF1bHRzLCBvcHRpb25zLCBrZXlzKSB7XG5cbiAgICBleHBvcnRzLmFzc2VydChkZWZhdWx0cyAmJiB0eXBlb2YgZGVmYXVsdHMgPT09ICdvYmplY3QnLCAnSW52YWxpZCBkZWZhdWx0cyB2YWx1ZTogbXVzdCBiZSBhbiBvYmplY3QnKTtcbiAgICBleHBvcnRzLmFzc2VydCghb3B0aW9ucyB8fCBvcHRpb25zID09PSB0cnVlIHx8IHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0JywgJ0ludmFsaWQgb3B0aW9ucyB2YWx1ZTogbXVzdCBiZSB0cnVlLCBmYWxzeSBvciBhbiBvYmplY3QnKTtcbiAgICBleHBvcnRzLmFzc2VydChrZXlzICYmIEFycmF5LmlzQXJyYXkoa2V5cyksICdJbnZhbGlkIGtleXMnKTtcblxuICAgIGlmICghb3B0aW9ucykgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBubyBvcHRpb25zLCByZXR1cm4gbnVsbFxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBjb3B5ID0gZXhwb3J0cy5jbG9uZVdpdGhTaGFsbG93KGRlZmF1bHRzLCBrZXlzKTtcblxuICAgIGlmIChvcHRpb25zID09PSB0cnVlKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBvcHRpb25zIGlzIHNldCB0byB0cnVlLCB1c2UgZGVmYXVsdHNcbiAgICAgICAgcmV0dXJuIGNvcHk7XG4gICAgfVxuXG4gICAgY29uc3Qgc3RvcmFnZSA9IGludGVybmFscy5zdG9yZShvcHRpb25zLCBrZXlzKTsgICAgIC8vIE1vdmUgc2hhbGxvdyBjb3B5IGl0ZW1zIHRvIHN0b3JhZ2VcbiAgICBleHBvcnRzLm1lcmdlKGNvcHksIG9wdGlvbnMsIGZhbHNlLCBmYWxzZSk7ICAgICAgICAgLy8gRGVlcCBjb3B5IHRoZSByZXN0XG4gICAgaW50ZXJuYWxzLnJlc3RvcmUoY29weSwgb3B0aW9ucywgc3RvcmFnZSk7ICAgICAgICAgIC8vIFNoYWxsb3cgY29weSB0aGUgc3RvcmVkIGl0ZW1zIGFuZCByZXN0b3JlXG4gICAgcmV0dXJuIGNvcHk7XG59O1xuXG5cbi8vIEZpbmQgdGhlIGNvbW1vbiB1bmlxdWUgaXRlbXMgaW4gdHdvIGFycmF5c1xuXG5leHBvcnRzLmludGVyc2VjdCA9IGZ1bmN0aW9uIChhcnJheTEsIGFycmF5MiwganVzdEZpcnN0ID0gZmFsc2UpIHtcblxuICAgIGlmICghYXJyYXkxIHx8XG4gICAgICAgICFhcnJheTIpIHtcblxuICAgICAgICByZXR1cm4gKGp1c3RGaXJzdCA/IG51bGwgOiBbXSk7XG4gICAgfVxuXG4gICAgY29uc3QgY29tbW9uID0gW107XG4gICAgY29uc3QgaGFzaCA9IChBcnJheS5pc0FycmF5KGFycmF5MSkgPyBuZXcgU2V0KGFycmF5MSkgOiBhcnJheTEpO1xuICAgIGNvbnN0IGZvdW5kID0gbmV3IFNldCgpO1xuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgYXJyYXkyKSB7XG4gICAgICAgIGlmIChpbnRlcm5hbHMuaGFzKGhhc2gsIHZhbHVlKSAmJlxuICAgICAgICAgICAgIWZvdW5kLmhhcyh2YWx1ZSkpIHtcblxuICAgICAgICAgICAgaWYgKGp1c3RGaXJzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29tbW9uLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgZm91bmQuYWRkKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAoanVzdEZpcnN0ID8gbnVsbCA6IGNvbW1vbik7XG59O1xuXG5cbmludGVybmFscy5oYXMgPSBmdW5jdGlvbiAocmVmLCBrZXkpIHtcblxuICAgIGlmICh0eXBlb2YgcmVmLmhhcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gcmVmLmhhcyhrZXkpO1xuICAgIH1cblxuICAgIHJldHVybiByZWZba2V5XSAhPT0gdW5kZWZpbmVkO1xufTtcblxuXG4vLyBUZXN0IGlmIHRoZSByZWZlcmVuY2UgY29udGFpbnMgdGhlIHZhbHVlc1xuXG5leHBvcnRzLmNvbnRhaW4gPSBmdW5jdGlvbiAocmVmLCB2YWx1ZXMsIG9wdGlvbnMgPSB7fSkgeyAgICAgICAgLy8gb3B0aW9uczogeyBkZWVwLCBvbmNlLCBvbmx5LCBwYXJ0LCBzeW1ib2xzIH1cblxuICAgIC8qXG4gICAgICAgIHN0cmluZyAtPiBzdHJpbmcocylcbiAgICAgICAgYXJyYXkgLT4gaXRlbShzKVxuICAgICAgICBvYmplY3QgLT4ga2V5KHMpXG4gICAgICAgIG9iamVjdCAtPiBvYmplY3QgKGtleTp2YWx1ZSlcbiAgICAqL1xuXG4gICAgbGV0IHZhbHVlUGFpcnMgPSBudWxsO1xuICAgIGlmICh0eXBlb2YgcmVmID09PSAnb2JqZWN0JyAmJlxuICAgICAgICB0eXBlb2YgdmFsdWVzID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAhQXJyYXkuaXNBcnJheShyZWYpICYmXG4gICAgICAgICFBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcblxuICAgICAgICB2YWx1ZVBhaXJzID0gdmFsdWVzO1xuICAgICAgICBjb25zdCBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh2YWx1ZXMpLmZpbHRlcihPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmJpbmQodmFsdWVzKSk7XG4gICAgICAgIHZhbHVlcyA9IFsuLi5PYmplY3Qua2V5cyh2YWx1ZXMpLCAuLi5zeW1ib2xzXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhbHVlcyA9IFtdLmNvbmNhdCh2YWx1ZXMpO1xuICAgIH1cblxuICAgIGV4cG9ydHMuYXNzZXJ0KHR5cGVvZiByZWYgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiByZWYgPT09ICdvYmplY3QnLCAnUmVmZXJlbmNlIG11c3QgYmUgc3RyaW5nIG9yIGFuIG9iamVjdCcpO1xuICAgIGV4cG9ydHMuYXNzZXJ0KHZhbHVlcy5sZW5ndGgsICdWYWx1ZXMgYXJyYXkgY2Fubm90IGJlIGVtcHR5Jyk7XG5cbiAgICBsZXQgY29tcGFyZTtcbiAgICBsZXQgY29tcGFyZUZsYWdzO1xuICAgIGlmIChvcHRpb25zLmRlZXApIHtcbiAgICAgICAgY29tcGFyZSA9IGV4cG9ydHMuZGVlcEVxdWFsO1xuXG4gICAgICAgIGNvbnN0IGhhc09ubHkgPSBvcHRpb25zLm9ubHkgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgaGFzUGFydCA9IG9wdGlvbnMucGFydCAhPT0gdW5kZWZpbmVkO1xuXG4gICAgICAgIGNvbXBhcmVGbGFncyA9IHtcbiAgICAgICAgICAgIHByb3RvdHlwZTogaGFzT25seSA/IG9wdGlvbnMub25seSA6IGhhc1BhcnQgPyAhb3B0aW9ucy5wYXJ0IDogZmFsc2UsXG4gICAgICAgICAgICBwYXJ0OiBoYXNPbmx5ID8gIW9wdGlvbnMub25seSA6IGhhc1BhcnQgPyBvcHRpb25zLnBhcnQgOiBmYWxzZVxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29tcGFyZSA9IChhLCBiKSA9PiBhID09PSBiO1xuICAgIH1cblxuICAgIGxldCBtaXNzZXMgPSBmYWxzZTtcbiAgICBjb25zdCBtYXRjaGVzID0gbmV3IEFycmF5KHZhbHVlcy5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF0Y2hlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBtYXRjaGVzW2ldID0gMDtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHJlZiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgbGV0IHBhdHRlcm4gPSAnKCc7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1tpXTtcbiAgICAgICAgICAgIGV4cG9ydHMuYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycsICdDYW5ub3QgY29tcGFyZSBzdHJpbmcgcmVmZXJlbmNlIHRvIG5vbi1zdHJpbmcgdmFsdWUnKTtcbiAgICAgICAgICAgIHBhdHRlcm4gKz0gKGkgPyAnfCcgOiAnJykgKyBleHBvcnRzLmVzY2FwZVJlZ2V4KHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlZ2V4ID0gbmV3IFJlZ0V4cChwYXR0ZXJuICsgJyknLCAnZycpO1xuICAgICAgICBjb25zdCBsZWZ0b3ZlcnMgPSByZWYucmVwbGFjZShyZWdleCwgKCQwLCAkMSkgPT4ge1xuXG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHZhbHVlcy5pbmRleE9mKCQxKTtcbiAgICAgICAgICAgICsrbWF0Y2hlc1tpbmRleF07XG4gICAgICAgICAgICByZXR1cm4gJyc7ICAgICAgICAgIC8vIFJlbW92ZSBmcm9tIHN0cmluZ1xuICAgICAgICB9KTtcblxuICAgICAgICBtaXNzZXMgPSAhIWxlZnRvdmVycztcbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShyZWYpKSB7XG4gICAgICAgIGNvbnN0IG9ubHlPbmNlID0gISEob3B0aW9ucy5vbmx5ICYmIG9wdGlvbnMub25jZSk7XG4gICAgICAgIGlmIChvbmx5T25jZSAmJiByZWYubGVuZ3RoICE9PSB2YWx1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlZi5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgbGV0IG1hdGNoZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdmFsdWVzLmxlbmd0aCAmJiBtYXRjaGVkID09PSBmYWxzZTsgKytqKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFvbmx5T25jZSB8fCBtYXRjaGVzW2pdID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZWQgPSBjb21wYXJlKHZhbHVlc1tqXSwgcmVmW2ldLCBjb21wYXJlRmxhZ3MpICYmIGo7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobWF0Y2hlZCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICArK21hdGNoZXNbbWF0Y2hlZF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtaXNzZXMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBrZXlzID0gaW50ZXJuYWxzLmtleXMocmVmLCBvcHRpb25zKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgY29uc3QgcG9zID0gdmFsdWVzLmluZGV4T2Yoa2V5KTtcbiAgICAgICAgICAgIGlmIChwb3MgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlUGFpcnMgJiZcbiAgICAgICAgICAgICAgICAgICAgIWNvbXBhcmUodmFsdWVQYWlyc1trZXldLCByZWZba2V5XSwgY29tcGFyZUZsYWdzKSkge1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICArK21hdGNoZXNbcG9zXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1pc3NlcyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5vbmx5KSB7XG4gICAgICAgIGlmIChtaXNzZXMgfHwgIW9wdGlvbnMub25jZSkge1xuICAgICAgICAgICAgcmV0dXJuICFtaXNzZXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgcmVzdWx0ID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXRjaGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdCB8fCAhIW1hdGNoZXNbaV07XG4gICAgICAgIGlmICgob3B0aW9ucy5vbmNlICYmIG1hdGNoZXNbaV0gPiAxKSB8fFxuICAgICAgICAgICAgKCFvcHRpb25zLnBhcnQgJiYgIW1hdGNoZXNbaV0pKSB7XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8vIEZsYXR0ZW4gYXJyYXlcblxuZXhwb3J0cy5mbGF0dGVuID0gZnVuY3Rpb24gKGFycmF5LCB0YXJnZXQpIHtcblxuICAgIGNvbnN0IHJlc3VsdCA9IHRhcmdldCB8fCBbXTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyYXlbaV0pKSB7XG4gICAgICAgICAgICBleHBvcnRzLmZsYXR0ZW4oYXJyYXlbaV0sIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChhcnJheVtpXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG4vLyBDb252ZXJ0IGFuIG9iamVjdCBrZXkgY2hhaW4gc3RyaW5nICgnYS5iLmMnKSB0byByZWZlcmVuY2UgKG9iamVjdFthXVtiXVtjXSlcblxuZXhwb3J0cy5yZWFjaCA9IGZ1bmN0aW9uIChvYmosIGNoYWluLCBvcHRpb25zKSB7XG5cbiAgICBpZiAoY2hhaW4gPT09IGZhbHNlIHx8XG4gICAgICAgIGNoYWluID09PSBudWxsIHx8XG4gICAgICAgIGNoYWluID09PSB1bmRlZmluZWQpIHtcblxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgb3B0aW9ucyA9IHsgc2VwYXJhdG9yOiBvcHRpb25zIH07XG4gICAgfVxuXG4gICAgY29uc3QgaXNDaGFpbkFycmF5ID0gQXJyYXkuaXNBcnJheShjaGFpbik7XG5cbiAgICBleHBvcnRzLmFzc2VydCghaXNDaGFpbkFycmF5IHx8ICFvcHRpb25zLnNlcGFyYXRvciwgJ1NlcGFyYXRvciBvcHRpb24gbm8gdmFsaWQgZm9yIGFycmF5LWJhc2VkIGNoYWluJyk7XG5cbiAgICBjb25zdCBwYXRoID0gaXNDaGFpbkFycmF5ID8gY2hhaW4gOiBjaGFpbi5zcGxpdChvcHRpb25zLnNlcGFyYXRvciB8fCAnLicpO1xuICAgIGxldCByZWYgPSBvYmo7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGxldCBrZXkgPSBwYXRoW2ldO1xuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlZikpIHtcbiAgICAgICAgICAgIGNvbnN0IG51bWJlciA9IE51bWJlcihrZXkpO1xuXG4gICAgICAgICAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcihudW1iZXIpICYmIG51bWJlciA8IDApIHtcbiAgICAgICAgICAgICAgICBrZXkgPSByZWYubGVuZ3RoICsgbnVtYmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFyZWYgfHxcbiAgICAgICAgICAgICEoKHR5cGVvZiByZWYgPT09ICdvYmplY3QnIHx8IHR5cGVvZiByZWYgPT09ICdmdW5jdGlvbicpICYmIGtleSBpbiByZWYpIHx8XG4gICAgICAgICAgICAodHlwZW9mIHJlZiAhPT0gJ29iamVjdCcgJiYgb3B0aW9ucy5mdW5jdGlvbnMgPT09IGZhbHNlKSkgeyAgICAgICAgIC8vIE9ubHkgb2JqZWN0IGFuZCBmdW5jdGlvbiBjYW4gaGF2ZSBwcm9wZXJ0aWVzXG5cbiAgICAgICAgICAgIGV4cG9ydHMuYXNzZXJ0KCFvcHRpb25zLnN0cmljdCB8fCBpICsgMSA9PT0gcGF0aC5sZW5ndGgsICdNaXNzaW5nIHNlZ21lbnQnLCBrZXksICdpbiByZWFjaCBwYXRoICcsIGNoYWluKTtcbiAgICAgICAgICAgIGV4cG9ydHMuYXNzZXJ0KHR5cGVvZiByZWYgPT09ICdvYmplY3QnIHx8IG9wdGlvbnMuZnVuY3Rpb25zID09PSB0cnVlIHx8IHR5cGVvZiByZWYgIT09ICdmdW5jdGlvbicsICdJbnZhbGlkIHNlZ21lbnQnLCBrZXksICdpbiByZWFjaCBwYXRoICcsIGNoYWluKTtcbiAgICAgICAgICAgIHJlZiA9IG9wdGlvbnMuZGVmYXVsdDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVmID0gcmVmW2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlZjtcbn07XG5cblxuZXhwb3J0cy5yZWFjaFRlbXBsYXRlID0gZnVuY3Rpb24gKG9iaiwgdGVtcGxhdGUsIG9wdGlvbnMpIHtcblxuICAgIHJldHVybiB0ZW1wbGF0ZS5yZXBsYWNlKC97KFtefV0rKX0vZywgKCQwLCBjaGFpbikgPT4ge1xuXG4gICAgICAgIGNvbnN0IHZhbHVlID0gZXhwb3J0cy5yZWFjaChvYmosIGNoYWluLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsID8gJycgOiB2YWx1ZSk7XG4gICAgfSk7XG59O1xuXG5cbmV4cG9ydHMuYXNzZXJ0ID0gZnVuY3Rpb24gKGNvbmRpdGlvbiwgLi4uYXJncykge1xuXG4gICAgaWYgKGNvbmRpdGlvbikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAxICYmIGFyZ3NbMF0gaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICB0aHJvdyBhcmdzWzBdO1xuICAgIH1cblxuICAgIGNvbnN0IG1zZ3MgPSBhcmdzXG4gICAgICAgIC5maWx0ZXIoKGFyZykgPT4gYXJnICE9PSAnJylcbiAgICAgICAgLm1hcCgoYXJnKSA9PiB7XG5cbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyA/IGFyZyA6IGFyZyBpbnN0YW5jZW9mIEVycm9yID8gYXJnLm1lc3NhZ2UgOiBleHBvcnRzLnN0cmluZ2lmeShhcmcpO1xuICAgICAgICB9KTtcblxuICAgIHRocm93IG5ldyBBc3NlcnQuQXNzZXJ0aW9uRXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOiBtc2dzLmpvaW4oJyAnKSB8fCAnVW5rbm93biBlcnJvcicsXG4gICAgICAgIGFjdHVhbDogZmFsc2UsXG4gICAgICAgIGV4cGVjdGVkOiB0cnVlLFxuICAgICAgICBvcGVyYXRvcjogJz09JyxcbiAgICAgICAgc3RhY2tTdGFydEZ1bmN0aW9uOiBleHBvcnRzLmFzc2VydFxuICAgIH0pO1xufTtcblxuXG5leHBvcnRzLkJlbmNoID0gY2xhc3Mge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG5cbiAgICAgICAgdGhpcy50cyA9IDA7XG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICB9XG5cbiAgICByZXNldCgpIHtcblxuICAgICAgICB0aGlzLnRzID0gZXhwb3J0cy5CZW5jaC5ub3coKTtcbiAgICB9XG5cbiAgICBlbGFwc2VkKCkge1xuXG4gICAgICAgIHJldHVybiBleHBvcnRzLkJlbmNoLm5vdygpIC0gdGhpcy50cztcbiAgICB9XG5cbiAgICBzdGF0aWMgbm93KCkge1xuXG4gICAgICAgIGNvbnN0IHRzID0gcHJvY2Vzcy5ocnRpbWUoKTtcbiAgICAgICAgcmV0dXJuICh0c1swXSAqIDFlMykgKyAodHNbMV0gLyAxZTYpO1xuICAgIH1cbn07XG5cblxuLy8gRXNjYXBlIHN0cmluZyBmb3IgUmVnZXggY29uc3RydWN0aW9uXG5cbmV4cG9ydHMuZXNjYXBlUmVnZXggPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG5cbiAgICAvLyBFc2NhcGUgXiQuKistPz0hOnxcXC8oKVtde30sXG4gICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9bXFxeXFwkXFwuXFwqXFwrXFwtXFw/XFw9XFwhXFw6XFx8XFxcXFxcL1xcKFxcKVxcW1xcXVxce1xcfVxcLF0vZywgJ1xcXFwkJicpO1xufTtcblxuXG4vLyBFc2NhcGUgYXR0cmlidXRlIHZhbHVlIGZvciB1c2UgaW4gSFRUUCBoZWFkZXJcblxuZXhwb3J0cy5lc2NhcGVIZWFkZXJBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoYXR0cmlidXRlKSB7XG5cbiAgICAvLyBBbGxvd2VkIHZhbHVlIGNoYXJhY3RlcnM6ICEjJCUmJygpKissLS4vOjs8PT4/QFtdXl9ge3x9fiBhbmQgc3BhY2UsIGEteiwgQS1aLCAwLTksIFxcLCBcIlxuXG4gICAgZXhwb3J0cy5hc3NlcnQoL15bIFxcd1xcISNcXCQlJidcXChcXClcXCpcXCssXFwtXFwuXFwvXFw6OzxcXD0+XFw/QFxcW1xcXVxcXmBcXHtcXHxcXH1+XFxcIlxcXFxdKiQvLnRlc3QoYXR0cmlidXRlKSwgJ0JhZCBhdHRyaWJ1dGUgdmFsdWUgKCcgKyBhdHRyaWJ1dGUgKyAnKScpO1xuXG4gICAgcmV0dXJuIGF0dHJpYnV0ZS5yZXBsYWNlKC9cXFxcL2csICdcXFxcXFxcXCcpLnJlcGxhY2UoL1xcXCIvZywgJ1xcXFxcIicpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXNjYXBlIHF1b3RlcyBhbmQgc2xhc2hcbn07XG5cblxuZXhwb3J0cy5lc2NhcGVIdG1sID0gZnVuY3Rpb24gKHN0cmluZykge1xuXG4gICAgcmV0dXJuIEVzY2FwZS5lc2NhcGVIdG1sKHN0cmluZyk7XG59O1xuXG5cbmV4cG9ydHMuZXNjYXBlSnNvbiA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcblxuICAgIHJldHVybiBFc2NhcGUuZXNjYXBlSnNvbihzdHJpbmcpO1xufTtcblxuXG5leHBvcnRzLm9uY2UgPSBmdW5jdGlvbiAobWV0aG9kKSB7XG5cbiAgICBpZiAobWV0aG9kLl9ob2VrT25jZSkge1xuICAgICAgICByZXR1cm4gbWV0aG9kO1xuICAgIH1cblxuICAgIGxldCBvbmNlID0gZmFsc2U7XG4gICAgY29uc3Qgd3JhcHBlZCA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG5cbiAgICAgICAgaWYgKCFvbmNlKSB7XG4gICAgICAgICAgICBvbmNlID0gdHJ1ZTtcbiAgICAgICAgICAgIG1ldGhvZCguLi5hcmdzKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB3cmFwcGVkLl9ob2VrT25jZSA9IHRydWU7XG4gICAgcmV0dXJuIHdyYXBwZWQ7XG59O1xuXG5cbmV4cG9ydHMuaWdub3JlID0gZnVuY3Rpb24gKCkgeyB9O1xuXG5cbmV4cG9ydHMudW5pcXVlRmlsZW5hbWUgPSBmdW5jdGlvbiAocGF0aCwgZXh0ZW5zaW9uKSB7XG5cbiAgICBpZiAoZXh0ZW5zaW9uKSB7XG4gICAgICAgIGV4dGVuc2lvbiA9IGV4dGVuc2lvblswXSAhPT0gJy4nID8gJy4nICsgZXh0ZW5zaW9uIDogZXh0ZW5zaW9uO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZXh0ZW5zaW9uID0gJyc7XG4gICAgfVxuXG4gICAgcGF0aCA9IFBhdGgucmVzb2x2ZShwYXRoKTtcbiAgICBjb25zdCBuYW1lID0gW0RhdGUubm93KCksIHByb2Nlc3MucGlkLCBDcnlwdG8ucmFuZG9tQnl0ZXMoOCkudG9TdHJpbmcoJ2hleCcpXS5qb2luKCctJykgKyBleHRlbnNpb247XG4gICAgcmV0dXJuIFBhdGguam9pbihwYXRoLCBuYW1lKTtcbn07XG5cblxuZXhwb3J0cy5zdHJpbmdpZnkgPSBmdW5jdGlvbiAoLi4uYXJncykge1xuXG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5LmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiAnW0Nhbm5vdCBkaXNwbGF5IG9iamVjdDogJyArIGVyci5tZXNzYWdlICsgJ10nO1xuICAgIH1cbn07XG5cblxuZXhwb3J0cy53YWl0ID0gZnVuY3Rpb24gKHRpbWVvdXQpIHtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCB0aW1lb3V0KSk7XG59O1xuXG5cbmV4cG9ydHMuYmxvY2sgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoZXhwb3J0cy5pZ25vcmUpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0ge1xuICAgIGFycmF5OiBBcnJheS5wcm90b3R5cGUsXG4gICAgYnVmZmVyOiBCdWZmZXIucHJvdG90eXBlLFxuICAgIGRhdGU6IERhdGUucHJvdG90eXBlLFxuICAgIGVycm9yOiBFcnJvci5wcm90b3R5cGUsXG4gICAgZ2VuZXJpYzogT2JqZWN0LnByb3RvdHlwZSxcbiAgICBtYXA6IE1hcC5wcm90b3R5cGUsXG4gICAgcHJvbWlzZTogUHJvbWlzZS5wcm90b3R5cGUsXG4gICAgcmVnZXg6IFJlZ0V4cC5wcm90b3R5cGUsXG4gICAgc2V0OiBTZXQucHJvdG90eXBlLFxuICAgIHdlYWtNYXA6IFdlYWtNYXAucHJvdG90eXBlLFxuICAgIHdlYWtTZXQ6IFdlYWtTZXQucHJvdG90eXBlXG59O1xuXG5cbmludGVybmFscy50eXBlTWFwID0gbmV3IE1hcChbXG4gICAgWydbb2JqZWN0IEVycm9yXScsIGV4cG9ydHMuZXJyb3JdLFxuICAgIFsnW29iamVjdCBNYXBdJywgZXhwb3J0cy5tYXBdLFxuICAgIFsnW29iamVjdCBQcm9taXNlXScsIGV4cG9ydHMucHJvbWlzZV0sXG4gICAgWydbb2JqZWN0IFNldF0nLCBleHBvcnRzLnNldF0sXG4gICAgWydbb2JqZWN0IFdlYWtNYXBdJywgZXhwb3J0cy53ZWFrTWFwXSxcbiAgICBbJ1tvYmplY3QgV2Vha1NldF0nLCBleHBvcnRzLndlYWtTZXRdXG5dKTtcblxuXG5leHBvcnRzLmdldEludGVybmFsUHJvdG8gPSBmdW5jdGlvbiAob2JqKSB7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLmFycmF5O1xuICAgIH1cblxuICAgIGlmIChvYmogaW5zdGFuY2VvZiBCdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuYnVmZmVyO1xuICAgIH1cblxuICAgIGlmIChvYmogaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLmRhdGU7XG4gICAgfVxuXG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5yZWdleDtcbiAgICB9XG5cbiAgICBjb25zdCBvYmpOYW1lID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaik7XG4gICAgcmV0dXJuIGludGVybmFscy50eXBlTWFwLmdldChvYmpOYW1lKSB8fCBleHBvcnRzLmdlbmVyaWM7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBIb2VrID0gcmVxdWlyZSgnQGhhcGkvaG9laycpO1xuXG5jb25zdCBSZWYgPSByZXF1aXJlKCcuL3JlZicpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbmV4cG9ydHMuc2NoZW1hID0gZnVuY3Rpb24gKEpvaSwgY29uZmlnKSB7XG5cbiAgICBpZiAoY29uZmlnICE9PSB1bmRlZmluZWQgJiYgY29uZmlnICE9PSBudWxsICYmIHR5cGVvZiBjb25maWcgPT09ICdvYmplY3QnKSB7XG5cbiAgICAgICAgaWYgKGNvbmZpZy5pc0pvaSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvbmZpZykpIHtcbiAgICAgICAgICAgIHJldHVybiBKb2kuYWx0ZXJuYXRpdmVzKCkudHJ5KGNvbmZpZyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29uZmlnIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgICAgICByZXR1cm4gSm9pLnN0cmluZygpLnJlZ2V4KGNvbmZpZyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29uZmlnIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIEpvaS5kYXRlKCkudmFsaWQoY29uZmlnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBKb2kub2JqZWN0KCkua2V5cyhjb25maWcpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gSm9pLnN0cmluZygpLnZhbGlkKGNvbmZpZyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBKb2kubnVtYmVyKCkudmFsaWQoY29uZmlnKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiBKb2kuYm9vbGVhbigpLnZhbGlkKGNvbmZpZyk7XG4gICAgfVxuXG4gICAgaWYgKFJlZi5pc1JlZihjb25maWcpKSB7XG4gICAgICAgIHJldHVybiBKb2kudmFsaWQoY29uZmlnKTtcbiAgICB9XG5cbiAgICBIb2VrLmFzc2VydChjb25maWcgPT09IG51bGwsICdJbnZhbGlkIHNjaGVtYSBjb250ZW50OicsIGNvbmZpZyk7XG5cbiAgICByZXR1cm4gSm9pLnZhbGlkKG51bGwpO1xufTtcblxuXG5leHBvcnRzLnJlZiA9IGZ1bmN0aW9uIChpZCkge1xuXG4gICAgcmV0dXJuIFJlZi5pc1JlZihpZCkgPyBpZCA6IFJlZi5jcmVhdGUoaWQpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgSG9layA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsnKTtcblxuY29uc3QgTGFuZ3VhZ2UgPSByZXF1aXJlKCcuL2xhbmd1YWdlJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge1xuICAgIGFubm90YXRpb25zOiBTeW1ib2woJ2pvaS1hbm5vdGF0aW9ucycpXG59O1xuXG5cbmludGVybmFscy5zdHJpbmdpZnkgPSBmdW5jdGlvbiAodmFsdWUsIHdyYXBBcnJheXMpIHtcblxuICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cbiAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICdudWxsJztcbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIGV4cG9ydHMuRXJyIHx8IHR5cGUgPT09ICdmdW5jdGlvbicgfHwgdHlwZSA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgbGV0IHBhcnRpYWwgPSAnJztcblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHBhcnRpYWwgPSBwYXJ0aWFsICsgKHBhcnRpYWwubGVuZ3RoID8gJywgJyA6ICcnKSArIGludGVybmFscy5zdHJpbmdpZnkodmFsdWVbaV0sIHdyYXBBcnJheXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gd3JhcEFycmF5cyA/ICdbJyArIHBhcnRpYWwgKyAnXScgOiBwYXJ0aWFsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbn07XG5cblxuZXhwb3J0cy5FcnIgPSBjbGFzcyB7XG5cbiAgICBjb25zdHJ1Y3Rvcih0eXBlLCBjb250ZXh0LCBzdGF0ZSwgb3B0aW9ucywgZmxhZ3MsIG1lc3NhZ2UsIHRlbXBsYXRlKSB7XG5cbiAgICAgICAgdGhpcy5pc0pvaSA9IHRydWU7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQgfHwge307XG4gICAgICAgIHRoaXMuY29udGV4dC5rZXkgPSBzdGF0ZS5wYXRoW3N0YXRlLnBhdGgubGVuZ3RoIC0gMV07XG4gICAgICAgIHRoaXMuY29udGV4dC5sYWJlbCA9IHN0YXRlLmtleTtcbiAgICAgICAgdGhpcy5wYXRoID0gc3RhdGUucGF0aDtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5mbGFncyA9IGZsYWdzO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gdGVtcGxhdGU7XG5cbiAgICAgICAgY29uc3QgbG9jYWxpemVkID0gdGhpcy5vcHRpb25zLmxhbmd1YWdlO1xuXG4gICAgICAgIGlmICh0aGlzLmZsYWdzLmxhYmVsKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQubGFiZWwgPSB0aGlzLmZsYWdzLmxhYmVsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxvY2FsaXplZCAmJiAgICAgICAgICAgICAgICAgICAvLyBsYW5ndWFnZSBjYW4gYmUgbnVsbCBmb3IgYXJyYXlzIGV4Y2x1c2lvbiBjaGVja1xuICAgICAgICAgICAgKHRoaXMuY29udGV4dC5sYWJlbCA9PT0gJycgfHxcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5sYWJlbCA9PT0gbnVsbCkpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5sYWJlbCA9IGxvY2FsaXplZC5yb290IHx8IExhbmd1YWdlLmVycm9ycy5yb290O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdG9TdHJpbmcoKSB7XG5cbiAgICAgICAgaWYgKHRoaXMubWVzc2FnZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBmb3JtYXQ7XG5cbiAgICAgICAgaWYgKHRoaXMudGVtcGxhdGUpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IHRoaXMudGVtcGxhdGU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBsb2NhbGl6ZWQgPSB0aGlzLm9wdGlvbnMubGFuZ3VhZ2U7XG5cbiAgICAgICAgZm9ybWF0ID0gZm9ybWF0IHx8IEhvZWsucmVhY2gobG9jYWxpemVkLCB0aGlzLnR5cGUpIHx8IEhvZWsucmVhY2goTGFuZ3VhZ2UuZXJyb3JzLCB0aGlzLnR5cGUpO1xuXG4gICAgICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGBFcnJvciBjb2RlIFwiJHt0aGlzLnR5cGV9XCIgaXMgbm90IGRlZmluZWQsIHlvdXIgY3VzdG9tIHR5cGUgaXMgbWlzc2luZyB0aGUgY29ycmVjdCBsYW5ndWFnZSBkZWZpbml0aW9uYDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCB3cmFwQXJyYXlzID0gSG9lay5yZWFjaChsb2NhbGl6ZWQsICdtZXNzYWdlcy53cmFwQXJyYXlzJyk7XG4gICAgICAgIGlmICh0eXBlb2Ygd3JhcEFycmF5cyAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICB3cmFwQXJyYXlzID0gTGFuZ3VhZ2UuZXJyb3JzLm1lc3NhZ2VzLndyYXBBcnJheXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZm9ybWF0ID09PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZHJlblN0cmluZyA9IGludGVybmFscy5zdHJpbmdpZnkodGhpcy5jb250ZXh0LnJlYXNvbiwgd3JhcEFycmF5cyk7XG4gICAgICAgICAgICBpZiAod3JhcEFycmF5cykge1xuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZHJlblN0cmluZy5zbGljZSgxLCAtMSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBjaGlsZHJlblN0cmluZztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGhhc0tleSA9IC97eyE/bGFiZWx9fS8udGVzdChmb3JtYXQpO1xuICAgICAgICBjb25zdCBza2lwS2V5ID0gZm9ybWF0Lmxlbmd0aCA+IDIgJiYgZm9ybWF0WzBdID09PSAnIScgJiYgZm9ybWF0WzFdID09PSAnISc7XG5cbiAgICAgICAgaWYgKHNraXBLZXkpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5zbGljZSgyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaGFzS2V5ICYmICFza2lwS2V5KSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbGl6ZWRLZXkgPSBIb2VrLnJlYWNoKGxvY2FsaXplZCwgJ2tleScpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBsb2NhbGl6ZWRLZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgZm9ybWF0ID0gbG9jYWxpemVkS2V5ICsgZm9ybWF0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9ybWF0ID0gSG9lay5yZWFjaChMYW5ndWFnZS5lcnJvcnMsICdrZXknKSArIGZvcm1hdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAgZm9ybWF0LnJlcGxhY2UoL3t7KCE/KShbXn1dKyl9fS9nLCAoJDAsIGlzU2VjdXJlLCBuYW1lKSA9PiB7XG5cbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gSG9lay5yZWFjaCh0aGlzLmNvbnRleHQsIG5hbWUpO1xuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IGludGVybmFscy5zdHJpbmdpZnkodmFsdWUsIHdyYXBBcnJheXMpO1xuICAgICAgICAgICAgcmV0dXJuIChpc1NlY3VyZSAmJiB0aGlzLm9wdGlvbnMuZXNjYXBlSHRtbCA/IEhvZWsuZXNjYXBlSHRtbChub3JtYWxpemVkKSA6IG5vcm1hbGl6ZWQpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnRvU3RyaW5nID0gKCkgPT4gbWVzc2FnZTsgIC8vIFBlcnNpc3QgcmVzdWx0IG9mIGxhc3QgdG9TdHJpbmcgY2FsbCwgaXQgd29uJ3QgY2hhbmdlXG5cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuXG59O1xuXG5cbmV4cG9ydHMuY3JlYXRlID0gZnVuY3Rpb24gKHR5cGUsIGNvbnRleHQsIHN0YXRlLCBvcHRpb25zLCBmbGFncywgbWVzc2FnZSwgdGVtcGxhdGUpIHtcblxuICAgIHJldHVybiBuZXcgZXhwb3J0cy5FcnIodHlwZSwgY29udGV4dCwgc3RhdGUsIG9wdGlvbnMsIGZsYWdzLCBtZXNzYWdlLCB0ZW1wbGF0ZSk7XG59O1xuXG5cbmV4cG9ydHMucHJvY2VzcyA9IGZ1bmN0aW9uIChlcnJvcnMsIG9iamVjdCkge1xuXG4gICAgaWYgKCFlcnJvcnMpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gQ29uc3RydWN0IGVycm9yXG5cbiAgICBsZXQgbWVzc2FnZSA9ICcnO1xuICAgIGNvbnN0IGRldGFpbHMgPSBbXTtcblxuICAgIGNvbnN0IHByb2Nlc3NFcnJvcnMgPSBmdW5jdGlvbiAobG9jYWxFcnJvcnMsIHBhcmVudCwgb3ZlcnJpZGVNZXNzYWdlKSB7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsb2NhbEVycm9ycy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IGxvY2FsRXJyb3JzW2ldO1xuXG4gICAgICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpdGVtLmZsYWdzLmVycm9yICYmIHR5cGVvZiBpdGVtLmZsYWdzLmVycm9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpdGVtLmZsYWdzLnNlbGZFcnJvciB8fCAhaXRlbS5jb250ZXh0LnJlYXNvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbS5mbGFncy5lcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBpdGVtTWVzc2FnZTtcbiAgICAgICAgICAgIGlmIChwYXJlbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGl0ZW1NZXNzYWdlID0gaXRlbS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlICsgKG1lc3NhZ2UgPyAnLiAnIDogJycpICsgaXRlbU1lc3NhZ2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIERvIG5vdCBwdXNoIGludGVybWVkaWF0ZSBlcnJvcnMsIHdlJ3JlIG9ubHkgaW50ZXJlc3RlZCBpbiBsZWFmc1xuXG4gICAgICAgICAgICBpZiAoaXRlbS5jb250ZXh0LnJlYXNvbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IG92ZXJyaWRlID0gcHJvY2Vzc0Vycm9ycyhpdGVtLmNvbnRleHQucmVhc29uLCBpdGVtLnBhdGgsIGl0ZW0udHlwZSA9PT0gJ292ZXJyaWRlJyA/IGl0ZW0ubWVzc2FnZSA6IG51bGwpO1xuICAgICAgICAgICAgICAgIGlmIChvdmVycmlkZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3ZlcnJpZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGV0YWlscy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogb3ZlcnJpZGVNZXNzYWdlIHx8IGl0ZW1NZXNzYWdlIHx8IGl0ZW0udG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogaXRlbS5wYXRoLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBpdGVtLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IGl0ZW0uY29udGV4dFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IG92ZXJyaWRlID0gcHJvY2Vzc0Vycm9ycyhlcnJvcnMpO1xuICAgIGlmIChvdmVycmlkZSkge1xuICAgICAgICByZXR1cm4gb3ZlcnJpZGU7XG4gICAgfVxuXG4gICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgZXJyb3IuaXNKb2kgPSB0cnVlO1xuICAgIGVycm9yLm5hbWUgPSAnVmFsaWRhdGlvbkVycm9yJztcbiAgICBlcnJvci5kZXRhaWxzID0gZGV0YWlscztcbiAgICBlcnJvci5fb2JqZWN0ID0gb2JqZWN0O1xuICAgIGVycm9yLmFubm90YXRlID0gaW50ZXJuYWxzLmFubm90YXRlO1xuICAgIHJldHVybiBlcnJvcjtcbn07XG5cblxuLy8gSW5zcGlyZWQgYnkganNvbi1zdHJpbmdpZnktc2FmZVxuXG5pbnRlcm5hbHMuc2FmZVN0cmluZ2lmeSA9IGZ1bmN0aW9uIChvYmosIHNwYWNlcykge1xuXG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9iaiwgaW50ZXJuYWxzLnNlcmlhbGl6ZXIoKSwgc3BhY2VzKTtcbn07XG5cblxuaW50ZXJuYWxzLnNlcmlhbGl6ZXIgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICBjb25zdCBrZXlzID0gW107XG4gICAgY29uc3Qgc3RhY2sgPSBbXTtcblxuICAgIGNvbnN0IGN5Y2xlUmVwbGFjZXIgPSAoa2V5LCB2YWx1ZSkgPT4ge1xuXG4gICAgICAgIGlmIChzdGFja1swXSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiAnW0NpcmN1bGFyIH5dJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAnW0NpcmN1bGFyIH4uJyArIGtleXMuc2xpY2UoMCwgc3RhY2suaW5kZXhPZih2YWx1ZSkpLmpvaW4oJy4nKSArICddJztcbiAgICB9O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG5cbiAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHRoaXNQb3MgPSBzdGFjay5pbmRleE9mKHRoaXMpO1xuICAgICAgICAgICAgaWYgKH50aGlzUG9zKSB7XG4gICAgICAgICAgICAgICAgc3RhY2subGVuZ3RoID0gdGhpc1BvcyArIDE7XG4gICAgICAgICAgICAgICAga2V5cy5sZW5ndGggPSB0aGlzUG9zICsgMTtcbiAgICAgICAgICAgICAgICBrZXlzW3RoaXNQb3NdID0ga2V5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhY2sucHVzaCh0aGlzKTtcbiAgICAgICAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKH5zdGFjay5pbmRleE9mKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gY3ljbGVSZXBsYWNlci5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhY2sucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGFubm90YXRpb25zID0gdmFsdWVbaW50ZXJuYWxzLmFubm90YXRpb25zXTtcbiAgICAgICAgICAgIGlmIChhbm5vdGF0aW9ucykge1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhbm5vdGF0ZWQgPSBbXTtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYW5ub3RhdGlvbnMuZXJyb3JzW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5ub3RhdGVkLnB1c2goYF8kaWR4JF8ke2Fubm90YXRpb25zLmVycm9yc1tpXS5zb3J0KCkuam9pbignLCAnKX1fJGVuZCRfYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGFubm90YXRlZC5wdXNoKHZhbHVlW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gYW5ub3RhdGVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3JLZXlzID0gT2JqZWN0LmtleXMoYW5ub3RhdGlvbnMuZXJyb3JzKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlcnJvcktleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yS2V5ID0gZXJyb3JLZXlzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVbYCR7ZXJyb3JLZXl9XyRrZXkkXyR7YW5ub3RhdGlvbnMuZXJyb3JzW2Vycm9yS2V5XS5zb3J0KCkuam9pbignLCAnKX1fJGVuZCRfYF0gPSB2YWx1ZVtlcnJvcktleV07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVtlcnJvcktleV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBtaXNzaW5nS2V5cyA9IE9iamVjdC5rZXlzKGFubm90YXRpb25zLm1pc3NpbmcpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1pc3NpbmdLZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtaXNzaW5nS2V5ID0gbWlzc2luZ0tleXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVtgXyRtaXNzJF8ke21pc3NpbmdLZXl9fCR7YW5ub3RhdGlvbnMubWlzc2luZ1ttaXNzaW5nS2V5XX1fJGVuZCRfYF0gPSAnX19taXNzaW5nX18nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSBJbmZpbml0eSB8fCB2YWx1ZSA9PT0gLUluZmluaXR5IHx8IE51bWJlci5pc05hTih2YWx1ZSkgfHxcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1snICsgdmFsdWUudG9TdHJpbmcoKSArICddJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xufTtcblxuXG5pbnRlcm5hbHMuYW5ub3RhdGUgPSBmdW5jdGlvbiAoc3RyaXBDb2xvckNvZGVzKSB7XG5cbiAgICBjb25zdCByZWRGZ0VzY2FwZSA9IHN0cmlwQ29sb3JDb2RlcyA/ICcnIDogJ1xcdTAwMWJbMzFtJztcbiAgICBjb25zdCByZWRCZ0VzY2FwZSA9IHN0cmlwQ29sb3JDb2RlcyA/ICcnIDogJ1xcdTAwMWJbNDFtJztcbiAgICBjb25zdCBlbmRDb2xvciA9IHN0cmlwQ29sb3JDb2RlcyA/ICcnIDogJ1xcdTAwMWJbMG0nO1xuXG4gICAgaWYgKHR5cGVvZiB0aGlzLl9vYmplY3QgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRldGFpbHNbMF0ubWVzc2FnZTtcbiAgICB9XG5cbiAgICBjb25zdCBvYmogPSBIb2VrLmNsb25lKHRoaXMuX29iamVjdCB8fCB7fSk7XG5cbiAgICBmb3IgKGxldCBpID0gdGhpcy5kZXRhaWxzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7ICAgICAgICAvLyBSZXZlcnNlIG9yZGVyIHRvIHByb2Nlc3MgZGVlcGVzdCBjaGlsZCBmaXJzdFxuICAgICAgICBjb25zdCBwb3MgPSBpICsgMTtcbiAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmRldGFpbHNbaV07XG4gICAgICAgIGNvbnN0IHBhdGggPSBlcnJvci5wYXRoO1xuICAgICAgICBsZXQgcmVmID0gb2JqO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgOyArK2opIHtcbiAgICAgICAgICAgIGNvbnN0IHNlZyA9IHBhdGhbal07XG5cbiAgICAgICAgICAgIGlmIChyZWYuaXNJbW11dGFibGUpIHtcbiAgICAgICAgICAgICAgICByZWYgPSByZWYuY2xvbmUoKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBqb2kgc2NoZW1hcyBhcmUgbm90IGNsb25lZCBieSBob2VrLCB3ZSBoYXZlIHRvIHRha2UgdGhpcyBleHRyYSBzdGVwXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChqICsgMSA8IHBhdGgubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgcmVmW3NlZ10gJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgcmVmW3NlZ10gIT09ICdzdHJpbmcnKSB7XG5cbiAgICAgICAgICAgICAgICByZWYgPSByZWZbc2VnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZkFubm90YXRpb25zID0gcmVmW2ludGVybmFscy5hbm5vdGF0aW9uc10gPSByZWZbaW50ZXJuYWxzLmFubm90YXRpb25zXSB8fCB7IGVycm9yczoge30sIG1pc3Npbmc6IHt9IH07XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSByZWZbc2VnXTtcbiAgICAgICAgICAgICAgICBjb25zdCBjYWNoZUtleSA9IHNlZyB8fCBlcnJvci5jb250ZXh0LmxhYmVsO1xuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVmQW5ub3RhdGlvbnMuZXJyb3JzW2NhY2hlS2V5XSA9IHJlZkFubm90YXRpb25zLmVycm9yc1tjYWNoZUtleV0gfHwgW107XG4gICAgICAgICAgICAgICAgICAgIHJlZkFubm90YXRpb25zLmVycm9yc1tjYWNoZUtleV0ucHVzaChwb3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVmQW5ub3RhdGlvbnMubWlzc2luZ1tjYWNoZUtleV0gPSBwb3M7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCByZXBsYWNlcnMgPSB7XG4gICAgICAgIGtleTogL19cXCRrZXlcXCRfKFssIFxcZF0rKV9cXCRlbmRcXCRfXCIvZyxcbiAgICAgICAgbWlzc2luZzogL1wiX1xcJG1pc3NcXCRfKFtefF0rKVxcfChcXGQrKV9cXCRlbmRcXCRfXCI6IFwiX19taXNzaW5nX19cIi9nLFxuICAgICAgICBhcnJheUluZGV4OiAvXFxzKlwiX1xcJGlkeFxcJF8oWywgXFxkXSspX1xcJGVuZFxcJF9cIiw/XFxuKC4qKS9nLFxuICAgICAgICBzcGVjaWFsczogL1wiXFxbKE5hTnxTeW1ib2wuKnwtP0luZmluaXR5fGZ1bmN0aW9uLip8XFwoLiopXVwiL2dcbiAgICB9O1xuXG4gICAgbGV0IG1lc3NhZ2UgPSBpbnRlcm5hbHMuc2FmZVN0cmluZ2lmeShvYmosIDIpXG4gICAgICAgIC5yZXBsYWNlKHJlcGxhY2Vycy5rZXksICgkMCwgJDEpID0+IGBcIiAke3JlZEZnRXNjYXBlfVskeyQxfV0ke2VuZENvbG9yfWApXG4gICAgICAgIC5yZXBsYWNlKHJlcGxhY2Vycy5taXNzaW5nLCAoJDAsICQxLCAkMikgPT4gYCR7cmVkQmdFc2NhcGV9XCIkeyQxfVwiJHtlbmRDb2xvcn0ke3JlZEZnRXNjYXBlfSBbJHskMn1dOiAtLSBtaXNzaW5nIC0tJHtlbmRDb2xvcn1gKVxuICAgICAgICAucmVwbGFjZShyZXBsYWNlcnMuYXJyYXlJbmRleCwgKCQwLCAkMSwgJDIpID0+IGBcXG4keyQyfSAke3JlZEZnRXNjYXBlfVskeyQxfV0ke2VuZENvbG9yfWApXG4gICAgICAgIC5yZXBsYWNlKHJlcGxhY2Vycy5zcGVjaWFscywgKCQwLCAkMSkgPT4gJDEpO1xuXG4gICAgbWVzc2FnZSA9IGAke21lc3NhZ2V9XFxuJHtyZWRGZ0VzY2FwZX1gO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmRldGFpbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgcG9zID0gaSArIDE7XG4gICAgICAgIG1lc3NhZ2UgPSBgJHttZXNzYWdlfVxcblske3Bvc31dICR7dGhpcy5kZXRhaWxzW2ldLm1lc3NhZ2V9YDtcbiAgICB9XG5cbiAgICBtZXNzYWdlID0gbWVzc2FnZSArIGVuZENvbG9yO1xuXG4gICAgcmV0dXJuIG1lc3NhZ2U7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBIb2VrID0gcmVxdWlyZSgnQGhhcGkvaG9laycpO1xuXG5jb25zdCBBbnkgPSByZXF1aXJlKCcuL3R5cGVzL2FueScpO1xuY29uc3QgQ2FzdCA9IHJlcXVpcmUoJy4vY2FzdCcpO1xuY29uc3QgRXJyb3JzID0gcmVxdWlyZSgnLi9lcnJvcnMnKTtcbmNvbnN0IExhenkgPSByZXF1aXJlKCcuL3R5cGVzL2xhenknKTtcbmNvbnN0IFJlZiA9IHJlcXVpcmUoJy4vcmVmJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge1xuICAgIGFsdGVybmF0aXZlczogcmVxdWlyZSgnLi90eXBlcy9hbHRlcm5hdGl2ZXMnKSxcbiAgICBhcnJheTogcmVxdWlyZSgnLi90eXBlcy9hcnJheScpLFxuICAgIGJvb2xlYW46IHJlcXVpcmUoJy4vdHlwZXMvYm9vbGVhbicpLFxuICAgIGJpbmFyeTogcmVxdWlyZSgnLi90eXBlcy9iaW5hcnknKSxcbiAgICBkYXRlOiByZXF1aXJlKCcuL3R5cGVzL2RhdGUnKSxcbiAgICBmdW5jOiByZXF1aXJlKCcuL3R5cGVzL2Z1bmMnKSxcbiAgICBudW1iZXI6IHJlcXVpcmUoJy4vdHlwZXMvbnVtYmVyJyksXG4gICAgb2JqZWN0OiByZXF1aXJlKCcuL3R5cGVzL29iamVjdCcpLFxuICAgIHN0cmluZzogcmVxdWlyZSgnLi90eXBlcy9zdHJpbmcnKSxcbiAgICBzeW1ib2w6IHJlcXVpcmUoJy4vdHlwZXMvc3ltYm9sJylcbn07XG5cblxuaW50ZXJuYWxzLmNhbGxXaXRoRGVmYXVsdHMgPSBmdW5jdGlvbiAoc2NoZW1hLCBhcmdzKSB7XG5cbiAgICBIb2VrLmFzc2VydCh0aGlzLCAnTXVzdCBiZSBpbnZva2VkIG9uIGEgSm9pIGluc3RhbmNlLicpO1xuXG4gICAgaWYgKHRoaXMuX2RlZmF1bHRzKSB7XG4gICAgICAgIHNjaGVtYSA9IHRoaXMuX2RlZmF1bHRzKHNjaGVtYSk7XG4gICAgfVxuXG4gICAgc2NoZW1hLl9jdXJyZW50Sm9pID0gdGhpcztcblxuICAgIHJldHVybiBzY2hlbWEuX2luaXQoLi4uYXJncyk7XG59O1xuXG5cbmludGVybmFscy5yb290ID0gZnVuY3Rpb24gKCkge1xuXG4gICAgY29uc3QgYW55ID0gbmV3IEFueSgpO1xuXG4gICAgY29uc3Qgcm9vdCA9IGFueS5jbG9uZSgpO1xuICAgIEFueS5wcm90b3R5cGUuX2N1cnJlbnRKb2kgPSByb290O1xuICAgIHJvb3QuX2N1cnJlbnRKb2kgPSByb290O1xuICAgIHJvb3QuX2JpbmRzID0gbmV3IFNldChbJ2FueScsICdhbHRlcm5hdGl2ZXMnLCAnYWx0JywgJ2FycmF5JywgJ2Jvb2wnLCAnYm9vbGVhbicsICdiaW5hcnknLCAnZGF0ZScsICdmdW5jJywgJ251bWJlcicsICdvYmplY3QnLCAnc3RyaW5nJywgJ3N5bWJvbCcsICd2YWxpZGF0ZScsICdkZXNjcmliZScsICdjb21waWxlJywgJ2Fzc2VydCcsICdhdHRlbXB0JywgJ2xhenknLCAnZGVmYXVsdHMnLCAnZXh0ZW5kJywgJ2FsbG93JywgJ3ZhbGlkJywgJ29ubHknLCAnZXF1YWwnLCAnaW52YWxpZCcsICdkaXNhbGxvdycsICdub3QnLCAncmVxdWlyZWQnLCAnZXhpc3QnLCAnb3B0aW9uYWwnLCAnZm9yYmlkZGVuJywgJ3N0cmlwJywgJ3doZW4nLCAnZW1wdHknLCAnZGVmYXVsdCddKTtcblxuICAgIHJvb3QuYW55ID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcblxuICAgICAgICBIb2VrLmFzc2VydChhcmdzLmxlbmd0aCA9PT0gMCwgJ0pvaS5hbnkoKSBkb2VzIG5vdCBhbGxvdyBhcmd1bWVudHMuJyk7XG5cbiAgICAgICAgcmV0dXJuIGludGVybmFscy5jYWxsV2l0aERlZmF1bHRzLmNhbGwodGhpcywgYW55LCBhcmdzKTtcbiAgICB9O1xuXG4gICAgcm9vdC5hbHRlcm5hdGl2ZXMgPSByb290LmFsdCA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG5cbiAgICAgICAgcmV0dXJuIGludGVybmFscy5jYWxsV2l0aERlZmF1bHRzLmNhbGwodGhpcywgaW50ZXJuYWxzLmFsdGVybmF0aXZlcywgYXJncyk7XG4gICAgfTtcblxuICAgIHJvb3QuYXJyYXkgPSBmdW5jdGlvbiAoLi4uYXJncykge1xuXG4gICAgICAgIEhvZWsuYXNzZXJ0KGFyZ3MubGVuZ3RoID09PSAwLCAnSm9pLmFycmF5KCkgZG9lcyBub3QgYWxsb3cgYXJndW1lbnRzLicpO1xuXG4gICAgICAgIHJldHVybiBpbnRlcm5hbHMuY2FsbFdpdGhEZWZhdWx0cy5jYWxsKHRoaXMsIGludGVybmFscy5hcnJheSwgYXJncyk7XG4gICAgfTtcblxuICAgIHJvb3QuYm9vbGVhbiA9IHJvb3QuYm9vbCA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG5cbiAgICAgICAgSG9lay5hc3NlcnQoYXJncy5sZW5ndGggPT09IDAsICdKb2kuYm9vbGVhbigpIGRvZXMgbm90IGFsbG93IGFyZ3VtZW50cy4nKTtcblxuICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmNhbGxXaXRoRGVmYXVsdHMuY2FsbCh0aGlzLCBpbnRlcm5hbHMuYm9vbGVhbiwgYXJncyk7XG4gICAgfTtcblxuICAgIHJvb3QuYmluYXJ5ID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcblxuICAgICAgICBIb2VrLmFzc2VydChhcmdzLmxlbmd0aCA9PT0gMCwgJ0pvaS5iaW5hcnkoKSBkb2VzIG5vdCBhbGxvdyBhcmd1bWVudHMuJyk7XG5cbiAgICAgICAgcmV0dXJuIGludGVybmFscy5jYWxsV2l0aERlZmF1bHRzLmNhbGwodGhpcywgaW50ZXJuYWxzLmJpbmFyeSwgYXJncyk7XG4gICAgfTtcblxuICAgIHJvb3QuZGF0ZSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG5cbiAgICAgICAgSG9lay5hc3NlcnQoYXJncy5sZW5ndGggPT09IDAsICdKb2kuZGF0ZSgpIGRvZXMgbm90IGFsbG93IGFyZ3VtZW50cy4nKTtcblxuICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmNhbGxXaXRoRGVmYXVsdHMuY2FsbCh0aGlzLCBpbnRlcm5hbHMuZGF0ZSwgYXJncyk7XG4gICAgfTtcblxuICAgIHJvb3QuZnVuYyA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG5cbiAgICAgICAgSG9lay5hc3NlcnQoYXJncy5sZW5ndGggPT09IDAsICdKb2kuZnVuYygpIGRvZXMgbm90IGFsbG93IGFyZ3VtZW50cy4nKTtcblxuICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmNhbGxXaXRoRGVmYXVsdHMuY2FsbCh0aGlzLCBpbnRlcm5hbHMuZnVuYywgYXJncyk7XG4gICAgfTtcblxuICAgIHJvb3QubnVtYmVyID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcblxuICAgICAgICBIb2VrLmFzc2VydChhcmdzLmxlbmd0aCA9PT0gMCwgJ0pvaS5udW1iZXIoKSBkb2VzIG5vdCBhbGxvdyBhcmd1bWVudHMuJyk7XG5cbiAgICAgICAgcmV0dXJuIGludGVybmFscy5jYWxsV2l0aERlZmF1bHRzLmNhbGwodGhpcywgaW50ZXJuYWxzLm51bWJlciwgYXJncyk7XG4gICAgfTtcblxuICAgIHJvb3Qub2JqZWN0ID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcblxuICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmNhbGxXaXRoRGVmYXVsdHMuY2FsbCh0aGlzLCBpbnRlcm5hbHMub2JqZWN0LCBhcmdzKTtcbiAgICB9O1xuXG4gICAgcm9vdC5zdHJpbmcgPSBmdW5jdGlvbiAoLi4uYXJncykge1xuXG4gICAgICAgIEhvZWsuYXNzZXJ0KGFyZ3MubGVuZ3RoID09PSAwLCAnSm9pLnN0cmluZygpIGRvZXMgbm90IGFsbG93IGFyZ3VtZW50cy4nKTtcblxuICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmNhbGxXaXRoRGVmYXVsdHMuY2FsbCh0aGlzLCBpbnRlcm5hbHMuc3RyaW5nLCBhcmdzKTtcbiAgICB9O1xuXG4gICAgcm9vdC5zeW1ib2wgPSBmdW5jdGlvbiAoLi4uYXJncykge1xuXG4gICAgICAgIEhvZWsuYXNzZXJ0KGFyZ3MubGVuZ3RoID09PSAwLCAnSm9pLnN5bWJvbCgpIGRvZXMgbm90IGFsbG93IGFyZ3VtZW50cy4nKTtcblxuICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmNhbGxXaXRoRGVmYXVsdHMuY2FsbCh0aGlzLCBpbnRlcm5hbHMuc3ltYm9sLCBhcmdzKTtcbiAgICB9O1xuXG4gICAgcm9vdC5yZWYgPSBmdW5jdGlvbiAoLi4uYXJncykge1xuXG4gICAgICAgIHJldHVybiBSZWYuY3JlYXRlKC4uLmFyZ3MpO1xuICAgIH07XG5cbiAgICByb290LmlzUmVmID0gZnVuY3Rpb24gKHJlZikge1xuXG4gICAgICAgIHJldHVybiBSZWYuaXNSZWYocmVmKTtcbiAgICB9O1xuXG4gICAgcm9vdC52YWxpZGF0ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgLi4uYXJncyAvKiwgW3NjaGVtYV0sIFtvcHRpb25zXSwgY2FsbGJhY2sgKi8pIHtcblxuICAgICAgICBjb25zdCBsYXN0ID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdO1xuICAgICAgICBjb25zdCBjYWxsYmFjayA9IHR5cGVvZiBsYXN0ID09PSAnZnVuY3Rpb24nID8gbGFzdCA6IG51bGw7XG5cbiAgICAgICAgY29uc3QgY291bnQgPSBhcmdzLmxlbmd0aCAtIChjYWxsYmFjayA/IDEgOiAwKTtcbiAgICAgICAgaWYgKGNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gYW55LnZhbGlkYXRlKHZhbHVlLCBjYWxsYmFjayk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBvcHRpb25zID0gY291bnQgPT09IDIgPyBhcmdzWzFdIDogdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBzY2hlbWEgPSB0aGlzLmNvbXBpbGUoYXJnc1swXSk7XG5cbiAgICAgICAgcmV0dXJuIHNjaGVtYS5fdmFsaWRhdGVXaXRoT3B0aW9ucyh2YWx1ZSwgb3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICByb290LmRlc2NyaWJlID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcblxuICAgICAgICBjb25zdCBzY2hlbWEgPSBhcmdzLmxlbmd0aCA/IHRoaXMuY29tcGlsZShhcmdzWzBdKSA6IGFueTtcbiAgICAgICAgcmV0dXJuIHNjaGVtYS5kZXNjcmliZSgpO1xuICAgIH07XG5cbiAgICByb290LmNvbXBpbGUgPSBmdW5jdGlvbiAoc2NoZW1hKSB7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBDYXN0LnNjaGVtYSh0aGlzLCBzY2hlbWEpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIuaGFzT3duUHJvcGVydHkoJ3BhdGgnKSkge1xuICAgICAgICAgICAgICAgIGVyci5tZXNzYWdlID0gZXJyLm1lc3NhZ2UgKyAnKCcgKyBlcnIucGF0aCArICcpJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHJvb3QuYXNzZXJ0ID0gZnVuY3Rpb24gKHZhbHVlLCBzY2hlbWEsIG1lc3NhZ2UpIHtcblxuICAgICAgICB0aGlzLmF0dGVtcHQodmFsdWUsIHNjaGVtYSwgbWVzc2FnZSk7XG4gICAgfTtcblxuICAgIHJvb3QuYXR0ZW1wdCA9IGZ1bmN0aW9uICh2YWx1ZSwgc2NoZW1hLCBtZXNzYWdlKSB7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy52YWxpZGF0ZSh2YWx1ZSwgc2NoZW1hKTtcbiAgICAgICAgY29uc3QgZXJyb3IgPSByZXN1bHQuZXJyb3I7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKCFtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlcnJvci5hbm5vdGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBlcnJvci5tZXNzYWdlID0gZXJyb3IuYW5ub3RhdGUoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCEobWVzc2FnZSBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZXJyb3IuYW5ub3RhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IubWVzc2FnZSA9IGAke21lc3NhZ2V9ICR7ZXJyb3IuYW5ub3RhdGUoKX1gO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aHJvdyBtZXNzYWdlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdC52YWx1ZTtcbiAgICB9O1xuXG4gICAgcm9vdC5yZWFjaCA9IGZ1bmN0aW9uIChzY2hlbWEsIHBhdGgpIHtcblxuICAgICAgICBIb2VrLmFzc2VydChzY2hlbWEgJiYgc2NoZW1hIGluc3RhbmNlb2YgQW55LCAneW91IG11c3QgcHJvdmlkZSBhIGpvaSBzY2hlbWEnKTtcbiAgICAgICAgSG9lay5hc3NlcnQoQXJyYXkuaXNBcnJheShwYXRoKSB8fCB0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycsICdwYXRoIG11c3QgYmUgYSBzdHJpbmcgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncycpO1xuXG4gICAgICAgIGNvbnN0IHJlYWNoID0gKHNvdXJjZVNjaGVtYSwgc2NoZW1hUGF0aCkgPT4ge1xuXG4gICAgICAgICAgICBpZiAoIXNjaGVtYVBhdGgubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNvdXJjZVNjaGVtYTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBzb3VyY2VTY2hlbWEuX2lubmVyLmNoaWxkcmVuO1xuICAgICAgICAgICAgaWYgKCFjaGlsZHJlbikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3Qga2V5ID0gc2NoZW1hUGF0aC5zaGlmdCgpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLmtleSA9PT0ga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWFjaChjaGlsZC5zY2hlbWEsIHNjaGVtYVBhdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBzY2hlbWFQYXRoID0gdHlwZW9mIHBhdGggPT09ICdzdHJpbmcnID8gKHBhdGggPyBwYXRoLnNwbGl0KCcuJykgOiBbXSkgOiBwYXRoLnNsaWNlKCk7XG5cbiAgICAgICAgcmV0dXJuIHJlYWNoKHNjaGVtYSwgc2NoZW1hUGF0aCk7XG4gICAgfTtcblxuICAgIHJvb3QubGF6eSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG5cbiAgICAgICAgcmV0dXJuIGludGVybmFscy5jYWxsV2l0aERlZmF1bHRzLmNhbGwodGhpcywgTGF6eSwgYXJncyk7XG4gICAgfTtcblxuICAgIHJvb3QuZGVmYXVsdHMgPSBmdW5jdGlvbiAoZm4pIHtcblxuICAgICAgICBIb2VrLmFzc2VydCh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicsICdEZWZhdWx0cyBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICAgICAgICBsZXQgam9pID0gT2JqZWN0LmNyZWF0ZSh0aGlzLmFueSgpKTtcbiAgICAgICAgam9pID0gZm4oam9pKTtcblxuICAgICAgICBIb2VrLmFzc2VydChqb2kgJiYgam9pIGluc3RhbmNlb2YgdGhpcy5jb25zdHJ1Y3RvciwgJ2RlZmF1bHRzKCkgbXVzdCByZXR1cm4gYSBzY2hlbWEnKTtcblxuICAgICAgICBPYmplY3QuYXNzaWduKGpvaSwgdGhpcywgam9pLmNsb25lKCkpOyAvLyBSZS1hZGQgdGhlIHR5cGVzIGZyb20gYHRoaXNgIGJ1dCBhbHNvIGtlZXAgdGhlIHNldHRpbmdzIGZyb20gam9pJ3MgcG90ZW50aWFsIG5ldyBkZWZhdWx0c1xuXG4gICAgICAgIGpvaS5fZGVmYXVsdHMgPSAoc2NoZW1hKSA9PiB7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9kZWZhdWx0cykge1xuICAgICAgICAgICAgICAgIHNjaGVtYSA9IHRoaXMuX2RlZmF1bHRzKHNjaGVtYSk7XG4gICAgICAgICAgICAgICAgSG9lay5hc3NlcnQoc2NoZW1hIGluc3RhbmNlb2YgdGhpcy5jb25zdHJ1Y3RvciwgJ2RlZmF1bHRzKCkgbXVzdCByZXR1cm4gYSBzY2hlbWEnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2NoZW1hID0gZm4oc2NoZW1hKTtcbiAgICAgICAgICAgIEhvZWsuYXNzZXJ0KHNjaGVtYSBpbnN0YW5jZW9mIHRoaXMuY29uc3RydWN0b3IsICdkZWZhdWx0cygpIG11c3QgcmV0dXJuIGEgc2NoZW1hJyk7XG4gICAgICAgICAgICByZXR1cm4gc2NoZW1hO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBqb2k7XG4gICAgfTtcblxuICAgIHJvb3QuYmluZCA9IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICBjb25zdCBqb2kgPSBPYmplY3QuY3JlYXRlKHRoaXMpO1xuXG4gICAgICAgIGpvaS5fYmluZHMuZm9yRWFjaCgoYmluZCkgPT4ge1xuXG4gICAgICAgICAgICBqb2lbYmluZF0gPSBqb2lbYmluZF0uYmluZChqb2kpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gam9pO1xuICAgIH07XG5cbiAgICByb290LmV4dGVuZCA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG5cbiAgICAgICAgY29uc3QgZXh0ZW5zaW9ucyA9IEhvZWsuZmxhdHRlbihhcmdzKTtcbiAgICAgICAgSG9lay5hc3NlcnQoZXh0ZW5zaW9ucy5sZW5ndGggPiAwLCAnWW91IG5lZWQgdG8gcHJvdmlkZSBhdCBsZWFzdCBvbmUgZXh0ZW5zaW9uJyk7XG5cbiAgICAgICAgdGhpcy5hc3NlcnQoZXh0ZW5zaW9ucywgcm9vdC5leHRlbnNpb25zU2NoZW1hKTtcblxuICAgICAgICBjb25zdCBqb2kgPSBPYmplY3QuY3JlYXRlKHRoaXMuYW55KCkpO1xuICAgICAgICBPYmplY3QuYXNzaWduKGpvaSwgdGhpcyk7XG4gICAgICAgIGpvaS5fY3VycmVudEpvaSA9IGpvaTtcbiAgICAgICAgam9pLl9iaW5kcyA9IG5ldyBTZXQoam9pLl9iaW5kcyk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBleHRlbnNpb25zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBsZXQgZXh0ZW5zaW9uID0gZXh0ZW5zaW9uc1tpXTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBleHRlbnNpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBleHRlbnNpb24gPSBleHRlbnNpb24oam9pKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5hc3NlcnQoZXh0ZW5zaW9uLCByb290LmV4dGVuc2lvblNjaGVtYSk7XG5cbiAgICAgICAgICAgIGNvbnN0IGJhc2UgPSAoZXh0ZW5zaW9uLmJhc2UgfHwgdGhpcy5hbnkoKSkuY2xvbmUoKTsgLy8gQ2xvbmluZyBiZWNhdXNlIHdlJ3JlIGdvaW5nIHRvIG92ZXJyaWRlIGxhbmd1YWdlIGFmdGVyd2FyZHNcbiAgICAgICAgICAgIGNvbnN0IGN0b3IgPSBiYXNlLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgY29uc3QgdHlwZSA9IGNsYXNzIGV4dGVuZHMgY3RvciB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbG9vcC1mdW5jXG5cbiAgICAgICAgICAgICAgICBjb25zdHJ1Y3RvcigpIHtcblxuICAgICAgICAgICAgICAgICAgICBzdXBlcigpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXh0ZW5zaW9uLmJhc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgYmFzZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90eXBlID0gZXh0ZW5zaW9uLm5hbWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAoZXh0ZW5zaW9uLmxhbmd1YWdlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGFuZyA9IHtcbiAgICAgICAgICAgICAgICAgICAgW2V4dGVuc2lvbi5uYW1lXTogZXh0ZW5zaW9uLmxhbmd1YWdlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0eXBlLnByb3RvdHlwZS5fbGFuZ3VhZ2UgPSBIb2VrLmFwcGx5VG9EZWZhdWx0cyh0eXBlLnByb3RvdHlwZS5fbGFuZ3VhZ2UgfHwgKGJhc2UuX3NldHRpbmdzICYmIGJhc2UuX3NldHRpbmdzLmxhbmd1YWdlKSB8fCB7fSwgbGFuZyk7XG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgaWYgKGV4dGVuc2lvbi5jb2VyY2UpIHtcbiAgICAgICAgICAgICAgICB0eXBlLnByb3RvdHlwZS5fY29lcmNlID0gZnVuY3Rpb24gKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucykge1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdG9yLnByb3RvdHlwZS5fY29lcmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBiYXNlUmV0ID0gY3Rvci5wcm90b3R5cGUuX2NvZXJjZS5jYWxsKHRoaXMsIHZhbHVlLCBzdGF0ZSwgb3B0aW9ucyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiYXNlUmV0LmVycm9ycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBiYXNlUmV0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGJhc2VSZXQudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXQgPSBleHRlbnNpb24uY29lcmNlLmNhbGwodGhpcywgdmFsdWUsIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJldCBpbnN0YW5jZW9mIEVycm9ycy5FcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlLCBlcnJvcnM6IHJldCB9O1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHJldCB9O1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChleHRlbnNpb24ucHJlKSB7XG4gICAgICAgICAgICAgICAgdHlwZS5wcm90b3R5cGUuX2Jhc2UgPSBmdW5jdGlvbiAodmFsdWUsIHN0YXRlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGN0b3IucHJvdG90eXBlLl9iYXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBiYXNlUmV0ID0gY3Rvci5wcm90b3R5cGUuX2Jhc2UuY2FsbCh0aGlzLCB2YWx1ZSwgc3RhdGUsIG9wdGlvbnMpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmFzZVJldC5lcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmFzZVJldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBiYXNlUmV0LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmV0ID0gZXh0ZW5zaW9uLnByZS5jYWxsKHRoaXMsIHZhbHVlLCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXQgaW5zdGFuY2VvZiBFcnJvcnMuRXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZSwgZXJyb3JzOiByZXQgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiByZXQgfTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZXh0ZW5zaW9uLnJ1bGVzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBleHRlbnNpb24ucnVsZXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcnVsZSA9IGV4dGVuc2lvbi5ydWxlc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcnVsZUFyZ3MgPSBydWxlLnBhcmFtcyA/XG4gICAgICAgICAgICAgICAgICAgICAgICAocnVsZS5wYXJhbXMgaW5zdGFuY2VvZiBBbnkgPyBydWxlLnBhcmFtcy5faW5uZXIuY2hpbGRyZW4ubWFwKChrKSA9PiBrLmtleSkgOiBPYmplY3Qua2V5cyhydWxlLnBhcmFtcykpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIFtdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWxpZGF0ZUFyZ3MgPSBydWxlLnBhcmFtcyA/IENhc3Quc2NoZW1hKHRoaXMsIHJ1bGUucGFyYW1zKSA6IG51bGw7XG5cbiAgICAgICAgICAgICAgICAgICAgdHlwZS5wcm90b3R5cGVbcnVsZS5uYW1lXSA9IGZ1bmN0aW9uICguLi5yQXJncykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWxvb3AtZnVuY1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAockFyZ3MubGVuZ3RoID4gcnVsZUFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIG51bWJlciBvZiBhcmd1bWVudHMnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGhhc1JlZiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGFyZyA9IHt9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IHJ1bGVBcmdzLmxlbmd0aDsgKytrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnW3J1bGVBcmdzW2tdXSA9IHJBcmdzW2tdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaGFzUmVmICYmIFJlZi5pc1JlZihyQXJnc1trXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzUmVmID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWxpZGF0ZUFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmcgPSBqb2kuYXR0ZW1wdChhcmcsIHZhbGlkYXRlQXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzY2hlbWE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocnVsZS52YWxpZGF0ZSAmJiAhcnVsZS5zZXR1cCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkYXRlID0gZnVuY3Rpb24gKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucykge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBydWxlLnZhbGlkYXRlLmNhbGwodGhpcywgYXJnLCB2YWx1ZSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2hlbWEgPSB0aGlzLl90ZXN0KHJ1bGUubmFtZSwgYXJnLCB2YWxpZGF0ZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogcnVsZS5kZXNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzUmVmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2hlbWEgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChydWxlLnNldHVwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3U2NoZW1hID0gcnVsZS5zZXR1cC5jYWxsKHNjaGVtYSwgYXJnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3U2NoZW1hICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSG9lay5hc3NlcnQobmV3U2NoZW1hIGluc3RhbmNlb2YgQW55LCBgU2V0dXAgb2YgZXh0ZW5zaW9uIEpvaS4ke3RoaXMuX3R5cGV9KCkuJHtydWxlLm5hbWV9KCkgbXVzdCByZXR1cm4gdW5kZWZpbmVkIG9yIGEgSm9pIG9iamVjdGApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2hlbWEgPSBuZXdTY2hlbWE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJ1bGUudmFsaWRhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsaWRhdGUgPSBmdW5jdGlvbiAodmFsdWUsIHN0YXRlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBydWxlLnZhbGlkYXRlLmNhbGwodGhpcywgYXJnLCB2YWx1ZSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjaGVtYSA9IHNjaGVtYS5fdGVzdChydWxlLm5hbWUsIGFyZywgdmFsaWRhdGUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBydWxlLmRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzUmVmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNjaGVtYTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChleHRlbnNpb24uZGVzY3JpYmUpIHtcbiAgICAgICAgICAgICAgICB0eXBlLnByb3RvdHlwZS5kZXNjcmliZSA9IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IGN0b3IucHJvdG90eXBlLmRlc2NyaWJlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBleHRlbnNpb24uZGVzY3JpYmUuY2FsbCh0aGlzLCBkZXNjcmlwdGlvbik7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBuZXcgdHlwZSgpO1xuICAgICAgICAgICAgam9pW2V4dGVuc2lvbi5uYW1lXSA9IGZ1bmN0aW9uICguLi5leHRBcmdzKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmNhbGxXaXRoRGVmYXVsdHMuY2FsbCh0aGlzLCBpbnN0YW5jZSwgZXh0QXJncyk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBqb2kuX2JpbmRzLmFkZChleHRlbnNpb24ubmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gam9pO1xuICAgIH07XG5cbiAgICByb290LmV4dGVuc2lvblNjaGVtYSA9IGludGVybmFscy5vYmplY3Qua2V5cyh7XG4gICAgICAgIGJhc2U6IGludGVybmFscy5vYmplY3QudHlwZShBbnksICdKb2kgb2JqZWN0JyksXG4gICAgICAgIG5hbWU6IGludGVybmFscy5zdHJpbmcucmVxdWlyZWQoKSxcbiAgICAgICAgY29lcmNlOiBpbnRlcm5hbHMuZnVuYy5hcml0eSgzKSxcbiAgICAgICAgcHJlOiBpbnRlcm5hbHMuZnVuYy5hcml0eSgzKSxcbiAgICAgICAgbGFuZ3VhZ2U6IGludGVybmFscy5vYmplY3QsXG4gICAgICAgIGRlc2NyaWJlOiBpbnRlcm5hbHMuZnVuYy5hcml0eSgxKSxcbiAgICAgICAgcnVsZXM6IGludGVybmFscy5hcnJheS5pdGVtcyhpbnRlcm5hbHMub2JqZWN0LmtleXMoe1xuICAgICAgICAgICAgbmFtZTogaW50ZXJuYWxzLnN0cmluZy5yZXF1aXJlZCgpLFxuICAgICAgICAgICAgc2V0dXA6IGludGVybmFscy5mdW5jLmFyaXR5KDEpLFxuICAgICAgICAgICAgdmFsaWRhdGU6IGludGVybmFscy5mdW5jLmFyaXR5KDQpLFxuICAgICAgICAgICAgcGFyYW1zOiBbXG4gICAgICAgICAgICAgICAgaW50ZXJuYWxzLm9iamVjdC5wYXR0ZXJuKC8uKi8sIGludGVybmFscy5vYmplY3QudHlwZShBbnksICdKb2kgb2JqZWN0JykpLFxuICAgICAgICAgICAgICAgIGludGVybmFscy5vYmplY3QudHlwZShpbnRlcm5hbHMub2JqZWN0LmNvbnN0cnVjdG9yLCAnSm9pIG9iamVjdCcpXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IFtpbnRlcm5hbHMuc3RyaW5nLCBpbnRlcm5hbHMuZnVuYy5hcml0eSgxKV1cbiAgICAgICAgfSkub3IoJ3NldHVwJywgJ3ZhbGlkYXRlJykpXG4gICAgfSkuc3RyaWN0KCk7XG5cbiAgICByb290LmV4dGVuc2lvbnNTY2hlbWEgPSBpbnRlcm5hbHMuYXJyYXkuaXRlbXMoW2ludGVybmFscy5vYmplY3QsIGludGVybmFscy5mdW5jLmFyaXR5KDEpXSkuc3RyaWN0KCk7XG5cbiAgICByb290LnZlcnNpb24gPSByZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uO1xuXG4gICAgcmV0dXJuIHJvb3Q7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gaW50ZXJuYWxzLnJvb3QoKTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxuZXhwb3J0cy5lcnJvcnMgPSB7XG4gICAgcm9vdDogJ3ZhbHVlJyxcbiAgICBrZXk6ICdcInt7IWxhYmVsfX1cIiAnLFxuICAgIG1lc3NhZ2VzOiB7XG4gICAgICAgIHdyYXBBcnJheXM6IHRydWVcbiAgICB9LFxuICAgIGFueToge1xuICAgICAgICB1bmtub3duOiAnaXMgbm90IGFsbG93ZWQnLFxuICAgICAgICBpbnZhbGlkOiAnY29udGFpbnMgYW4gaW52YWxpZCB2YWx1ZScsXG4gICAgICAgIGVtcHR5OiAnaXMgbm90IGFsbG93ZWQgdG8gYmUgZW1wdHknLFxuICAgICAgICByZXF1aXJlZDogJ2lzIHJlcXVpcmVkJyxcbiAgICAgICAgYWxsb3dPbmx5OiAnbXVzdCBiZSBvbmUgb2Yge3t2YWxpZHN9fScsXG4gICAgICAgIGRlZmF1bHQ6ICd0aHJldyBhbiBlcnJvciB3aGVuIHJ1bm5pbmcgZGVmYXVsdCBtZXRob2QnXG4gICAgfSxcbiAgICBhbHRlcm5hdGl2ZXM6IHtcbiAgICAgICAgYmFzZTogJ25vdCBtYXRjaGluZyBhbnkgb2YgdGhlIGFsbG93ZWQgYWx0ZXJuYXRpdmVzJyxcbiAgICAgICAgY2hpbGQ6IG51bGxcbiAgICB9LFxuICAgIGFycmF5OiB7XG4gICAgICAgIGJhc2U6ICdtdXN0IGJlIGFuIGFycmF5JyxcbiAgICAgICAgaW5jbHVkZXM6ICdhdCBwb3NpdGlvbiB7e3Bvc319IGRvZXMgbm90IG1hdGNoIGFueSBvZiB0aGUgYWxsb3dlZCB0eXBlcycsXG4gICAgICAgIGluY2x1ZGVzU2luZ2xlOiAnc2luZ2xlIHZhbHVlIG9mIFwie3shbGFiZWx9fVwiIGRvZXMgbm90IG1hdGNoIGFueSBvZiB0aGUgYWxsb3dlZCB0eXBlcycsXG4gICAgICAgIGluY2x1ZGVzT25lOiAnYXQgcG9zaXRpb24ge3twb3N9fSBmYWlscyBiZWNhdXNlIHt7cmVhc29ufX0nLFxuICAgICAgICBpbmNsdWRlc09uZVNpbmdsZTogJ3NpbmdsZSB2YWx1ZSBvZiBcInt7IWxhYmVsfX1cIiBmYWlscyBiZWNhdXNlIHt7cmVhc29ufX0nLFxuICAgICAgICBpbmNsdWRlc1JlcXVpcmVkVW5rbm93bnM6ICdkb2VzIG5vdCBjb250YWluIHt7dW5rbm93bk1pc3Nlc319IHJlcXVpcmVkIHZhbHVlKHMpJyxcbiAgICAgICAgaW5jbHVkZXNSZXF1aXJlZEtub3duczogJ2RvZXMgbm90IGNvbnRhaW4ge3trbm93bk1pc3Nlc319JyxcbiAgICAgICAgaW5jbHVkZXNSZXF1aXJlZEJvdGg6ICdkb2VzIG5vdCBjb250YWluIHt7a25vd25NaXNzZXN9fSBhbmQge3t1bmtub3duTWlzc2VzfX0gb3RoZXIgcmVxdWlyZWQgdmFsdWUocyknLFxuICAgICAgICBleGNsdWRlczogJ2F0IHBvc2l0aW9uIHt7cG9zfX0gY29udGFpbnMgYW4gZXhjbHVkZWQgdmFsdWUnLFxuICAgICAgICBleGNsdWRlc1NpbmdsZTogJ3NpbmdsZSB2YWx1ZSBvZiBcInt7IWxhYmVsfX1cIiBjb250YWlucyBhbiBleGNsdWRlZCB2YWx1ZScsXG4gICAgICAgIGhhc0tub3duOiAnZG9lcyBub3QgY29udGFpbiBhdCBsZWFzdCBvbmUgcmVxdWlyZWQgbWF0Y2ggZm9yIHR5cGUgXCJ7eyFwYXR0ZXJuTGFiZWx9fVwiJyxcbiAgICAgICAgaGFzVW5rbm93bjogJ2RvZXMgbm90IGNvbnRhaW4gYXQgbGVhc3Qgb25lIHJlcXVpcmVkIG1hdGNoJyxcbiAgICAgICAgbWluOiAnbXVzdCBjb250YWluIGF0IGxlYXN0IHt7bGltaXR9fSBpdGVtcycsXG4gICAgICAgIG1heDogJ211c3QgY29udGFpbiBsZXNzIHRoYW4gb3IgZXF1YWwgdG8ge3tsaW1pdH19IGl0ZW1zJyxcbiAgICAgICAgbGVuZ3RoOiAnbXVzdCBjb250YWluIHt7bGltaXR9fSBpdGVtcycsXG4gICAgICAgIG9yZGVyZWQ6ICdhdCBwb3NpdGlvbiB7e3Bvc319IGZhaWxzIGJlY2F1c2Uge3tyZWFzb259fScsXG4gICAgICAgIG9yZGVyZWRMZW5ndGg6ICdhdCBwb3NpdGlvbiB7e3Bvc319IGZhaWxzIGJlY2F1c2UgYXJyYXkgbXVzdCBjb250YWluIGF0IG1vc3Qge3tsaW1pdH19IGl0ZW1zJyxcbiAgICAgICAgcmVmOiAncmVmZXJlbmNlcyBcInt7cmVmfX1cIiB3aGljaCBpcyBub3QgYSBwb3NpdGl2ZSBpbnRlZ2VyJyxcbiAgICAgICAgc3BhcnNlOiAnbXVzdCBub3QgYmUgYSBzcGFyc2UgYXJyYXknLFxuICAgICAgICB1bmlxdWU6ICdwb3NpdGlvbiB7e3Bvc319IGNvbnRhaW5zIGEgZHVwbGljYXRlIHZhbHVlJ1xuICAgIH0sXG4gICAgYm9vbGVhbjoge1xuICAgICAgICBiYXNlOiAnbXVzdCBiZSBhIGJvb2xlYW4nXG4gICAgfSxcbiAgICBiaW5hcnk6IHtcbiAgICAgICAgYmFzZTogJ211c3QgYmUgYSBidWZmZXIgb3IgYSBzdHJpbmcnLFxuICAgICAgICBtaW46ICdtdXN0IGJlIGF0IGxlYXN0IHt7bGltaXR9fSBieXRlcycsXG4gICAgICAgIG1heDogJ211c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHt7bGltaXR9fSBieXRlcycsXG4gICAgICAgIGxlbmd0aDogJ211c3QgYmUge3tsaW1pdH19IGJ5dGVzJ1xuICAgIH0sXG4gICAgZGF0ZToge1xuICAgICAgICBiYXNlOiAnbXVzdCBiZSBhIG51bWJlciBvZiBtaWxsaXNlY29uZHMgb3IgdmFsaWQgZGF0ZSBzdHJpbmcnLFxuICAgICAgICBzdHJpY3Q6ICdtdXN0IGJlIGEgdmFsaWQgZGF0ZScsXG4gICAgICAgIG1pbjogJ211c3QgYmUgbGFyZ2VyIHRoYW4gb3IgZXF1YWwgdG8gXCJ7e2xpbWl0fX1cIicsXG4gICAgICAgIG1heDogJ211c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIFwie3tsaW1pdH19XCInLFxuICAgICAgICBsZXNzOiAnbXVzdCBiZSBsZXNzIHRoYW4gXCJ7e2xpbWl0fX1cIicsXG4gICAgICAgIGdyZWF0ZXI6ICdtdXN0IGJlIGdyZWF0ZXIgdGhhbiBcInt7bGltaXR9fVwiJyxcbiAgICAgICAgaXNvRGF0ZTogJ211c3QgYmUgYSB2YWxpZCBJU08gODYwMSBkYXRlJyxcbiAgICAgICAgdGltZXN0YW1wOiB7XG4gICAgICAgICAgICBqYXZhc2NyaXB0OiAnbXVzdCBiZSBhIHZhbGlkIHRpbWVzdGFtcCBvciBudW1iZXIgb2YgbWlsbGlzZWNvbmRzJyxcbiAgICAgICAgICAgIHVuaXg6ICdtdXN0IGJlIGEgdmFsaWQgdGltZXN0YW1wIG9yIG51bWJlciBvZiBzZWNvbmRzJ1xuICAgICAgICB9LFxuICAgICAgICByZWY6ICdyZWZlcmVuY2VzIFwie3tyZWZ9fVwiIHdoaWNoIGlzIG5vdCBhIGRhdGUnXG4gICAgfSxcbiAgICBmdW5jdGlvbjoge1xuICAgICAgICBiYXNlOiAnbXVzdCBiZSBhIEZ1bmN0aW9uJyxcbiAgICAgICAgYXJpdHk6ICdtdXN0IGhhdmUgYW4gYXJpdHkgb2Yge3tufX0nLFxuICAgICAgICBtaW5Bcml0eTogJ211c3QgaGF2ZSBhbiBhcml0eSBncmVhdGVyIG9yIGVxdWFsIHRvIHt7bn19JyxcbiAgICAgICAgbWF4QXJpdHk6ICdtdXN0IGhhdmUgYW4gYXJpdHkgbGVzc2VyIG9yIGVxdWFsIHRvIHt7bn19JyxcbiAgICAgICAgcmVmOiAnbXVzdCBiZSBhIEpvaSByZWZlcmVuY2UnLFxuICAgICAgICBjbGFzczogJ211c3QgYmUgYSBjbGFzcydcbiAgICB9LFxuICAgIGxhenk6IHtcbiAgICAgICAgYmFzZTogJyEhc2NoZW1hIGVycm9yOiBsYXp5IHNjaGVtYSBtdXN0IGJlIHNldCcsXG4gICAgICAgIHNjaGVtYTogJyEhc2NoZW1hIGVycm9yOiBsYXp5IHNjaGVtYSBmdW5jdGlvbiBtdXN0IHJldHVybiBhIHNjaGVtYSdcbiAgICB9LFxuICAgIG9iamVjdDoge1xuICAgICAgICBiYXNlOiAnbXVzdCBiZSBhbiBvYmplY3QnLFxuICAgICAgICBjaGlsZDogJyEhY2hpbGQgXCJ7eyFjaGlsZH19XCIgZmFpbHMgYmVjYXVzZSB7e3JlYXNvbn19JyxcbiAgICAgICAgbWluOiAnbXVzdCBoYXZlIGF0IGxlYXN0IHt7bGltaXR9fSBjaGlsZHJlbicsXG4gICAgICAgIG1heDogJ211c3QgaGF2ZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8ge3tsaW1pdH19IGNoaWxkcmVuJyxcbiAgICAgICAgbGVuZ3RoOiAnbXVzdCBoYXZlIHt7bGltaXR9fSBjaGlsZHJlbicsXG4gICAgICAgIGFsbG93VW5rbm93bjogJyEhXCJ7eyFjaGlsZH19XCIgaXMgbm90IGFsbG93ZWQnLFxuICAgICAgICB3aXRoOiAnISFcInt7bWFpbldpdGhMYWJlbH19XCIgbWlzc2luZyByZXF1aXJlZCBwZWVyIFwie3twZWVyV2l0aExhYmVsfX1cIicsXG4gICAgICAgIHdpdGhvdXQ6ICchIVwie3ttYWluV2l0aExhYmVsfX1cIiBjb25mbGljdCB3aXRoIGZvcmJpZGRlbiBwZWVyIFwie3twZWVyV2l0aExhYmVsfX1cIicsXG4gICAgICAgIG1pc3Npbmc6ICdtdXN0IGNvbnRhaW4gYXQgbGVhc3Qgb25lIG9mIHt7cGVlcnNXaXRoTGFiZWxzfX0nLFxuICAgICAgICB4b3I6ICdjb250YWlucyBhIGNvbmZsaWN0IGJldHdlZW4gZXhjbHVzaXZlIHBlZXJzIHt7cGVlcnNXaXRoTGFiZWxzfX0nLFxuICAgICAgICBveG9yOiAnY29udGFpbnMgYSBjb25mbGljdCBiZXR3ZWVuIG9wdGlvbmFsIGV4Y2x1c2l2ZSBwZWVycyB7e3BlZXJzV2l0aExhYmVsc319JyxcbiAgICAgICAgYW5kOiAnY29udGFpbnMge3twcmVzZW50V2l0aExhYmVsc319IHdpdGhvdXQgaXRzIHJlcXVpcmVkIHBlZXJzIHt7bWlzc2luZ1dpdGhMYWJlbHN9fScsXG4gICAgICAgIG5hbmQ6ICchIVwie3ttYWluV2l0aExhYmVsfX1cIiBtdXN0IG5vdCBleGlzdCBzaW11bHRhbmVvdXNseSB3aXRoIHt7cGVlcnNXaXRoTGFiZWxzfX0nLFxuICAgICAgICBhc3NlcnQ6ICchIVwie3tyZWZ9fVwiIHZhbGlkYXRpb24gZmFpbGVkIGJlY2F1c2UgXCJ7e3JlZn19XCIgZmFpbGVkIHRvIHt7bWVzc2FnZX19JyxcbiAgICAgICAgcmVuYW1lOiB7XG4gICAgICAgICAgICBtdWx0aXBsZTogJ2Nhbm5vdCByZW5hbWUgY2hpbGQgXCJ7e2Zyb219fVwiIGJlY2F1c2UgbXVsdGlwbGUgcmVuYW1lcyBhcmUgZGlzYWJsZWQgYW5kIGFub3RoZXIga2V5IHdhcyBhbHJlYWR5IHJlbmFtZWQgdG8gXCJ7e3RvfX1cIicsXG4gICAgICAgICAgICBvdmVycmlkZTogJ2Nhbm5vdCByZW5hbWUgY2hpbGQgXCJ7e2Zyb219fVwiIGJlY2F1c2Ugb3ZlcnJpZGUgaXMgZGlzYWJsZWQgYW5kIHRhcmdldCBcInt7dG99fVwiIGV4aXN0cycsXG4gICAgICAgICAgICByZWdleDoge1xuICAgICAgICAgICAgICAgIG11bHRpcGxlOiAnY2Fubm90IHJlbmFtZSBjaGlsZHJlbiB7e2Zyb219fSBiZWNhdXNlIG11bHRpcGxlIHJlbmFtZXMgYXJlIGRpc2FibGVkIGFuZCBhbm90aGVyIGtleSB3YXMgYWxyZWFkeSByZW5hbWVkIHRvIFwie3t0b319XCInLFxuICAgICAgICAgICAgICAgIG92ZXJyaWRlOiAnY2Fubm90IHJlbmFtZSBjaGlsZHJlbiB7e2Zyb219fSBiZWNhdXNlIG92ZXJyaWRlIGlzIGRpc2FibGVkIGFuZCB0YXJnZXQgXCJ7e3RvfX1cIiBleGlzdHMnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHR5cGU6ICdtdXN0IGJlIGFuIGluc3RhbmNlIG9mIFwie3t0eXBlfX1cIicsXG4gICAgICAgIHNjaGVtYTogJ211c3QgYmUgYSBKb2kgaW5zdGFuY2UnXG4gICAgfSxcbiAgICBudW1iZXI6IHtcbiAgICAgICAgYmFzZTogJ211c3QgYmUgYSBudW1iZXInLFxuICAgICAgICB1bnNhZmU6ICdtdXN0IGJlIGEgc2FmZSBudW1iZXInLFxuICAgICAgICBtaW46ICdtdXN0IGJlIGxhcmdlciB0aGFuIG9yIGVxdWFsIHRvIHt7bGltaXR9fScsXG4gICAgICAgIG1heDogJ211c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHt7bGltaXR9fScsXG4gICAgICAgIGxlc3M6ICdtdXN0IGJlIGxlc3MgdGhhbiB7e2xpbWl0fX0nLFxuICAgICAgICBncmVhdGVyOiAnbXVzdCBiZSBncmVhdGVyIHRoYW4ge3tsaW1pdH19JyxcbiAgICAgICAgaW50ZWdlcjogJ211c3QgYmUgYW4gaW50ZWdlcicsXG4gICAgICAgIG5lZ2F0aXZlOiAnbXVzdCBiZSBhIG5lZ2F0aXZlIG51bWJlcicsXG4gICAgICAgIHBvc2l0aXZlOiAnbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicsXG4gICAgICAgIHByZWNpc2lvbjogJ211c3QgaGF2ZSBubyBtb3JlIHRoYW4ge3tsaW1pdH19IGRlY2ltYWwgcGxhY2VzJyxcbiAgICAgICAgcmVmOiAncmVmZXJlbmNlcyBcInt7cmVmfX1cIiB3aGljaCBpcyBub3QgYSBudW1iZXInLFxuICAgICAgICBtdWx0aXBsZTogJ211c3QgYmUgYSBtdWx0aXBsZSBvZiB7e211bHRpcGxlfX0nLFxuICAgICAgICBwb3J0OiAnbXVzdCBiZSBhIHZhbGlkIHBvcnQnXG4gICAgfSxcbiAgICBzdHJpbmc6IHtcbiAgICAgICAgYmFzZTogJ211c3QgYmUgYSBzdHJpbmcnLFxuICAgICAgICBtaW46ICdsZW5ndGggbXVzdCBiZSBhdCBsZWFzdCB7e2xpbWl0fX0gY2hhcmFjdGVycyBsb25nJyxcbiAgICAgICAgbWF4OiAnbGVuZ3RoIG11c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHt7bGltaXR9fSBjaGFyYWN0ZXJzIGxvbmcnLFxuICAgICAgICBsZW5ndGg6ICdsZW5ndGggbXVzdCBiZSB7e2xpbWl0fX0gY2hhcmFjdGVycyBsb25nJyxcbiAgICAgICAgYWxwaGFudW06ICdtdXN0IG9ubHkgY29udGFpbiBhbHBoYS1udW1lcmljIGNoYXJhY3RlcnMnLFxuICAgICAgICB0b2tlbjogJ211c3Qgb25seSBjb250YWluIGFscGhhLW51bWVyaWMgYW5kIHVuZGVyc2NvcmUgY2hhcmFjdGVycycsXG4gICAgICAgIHJlZ2V4OiB7XG4gICAgICAgICAgICBiYXNlOiAnd2l0aCB2YWx1ZSBcInt7IXZhbHVlfX1cIiBmYWlscyB0byBtYXRjaCB0aGUgcmVxdWlyZWQgcGF0dGVybjoge3twYXR0ZXJufX0nLFxuICAgICAgICAgICAgbmFtZTogJ3dpdGggdmFsdWUgXCJ7eyF2YWx1ZX19XCIgZmFpbHMgdG8gbWF0Y2ggdGhlIHt7bmFtZX19IHBhdHRlcm4nLFxuICAgICAgICAgICAgaW52ZXJ0OiB7XG4gICAgICAgICAgICAgICAgYmFzZTogJ3dpdGggdmFsdWUgXCJ7eyF2YWx1ZX19XCIgbWF0Y2hlcyB0aGUgaW52ZXJ0ZWQgcGF0dGVybjoge3twYXR0ZXJufX0nLFxuICAgICAgICAgICAgICAgIG5hbWU6ICd3aXRoIHZhbHVlIFwie3shdmFsdWV9fVwiIG1hdGNoZXMgdGhlIGludmVydGVkIHt7bmFtZX19IHBhdHRlcm4nXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVtYWlsOiAnbXVzdCBiZSBhIHZhbGlkIGVtYWlsJyxcbiAgICAgICAgdXJpOiAnbXVzdCBiZSBhIHZhbGlkIHVyaScsXG4gICAgICAgIHVyaVJlbGF0aXZlT25seTogJ211c3QgYmUgYSB2YWxpZCByZWxhdGl2ZSB1cmknLFxuICAgICAgICB1cmlDdXN0b21TY2hlbWU6ICdtdXN0IGJlIGEgdmFsaWQgdXJpIHdpdGggYSBzY2hlbWUgbWF0Y2hpbmcgdGhlIHt7c2NoZW1lfX0gcGF0dGVybicsXG4gICAgICAgIGlzb0RhdGU6ICdtdXN0IGJlIGEgdmFsaWQgSVNPIDg2MDEgZGF0ZScsXG4gICAgICAgIGd1aWQ6ICdtdXN0IGJlIGEgdmFsaWQgR1VJRCcsXG4gICAgICAgIGhleDogJ211c3Qgb25seSBjb250YWluIGhleGFkZWNpbWFsIGNoYXJhY3RlcnMnLFxuICAgICAgICBoZXhBbGlnbjogJ2hleCBkZWNvZGVkIHJlcHJlc2VudGF0aW9uIG11c3QgYmUgYnl0ZSBhbGlnbmVkJyxcbiAgICAgICAgYmFzZTY0OiAnbXVzdCBiZSBhIHZhbGlkIGJhc2U2NCBzdHJpbmcnLFxuICAgICAgICBkYXRhVXJpOiAnbXVzdCBiZSBhIHZhbGlkIGRhdGFVcmkgc3RyaW5nJyxcbiAgICAgICAgaG9zdG5hbWU6ICdtdXN0IGJlIGEgdmFsaWQgaG9zdG5hbWUnLFxuICAgICAgICBub3JtYWxpemU6ICdtdXN0IGJlIHVuaWNvZGUgbm9ybWFsaXplZCBpbiB0aGUge3tmb3JtfX0gZm9ybScsXG4gICAgICAgIGxvd2VyY2FzZTogJ211c3Qgb25seSBjb250YWluIGxvd2VyY2FzZSBjaGFyYWN0ZXJzJyxcbiAgICAgICAgdXBwZXJjYXNlOiAnbXVzdCBvbmx5IGNvbnRhaW4gdXBwZXJjYXNlIGNoYXJhY3RlcnMnLFxuICAgICAgICB0cmltOiAnbXVzdCBub3QgaGF2ZSBsZWFkaW5nIG9yIHRyYWlsaW5nIHdoaXRlc3BhY2UnLFxuICAgICAgICBjcmVkaXRDYXJkOiAnbXVzdCBiZSBhIGNyZWRpdCBjYXJkJyxcbiAgICAgICAgcmVmOiAncmVmZXJlbmNlcyBcInt7cmVmfX1cIiB3aGljaCBpcyBub3QgYSBudW1iZXInLFxuICAgICAgICBpcDogJ211c3QgYmUgYSB2YWxpZCBpcCBhZGRyZXNzIHdpdGggYSB7e2NpZHJ9fSBDSURSJyxcbiAgICAgICAgaXBWZXJzaW9uOiAnbXVzdCBiZSBhIHZhbGlkIGlwIGFkZHJlc3Mgb2Ygb25lIG9mIHRoZSBmb2xsb3dpbmcgdmVyc2lvbnMge3t2ZXJzaW9ufX0gd2l0aCBhIHt7Y2lkcn19IENJRFInXG4gICAgfSxcbiAgICBzeW1ib2w6IHtcbiAgICAgICAgYmFzZTogJ211c3QgYmUgYSBzeW1ib2wnLFxuICAgICAgICBtYXA6ICdtdXN0IGJlIG9uZSBvZiB7e21hcH19J1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEhvZWsgPSByZXF1aXJlKCdAaGFwaS9ob2VrJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxuZXhwb3J0cy5jcmVhdGUgPSBmdW5jdGlvbiAoa2V5LCBvcHRpb25zKSB7XG5cbiAgICBIb2VrLmFzc2VydCh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJywgJ0ludmFsaWQgcmVmZXJlbmNlIGtleTonLCBrZXkpO1xuXG4gICAgY29uc3Qgc2V0dGluZ3MgPSBIb2VrLmNsb25lKG9wdGlvbnMpOyAgICAgICAgIC8vIG9wdGlvbnMgY2FuIGJlIHJldXNlZCBhbmQgbW9kaWZpZWRcblxuICAgIGNvbnN0IHJlZiA9IGZ1bmN0aW9uICh2YWx1ZSwgdmFsaWRhdGlvbk9wdGlvbnMpIHtcblxuICAgICAgICByZXR1cm4gSG9lay5yZWFjaChyZWYuaXNDb250ZXh0ID8gdmFsaWRhdGlvbk9wdGlvbnMuY29udGV4dCA6IHZhbHVlLCByZWYua2V5LCBzZXR0aW5ncyk7XG4gICAgfTtcblxuICAgIHJlZi5pc0NvbnRleHQgPSAoa2V5WzBdID09PSAoKHNldHRpbmdzICYmIHNldHRpbmdzLmNvbnRleHRQcmVmaXgpIHx8ICckJykpO1xuICAgIHJlZi5rZXkgPSAocmVmLmlzQ29udGV4dCA/IGtleS5zbGljZSgxKSA6IGtleSk7XG4gICAgcmVmLnBhdGggPSByZWYua2V5LnNwbGl0KChzZXR0aW5ncyAmJiBzZXR0aW5ncy5zZXBhcmF0b3IpIHx8ICcuJyk7XG4gICAgcmVmLmRlcHRoID0gcmVmLnBhdGgubGVuZ3RoO1xuICAgIHJlZi5yb290ID0gcmVmLnBhdGhbMF07XG4gICAgcmVmLmlzSm9pID0gdHJ1ZTtcblxuICAgIHJlZi50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICByZXR1cm4gKHJlZi5pc0NvbnRleHQgPyAnY29udGV4dDonIDogJ3JlZjonKSArIHJlZi5rZXk7XG4gICAgfTtcblxuICAgIHJldHVybiByZWY7XG59O1xuXG5cbmV4cG9ydHMuaXNSZWYgPSBmdW5jdGlvbiAocmVmKSB7XG5cbiAgICByZXR1cm4gdHlwZW9mIHJlZiA9PT0gJ2Z1bmN0aW9uJyAmJiByZWYuaXNKb2k7XG59O1xuXG5cbmV4cG9ydHMucHVzaCA9IGZ1bmN0aW9uIChhcnJheSwgcmVmKSB7XG5cbiAgICBpZiAoZXhwb3J0cy5pc1JlZihyZWYpICYmXG4gICAgICAgICFyZWYuaXNDb250ZXh0KSB7XG5cbiAgICAgICAgYXJyYXkucHVzaChyZWYucm9vdCk7XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgSm9pID0gcmVxdWlyZSgnLi9pbmRleCcpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbmV4cG9ydHMub3B0aW9ucyA9IEpvaS5vYmplY3Qoe1xuICAgIGFib3J0RWFybHk6IEpvaS5ib29sZWFuKCksXG4gICAgY29udmVydDogSm9pLmJvb2xlYW4oKSxcbiAgICBhbGxvd1Vua25vd246IEpvaS5ib29sZWFuKCksXG4gICAgc2tpcEZ1bmN0aW9uczogSm9pLmJvb2xlYW4oKSxcbiAgICBzdHJpcFVua25vd246IFtKb2kuYm9vbGVhbigpLCBKb2kub2JqZWN0KHsgYXJyYXlzOiBKb2kuYm9vbGVhbigpLCBvYmplY3RzOiBKb2kuYm9vbGVhbigpIH0pLm9yKCdhcnJheXMnLCAnb2JqZWN0cycpXSxcbiAgICBsYW5ndWFnZTogSm9pLm9iamVjdCgpLFxuICAgIHByZXNlbmNlOiBKb2kuc3RyaW5nKCkub25seSgncmVxdWlyZWQnLCAnb3B0aW9uYWwnLCAnZm9yYmlkZGVuJywgJ2lnbm9yZScpLFxuICAgIGNvbnRleHQ6IEpvaS5vYmplY3QoKSxcbiAgICBub0RlZmF1bHRzOiBKb2kuYm9vbGVhbigpLFxuICAgIGVzY2FwZUh0bWw6IEpvaS5ib29sZWFuKClcbn0pLnN0cmljdCgpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBSZWYgPSByZXF1aXJlKCcuL3JlZicpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbmludGVybmFscy5leHRlbmRlZENoZWNrRm9yVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUsIGluc2Vuc2l0aXZlKSB7XG5cbiAgICBjb25zdCB2YWx1ZVR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cbiAgICBpZiAodmFsdWVUeXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gKGl0ZW0pID0+IHtcblxuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtIGluc3RhbmNlb2YgRGF0ZSAmJiB2YWx1ZS5nZXRUaW1lKCkgPT09IGl0ZW0uZ2V0VGltZSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gKGl0ZW0pID0+IHtcblxuICAgICAgICAgICAgICAgIHJldHVybiBCdWZmZXIuaXNCdWZmZXIoaXRlbSkgJiYgdmFsdWUubGVuZ3RoID09PSBpdGVtLmxlbmd0aCAmJiB2YWx1ZS50b1N0cmluZygnYmluYXJ5JykgPT09IGl0ZW0udG9TdHJpbmcoJ2JpbmFyeScpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChpbnNlbnNpdGl2ZSAmJiB2YWx1ZVR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbnN0IGxvd2VyY2FzZVZhbHVlID0gdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgcmV0dXJuIChpdGVtKSA9PiB7XG5cbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZycgJiYgbG93ZXJjYXNlVmFsdWUgPT09IGl0ZW0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBJbnRlcm5hbFNldCB7XG5cbiAgICBjb25zdHJ1Y3Rvcihmcm9tKSB7XG5cbiAgICAgICAgdGhpcy5fc2V0ID0gbmV3IFNldChmcm9tKTtcbiAgICAgICAgdGhpcy5faGFzUmVmID0gZmFsc2U7XG4gICAgfVxuXG4gICAgYWRkKHZhbHVlLCByZWZzKSB7XG5cbiAgICAgICAgY29uc3QgaXNSZWYgPSBSZWYuaXNSZWYodmFsdWUpO1xuICAgICAgICBpZiAoIWlzUmVmICYmIHRoaXMuaGFzKHZhbHVlLCBudWxsLCBudWxsLCBmYWxzZSkpIHtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVmcyAhPT0gdW5kZWZpbmVkKSB7IC8vIElmIGl0J3MgYSBtZXJnZSwgd2UgZG9uJ3QgaGF2ZSBhbnkgcmVmc1xuICAgICAgICAgICAgUmVmLnB1c2gocmVmcywgdmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc2V0LmFkZCh2YWx1ZSk7XG5cbiAgICAgICAgdGhpcy5faGFzUmVmIHw9IGlzUmVmO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIG1lcmdlKGFkZCwgcmVtb3ZlKSB7XG5cbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGFkZC5fc2V0KSB7XG4gICAgICAgICAgICB0aGlzLmFkZChpdGVtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiByZW1vdmUuX3NldCkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmUoaXRlbSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZW1vdmUodmFsdWUpIHtcblxuICAgICAgICB0aGlzLl9zZXQuZGVsZXRlKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaGFzKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucywgaW5zZW5zaXRpdmUpIHtcblxuICAgICAgICByZXR1cm4gISF0aGlzLmdldCh2YWx1ZSwgc3RhdGUsIG9wdGlvbnMsIGluc2Vuc2l0aXZlKTtcbiAgICB9XG5cbiAgICBnZXQodmFsdWUsIHN0YXRlLCBvcHRpb25zLCBpbnNlbnNpdGl2ZSkge1xuXG4gICAgICAgIGlmICghdGhpcy5fc2V0LnNpemUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGhhc1ZhbHVlID0gdGhpcy5fc2V0Lmhhcyh2YWx1ZSk7XG4gICAgICAgIGlmIChoYXNWYWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWUgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGV4dGVuZGVkQ2hlY2sgPSBpbnRlcm5hbHMuZXh0ZW5kZWRDaGVja0ZvclZhbHVlKHZhbHVlLCBpbnNlbnNpdGl2ZSk7XG4gICAgICAgIGlmICghZXh0ZW5kZWRDaGVjaykge1xuICAgICAgICAgICAgaWYgKHN0YXRlICYmIHRoaXMuX2hhc1JlZikge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGl0ZW0gb2YgdGhpcy5fc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChSZWYuaXNSZWYoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0gPSBbXS5jb25jYXQoaXRlbShzdGF0ZS5yZWZlcmVuY2UgfHwgc3RhdGUucGFyZW50LCBvcHRpb25zKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmb3VuZCA9IGl0ZW0uaW5kZXhPZih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZm91bmQgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBpdGVtW2ZvdW5kXSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5faGFzKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucywgZXh0ZW5kZWRDaGVjayk7XG4gICAgfVxuXG4gICAgX2hhcyh2YWx1ZSwgc3RhdGUsIG9wdGlvbnMsIGNoZWNrKSB7XG5cbiAgICAgICAgY29uc3QgY2hlY2tSZWYgPSAhIShzdGF0ZSAmJiB0aGlzLl9oYXNSZWYpO1xuXG4gICAgICAgIGNvbnN0IGlzUmVhbGx5RXF1YWwgPSBmdW5jdGlvbiAoaXRlbSkge1xuXG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IGl0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGNoZWNrKGl0ZW0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAobGV0IGl0ZW0gb2YgdGhpcy5fc2V0KSB7XG4gICAgICAgICAgICBpZiAoY2hlY2tSZWYgJiYgUmVmLmlzUmVmKGl0ZW0pKSB7IC8vIE9ubHkgcmVzb2x2ZSByZWZlcmVuY2VzIGlmIHRoZXJlIGlzIGEgc3RhdGUsIG90aGVyd2lzZSBpdCdzIGEgbWVyZ2VcbiAgICAgICAgICAgICAgICBpdGVtID0gaXRlbShzdGF0ZS5yZWZlcmVuY2UgfHwgc3RhdGUucGFyZW50LCBvcHRpb25zKTtcblxuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZvdW5kID0gaXRlbS5maW5kSW5kZXgoaXNSZWFsbHlFcXVhbCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmb3VuZCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBpdGVtW2ZvdW5kXVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGlzUmVhbGx5RXF1YWwoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaXRlbVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFsdWVzKG9wdGlvbnMpIHtcblxuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnN0cmlwVW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSBbXTtcblxuICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMuX3NldCkge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5fc2V0KTtcbiAgICB9XG5cbiAgICBzbGljZSgpIHtcblxuICAgICAgICBjb25zdCBzZXQgPSBuZXcgSW50ZXJuYWxTZXQodGhpcy5fc2V0KTtcbiAgICAgICAgc2V0Ll9oYXNSZWYgPSB0aGlzLl9oYXNSZWY7XG4gICAgICAgIHJldHVybiBzZXQ7XG4gICAgfVxuXG4gICAgY29uY2F0KHNvdXJjZSkge1xuXG4gICAgICAgIGNvbnN0IHNldCA9IG5ldyBJbnRlcm5hbFNldChbLi4udGhpcy5fc2V0LCAuLi5zb3VyY2UuX3NldF0pO1xuICAgICAgICBzZXQuX2hhc1JlZiA9ICEhKHRoaXMuX2hhc1JlZiB8IHNvdXJjZS5faGFzUmVmKTtcbiAgICAgICAgcmV0dXJuIHNldDtcbiAgICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBIb2VrID0gcmVxdWlyZSgnQGhhcGkvaG9laycpO1xuXG5jb25zdCBBbnkgPSByZXF1aXJlKCcuLi9hbnknKTtcbmNvbnN0IENhc3QgPSByZXF1aXJlKCcuLi8uLi9jYXN0Jyk7XG5jb25zdCBSZWYgPSByZXF1aXJlKCcuLi8uLi9yZWYnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5pbnRlcm5hbHMuQWx0ZXJuYXRpdmVzID0gY2xhc3MgZXh0ZW5kcyBBbnkge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG5cbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fdHlwZSA9ICdhbHRlcm5hdGl2ZXMnO1xuICAgICAgICB0aGlzLl9pbnZhbGlkcy5yZW1vdmUobnVsbCk7XG4gICAgICAgIHRoaXMuX2lubmVyLm1hdGNoZXMgPSBbXTtcbiAgICB9XG5cbiAgICBfaW5pdCguLi5hcmdzKSB7XG5cbiAgICAgICAgcmV0dXJuIGFyZ3MubGVuZ3RoID8gdGhpcy50cnkoLi4uYXJncykgOiB0aGlzO1xuICAgIH1cblxuICAgIF9iYXNlKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucykge1xuXG4gICAgICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuICAgICAgICBjb25zdCBpbCA9IHRoaXMuX2lubmVyLm1hdGNoZXMubGVuZ3RoO1xuICAgICAgICBjb25zdCBiYXNlVHlwZSA9IHRoaXMuX2Jhc2VUeXBlO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaWw7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuX2lubmVyLm1hdGNoZXNbaV07XG4gICAgICAgICAgICBpZiAoIWl0ZW0uc2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NoZW1hID0gaXRlbS5wZWVrIHx8IGl0ZW0uaXM7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5wdXQgPSBpdGVtLmlzID8gaXRlbS5yZWYoc3RhdGUucmVmZXJlbmNlIHx8IHN0YXRlLnBhcmVudCwgb3B0aW9ucykgOiB2YWx1ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBmYWlsZWQgPSBzY2hlbWEuX3ZhbGlkYXRlKGlucHV0LCBudWxsLCBvcHRpb25zLCBzdGF0ZS5wYXJlbnQpLmVycm9ycztcblxuICAgICAgICAgICAgICAgIGlmIChmYWlsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0ub3RoZXJ3aXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbS5vdGhlcndpc2UuX3ZhbGlkYXRlKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXRlbS50aGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtLnRoZW4uX3ZhbGlkYXRlKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IChpbCAtIDEpICYmIGJhc2VUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBiYXNlVHlwZS5fdmFsaWRhdGUodmFsdWUsIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gaXRlbS5zY2hlbWEuX3ZhbGlkYXRlKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAoIXJlc3VsdC5lcnJvcnMpIHsgICAgIC8vIEZvdW5kIGEgdmFsaWQgbWF0Y2hcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlcnJvcnMucHVzaCguLi5yZXN1bHQuZXJyb3JzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4geyBlcnJvcnM6IHRoaXMuY3JlYXRlRXJyb3IoJ2FsdGVybmF0aXZlcy5jaGlsZCcsIHsgcmVhc29uOiBlcnJvcnMgfSwgc3RhdGUsIG9wdGlvbnMpIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyBlcnJvcnM6IHRoaXMuY3JlYXRlRXJyb3IoJ2FsdGVybmF0aXZlcy5iYXNlJywgbnVsbCwgc3RhdGUsIG9wdGlvbnMpIH07XG4gICAgfVxuXG4gICAgdHJ5KC4uLnNjaGVtYXMpIHtcblxuICAgICAgICBzY2hlbWFzID0gSG9lay5mbGF0dGVuKHNjaGVtYXMpO1xuICAgICAgICBIb2VrLmFzc2VydChzY2hlbWFzLmxlbmd0aCwgJ0Nhbm5vdCBhZGQgb3RoZXIgYWx0ZXJuYXRpdmVzIHdpdGhvdXQgYXQgbGVhc3Qgb25lIHNjaGVtYScpO1xuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNjaGVtYXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhc3QgPSBDYXN0LnNjaGVtYSh0aGlzLl9jdXJyZW50Sm9pLCBzY2hlbWFzW2ldKTtcbiAgICAgICAgICAgIGlmIChjYXN0Ll9yZWZzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG9iai5fcmVmcy5wdXNoKC4uLmNhc3QuX3JlZnMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvYmouX2lubmVyLm1hdGNoZXMucHVzaCh7IHNjaGVtYTogY2FzdCB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgd2hlbihjb25kaXRpb24sIG9wdGlvbnMpIHtcblxuICAgICAgICBsZXQgc2NoZW1hQ29uZGl0aW9uID0gZmFsc2U7XG4gICAgICAgIEhvZWsuYXNzZXJ0KFJlZi5pc1JlZihjb25kaXRpb24pIHx8IHR5cGVvZiBjb25kaXRpb24gPT09ICdzdHJpbmcnIHx8IChzY2hlbWFDb25kaXRpb24gPSBjb25kaXRpb24gaW5zdGFuY2VvZiBBbnkpLCAnSW52YWxpZCBjb25kaXRpb246JywgY29uZGl0aW9uKTtcbiAgICAgICAgSG9lay5hc3NlcnQob3B0aW9ucywgJ01pc3Npbmcgb3B0aW9ucycpO1xuICAgICAgICBIb2VrLmFzc2VydCh0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcsICdJbnZhbGlkIG9wdGlvbnMnKTtcbiAgICAgICAgaWYgKHNjaGVtYUNvbmRpdGlvbikge1xuICAgICAgICAgICAgSG9lay5hc3NlcnQoIW9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ2lzJyksICdcImlzXCIgY2FuIG5vdCBiZSB1c2VkIHdpdGggYSBzY2hlbWEgY29uZGl0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBIb2VrLmFzc2VydChvcHRpb25zLmhhc093blByb3BlcnR5KCdpcycpLCAnTWlzc2luZyBcImlzXCIgZGlyZWN0aXZlJyk7XG4gICAgICAgIH1cblxuICAgICAgICBIb2VrLmFzc2VydChvcHRpb25zLnRoZW4gIT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLm90aGVyd2lzZSAhPT0gdW5kZWZpbmVkLCAnb3B0aW9ucyBtdXN0IGhhdmUgYXQgbGVhc3Qgb25lIG9mIFwidGhlblwiIG9yIFwib3RoZXJ3aXNlXCInKTtcblxuICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIGxldCBpcztcbiAgICAgICAgaWYgKCFzY2hlbWFDb25kaXRpb24pIHtcbiAgICAgICAgICAgIGlzID0gQ2FzdC5zY2hlbWEodGhpcy5fY3VycmVudEpvaSwgb3B0aW9ucy5pcyk7XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmlzID09PSBudWxsIHx8ICEoUmVmLmlzUmVmKG9wdGlvbnMuaXMpIHx8IG9wdGlvbnMuaXMgaW5zdGFuY2VvZiBBbnkpKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBPbmx5IGFwcGx5IHJlcXVpcmVkIGlmIHRoaXMgd2Fzbid0IGFscmVhZHkgYSBzY2hlbWEgb3IgYSByZWYsIHdlJ2xsIHN1cHBvc2UgcGVvcGxlIGtub3cgd2hhdCB0aGV5J3JlIGRvaW5nXG4gICAgICAgICAgICAgICAgaXMgPSBpcy5yZXF1aXJlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaXRlbSA9IHtcbiAgICAgICAgICAgIHJlZjogc2NoZW1hQ29uZGl0aW9uID8gbnVsbCA6IENhc3QucmVmKGNvbmRpdGlvbiksXG4gICAgICAgICAgICBwZWVrOiBzY2hlbWFDb25kaXRpb24gPyBjb25kaXRpb24gOiBudWxsLFxuICAgICAgICAgICAgaXMsXG4gICAgICAgICAgICB0aGVuOiBvcHRpb25zLnRoZW4gIT09IHVuZGVmaW5lZCA/IENhc3Quc2NoZW1hKHRoaXMuX2N1cnJlbnRKb2ksIG9wdGlvbnMudGhlbikgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBvdGhlcndpc2U6IG9wdGlvbnMub3RoZXJ3aXNlICE9PSB1bmRlZmluZWQgPyBDYXN0LnNjaGVtYSh0aGlzLl9jdXJyZW50Sm9pLCBvcHRpb25zLm90aGVyd2lzZSkgOiB1bmRlZmluZWRcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAob2JqLl9iYXNlVHlwZSkge1xuXG4gICAgICAgICAgICBpdGVtLnRoZW4gPSBpdGVtLnRoZW4gJiYgb2JqLl9iYXNlVHlwZS5jb25jYXQoaXRlbS50aGVuKTtcbiAgICAgICAgICAgIGl0ZW0ub3RoZXJ3aXNlID0gaXRlbS5vdGhlcndpc2UgJiYgb2JqLl9iYXNlVHlwZS5jb25jYXQoaXRlbS5vdGhlcndpc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzY2hlbWFDb25kaXRpb24pIHtcbiAgICAgICAgICAgIFJlZi5wdXNoKG9iai5fcmVmcywgaXRlbS5yZWYpO1xuICAgICAgICAgICAgb2JqLl9yZWZzLnB1c2goLi4uaXRlbS5pcy5fcmVmcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXRlbS50aGVuICYmIGl0ZW0udGhlbi5fcmVmcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIG9iai5fcmVmcy5wdXNoKC4uLml0ZW0udGhlbi5fcmVmcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXRlbS5vdGhlcndpc2UgJiYgaXRlbS5vdGhlcndpc2UuX3JlZnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBvYmouX3JlZnMucHVzaCguLi5pdGVtLm90aGVyd2lzZS5fcmVmcyk7XG4gICAgICAgIH1cblxuICAgICAgICBvYmouX2lubmVyLm1hdGNoZXMucHVzaChpdGVtKTtcblxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIGxhYmVsKG5hbWUpIHtcblxuICAgICAgICBjb25zdCBvYmogPSBzdXBlci5sYWJlbChuYW1lKTtcbiAgICAgICAgb2JqLl9pbm5lci5tYXRjaGVzID0gb2JqLl9pbm5lci5tYXRjaGVzLm1hcCgobWF0Y2gpID0+IHtcblxuICAgICAgICAgICAgaWYgKG1hdGNoLnNjaGVtYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHNjaGVtYTogbWF0Y2guc2NoZW1hLmxhYmVsKG5hbWUpIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1hdGNoID0gT2JqZWN0LmFzc2lnbih7fSwgbWF0Y2gpO1xuICAgICAgICAgICAgaWYgKG1hdGNoLnRoZW4pIHtcbiAgICAgICAgICAgICAgICBtYXRjaC50aGVuID0gbWF0Y2gudGhlbi5sYWJlbChuYW1lKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1hdGNoLm90aGVyd2lzZSkge1xuICAgICAgICAgICAgICAgIG1hdGNoLm90aGVyd2lzZSA9IG1hdGNoLm90aGVyd2lzZS5sYWJlbChuYW1lKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBkZXNjcmliZSgpIHtcblxuICAgICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IHN1cGVyLmRlc2NyaWJlKCk7XG4gICAgICAgIGNvbnN0IGFsdGVybmF0aXZlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2lubmVyLm1hdGNoZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLl9pbm5lci5tYXRjaGVzW2ldO1xuICAgICAgICAgICAgaWYgKGl0ZW0uc2NoZW1hKSB7XG5cbiAgICAgICAgICAgICAgICAvLyB0cnkoKVxuXG4gICAgICAgICAgICAgICAgYWx0ZXJuYXRpdmVzLnB1c2goaXRlbS5zY2hlbWEuZGVzY3JpYmUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgIC8vIHdoZW4oKVxuXG4gICAgICAgICAgICAgICAgY29uc3Qgd2hlbiA9IGl0ZW0uaXMgPyB7XG4gICAgICAgICAgICAgICAgICAgIHJlZjogaXRlbS5yZWYudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgaXM6IGl0ZW0uaXMuZGVzY3JpYmUoKVxuICAgICAgICAgICAgICAgIH0gOiB7XG4gICAgICAgICAgICAgICAgICAgIHBlZWs6IGl0ZW0ucGVlay5kZXNjcmliZSgpXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGlmIChpdGVtLnRoZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgd2hlbi50aGVuID0gaXRlbS50aGVuLmRlc2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0ub3RoZXJ3aXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHdoZW4ub3RoZXJ3aXNlID0gaXRlbS5vdGhlcndpc2UuZGVzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBhbHRlcm5hdGl2ZXMucHVzaCh3aGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGRlc2NyaXB0aW9uLmFsdGVybmF0aXZlcyA9IGFsdGVybmF0aXZlcztcbiAgICAgICAgcmV0dXJuIGRlc2NyaXB0aW9uO1xuICAgIH1cblxufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBpbnRlcm5hbHMuQWx0ZXJuYXRpdmVzKCk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEhvZWsgPSByZXF1aXJlKCdAaGFwaS9ob2VrJyk7XG5jb25zdCBNYXJrZXIgPSByZXF1aXJlKCdAaGFwaS9tYXJrZXInKTtcblxuY29uc3QgQ2FzdCA9IHJlcXVpcmUoJy4uLy4uL2Nhc3QnKTtcbmNvbnN0IFNldHRpbmdzID0gcmVxdWlyZSgnLi9zZXR0aW5ncycpO1xuY29uc3QgUmVmID0gcmVxdWlyZSgnLi4vLi4vcmVmJyk7XG5jb25zdCBFcnJvcnMgPSByZXF1aXJlKCcuLi8uLi9lcnJvcnMnKTtcbmNvbnN0IFN0YXRlID0gcmVxdWlyZSgnLi4vc3RhdGUnKTtcbmNvbnN0IFN5bWJvbHMgPSByZXF1aXJlKCcuLi9zeW1ib2xzJyk7XG5cbmNvbnN0IFBrZyA9IHJlcXVpcmUoJy4uLy4uLy4uL3BhY2thZ2UuanNvbicpO1xuXG5sZXQgQWx0ZXJuYXRpdmVzID0gbnVsbDsgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVsYXktbG9hZGVkIHRvIHByZXZlbnQgY2lyY3VsYXIgZGVwZW5kZW5jaWVzXG5sZXQgU2NoZW1hcyA9IG51bGw7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge1xuICAgIFNldDogcmVxdWlyZSgnLi4vLi4vc2V0JyksXG4gICAgc3ltYm9sOiBNYXJrZXIoJ2pvaS1hbnktYmFzZScpXG59O1xuXG5cbmludGVybmFscy5kZWZhdWx0cyA9IHtcbiAgICBhYm9ydEVhcmx5OiB0cnVlLFxuICAgIGNvbnZlcnQ6IHRydWUsXG4gICAgYWxsb3dVbmtub3duOiBmYWxzZSxcbiAgICBza2lwRnVuY3Rpb25zOiBmYWxzZSxcbiAgICBzdHJpcFVua25vd246IGZhbHNlLFxuICAgIGxhbmd1YWdlOiB7fSxcbiAgICBwcmVzZW5jZTogJ29wdGlvbmFsJyxcbiAgICBub0RlZmF1bHRzOiBmYWxzZSxcbiAgICBlc2NhcGVIdG1sOiBmYWxzZVxuXG4gICAgLy8gY29udGV4dDogbnVsbFxufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGludGVybmFscy5BbnkgPSBjbGFzcyB7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcblxuICAgICAgICB0aGlzLmlzSm9pID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fdHlwZSA9ICdhbnknO1xuICAgICAgICB0aGlzLl9zZXR0aW5ncyA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ZhbGlkcyA9IG5ldyBpbnRlcm5hbHMuU2V0KCk7XG4gICAgICAgIHRoaXMuX2ludmFsaWRzID0gbmV3IGludGVybmFscy5TZXQoKTtcbiAgICAgICAgdGhpcy5fdGVzdHMgPSBbXTtcbiAgICAgICAgdGhpcy5fcmVmcyA9IFtdO1xuICAgICAgICB0aGlzLl9mbGFncyA9IHtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgcHJlc2VuY2U6ICdvcHRpb25hbCcsICAgICAgICAgICAgICAgICAgIC8vIG9wdGlvbmFsLCByZXF1aXJlZCwgZm9yYmlkZGVuLCBpZ25vcmVcbiAgICAgICAgICAgICBhbGxvd09ubHk6IGZhbHNlLFxuICAgICAgICAgICAgIGFsbG93VW5rbm93bjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgIGRlZmF1bHQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICBmb3JiaWRkZW46IGZhbHNlLFxuICAgICAgICAgICAgIGVuY29kaW5nOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgaW5zZW5zaXRpdmU6IGZhbHNlLFxuICAgICAgICAgICAgIHRyaW06IGZhbHNlLFxuICAgICAgICAgICAgIG5vcm1hbGl6ZTogdW5kZWZpbmVkLCAgICAgICAgICAgICAgICAgICAvLyBORkMsIE5GRCwgTkZLQywgTkZLRFxuICAgICAgICAgICAgIGNhc2U6IHVuZGVmaW5lZCwgICAgICAgICAgICAgICAgICAgICAgICAvLyB1cHBlciwgbG93ZXJcbiAgICAgICAgICAgICBlbXB0eTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgIGZ1bmM6IGZhbHNlLFxuICAgICAgICAgICAgIHJhdzogZmFsc2VcbiAgICAgICAgICAgICAqL1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuX2Rlc2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5fdW5pdCA9IG51bGw7XG4gICAgICAgIHRoaXMuX25vdGVzID0gW107XG4gICAgICAgIHRoaXMuX3RhZ3MgPSBbXTtcbiAgICAgICAgdGhpcy5fZXhhbXBsZXMgPSBbXTtcbiAgICAgICAgdGhpcy5fbWV0YSA9IFtdO1xuXG4gICAgICAgIHRoaXMuX2lubmVyID0ge307ICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGFzaCBvZiBhcnJheXMgb2YgaW1tdXRhYmxlIG9iamVjdHNcbiAgICB9XG5cbiAgICBfaW5pdCgpIHtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBnZXQgc2NoZW1hVHlwZSgpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5fdHlwZTtcbiAgICB9XG5cbiAgICBjcmVhdGVFcnJvcih0eXBlLCBjb250ZXh0LCBzdGF0ZSwgb3B0aW9ucywgZmxhZ3MgPSB0aGlzLl9mbGFncykge1xuXG4gICAgICAgIHJldHVybiBFcnJvcnMuY3JlYXRlKHR5cGUsIGNvbnRleHQsIHN0YXRlLCBvcHRpb25zLCBmbGFncyk7XG4gICAgfVxuXG4gICAgY3JlYXRlT3ZlcnJpZGVFcnJvcih0eXBlLCBjb250ZXh0LCBzdGF0ZSwgb3B0aW9ucywgbWVzc2FnZSwgdGVtcGxhdGUpIHtcblxuICAgICAgICByZXR1cm4gRXJyb3JzLmNyZWF0ZSh0eXBlLCBjb250ZXh0LCBzdGF0ZSwgb3B0aW9ucywgdGhpcy5fZmxhZ3MsIG1lc3NhZ2UsIHRlbXBsYXRlKTtcbiAgICB9XG5cbiAgICBjaGVja09wdGlvbnMob3B0aW9ucykge1xuXG4gICAgICAgIFNjaGVtYXMgPSBTY2hlbWFzIHx8IHJlcXVpcmUoJy4uLy4uL3NjaGVtYXMnKTtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSBTY2hlbWFzLm9wdGlvbnMudmFsaWRhdGUob3B0aW9ucyk7XG5cbiAgICAgICAgaWYgKHJlc3VsdC5lcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlc3VsdC5lcnJvci5kZXRhaWxzWzBdLm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2xvbmUoKSB7XG5cbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykpO1xuXG4gICAgICAgIG9iai5pc0pvaSA9IHRydWU7XG4gICAgICAgIG9iai5fY3VycmVudEpvaSA9IHRoaXMuX2N1cnJlbnRKb2k7XG4gICAgICAgIG9iai5fdHlwZSA9IHRoaXMuX3R5cGU7XG4gICAgICAgIG9iai5fc2V0dGluZ3MgPSB0aGlzLl9zZXR0aW5ncztcbiAgICAgICAgb2JqLl9iYXNlVHlwZSA9IHRoaXMuX2Jhc2VUeXBlO1xuICAgICAgICBvYmouX3ZhbGlkcyA9IHRoaXMuX3ZhbGlkcy5zbGljZSgpO1xuICAgICAgICBvYmouX2ludmFsaWRzID0gdGhpcy5faW52YWxpZHMuc2xpY2UoKTtcbiAgICAgICAgb2JqLl90ZXN0cyA9IHRoaXMuX3Rlc3RzLnNsaWNlKCk7XG4gICAgICAgIG9iai5fcmVmcyA9IHRoaXMuX3JlZnMuc2xpY2UoKTtcbiAgICAgICAgb2JqLl9mbGFncyA9IEhvZWsuY2xvbmUodGhpcy5fZmxhZ3MpO1xuXG4gICAgICAgIG9iai5fZGVzY3JpcHRpb24gPSB0aGlzLl9kZXNjcmlwdGlvbjtcbiAgICAgICAgb2JqLl91bml0ID0gdGhpcy5fdW5pdDtcbiAgICAgICAgb2JqLl9ub3RlcyA9IHRoaXMuX25vdGVzLnNsaWNlKCk7XG4gICAgICAgIG9iai5fdGFncyA9IHRoaXMuX3RhZ3Muc2xpY2UoKTtcbiAgICAgICAgb2JqLl9leGFtcGxlcyA9IHRoaXMuX2V4YW1wbGVzLnNsaWNlKCk7XG4gICAgICAgIG9iai5fbWV0YSA9IHRoaXMuX21ldGEuc2xpY2UoKTtcblxuICAgICAgICBvYmouX2lubmVyID0ge307XG4gICAgICAgIGNvbnN0IGlubmVycyA9IE9iamVjdC5rZXlzKHRoaXMuX2lubmVyKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbm5lcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGlubmVyc1tpXTtcbiAgICAgICAgICAgIG9iai5faW5uZXJba2V5XSA9IHRoaXMuX2lubmVyW2tleV0gPyB0aGlzLl9pbm5lcltrZXldLnNsaWNlKCkgOiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBjb25jYXQoc2NoZW1hKSB7XG5cbiAgICAgICAgSG9lay5hc3NlcnQoc2NoZW1hIGluc3RhbmNlb2YgaW50ZXJuYWxzLkFueSwgJ0ludmFsaWQgc2NoZW1hIG9iamVjdCcpO1xuICAgICAgICBIb2VrLmFzc2VydCh0aGlzLl90eXBlID09PSAnYW55JyB8fCBzY2hlbWEuX3R5cGUgPT09ICdhbnknIHx8IHNjaGVtYS5fdHlwZSA9PT0gdGhpcy5fdHlwZSwgJ0Nhbm5vdCBtZXJnZSB0eXBlJywgdGhpcy5fdHlwZSwgJ3dpdGggYW5vdGhlciB0eXBlOicsIHNjaGVtYS5fdHlwZSk7XG5cbiAgICAgICAgbGV0IG9iaiA9IHRoaXMuY2xvbmUoKTtcblxuICAgICAgICBpZiAodGhpcy5fdHlwZSA9PT0gJ2FueScgJiYgc2NoZW1hLl90eXBlICE9PSAnYW55Jykge1xuXG4gICAgICAgICAgICAvLyBSZXNldCB2YWx1ZXMgYXMgaWYgd2Ugd2VyZSBcInRoaXNcIlxuICAgICAgICAgICAgY29uc3QgdG1wT2JqID0gc2NoZW1hLmNsb25lKCk7XG4gICAgICAgICAgICBjb25zdCBrZXlzVG9SZXN0b3JlID0gWydfc2V0dGluZ3MnLCAnX3ZhbGlkcycsICdfaW52YWxpZHMnLCAnX3Rlc3RzJywgJ19yZWZzJywgJ19mbGFncycsICdfZGVzY3JpcHRpb24nLCAnX3VuaXQnLFxuICAgICAgICAgICAgICAgICdfbm90ZXMnLCAnX3RhZ3MnLCAnX2V4YW1wbGVzJywgJ19tZXRhJywgJ19pbm5lciddO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXNUb1Jlc3RvcmUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB0bXBPYmpba2V5c1RvUmVzdG9yZVtpXV0gPSBvYmpba2V5c1RvUmVzdG9yZVtpXV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9iaiA9IHRtcE9iajtcbiAgICAgICAgfVxuXG4gICAgICAgIG9iai5fc2V0dGluZ3MgPSBvYmouX3NldHRpbmdzID8gU2V0dGluZ3MuY29uY2F0KG9iai5fc2V0dGluZ3MsIHNjaGVtYS5fc2V0dGluZ3MpIDogc2NoZW1hLl9zZXR0aW5ncztcbiAgICAgICAgb2JqLl92YWxpZHMubWVyZ2Uoc2NoZW1hLl92YWxpZHMsIHNjaGVtYS5faW52YWxpZHMpO1xuICAgICAgICBvYmouX2ludmFsaWRzLm1lcmdlKHNjaGVtYS5faW52YWxpZHMsIHNjaGVtYS5fdmFsaWRzKTtcbiAgICAgICAgb2JqLl90ZXN0cy5wdXNoKC4uLnNjaGVtYS5fdGVzdHMpO1xuICAgICAgICBvYmouX3JlZnMucHVzaCguLi5zY2hlbWEuX3JlZnMpO1xuICAgICAgICBpZiAob2JqLl9mbGFncy5lbXB0eSAmJiBzY2hlbWEuX2ZsYWdzLmVtcHR5KSB7XG4gICAgICAgICAgICBvYmouX2ZsYWdzLmVtcHR5ID0gb2JqLl9mbGFncy5lbXB0eS5jb25jYXQoc2NoZW1hLl9mbGFncy5lbXB0eSk7XG4gICAgICAgICAgICBjb25zdCBmbGFncyA9IE9iamVjdC5hc3NpZ24oe30sIHNjaGVtYS5fZmxhZ3MpO1xuICAgICAgICAgICAgZGVsZXRlIGZsYWdzLmVtcHR5O1xuICAgICAgICAgICAgSG9lay5tZXJnZShvYmouX2ZsYWdzLCBmbGFncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2NoZW1hLl9mbGFncy5lbXB0eSkge1xuICAgICAgICAgICAgb2JqLl9mbGFncy5lbXB0eSA9IHNjaGVtYS5fZmxhZ3MuZW1wdHk7XG4gICAgICAgICAgICBjb25zdCBmbGFncyA9IE9iamVjdC5hc3NpZ24oe30sIHNjaGVtYS5fZmxhZ3MpO1xuICAgICAgICAgICAgZGVsZXRlIGZsYWdzLmVtcHR5O1xuICAgICAgICAgICAgSG9lay5tZXJnZShvYmouX2ZsYWdzLCBmbGFncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBIb2VrLm1lcmdlKG9iai5fZmxhZ3MsIHNjaGVtYS5fZmxhZ3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgb2JqLl9kZXNjcmlwdGlvbiA9IHNjaGVtYS5fZGVzY3JpcHRpb24gfHwgb2JqLl9kZXNjcmlwdGlvbjtcbiAgICAgICAgb2JqLl91bml0ID0gc2NoZW1hLl91bml0IHx8IG9iai5fdW5pdDtcbiAgICAgICAgb2JqLl9ub3Rlcy5wdXNoKC4uLnNjaGVtYS5fbm90ZXMpO1xuICAgICAgICBvYmouX3RhZ3MucHVzaCguLi5zY2hlbWEuX3RhZ3MpO1xuICAgICAgICBvYmouX2V4YW1wbGVzLnB1c2goLi4uc2NoZW1hLl9leGFtcGxlcyk7XG4gICAgICAgIG9iai5fbWV0YS5wdXNoKC4uLnNjaGVtYS5fbWV0YSk7XG5cbiAgICAgICAgY29uc3QgaW5uZXJzID0gT2JqZWN0LmtleXMoc2NoZW1hLl9pbm5lcik7XG4gICAgICAgIGNvbnN0IGlzT2JqZWN0ID0gb2JqLl90eXBlID09PSAnb2JqZWN0JztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbm5lcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGlubmVyc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZSA9IHNjaGVtYS5faW5uZXJba2V5XTtcbiAgICAgICAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXQgPSBvYmouX2lubmVyW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNPYmplY3QgJiYga2V5ID09PSAnY2hpbGRyZW4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXlzID0ge307XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGFyZ2V0Lmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5c1t0YXJnZXRbal0ua2V5XSA9IGo7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc291cmNlLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc291cmNlS2V5ID0gc291cmNlW2pdLmtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5c1tzb3VyY2VLZXldID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2tleXNbc291cmNlS2V5XV0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6IHNvdXJjZUtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjaGVtYTogdGFyZ2V0W2tleXNbc291cmNlS2V5XV0uc2NoZW1hLmNvbmNhdChzb3VyY2Vbal0uc2NoZW1hKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnB1c2goc291cmNlW2pdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmouX2lubmVyW2tleV0gPSBvYmouX2lubmVyW2tleV0uY29uY2F0KHNvdXJjZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9iai5faW5uZXJba2V5XSA9IHNvdXJjZS5zbGljZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX3Rlc3QobmFtZSwgYXJnLCBmdW5jLCBvcHRpb25zKSB7XG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBvYmouX3Rlc3RzLnB1c2goeyBmdW5jLCBuYW1lLCBhcmcsIG9wdGlvbnMgfSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX3Rlc3RVbmlxdWUobmFtZSwgYXJnLCBmdW5jLCBvcHRpb25zKSB7XG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBvYmouX3Rlc3RzID0gb2JqLl90ZXN0cy5maWx0ZXIoKHRlc3QpID0+IHRlc3QubmFtZSAhPT0gbmFtZSk7XG4gICAgICAgIG9iai5fdGVzdHMucHVzaCh7IGZ1bmMsIG5hbWUsIGFyZywgb3B0aW9ucyB9KTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBvcHRpb25zKG9wdGlvbnMpIHtcblxuICAgICAgICBIb2VrLmFzc2VydCghb3B0aW9ucy5jb250ZXh0LCAnQ2Fubm90IG92ZXJyaWRlIGNvbnRleHQnKTtcbiAgICAgICAgdGhpcy5jaGVja09wdGlvbnMob3B0aW9ucyk7XG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBvYmouX3NldHRpbmdzID0gU2V0dGluZ3MuY29uY2F0KG9iai5fc2V0dGluZ3MsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIHN0cmljdChpc1N0cmljdCkge1xuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcblxuICAgICAgICBjb25zdCBjb252ZXJ0ID0gaXNTdHJpY3QgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogIWlzU3RyaWN0O1xuICAgICAgICBvYmouX3NldHRpbmdzID0gU2V0dGluZ3MuY29uY2F0KG9iai5fc2V0dGluZ3MsIHsgY29udmVydCB9KTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICByYXcoaXNSYXcpIHtcblxuICAgICAgICBjb25zdCB2YWx1ZSA9IGlzUmF3ID09PSB1bmRlZmluZWQgPyB0cnVlIDogaXNSYXc7XG5cbiAgICAgICAgaWYgKHRoaXMuX2ZsYWdzLnJhdyA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBvYmouX2ZsYWdzLnJhdyA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIGVycm9yKGVyciwgb3B0aW9ucyA9IHsgc2VsZjogZmFsc2UgfSkge1xuXG4gICAgICAgIEhvZWsuYXNzZXJ0KGVyciAmJiAoZXJyIGluc3RhbmNlb2YgRXJyb3IgfHwgdHlwZW9mIGVyciA9PT0gJ2Z1bmN0aW9uJyksICdNdXN0IHByb3ZpZGUgYSB2YWxpZCBFcnJvciBvYmplY3Qgb3IgYSBmdW5jdGlvbicpO1xuXG4gICAgICAgIGNvbnN0IHVua25vd25LZXlzID0gT2JqZWN0LmtleXMob3B0aW9ucykuZmlsdGVyKChrKSA9PiAhWydzZWxmJ10uaW5jbHVkZXMoaykpO1xuICAgICAgICBIb2VrLmFzc2VydCh1bmtub3duS2V5cy5sZW5ndGggPT09IDAsIGBPcHRpb25zICR7dW5rbm93bktleXN9IGFyZSB1bmtub3duYCk7XG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBvYmouX2ZsYWdzLmVycm9yID0gZXJyO1xuXG4gICAgICAgIGlmIChvcHRpb25zLnNlbGYpIHtcbiAgICAgICAgICAgIG9iai5fZmxhZ3Muc2VsZkVycm9yID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgYWxsb3coLi4udmFsdWVzKSB7XG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICB2YWx1ZXMgPSBIb2VrLmZsYXR0ZW4odmFsdWVzKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVzW2ldO1xuXG4gICAgICAgICAgICBIb2VrLmFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkLCAnQ2Fubm90IGNhbGwgYWxsb3cvdmFsaWQvaW52YWxpZCB3aXRoIHVuZGVmaW5lZCcpO1xuICAgICAgICAgICAgb2JqLl9pbnZhbGlkcy5yZW1vdmUodmFsdWUpO1xuICAgICAgICAgICAgb2JqLl92YWxpZHMuYWRkKHZhbHVlLCBvYmouX3JlZnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICB2YWxpZCguLi52YWx1ZXMpIHtcblxuICAgICAgICBjb25zdCBvYmogPSB0aGlzLmFsbG93KC4uLnZhbHVlcyk7XG4gICAgICAgIG9iai5fZmxhZ3MuYWxsb3dPbmx5ID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBpbnZhbGlkKC4uLnZhbHVlcykge1xuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgdmFsdWVzID0gSG9lay5mbGF0dGVuKHZhbHVlcyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1tpXTtcblxuICAgICAgICAgICAgSG9lay5hc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCwgJ0Nhbm5vdCBjYWxsIGFsbG93L3ZhbGlkL2ludmFsaWQgd2l0aCB1bmRlZmluZWQnKTtcbiAgICAgICAgICAgIG9iai5fdmFsaWRzLnJlbW92ZSh2YWx1ZSk7XG4gICAgICAgICAgICBvYmouX2ludmFsaWRzLmFkZCh2YWx1ZSwgb2JqLl9yZWZzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgcmVxdWlyZWQoKSB7XG5cbiAgICAgICAgaWYgKHRoaXMuX2ZsYWdzLnByZXNlbmNlID09PSAncmVxdWlyZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgb2JqLl9mbGFncy5wcmVzZW5jZSA9ICdyZXF1aXJlZCc7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgb3B0aW9uYWwoKSB7XG5cbiAgICAgICAgaWYgKHRoaXMuX2ZsYWdzLnByZXNlbmNlID09PSAnb3B0aW9uYWwnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgb2JqLl9mbGFncy5wcmVzZW5jZSA9ICdvcHRpb25hbCc7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG5cbiAgICBmb3JiaWRkZW4oKSB7XG5cbiAgICAgICAgaWYgKHRoaXMuX2ZsYWdzLnByZXNlbmNlID09PSAnZm9yYmlkZGVuJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIG9iai5fZmxhZ3MucHJlc2VuY2UgPSAnZm9yYmlkZGVuJztcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cblxuICAgIHN0cmlwKCkge1xuXG4gICAgICAgIGlmICh0aGlzLl9mbGFncy5zdHJpcCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIG9iai5fZmxhZ3Muc3RyaXAgPSB0cnVlO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIGFwcGx5RnVuY3Rpb25Ub0NoaWxkcmVuKGNoaWxkcmVuLCBmbiwgYXJncyA9IFtdLCByb290KSB7XG5cbiAgICAgICAgY2hpbGRyZW4gPSBbXS5jb25jYXQoY2hpbGRyZW4pO1xuXG4gICAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGggIT09IDEgfHwgY2hpbGRyZW5bMF0gIT09ICcnKSB7XG4gICAgICAgICAgICByb290ID0gcm9vdCA/IChyb290ICsgJy4nKSA6ICcnO1xuXG4gICAgICAgICAgICBjb25zdCBleHRyYUNoaWxkcmVuID0gKGNoaWxkcmVuWzBdID09PSAnJyA/IGNoaWxkcmVuLnNsaWNlKDEpIDogY2hpbGRyZW4pLm1hcCgoY2hpbGQpID0+IHtcblxuICAgICAgICAgICAgICAgIHJldHVybiByb290ICsgY2hpbGQ7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGtleShzKSAnICsgZXh0cmFDaGlsZHJlbi5qb2luKCcsICcpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzW2ZuXSguLi5hcmdzKTtcbiAgICB9XG5cbiAgICBkZWZhdWx0KHZhbHVlLCBkZXNjcmlwdGlvbikge1xuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgICFSZWYuaXNSZWYodmFsdWUpKSB7XG5cbiAgICAgICAgICAgIGlmICghdmFsdWUuZGVzY3JpcHRpb24gJiZcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbikge1xuXG4gICAgICAgICAgICAgICAgdmFsdWUuZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCF0aGlzLl9mbGFncy5mdW5jKSB7XG4gICAgICAgICAgICAgICAgSG9lay5hc3NlcnQodHlwZW9mIHZhbHVlLmRlc2NyaXB0aW9uID09PSAnc3RyaW5nJyAmJiB2YWx1ZS5kZXNjcmlwdGlvbi5sZW5ndGggPiAwLCAnZGVzY3JpcHRpb24gbXVzdCBiZSBwcm92aWRlZCB3aGVuIGRlZmF1bHQgdmFsdWUgaXMgYSBmdW5jdGlvbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBvYmouX2ZsYWdzLmRlZmF1bHQgPSB2YWx1ZTtcbiAgICAgICAgUmVmLnB1c2gob2JqLl9yZWZzLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgZW1wdHkoc2NoZW1hKSB7XG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBpZiAoc2NoZW1hID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBvYmouX2ZsYWdzLmVtcHR5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2JqLl9mbGFncy5lbXB0eSA9IENhc3Quc2NoZW1hKHRoaXMuX2N1cnJlbnRKb2ksIHNjaGVtYSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIHdoZW4oY29uZGl0aW9uLCBvcHRpb25zKSB7XG5cbiAgICAgICAgSG9lay5hc3NlcnQob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcsICdJbnZhbGlkIG9wdGlvbnMnKTtcbiAgICAgICAgSG9lay5hc3NlcnQob3B0aW9ucy50aGVuICE9PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5vdGhlcndpc2UgIT09IHVuZGVmaW5lZCwgJ29wdGlvbnMgbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBvZiBcInRoZW5cIiBvciBcIm90aGVyd2lzZVwiJyk7XG5cbiAgICAgICAgY29uc3QgdGhlbiA9IG9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ3RoZW4nKSA/IHRoaXMuY29uY2F0KENhc3Quc2NoZW1hKHRoaXMuX2N1cnJlbnRKb2ksIG9wdGlvbnMudGhlbikpIDogdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBvdGhlcndpc2UgPSBvcHRpb25zLmhhc093blByb3BlcnR5KCdvdGhlcndpc2UnKSA/IHRoaXMuY29uY2F0KENhc3Quc2NoZW1hKHRoaXMuX2N1cnJlbnRKb2ksIG9wdGlvbnMub3RoZXJ3aXNlKSkgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgQWx0ZXJuYXRpdmVzID0gQWx0ZXJuYXRpdmVzIHx8IHJlcXVpcmUoJy4uL2FsdGVybmF0aXZlcycpO1xuXG4gICAgICAgIGNvbnN0IGFsdGVybmF0aXZlT3B0aW9ucyA9IHsgdGhlbiwgb3RoZXJ3aXNlIH07XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgJ2lzJykpIHtcbiAgICAgICAgICAgIGFsdGVybmF0aXZlT3B0aW9ucy5pcyA9IG9wdGlvbnMuaXM7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBvYmogPSBBbHRlcm5hdGl2ZXMud2hlbihjb25kaXRpb24sIGFsdGVybmF0aXZlT3B0aW9ucyk7XG4gICAgICAgIG9iai5fZmxhZ3MucHJlc2VuY2UgPSAnaWdub3JlJztcbiAgICAgICAgb2JqLl9iYXNlVHlwZSA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBkZXNjcmlwdGlvbihkZXNjKSB7XG5cbiAgICAgICAgSG9lay5hc3NlcnQoZGVzYyAmJiB0eXBlb2YgZGVzYyA9PT0gJ3N0cmluZycsICdEZXNjcmlwdGlvbiBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgb2JqLl9kZXNjcmlwdGlvbiA9IGRlc2M7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgbm90ZXMobm90ZXMpIHtcblxuICAgICAgICBIb2VrLmFzc2VydChub3RlcyAmJiAodHlwZW9mIG5vdGVzID09PSAnc3RyaW5nJyB8fCBBcnJheS5pc0FycmF5KG5vdGVzKSksICdOb3RlcyBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZyBvciBhcnJheScpO1xuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgb2JqLl9ub3RlcyA9IG9iai5fbm90ZXMuY29uY2F0KG5vdGVzKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICB0YWdzKHRhZ3MpIHtcblxuICAgICAgICBIb2VrLmFzc2VydCh0YWdzICYmICh0eXBlb2YgdGFncyA9PT0gJ3N0cmluZycgfHwgQXJyYXkuaXNBcnJheSh0YWdzKSksICdUYWdzIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nIG9yIGFycmF5Jyk7XG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBvYmouX3RhZ3MgPSBvYmouX3RhZ3MuY29uY2F0KHRhZ3MpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIG1ldGEobWV0YSkge1xuXG4gICAgICAgIEhvZWsuYXNzZXJ0KG1ldGEgIT09IHVuZGVmaW5lZCwgJ01ldGEgY2Fubm90IGJlIHVuZGVmaW5lZCcpO1xuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgb2JqLl9tZXRhID0gb2JqLl9tZXRhLmNvbmNhdChtZXRhKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBleGFtcGxlKC4uLmV4YW1wbGVzKSB7XG5cbiAgICAgICAgSG9lay5hc3NlcnQoZXhhbXBsZXMubGVuZ3RoID4gMCwgJ01pc3NpbmcgZXhhbXBsZXMnKTtcblxuICAgICAgICBjb25zdCBwcm9jZXNzZWQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBleGFtcGxlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgZXhhbXBsZSA9IFtdLmNvbmNhdChleGFtcGxlc1tpXSk7XG4gICAgICAgICAgICBIb2VrLmFzc2VydChleGFtcGxlLmxlbmd0aCA8PSAyLCBgQmFkIGV4YW1wbGUgZm9ybWF0IGF0IGluZGV4ICR7aX1gKTtcblxuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBleGFtcGxlWzBdO1xuICAgICAgICAgICAgbGV0IG9wdGlvbnMgPSBleGFtcGxlWzFdO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIEhvZWsuYXNzZXJ0KG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnLCBgT3B0aW9ucyBmb3IgZXhhbXBsZSBhdCBpbmRleCAke2l9IG11c3QgYmUgYW4gb2JqZWN0YCk7XG4gICAgICAgICAgICAgICAgY29uc3QgdW5rbm93bk9wdGlvbnMgPSBPYmplY3Qua2V5cyhvcHRpb25zKS5maWx0ZXIoKG9wdGlvbikgPT4gIVsncGFyZW50JywgJ2NvbnRleHQnXS5pbmNsdWRlcyhvcHRpb24pKTtcbiAgICAgICAgICAgICAgICBIb2VrLmFzc2VydCh1bmtub3duT3B0aW9ucy5sZW5ndGggPT09IDAsIGBVbmtub3duIGV4YW1wbGUgb3B0aW9ucyAke3Vua25vd25PcHRpb25zfSBhdCBpbmRleCAke2l9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsU3RhdGUgPSBuZXcgU3RhdGUoJycsIFtdLCBvcHRpb25zLnBhcmVudCB8fCBudWxsKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX3ZhbGlkYXRlKHZhbHVlLCBsb2NhbFN0YXRlLCBTZXR0aW5ncy5jb25jYXQoaW50ZXJuYWxzLmRlZmF1bHRzLCBvcHRpb25zLmNvbnRleHQgPyB7IGNvbnRleHQ6IG9wdGlvbnMuY29udGV4dCB9IDogbnVsbCkpO1xuICAgICAgICAgICAgSG9lay5hc3NlcnQoIXJlc3VsdC5lcnJvcnMsIGBCYWQgZXhhbXBsZSBhdCBpbmRleCAke2l9OmAsIHJlc3VsdC5lcnJvcnMgJiYgRXJyb3JzLnByb2Nlc3MocmVzdWx0LmVycm9ycywgdmFsdWUpKTtcblxuICAgICAgICAgICAgY29uc3QgZXggPSB7IHZhbHVlIH07XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMob3B0aW9ucykubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZXgub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHByb2Nlc3NlZC5wdXNoKGV4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgb2JqLl9leGFtcGxlcyA9IHByb2Nlc3NlZDtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICB1bml0KG5hbWUpIHtcblxuICAgICAgICBIb2VrLmFzc2VydChuYW1lICYmIHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJywgJ1VuaXQgbmFtZSBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgb2JqLl91bml0ID0gbmFtZTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfcHJlcGFyZUVtcHR5VmFsdWUodmFsdWUpIHtcblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB0aGlzLl9mbGFncy50cmltKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUudHJpbSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIF92YWxpZGF0ZSh2YWx1ZSwgc3RhdGUsIG9wdGlvbnMsIHJlZmVyZW5jZSkge1xuXG4gICAgICAgIGNvbnN0IG9yaWdpbmFsVmFsdWUgPSB2YWx1ZTtcblxuICAgICAgICAvLyBTZXR1cCBzdGF0ZSBhbmQgc2V0dGluZ3NcblxuICAgICAgICBzdGF0ZSA9IHN0YXRlIHx8IG5ldyBTdGF0ZSgnJywgW10sIG51bGwsIHJlZmVyZW5jZSk7XG5cbiAgICAgICAgaWYgKHRoaXMuX3NldHRpbmdzKSB7XG4gICAgICAgICAgICBjb25zdCBpc0RlZmF1bHRPcHRpb25zID0gb3B0aW9ucyA9PT0gaW50ZXJuYWxzLmRlZmF1bHRzO1xuICAgICAgICAgICAgaWYgKGlzRGVmYXVsdE9wdGlvbnMgJiYgdGhpcy5fc2V0dGluZ3NbU3ltYm9scy5zZXR0aW5nc0NhY2hlXSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB0aGlzLl9zZXR0aW5nc1tTeW1ib2xzLnNldHRpbmdzQ2FjaGVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IFNldHRpbmdzLmNvbmNhdCh0aGlzLl9sYW5ndWFnZSA/IFNldHRpbmdzLmNvbmNhdCh7IGxhbmd1YWdlOiB0aGlzLl9sYW5ndWFnZSB9LCBvcHRpb25zKSA6IG9wdGlvbnMsIHRoaXMuX3NldHRpbmdzKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNEZWZhdWx0T3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXR0aW5nc1tTeW1ib2xzLnNldHRpbmdzQ2FjaGVdID0gb3B0aW9ucztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5fbGFuZ3VhZ2UpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBTZXR0aW5ncy5jb25jYXQoeyBsYW5ndWFnZTogdGhpcy5fbGFuZ3VhZ2UgfSwgb3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZXJyb3JzID0gW107XG5cbiAgICAgICAgaWYgKHRoaXMuX2NvZXJjZSkge1xuICAgICAgICAgICAgY29uc3QgY29lcmNlZCA9IHRoaXMuX2NvZXJjZSh2YWx1ZSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKGNvZXJjZWQuZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBjb2VyY2VkLnZhbHVlO1xuICAgICAgICAgICAgICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQoY29lcmNlZC5lcnJvcnMpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9maW5hbGl6ZVZhbHVlKHZhbHVlLCBvcmlnaW5hbFZhbHVlLCBlcnJvcnMsIHN0YXRlLCBvcHRpb25zKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29lcmNlZCBlcnJvciBhbHdheXMgYWJvcnRzIGVhcmx5XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhbHVlID0gY29lcmNlZC52YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9mbGFncy5lbXB0eSAmJiAhdGhpcy5fZmxhZ3MuZW1wdHkuX3ZhbGlkYXRlKHRoaXMuX3ByZXBhcmVFbXB0eVZhbHVlKHZhbHVlKSwgbnVsbCwgaW50ZXJuYWxzLmRlZmF1bHRzKS5lcnJvcnMpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgcHJlc2VuY2UgcmVxdWlyZW1lbnRzXG5cbiAgICAgICAgY29uc3QgcHJlc2VuY2UgPSB0aGlzLl9mbGFncy5wcmVzZW5jZSB8fCBvcHRpb25zLnByZXNlbmNlO1xuICAgICAgICBpZiAocHJlc2VuY2UgPT09ICdvcHRpb25hbCcpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNEZWVwRGVmYXVsdCA9IHRoaXMuX2ZsYWdzLmhhc093blByb3BlcnR5KCdkZWZhdWx0JykgJiYgdGhpcy5fZmxhZ3MuZGVmYXVsdCA9PT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGlmIChpc0RlZXBEZWZhdWx0ICYmIHRoaXMuX3R5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0ge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZmluYWxpemVWYWx1ZSh2YWx1ZSwgb3JpZ2luYWxWYWx1ZSwgZXJyb3JzLCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByZXNlbmNlID09PSAncmVxdWlyZWQnICYmXG4gICAgICAgICAgICB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgICAgIGVycm9ycy5wdXNoKHRoaXMuY3JlYXRlRXJyb3IoJ2FueS5yZXF1aXJlZCcsIG51bGwsIHN0YXRlLCBvcHRpb25zKSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZmluYWxpemVWYWx1ZSh2YWx1ZSwgb3JpZ2luYWxWYWx1ZSwgZXJyb3JzLCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJlc2VuY2UgPT09ICdmb3JiaWRkZW4nKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9maW5hbGl6ZVZhbHVlKHZhbHVlLCBvcmlnaW5hbFZhbHVlLCBlcnJvcnMsIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXJyb3JzLnB1c2godGhpcy5jcmVhdGVFcnJvcignYW55LnVua25vd24nLCBudWxsLCBzdGF0ZSwgb3B0aW9ucykpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbmFsaXplVmFsdWUodmFsdWUsIG9yaWdpbmFsVmFsdWUsIGVycm9ycywgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgYWxsb3dlZCBhbmQgZGVuaWVkIHZhbHVlcyB1c2luZyB0aGUgb3JpZ2luYWwgdmFsdWVcblxuICAgICAgICBsZXQgbWF0Y2ggPSB0aGlzLl92YWxpZHMuZ2V0KHZhbHVlLCBzdGF0ZSwgb3B0aW9ucywgdGhpcy5fZmxhZ3MuaW5zZW5zaXRpdmUpO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmNvbnZlcnQpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG1hdGNoLnZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZmluYWxpemVWYWx1ZSh2YWx1ZSwgb3JpZ2luYWxWYWx1ZSwgZXJyb3JzLCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5faW52YWxpZHMuaGFzKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucywgdGhpcy5fZmxhZ3MuaW5zZW5zaXRpdmUpKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaCh0aGlzLmNyZWF0ZUVycm9yKHZhbHVlID09PSAnJyA/ICdhbnkuZW1wdHknIDogJ2FueS5pbnZhbGlkJywgeyB2YWx1ZSwgaW52YWxpZHM6IHRoaXMuX2ludmFsaWRzLnZhbHVlcyh7IHN0cmlwVW5kZWZpbmVkOiB0cnVlIH0pIH0sIHN0YXRlLCBvcHRpb25zKSk7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5hYm9ydEVhcmx5KSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZmluYWxpemVWYWx1ZSh2YWx1ZSwgb3JpZ2luYWxWYWx1ZSwgZXJyb3JzLCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb252ZXJ0IHZhbHVlIGFuZCB2YWxpZGF0ZSB0eXBlXG5cbiAgICAgICAgaWYgKHRoaXMuX2Jhc2UpIHtcbiAgICAgICAgICAgIGNvbnN0IGJhc2UgPSB0aGlzLl9iYXNlKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAoYmFzZS5lcnJvcnMpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGJhc2UudmFsdWU7XG4gICAgICAgICAgICAgICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdChiYXNlLmVycm9ycyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbmFsaXplVmFsdWUodmFsdWUsIG9yaWdpbmFsVmFsdWUsIGVycm9ycywgc3RhdGUsIG9wdGlvbnMpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBCYXNlIGVycm9yIGFsd2F5cyBhYm9ydHMgZWFybHlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGJhc2UudmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBiYXNlLnZhbHVlO1xuXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgYWxsb3dlZCBhbmQgZGVuaWVkIHZhbHVlcyB1c2luZyB0aGUgY29udmVydGVkIHZhbHVlXG5cbiAgICAgICAgICAgICAgICBtYXRjaCA9IHRoaXMuX3ZhbGlkcy5nZXQodmFsdWUsIHN0YXRlLCBvcHRpb25zLCB0aGlzLl9mbGFncy5pbnNlbnNpdGl2ZSk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbWF0Y2gudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9maW5hbGl6ZVZhbHVlKHZhbHVlLCBvcmlnaW5hbFZhbHVlLCBlcnJvcnMsIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faW52YWxpZHMuaGFzKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucywgdGhpcy5fZmxhZ3MuaW5zZW5zaXRpdmUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKHRoaXMuY3JlYXRlRXJyb3IodmFsdWUgPT09ICcnID8gJ2FueS5lbXB0eScgOiAnYW55LmludmFsaWQnLCB7IHZhbHVlLCBpbnZhbGlkczogdGhpcy5faW52YWxpZHMudmFsdWVzKHsgc3RyaXBVbmRlZmluZWQ6IHRydWUgfSkgfSwgc3RhdGUsIG9wdGlvbnMpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbmFsaXplVmFsdWUodmFsdWUsIG9yaWdpbmFsVmFsdWUsIGVycm9ycywgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVxdWlyZWQgdmFsdWVzIGRpZCBub3QgbWF0Y2hcblxuICAgICAgICBpZiAodGhpcy5fZmxhZ3MuYWxsb3dPbmx5KSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaCh0aGlzLmNyZWF0ZUVycm9yKCdhbnkuYWxsb3dPbmx5JywgeyB2YWx1ZSwgdmFsaWRzOiB0aGlzLl92YWxpZHMudmFsdWVzKHsgc3RyaXBVbmRlZmluZWQ6IHRydWUgfSkgfSwgc3RhdGUsIG9wdGlvbnMpKTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZmluYWxpemVWYWx1ZSh2YWx1ZSwgb3JpZ2luYWxWYWx1ZSwgZXJyb3JzLCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBWYWxpZGF0ZSB0ZXN0c1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fdGVzdHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IHRlc3QgPSB0aGlzLl90ZXN0c1tpXTtcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IHRlc3QuZnVuYy5jYWxsKHRoaXMsIHZhbHVlLCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAocmV0IGluc3RhbmNlb2YgRXJyb3JzLkVycikge1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKHJldCk7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZmluYWxpemVWYWx1ZSh2YWx1ZSwgb3JpZ2luYWxWYWx1ZSwgZXJyb3JzLCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSByZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fZmluYWxpemVWYWx1ZSh2YWx1ZSwgb3JpZ2luYWxWYWx1ZSwgZXJyb3JzLCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgX2ZpbmFsaXplVmFsdWUodmFsdWUsIG9yaWdpbmFsVmFsdWUsIGVycm9ycywgc3RhdGUsIG9wdGlvbnMpIHtcblxuICAgICAgICBsZXQgZmluYWxWYWx1ZTtcblxuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZmluYWxWYWx1ZSA9IHRoaXMuX2ZsYWdzLnJhdyA/IG9yaWdpbmFsVmFsdWUgOiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcHRpb25zLm5vRGVmYXVsdHMpIHtcbiAgICAgICAgICAgIGZpbmFsVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChSZWYuaXNSZWYodGhpcy5fZmxhZ3MuZGVmYXVsdCkpIHtcbiAgICAgICAgICAgIGZpbmFsVmFsdWUgPSB0aGlzLl9mbGFncy5kZWZhdWx0KHN0YXRlLnBhcmVudCwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHRoaXMuX2ZsYWdzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgICEodGhpcy5fZmxhZ3MuZnVuYyAmJiAhdGhpcy5fZmxhZ3MuZGVmYXVsdC5kZXNjcmlwdGlvbikpIHtcblxuICAgICAgICAgICAgbGV0IGFyZ3M7XG5cbiAgICAgICAgICAgIGlmIChzdGF0ZS5wYXJlbnQgIT09IG51bGwgJiZcbiAgICAgICAgICAgICAgICB0aGlzLl9mbGFncy5kZWZhdWx0Lmxlbmd0aCA+IDApIHtcblxuICAgICAgICAgICAgICAgIGFyZ3MgPSBbSG9lay5jbG9uZShzdGF0ZS5wYXJlbnQpLCBvcHRpb25zXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgZGVmYXVsdFZhbHVlID0gaW50ZXJuYWxzLl90cnkodGhpcy5fZmxhZ3MuZGVmYXVsdCwgYXJncyk7XG4gICAgICAgICAgICBmaW5hbFZhbHVlID0gZGVmYXVsdFZhbHVlLnZhbHVlO1xuICAgICAgICAgICAgaWYgKGRlZmF1bHRWYWx1ZS5lcnJvcikge1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKHRoaXMuY3JlYXRlRXJyb3IoJ2FueS5kZWZhdWx0JywgeyBlcnJvcjogZGVmYXVsdFZhbHVlLmVycm9yIH0sIHN0YXRlLCBvcHRpb25zKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmaW5hbFZhbHVlID0gSG9lay5jbG9uZSh0aGlzLl9mbGFncy5kZWZhdWx0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvcnMubGVuZ3RoICYmXG4gICAgICAgICAgICB0eXBlb2YgdGhpcy5fZmxhZ3MuZXJyb3IgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICAhdGhpcy5fZmxhZ3Muc2VsZkVycm9yIHx8XG4gICAgICAgICAgICAgICAgZXJyb3JzLnNvbWUoKGUpID0+IHN0YXRlLnBhdGgubGVuZ3RoID09PSBlLnBhdGgubGVuZ3RoKVxuICAgICAgICAgICAgKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYW5nZSA9IHRoaXMuX2ZsYWdzLmVycm9yLmNhbGwodGhpcywgZXJyb3JzKTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjaGFuZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JzID0gW3RoaXMuY3JlYXRlT3ZlcnJpZGVFcnJvcignb3ZlcnJpZGUnLCB7IHJlYXNvbjogZXJyb3JzIH0sIHN0YXRlLCBvcHRpb25zLCBjaGFuZ2UpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVycm9ycyA9IFtdLmNvbmNhdChjaGFuZ2UpXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoKGVycikgPT4ge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyIGluc3RhbmNlb2YgRXJyb3IgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVyciA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVPdmVycmlkZUVycm9yKGVyci50eXBlIHx8ICdvdmVycmlkZScsIGVyci5jb250ZXh0LCBzdGF0ZSwgb3B0aW9ucywgZXJyLm1lc3NhZ2UsIGVyci50ZW1wbGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLl9mbGFncy5zdHJpcCA/IHVuZGVmaW5lZCA6IGZpbmFsVmFsdWUsXG4gICAgICAgICAgICBmaW5hbFZhbHVlLFxuICAgICAgICAgICAgZXJyb3JzOiBlcnJvcnMubGVuZ3RoID8gZXJyb3JzIDogbnVsbFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIF92YWxpZGF0ZVdpdGhPcHRpb25zKHZhbHVlLCBvcHRpb25zLCBjYWxsYmFjaykge1xuXG4gICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHNldHRpbmdzID0gU2V0dGluZ3MuY29uY2F0KGludGVybmFscy5kZWZhdWx0cywgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX3ZhbGlkYXRlKHZhbHVlLCBudWxsLCBzZXR0aW5ncyk7XG4gICAgICAgIGNvbnN0IGVycm9ycyA9IEVycm9ycy5wcm9jZXNzKHJlc3VsdC5lcnJvcnMsIHZhbHVlKTtcblxuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnJvcnMsIHJlc3VsdC52YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZXJyb3I6IGVycm9ycyxcbiAgICAgICAgICAgIHZhbHVlOiByZXN1bHQudmFsdWUsXG4gICAgICAgICAgICB0aGVuKHJlc29sdmUsIHJlamVjdCkge1xuXG4gICAgICAgICAgICAgICAgaWYgKGVycm9ycykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3JzKS5jYXRjaChyZWplY3QpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0LnZhbHVlKS50aGVuKHJlc29sdmUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNhdGNoKHJlamVjdCkge1xuXG4gICAgICAgICAgICAgICAgaWYgKGVycm9ycykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3JzKS5jYXRjaChyZWplY3QpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0LnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YWxpZGF0ZSh2YWx1ZSwgb3B0aW9ucywgY2FsbGJhY2spIHtcblxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl92YWxpZGF0ZVdpdGhPcHRpb25zKHZhbHVlLCBudWxsLCBvcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl92YWxpZGF0ZVdpdGhPcHRpb25zKHZhbHVlLCBvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgZGVzY3JpYmUoKSB7XG5cbiAgICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSB7XG4gICAgICAgICAgICB0eXBlOiB0aGlzLl90eXBlXG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgZmxhZ3MgPSBPYmplY3Qua2V5cyh0aGlzLl9mbGFncyk7XG4gICAgICAgIGlmIChmbGFncy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChbJ2VtcHR5JywgJ2RlZmF1bHQnLCAnbGF6eScsICdsYWJlbCddLnNvbWUoKGZsYWcpID0+IHRoaXMuX2ZsYWdzLmhhc093blByb3BlcnR5KGZsYWcpKSkge1xuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uLmZsYWdzID0ge307XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmbGFncy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmbGFnID0gZmxhZ3NbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChmbGFnID09PSAnZW1wdHknKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbi5mbGFnc1tmbGFnXSA9IHRoaXMuX2ZsYWdzW2ZsYWddLmRlc2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZmxhZyA9PT0gJ2RlZmF1bHQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoUmVmLmlzUmVmKHRoaXMuX2ZsYWdzW2ZsYWddKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uLmZsYWdzW2ZsYWddID0gdGhpcy5fZmxhZ3NbZmxhZ10udG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB0aGlzLl9mbGFnc1tmbGFnXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uLmZsYWdzW2ZsYWddID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogdGhpcy5fZmxhZ3NbZmxhZ10uZGVzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICAgOiB0aGlzLl9mbGFnc1tmbGFnXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbi5mbGFnc1tmbGFnXSA9IHRoaXMuX2ZsYWdzW2ZsYWddO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZsYWcgPT09ICdsYXp5JyB8fCBmbGFnID09PSAnbGFiZWwnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBkb24ndCB3YW50IGl0IGluIHRoZSBkZXNjcmlwdGlvblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb24uZmxhZ3NbZmxhZ10gPSB0aGlzLl9mbGFnc1tmbGFnXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uLmZsYWdzID0gdGhpcy5fZmxhZ3M7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fc2V0dGluZ3MpIHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uLm9wdGlvbnMgPSBIb2VrLmNsb25lKHRoaXMuX3NldHRpbmdzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9iYXNlVHlwZSkge1xuICAgICAgICAgICAgZGVzY3JpcHRpb24uYmFzZSA9IHRoaXMuX2Jhc2VUeXBlLmRlc2NyaWJlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fZGVzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uLmRlc2NyaXB0aW9uID0gdGhpcy5fZGVzY3JpcHRpb247XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fbm90ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbi5ub3RlcyA9IHRoaXMuX25vdGVzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX3RhZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbi50YWdzID0gdGhpcy5fdGFncztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9tZXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgZGVzY3JpcHRpb24ubWV0YSA9IHRoaXMuX21ldGE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fZXhhbXBsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbi5leGFtcGxlcyA9IHRoaXMuX2V4YW1wbGVzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX3VuaXQpIHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uLnVuaXQgPSB0aGlzLl91bml0O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdmFsaWRzID0gdGhpcy5fdmFsaWRzLnZhbHVlcygpO1xuICAgICAgICBpZiAodmFsaWRzLmxlbmd0aCkge1xuICAgICAgICAgICAgZGVzY3JpcHRpb24udmFsaWRzID0gdmFsaWRzLm1hcCgodikgPT4ge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIFJlZi5pc1JlZih2KSA/IHYudG9TdHJpbmcoKSA6IHY7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGludmFsaWRzID0gdGhpcy5faW52YWxpZHMudmFsdWVzKCk7XG4gICAgICAgIGlmIChpbnZhbGlkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uLmludmFsaWRzID0gaW52YWxpZHMubWFwKCh2KSA9PiB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gUmVmLmlzUmVmKHYpID8gdi50b1N0cmluZygpIDogdjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVzY3JpcHRpb24ucnVsZXMgPSBbXTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3Rlc3RzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCB2YWxpZGF0b3IgPSB0aGlzLl90ZXN0c1tpXTtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSB7IG5hbWU6IHZhbGlkYXRvci5uYW1lIH07XG5cbiAgICAgICAgICAgIGlmICh2YWxpZGF0b3IuYXJnICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICBpdGVtLmFyZyA9IFJlZi5pc1JlZih2YWxpZGF0b3IuYXJnKSA/IHZhbGlkYXRvci5hcmcudG9TdHJpbmcoKSA6IHZhbGlkYXRvci5hcmc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSB2YWxpZGF0b3Iub3B0aW9ucztcbiAgICAgICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuaGFzUmVmKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uYXJnID0ge307XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh2YWxpZGF0b3IuYXJnKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBrZXlzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB2YWxpZGF0b3IuYXJnW2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmFyZ1trZXldID0gUmVmLmlzUmVmKHZhbHVlKSA/IHZhbHVlLnRvU3RyaW5nKCkgOiB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kZXNjcmlwdGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5kZXNjcmlwdGlvbiA9IG9wdGlvbnMuZGVzY3JpcHRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLmRlc2NyaXB0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uZGVzY3JpcHRpb24gPSBvcHRpb25zLmRlc2NyaXB0aW9uKGl0ZW0uYXJnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRlc2NyaXB0aW9uLnJ1bGVzLnB1c2goaXRlbSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWRlc2NyaXB0aW9uLnJ1bGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgZGVsZXRlIGRlc2NyaXB0aW9uLnJ1bGVzO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbGFiZWwgPSB0aGlzLl9nZXRMYWJlbCgpO1xuICAgICAgICBpZiAobGFiZWwpIHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uLmxhYmVsID0gbGFiZWw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVzY3JpcHRpb247XG4gICAgfVxuXG4gICAgbGFiZWwobmFtZSkge1xuXG4gICAgICAgIEhvZWsuYXNzZXJ0KG5hbWUgJiYgdHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnLCAnTGFiZWwgbmFtZSBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgb2JqLl9mbGFncy5sYWJlbCA9IG5hbWU7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX2dldExhYmVsKGRlZikge1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9mbGFncy5sYWJlbCB8fCBkZWY7XG4gICAgfVxuXG59O1xuXG5cbmludGVybmFscy5BbnkucHJvdG90eXBlLmlzSW1tdXRhYmxlID0gdHJ1ZTsgICAgIC8vIFByZXZlbnRzIEhvZWsgZnJvbSBkZWVwIGNsb25pbmcgc2NoZW1hIG9iamVjdHNcblxuLy8gQWxpYXNlc1xuXG5pbnRlcm5hbHMuQW55LnByb3RvdHlwZS5vbmx5ID0gaW50ZXJuYWxzLkFueS5wcm90b3R5cGUuZXF1YWwgPSBpbnRlcm5hbHMuQW55LnByb3RvdHlwZS52YWxpZDtcbmludGVybmFscy5BbnkucHJvdG90eXBlLmRpc2FsbG93ID0gaW50ZXJuYWxzLkFueS5wcm90b3R5cGUubm90ID0gaW50ZXJuYWxzLkFueS5wcm90b3R5cGUuaW52YWxpZDtcbmludGVybmFscy5BbnkucHJvdG90eXBlLmV4aXN0ID0gaW50ZXJuYWxzLkFueS5wcm90b3R5cGUucmVxdWlyZWQ7XG5cblxuaW50ZXJuYWxzLkFueS5wcm90b3R5cGVbaW50ZXJuYWxzLnN5bWJvbF0gPSB7XG4gICAgdmVyc2lvbjogUGtnLnZlcnNpb24sXG4gICAgY29tcGlsZTogQ2FzdC5zY2hlbWEsXG4gICAgcm9vdDogJ19jdXJyZW50Sm9pJ1xufTtcblxuXG5pbnRlcm5hbHMuX3RyeSA9IGZ1bmN0aW9uIChmbiwgYXJncyA9IFtdKSB7XG5cbiAgICBsZXQgZXJyO1xuICAgIGxldCByZXN1bHQ7XG5cbiAgICB0cnkge1xuICAgICAgICByZXN1bHQgPSBmbiguLi5hcmdzKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgZXJyID0gZTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogcmVzdWx0LFxuICAgICAgICBlcnJvcjogZXJyXG4gICAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEhvZWsgPSByZXF1aXJlKCdAaGFwaS9ob2VrJyk7XG5cbmNvbnN0IFN5bWJvbHMgPSByZXF1aXJlKCcuLi9zeW1ib2xzJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxuZXhwb3J0cy5jb25jYXQgPSBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcblxuICAgIGlmICghc291cmNlKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgY29uc3Qgb2JqID0gT2JqZWN0LmFzc2lnbih7fSwgdGFyZ2V0KTtcblxuICAgIGNvbnN0IGxhbmd1YWdlID0gc291cmNlLmxhbmd1YWdlO1xuXG4gICAgT2JqZWN0LmFzc2lnbihvYmosIHNvdXJjZSk7XG5cbiAgICBpZiAobGFuZ3VhZ2UgJiYgdGFyZ2V0ICYmIHRhcmdldC5sYW5ndWFnZSkge1xuICAgICAgICBvYmoubGFuZ3VhZ2UgPSBIb2VrLmFwcGx5VG9EZWZhdWx0cyh0YXJnZXQubGFuZ3VhZ2UsIGxhbmd1YWdlKTtcbiAgICB9XG5cbiAgICBpZiAob2JqW1N5bWJvbHMuc2V0dGluZ3NDYWNoZV0pIHtcbiAgICAgICAgZGVsZXRlIG9ialtTeW1ib2xzLnNldHRpbmdzQ2FjaGVdO1xuICAgIH1cblxuICAgIHJldHVybiBvYmo7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBIb2VrID0gcmVxdWlyZSgnQGhhcGkvaG9laycpO1xuXG5jb25zdCBBbnkgPSByZXF1aXJlKCcuLi9hbnknKTtcbmNvbnN0IENhc3QgPSByZXF1aXJlKCcuLi8uLi9jYXN0Jyk7XG5jb25zdCBSZWYgPSByZXF1aXJlKCcuLi8uLi9yZWYnKTtcbmNvbnN0IFN0YXRlID0gcmVxdWlyZSgnLi4vc3RhdGUnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5pbnRlcm5hbHMuZmFzdFNwbGljZSA9IGZ1bmN0aW9uIChhcnIsIGkpIHtcblxuICAgIGxldCBwb3MgPSBpO1xuICAgIHdoaWxlIChwb3MgPCBhcnIubGVuZ3RoKSB7XG4gICAgICAgIGFycltwb3MrK10gPSBhcnJbcG9zXTtcbiAgICB9XG5cbiAgICAtLWFyci5sZW5ndGg7XG59O1xuXG5cbmludGVybmFscy5BcnJheSA9IGNsYXNzIGV4dGVuZHMgQW55IHtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuXG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX3R5cGUgPSAnYXJyYXknO1xuICAgICAgICB0aGlzLl9pbm5lci5pdGVtcyA9IFtdO1xuICAgICAgICB0aGlzLl9pbm5lci5vcmRlcmVkcyA9IFtdO1xuICAgICAgICB0aGlzLl9pbm5lci5pbmNsdXNpb25zID0gW107XG4gICAgICAgIHRoaXMuX2lubmVyLmV4Y2x1c2lvbnMgPSBbXTtcbiAgICAgICAgdGhpcy5faW5uZXIucmVxdWlyZWRzID0gW107XG4gICAgICAgIHRoaXMuX2ZsYWdzLnNwYXJzZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIF9iYXNlKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucykge1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgIG9wdGlvbnMuY29udmVydCkge1xuXG4gICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID4gMSAmJlxuICAgICAgICAgICAgICAgICh2YWx1ZVswXSA9PT0gJ1snIHx8IC9eXFxzKlxcWy8udGVzdCh2YWx1ZSkpKSB7XG5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQudmFsdWUgPSBKU09OLnBhcnNlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGlzQXJyYXkgPSBBcnJheS5pc0FycmF5KHJlc3VsdC52YWx1ZSk7XG4gICAgICAgIGNvbnN0IHdhc0FycmF5ID0gaXNBcnJheTtcbiAgICAgICAgaWYgKG9wdGlvbnMuY29udmVydCAmJiB0aGlzLl9mbGFncy5zaW5nbGUgJiYgIWlzQXJyYXkpIHtcbiAgICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IFtyZXN1bHQudmFsdWVdO1xuICAgICAgICAgICAgaXNBcnJheSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzQXJyYXkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5lcnJvcnMgPSB0aGlzLmNyZWF0ZUVycm9yKCdhcnJheS5iYXNlJywgbnVsbCwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9pbm5lci5pbmNsdXNpb25zLmxlbmd0aCB8fFxuICAgICAgICAgICAgdGhpcy5faW5uZXIuZXhjbHVzaW9ucy5sZW5ndGggfHxcbiAgICAgICAgICAgIHRoaXMuX2lubmVyLnJlcXVpcmVkcy5sZW5ndGggfHxcbiAgICAgICAgICAgIHRoaXMuX2lubmVyLm9yZGVyZWRzLmxlbmd0aCB8fFxuICAgICAgICAgICAgIXRoaXMuX2ZsYWdzLnNwYXJzZSkge1xuXG4gICAgICAgICAgICAvLyBDbG9uZSB0aGUgYXJyYXkgc28gdGhhdCB3ZSBkb24ndCBtb2RpZnkgdGhlIG9yaWdpbmFsXG4gICAgICAgICAgICBpZiAod2FzQXJyYXkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQudmFsdWUgPSByZXN1bHQudmFsdWUuc2xpY2UoMCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc3VsdC5lcnJvcnMgPSB0aGlzLl9jaGVja0l0ZW1zKHJlc3VsdC52YWx1ZSwgd2FzQXJyYXksIHN0YXRlLCBvcHRpb25zKTtcblxuICAgICAgICAgICAgaWYgKHJlc3VsdC5lcnJvcnMgJiYgd2FzQXJyYXkgJiYgb3B0aW9ucy5jb252ZXJ0ICYmIHRoaXMuX2ZsYWdzLnNpbmdsZSkge1xuXG4gICAgICAgICAgICAgICAgLy8gQXR0ZW1wdCBhIDJuZCBwYXNzIGJ5IHB1dHRpbmcgdGhlIGFycmF5IGluc2lkZSBvbmUuXG4gICAgICAgICAgICAgICAgY29uc3QgcHJldmlvdXNFcnJvcnMgPSByZXN1bHQuZXJyb3JzO1xuXG4gICAgICAgICAgICAgICAgcmVzdWx0LnZhbHVlID0gW3Jlc3VsdC52YWx1ZV07XG4gICAgICAgICAgICAgICAgcmVzdWx0LmVycm9ycyA9IHRoaXMuX2NoZWNrSXRlbXMocmVzdWx0LnZhbHVlLCB3YXNBcnJheSwgc3RhdGUsIG9wdGlvbnMpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5lcnJvcnMpIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBSZXN0b3JlIHByZXZpb3VzIGVycm9ycyBhbmQgdmFsdWUgc2luY2UgdGhpcyBkaWRuJ3QgdmFsaWRhdGUgZWl0aGVyLlxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuZXJyb3JzID0gcHJldmlvdXNFcnJvcnM7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHJlc3VsdC52YWx1ZVswXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIF9jaGVja0l0ZW1zKGl0ZW1zLCB3YXNBcnJheSwgc3RhdGUsIG9wdGlvbnMpIHtcblxuICAgICAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICAgICAgbGV0IGVycm9yZWQ7XG5cbiAgICAgICAgY29uc3QgcmVxdWlyZWRzID0gdGhpcy5faW5uZXIucmVxdWlyZWRzLnNsaWNlKCk7XG4gICAgICAgIGNvbnN0IG9yZGVyZWRzID0gdGhpcy5faW5uZXIub3JkZXJlZHMuc2xpY2UoKTtcbiAgICAgICAgY29uc3QgaW5jbHVzaW9ucyA9IFsuLi50aGlzLl9pbm5lci5pbmNsdXNpb25zLCAuLi5yZXF1aXJlZHNdO1xuXG4gICAgICAgIGxldCBpbCA9IGl0ZW1zLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbDsgKytpKSB7XG4gICAgICAgICAgICBlcnJvcmVkID0gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gaXRlbXNbaV07XG4gICAgICAgICAgICBsZXQgaXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gd2FzQXJyYXkgPyBpIDogc3RhdGUua2V5O1xuICAgICAgICAgICAgY29uc3QgcGF0aCA9IHdhc0FycmF5ID8gWy4uLnN0YXRlLnBhdGgsIGldIDogc3RhdGUucGF0aDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsU3RhdGUgPSBuZXcgU3RhdGUoa2V5LCBwYXRoLCBzdGF0ZS5wYXJlbnQsIHN0YXRlLnJlZmVyZW5jZSk7XG4gICAgICAgICAgICBsZXQgcmVzO1xuXG4gICAgICAgICAgICAvLyBTcGFyc2VcblxuICAgICAgICAgICAgaWYgKCF0aGlzLl9mbGFncy5zcGFyc2UgJiYgaXRlbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2godGhpcy5jcmVhdGVFcnJvcignYXJyYXkuc3BhcnNlJywgbnVsbCwgeyBrZXk6IHN0YXRlLmtleSwgcGF0aDogbG9jYWxTdGF0ZS5wYXRoLCBwb3M6IGkgfSwgb3B0aW9ucykpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3JzO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG9yZGVyZWRzLnNoaWZ0KCk7XG5cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRXhjbHVzaW9uc1xuXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuX2lubmVyLmV4Y2x1c2lvbnMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICByZXMgPSB0aGlzLl9pbm5lci5leGNsdXNpb25zW2pdLl92YWxpZGF0ZShpdGVtLCBsb2NhbFN0YXRlLCB7fSk7ICAgICAgICAgICAgICAgIC8vIE5vdCBwYXNzaW5nIG9wdGlvbnMgdG8gdXNlIGRlZmF1bHRzXG5cbiAgICAgICAgICAgICAgICBpZiAoIXJlcy5lcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2godGhpcy5jcmVhdGVFcnJvcih3YXNBcnJheSA/ICdhcnJheS5leGNsdWRlcycgOiAnYXJyYXkuZXhjbHVkZXNTaW5nbGUnLCB7IHBvczogaSwgdmFsdWU6IGl0ZW0gfSwgeyBrZXk6IHN0YXRlLmtleSwgcGF0aDogbG9jYWxTdGF0ZS5wYXRoIH0sIG9wdGlvbnMpKTtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JlZCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9ycztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIG9yZGVyZWRzLnNoaWZ0KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZXJyb3JlZCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBPcmRlcmVkXG4gICAgICAgICAgICBpZiAodGhpcy5faW5uZXIub3JkZXJlZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9yZGVyZWRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3JkZXJlZCA9IG9yZGVyZWRzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHJlcyA9IG9yZGVyZWQuX3ZhbGlkYXRlKGl0ZW0sIGxvY2FsU3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlcy5lcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcmRlcmVkLl9mbGFncy5zdHJpcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFscy5mYXN0U3BsaWNlKGl0ZW1zLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAtLWk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLS1pbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCF0aGlzLl9mbGFncy5zcGFyc2UgJiYgcmVzLnZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCh0aGlzLmNyZWF0ZUVycm9yKCdhcnJheS5zcGFyc2UnLCBudWxsLCB7IGtleTogc3RhdGUua2V5LCBwYXRoOiBsb2NhbFN0YXRlLnBhdGgsIHBvczogaSB9LCBvcHRpb25zKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtc1tpXSA9IHJlcy52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKHRoaXMuY3JlYXRlRXJyb3IoJ2FycmF5Lm9yZGVyZWQnLCB7IHBvczogaSwgcmVhc29uOiByZXMuZXJyb3JzLCB2YWx1ZTogaXRlbSB9LCB7IGtleTogc3RhdGUua2V5LCBwYXRoOiBsb2NhbFN0YXRlLnBhdGggfSwgb3B0aW9ucykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIXRoaXMuX2lubmVyLml0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCh0aGlzLmNyZWF0ZUVycm9yKCdhcnJheS5vcmRlcmVkTGVuZ3RoJywgeyBwb3M6IGksIGxpbWl0OiB0aGlzLl9pbm5lci5vcmRlcmVkcy5sZW5ndGggfSwgeyBrZXk6IHN0YXRlLmtleSwgcGF0aDogbG9jYWxTdGF0ZS5wYXRoIH0sIG9wdGlvbnMpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9ycztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUmVxdWlyZWRzXG5cbiAgICAgICAgICAgIGNvbnN0IHJlcXVpcmVkQ2hlY2tzID0gW107XG4gICAgICAgICAgICBsZXQgamwgPSByZXF1aXJlZHMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBqbDsgKytqKSB7XG4gICAgICAgICAgICAgICAgcmVzID0gcmVxdWlyZWRDaGVja3Nbal0gPSByZXF1aXJlZHNbal0uX3ZhbGlkYXRlKGl0ZW0sIGxvY2FsU3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGlmICghcmVzLmVycm9ycykge1xuICAgICAgICAgICAgICAgICAgICBpdGVtc1tpXSA9IHJlcy52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaXNWYWxpZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGludGVybmFscy5mYXN0U3BsaWNlKHJlcXVpcmVkcywgaik7XG4gICAgICAgICAgICAgICAgICAgIC0tajtcbiAgICAgICAgICAgICAgICAgICAgLS1qbDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2ZsYWdzLnNwYXJzZSAmJiByZXMudmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2godGhpcy5jcmVhdGVFcnJvcignYXJyYXkuc3BhcnNlJywgbnVsbCwgeyBrZXk6IHN0YXRlLmtleSwgcGF0aDogbG9jYWxTdGF0ZS5wYXRoLCBwb3M6IGkgfSwgb3B0aW9ucykpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9ycztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGlzVmFsaWQpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSW5jbHVzaW9uc1xuXG4gICAgICAgICAgICBjb25zdCBzdHJpcFVua25vd24gPSBvcHRpb25zLnN0cmlwVW5rbm93biAmJiAhIW9wdGlvbnMuc3RyaXBVbmtub3duLmFycmF5cyB8fCBmYWxzZTtcblxuICAgICAgICAgICAgamwgPSBpbmNsdXNpb25zLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgamw7ICsraikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluY2x1c2lvbiA9IGluY2x1c2lvbnNbal07XG5cbiAgICAgICAgICAgICAgICAvLyBBdm9pZCByZS1ydW5uaW5nIHJlcXVpcmVkcyB0aGF0IGFscmVhZHkgZGlkbid0IG1hdGNoIGluIHRoZSBwcmV2aW91cyBsb29wXG4gICAgICAgICAgICAgICAgY29uc3QgcHJldmlvdXNDaGVjayA9IHJlcXVpcmVkcy5pbmRleE9mKGluY2x1c2lvbik7XG4gICAgICAgICAgICAgICAgaWYgKHByZXZpb3VzQ2hlY2sgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcyA9IHJlcXVpcmVkQ2hlY2tzW3ByZXZpb3VzQ2hlY2tdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzID0gaW5jbHVzaW9uLl92YWxpZGF0ZShpdGVtLCBsb2NhbFN0YXRlLCBvcHRpb25zKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlcy5lcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmNsdXNpb24uX2ZsYWdzLnN0cmlwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxzLmZhc3RTcGxpY2UoaXRlbXMsIGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0taTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAtLWlsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIXRoaXMuX2ZsYWdzLnNwYXJzZSAmJiByZXMudmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKHRoaXMuY3JlYXRlRXJyb3IoJ2FycmF5LnNwYXJzZScsIG51bGwsIHsga2V5OiBzdGF0ZS5rZXksIHBhdGg6IGxvY2FsU3RhdGUucGF0aCwgcG9zOiBpIH0sIG9wdGlvbnMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zW2ldID0gcmVzLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1ZhbGlkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gUmV0dXJuIHRoZSBhY3R1YWwgZXJyb3IgaWYgb25seSBvbmUgaW5jbHVzaW9uIGRlZmluZWRcbiAgICAgICAgICAgICAgICBpZiAoamwgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0cmlwVW5rbm93bikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxzLmZhc3RTcGxpY2UoaXRlbXMsIGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLS1pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLS1pbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzVmFsaWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCh0aGlzLmNyZWF0ZUVycm9yKHdhc0FycmF5ID8gJ2FycmF5LmluY2x1ZGVzT25lJyA6ICdhcnJheS5pbmNsdWRlc09uZVNpbmdsZScsIHsgcG9zOiBpLCByZWFzb246IHJlcy5lcnJvcnMsIHZhbHVlOiBpdGVtIH0sIHsga2V5OiBzdGF0ZS5rZXksIHBhdGg6IGxvY2FsU3RhdGUucGF0aCB9LCBvcHRpb25zKSk7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChlcnJvcmVkKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9pbm5lci5pbmNsdXNpb25zLmxlbmd0aCAmJiAhaXNWYWxpZCkge1xuICAgICAgICAgICAgICAgIGlmIChzdHJpcFVua25vd24pIHtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxzLmZhc3RTcGxpY2UoaXRlbXMsIGkpO1xuICAgICAgICAgICAgICAgICAgICAtLWk7XG4gICAgICAgICAgICAgICAgICAgIC0taWw7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKHRoaXMuY3JlYXRlRXJyb3Iod2FzQXJyYXkgPyAnYXJyYXkuaW5jbHVkZXMnIDogJ2FycmF5LmluY2x1ZGVzU2luZ2xlJywgeyBwb3M6IGksIHZhbHVlOiBpdGVtIH0sIHsga2V5OiBzdGF0ZS5rZXksIHBhdGg6IGxvY2FsU3RhdGUucGF0aCB9LCBvcHRpb25zKSk7XG5cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlcXVpcmVkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpbGxNaXNzZWRFcnJvcnMoZXJyb3JzLCByZXF1aXJlZHMsIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcmRlcmVkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpbGxPcmRlcmVkRXJyb3JzKGVycm9ycywgb3JkZXJlZHMsIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlcnJvcnMubGVuZ3RoID8gZXJyb3JzIDogbnVsbDtcbiAgICB9XG5cbiAgICBkZXNjcmliZSgpIHtcblxuICAgICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IHN1cGVyLmRlc2NyaWJlKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuX2lubmVyLm9yZGVyZWRzLmxlbmd0aCkge1xuICAgICAgICAgICAgZGVzY3JpcHRpb24ub3JkZXJlZEl0ZW1zID0gW107XG5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5faW5uZXIub3JkZXJlZHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbi5vcmRlcmVkSXRlbXMucHVzaCh0aGlzLl9pbm5lci5vcmRlcmVkc1tpXS5kZXNjcmliZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9pbm5lci5pdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uLml0ZW1zID0gW107XG5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5faW5uZXIuaXRlbXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbi5pdGVtcy5wdXNoKHRoaXMuX2lubmVyLml0ZW1zW2ldLmRlc2NyaWJlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlc2NyaXB0aW9uLnJ1bGVzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlc2NyaXB0aW9uLnJ1bGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcnVsZSA9IGRlc2NyaXB0aW9uLnJ1bGVzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChydWxlLm5hbWUgPT09ICdoYXMnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bGUuYXJnID0gcnVsZS5hcmcuZGVzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVzY3JpcHRpb247XG4gICAgfVxuXG4gICAgaXRlbXMoLi4uc2NoZW1hcykge1xuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcblxuICAgICAgICBIb2VrLmZsYXR0ZW4oc2NoZW1hcykuZm9yRWFjaCgodHlwZSwgaW5kZXgpID0+IHtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0eXBlID0gQ2FzdC5zY2hlbWEodGhpcy5fY3VycmVudEpvaSwgdHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoY2FzdEVycikge1xuICAgICAgICAgICAgICAgIGlmIChjYXN0RXJyLmhhc093blByb3BlcnR5KCdwYXRoJykpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzdEVyci5wYXRoID0gaW5kZXggKyAnLicgKyBjYXN0RXJyLnBhdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjYXN0RXJyLnBhdGggPSBpbmRleDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjYXN0RXJyLm1lc3NhZ2UgPSBgJHtjYXN0RXJyLm1lc3NhZ2V9KCR7Y2FzdEVyci5wYXRofSlgO1xuICAgICAgICAgICAgICAgIHRocm93IGNhc3RFcnI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9iai5faW5uZXIuaXRlbXMucHVzaCh0eXBlKTtcblxuICAgICAgICAgICAgaWYgKHR5cGUuX2ZsYWdzLnByZXNlbmNlID09PSAncmVxdWlyZWQnKSB7XG4gICAgICAgICAgICAgICAgb2JqLl9pbm5lci5yZXF1aXJlZHMucHVzaCh0eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUuX2ZsYWdzLnByZXNlbmNlID09PSAnZm9yYmlkZGVuJykge1xuICAgICAgICAgICAgICAgIG9iai5faW5uZXIuZXhjbHVzaW9ucy5wdXNoKHR5cGUub3B0aW9uYWwoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvYmouX2lubmVyLmluY2x1c2lvbnMucHVzaCh0eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBvcmRlcmVkKC4uLnNjaGVtYXMpIHtcblxuICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG5cbiAgICAgICAgSG9lay5mbGF0dGVuKHNjaGVtYXMpLmZvckVhY2goKHR5cGUsIGluZGV4KSA9PiB7XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdHlwZSA9IENhc3Quc2NoZW1hKHRoaXMuX2N1cnJlbnRKb2ksIHR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGNhc3RFcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2FzdEVyci5oYXNPd25Qcm9wZXJ0eSgncGF0aCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc3RFcnIucGF0aCA9IGluZGV4ICsgJy4nICsgY2FzdEVyci5wYXRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzdEVyci5wYXRoID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY2FzdEVyci5tZXNzYWdlID0gYCR7Y2FzdEVyci5tZXNzYWdlfSgke2Nhc3RFcnIucGF0aH0pYDtcbiAgICAgICAgICAgICAgICB0aHJvdyBjYXN0RXJyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvYmouX2lubmVyLm9yZGVyZWRzLnB1c2godHlwZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgbWluKGxpbWl0KSB7XG5cbiAgICAgICAgY29uc3QgaXNSZWYgPSBSZWYuaXNSZWYobGltaXQpO1xuXG4gICAgICAgIEhvZWsuYXNzZXJ0KChOdW1iZXIuaXNTYWZlSW50ZWdlcihsaW1pdCkgJiYgbGltaXQgPj0gMCkgfHwgaXNSZWYsICdsaW1pdCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciBvciByZWZlcmVuY2UnKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fdGVzdFVuaXF1ZSgnbWluJywgbGltaXQsIGZ1bmN0aW9uICh2YWx1ZSwgc3RhdGUsIG9wdGlvbnMpIHtcblxuICAgICAgICAgICAgbGV0IGNvbXBhcmVUbztcbiAgICAgICAgICAgIGlmIChpc1JlZikge1xuICAgICAgICAgICAgICAgIGNvbXBhcmVUbyA9IGxpbWl0KHN0YXRlLnJlZmVyZW5jZSB8fCBzdGF0ZS5wYXJlbnQsIG9wdGlvbnMpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCEoTnVtYmVyLmlzU2FmZUludGVnZXIoY29tcGFyZVRvKSAmJiBjb21wYXJlVG8gPj0gMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoJ2FycmF5LnJlZicsIHsgcmVmOiBsaW1pdCwgdmFsdWU6IGNvbXBhcmVUbyB9LCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29tcGFyZVRvID0gbGltaXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPj0gY29tcGFyZVRvKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVFcnJvcignYXJyYXkubWluJywgeyBsaW1pdCwgdmFsdWUgfSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBtYXgobGltaXQpIHtcblxuICAgICAgICBjb25zdCBpc1JlZiA9IFJlZi5pc1JlZihsaW1pdCk7XG5cbiAgICAgICAgSG9lay5hc3NlcnQoKE51bWJlci5pc1NhZmVJbnRlZ2VyKGxpbWl0KSAmJiBsaW1pdCA+PSAwKSB8fCBpc1JlZiwgJ2xpbWl0IG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIG9yIHJlZmVyZW5jZScpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl90ZXN0VW5pcXVlKCdtYXgnLCBsaW1pdCwgZnVuY3Rpb24gKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucykge1xuXG4gICAgICAgICAgICBsZXQgY29tcGFyZVRvO1xuICAgICAgICAgICAgaWYgKGlzUmVmKSB7XG4gICAgICAgICAgICAgICAgY29tcGFyZVRvID0gbGltaXQoc3RhdGUucmVmZXJlbmNlIHx8IHN0YXRlLnBhcmVudCwgb3B0aW9ucyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIShOdW1iZXIuaXNTYWZlSW50ZWdlcihjb21wYXJlVG8pICYmIGNvbXBhcmVUbyA+PSAwKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVFcnJvcignYXJyYXkucmVmJywgeyByZWY6IGxpbWl0LmtleSB9LCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29tcGFyZVRvID0gbGltaXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPD0gY29tcGFyZVRvKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVFcnJvcignYXJyYXkubWF4JywgeyBsaW1pdCwgdmFsdWUgfSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBsZW5ndGgobGltaXQpIHtcblxuICAgICAgICBjb25zdCBpc1JlZiA9IFJlZi5pc1JlZihsaW1pdCk7XG5cbiAgICAgICAgSG9lay5hc3NlcnQoKE51bWJlci5pc1NhZmVJbnRlZ2VyKGxpbWl0KSAmJiBsaW1pdCA+PSAwKSB8fCBpc1JlZiwgJ2xpbWl0IG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIG9yIHJlZmVyZW5jZScpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl90ZXN0VW5pcXVlKCdsZW5ndGgnLCBsaW1pdCwgZnVuY3Rpb24gKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucykge1xuXG4gICAgICAgICAgICBsZXQgY29tcGFyZVRvO1xuICAgICAgICAgICAgaWYgKGlzUmVmKSB7XG4gICAgICAgICAgICAgICAgY29tcGFyZVRvID0gbGltaXQoc3RhdGUucmVmZXJlbmNlIHx8IHN0YXRlLnBhcmVudCwgb3B0aW9ucyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIShOdW1iZXIuaXNTYWZlSW50ZWdlcihjb21wYXJlVG8pICYmIGNvbXBhcmVUbyA+PSAwKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVFcnJvcignYXJyYXkucmVmJywgeyByZWY6IGxpbWl0LmtleSB9LCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29tcGFyZVRvID0gbGltaXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IGNvbXBhcmVUbykge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoJ2FycmF5Lmxlbmd0aCcsIHsgbGltaXQsIHZhbHVlIH0sIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgaGFzKHNjaGVtYSkge1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzY2hlbWEgPSBDYXN0LnNjaGVtYSh0aGlzLl9jdXJyZW50Sm9pLCBzY2hlbWEpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChjYXN0RXJyKSB7XG4gICAgICAgICAgICBpZiAoY2FzdEVyci5oYXNPd25Qcm9wZXJ0eSgncGF0aCcpKSB7XG4gICAgICAgICAgICAgICAgY2FzdEVyci5tZXNzYWdlID0gYCR7Y2FzdEVyci5tZXNzYWdlfSgke2Nhc3RFcnIucGF0aH0pYDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhyb3cgY2FzdEVycjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl90ZXN0KCdoYXMnLCBzY2hlbWEsIGZ1bmN0aW9uICh2YWx1ZSwgc3RhdGUsIG9wdGlvbnMpIHtcblxuICAgICAgICAgICAgY29uc3QgaXNWYWxpZCA9IHZhbHVlLnNvbWUoKGl0ZW0sIGlkeCkgPT4ge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYWxTdGF0ZSA9IG5ldyBTdGF0ZShpZHgsIFsuLi5zdGF0ZS5wYXRoLCBpZHhdLCBzdGF0ZS5rZXksIHN0YXRlLnJlZmVyZW5jZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFzY2hlbWEuX3ZhbGlkYXRlKGl0ZW0sIGxvY2FsU3RhdGUsIG9wdGlvbnMpLmVycm9ycztcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoaXNWYWxpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgcGF0dGVybkxhYmVsID0gc2NoZW1hLl9nZXRMYWJlbCgpO1xuICAgICAgICAgICAgaWYgKHBhdHRlcm5MYWJlbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKCdhcnJheS5oYXNLbm93bicsIHsgcGF0dGVybkxhYmVsIH0sIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoJ2FycmF5Lmhhc1Vua25vd24nLCBudWxsLCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHVuaXF1ZShjb21wYXJhdG9yLCBjb25maWdzKSB7XG5cbiAgICAgICAgSG9lay5hc3NlcnQoY29tcGFyYXRvciA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICB0eXBlb2YgY29tcGFyYXRvciA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgICAgICAgdHlwZW9mIGNvbXBhcmF0b3IgPT09ICdzdHJpbmcnLCAnY29tcGFyYXRvciBtdXN0IGJlIGEgZnVuY3Rpb24gb3IgYSBzdHJpbmcnKTtcblxuICAgICAgICBIb2VrLmFzc2VydChjb25maWdzID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIHR5cGVvZiBjb25maWdzID09PSAnb2JqZWN0JywgJ2NvbmZpZ3MgbXVzdCBiZSBhbiBvYmplY3QnKTtcblxuICAgICAgICBjb25zdCBzZXR0aW5ncyA9IHtcbiAgICAgICAgICAgIGlnbm9yZVVuZGVmaW5lZDogKGNvbmZpZ3MgJiYgY29uZmlncy5pZ25vcmVVbmRlZmluZWQpIHx8IGZhbHNlXG4gICAgICAgIH07XG5cblxuICAgICAgICBpZiAodHlwZW9mIGNvbXBhcmF0b3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5wYXRoID0gY29tcGFyYXRvcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgY29tcGFyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgc2V0dGluZ3MuY29tcGFyYXRvciA9IGNvbXBhcmF0b3I7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fdGVzdCgndW5pcXVlJywgc2V0dGluZ3MsIGZ1bmN0aW9uICh2YWx1ZSwgc3RhdGUsIG9wdGlvbnMpIHtcblxuICAgICAgICAgICAgY29uc3QgZm91bmQgPSB7XG4gICAgICAgICAgICAgICAgc3RyaW5nOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgICAgICAgICAgIG51bWJlcjogT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgICAgICAgICAgICB1bmRlZmluZWQ6IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICAgICAgICAgICAgYm9vbGVhbjogT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgICAgICAgICAgICBvYmplY3Q6IG5ldyBNYXAoKSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbjogbmV3IE1hcCgpLFxuICAgICAgICAgICAgICAgIGN1c3RvbTogbmV3IE1hcCgpXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBjb25zdCBjb21wYXJlID0gc2V0dGluZ3MuY29tcGFyYXRvciB8fCBIb2VrLmRlZXBFcXVhbDtcbiAgICAgICAgICAgIGNvbnN0IGlnbm9yZVVuZGVmaW5lZCA9IHNldHRpbmdzLmlnbm9yZVVuZGVmaW5lZDtcblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBzZXR0aW5ncy5wYXRoID8gSG9lay5yZWFjaCh2YWx1ZVtpXSwgc2V0dGluZ3MucGF0aCkgOiB2YWx1ZVtpXTtcbiAgICAgICAgICAgICAgICBjb25zdCByZWNvcmRzID0gc2V0dGluZ3MuY29tcGFyYXRvciA/IGZvdW5kLmN1c3RvbSA6IGZvdW5kW3R5cGVvZiBpdGVtXTtcblxuICAgICAgICAgICAgICAgIC8vIEFsbCBhdmFpbGFibGUgdHlwZXMgYXJlIHN1cHBvcnRlZCwgc28gaXQncyBub3QgcG9zc2libGUgdG8gcmVhY2ggMTAwJSBjb3ZlcmFnZSB3aXRob3V0IGlnbm9yaW5nIHRoaXMgbGluZS5cbiAgICAgICAgICAgICAgICAvLyBJIHN0aWxsIHdhbnQgdG8ga2VlcCB0aGUgdGVzdCBmb3IgZnV0dXJlIGpzIHZlcnNpb25zIHdpdGggbmV3IHR5cGVzIChlZy4gU3ltYm9sKS5cbiAgICAgICAgICAgICAgICBpZiAoLyogJGxhYjpjb3ZlcmFnZTpvZmYkICovIHJlY29yZHMgLyogJGxhYjpjb3ZlcmFnZTpvbiQgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlY29yZHMgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVudHJpZXMgPSByZWNvcmRzLmVudHJpZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjdXJyZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCEoY3VycmVudCA9IGVudHJpZXMubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBhcmUoY3VycmVudC52YWx1ZVswXSwgaXRlbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9jYWxTdGF0ZSA9IG5ldyBTdGF0ZShzdGF0ZS5rZXksIFsuLi5zdGF0ZS5wYXRoLCBpXSwgc3RhdGUucGFyZW50LCBzdGF0ZS5yZWZlcmVuY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zOiBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlW2ldLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHVwZVBvczogY3VycmVudC52YWx1ZVsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR1cGVWYWx1ZTogdmFsdWVbY3VycmVudC52YWx1ZVsxXV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MucGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5wYXRoID0gc2V0dGluZ3MucGF0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKCdhcnJheS51bmlxdWUnLCBjb250ZXh0LCBsb2NhbFN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY29yZHMuc2V0KGl0ZW0sIGkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCghaWdub3JlVW5kZWZpbmVkIHx8IGl0ZW0gIT09IHVuZGVmaW5lZCkgJiYgcmVjb3Jkc1tpdGVtXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9jYWxTdGF0ZSA9IG5ldyBTdGF0ZShzdGF0ZS5rZXksIFsuLi5zdGF0ZS5wYXRoLCBpXSwgc3RhdGUucGFyZW50LCBzdGF0ZS5yZWZlcmVuY2UpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zOiBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVbaV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR1cGVQb3M6IHJlY29yZHNbaXRlbV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR1cGVWYWx1ZTogdmFsdWVbcmVjb3Jkc1tpdGVtXV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLnBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5wYXRoID0gc2V0dGluZ3MucGF0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVFcnJvcignYXJyYXkudW5pcXVlJywgY29udGV4dCwgbG9jYWxTdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY29yZHNbaXRlbV0gPSBpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHNwYXJzZShlbmFibGVkKSB7XG5cbiAgICAgICAgY29uc3QgdmFsdWUgPSBlbmFibGVkID09PSB1bmRlZmluZWQgPyB0cnVlIDogISFlbmFibGVkO1xuXG4gICAgICAgIGlmICh0aGlzLl9mbGFncy5zcGFyc2UgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgb2JqLl9mbGFncy5zcGFyc2UgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBzaW5nbGUoZW5hYmxlZCkge1xuXG4gICAgICAgIGNvbnN0IHZhbHVlID0gZW5hYmxlZCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6ICEhZW5hYmxlZDtcblxuICAgICAgICBpZiAodGhpcy5fZmxhZ3Muc2luZ2xlID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIG9iai5fZmxhZ3Muc2luZ2xlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX2ZpbGxNaXNzZWRFcnJvcnMoZXJyb3JzLCByZXF1aXJlZHMsIHN0YXRlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgY29uc3Qga25vd25NaXNzZXMgPSBbXTtcbiAgICAgICAgbGV0IHVua25vd25NaXNzZXMgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlcXVpcmVkcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgbGFiZWwgPSByZXF1aXJlZHNbaV0uX2dldExhYmVsKCk7XG4gICAgICAgICAgICBpZiAobGFiZWwpIHtcbiAgICAgICAgICAgICAgICBrbm93bk1pc3Nlcy5wdXNoKGxhYmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICsrdW5rbm93bk1pc3NlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChrbm93bk1pc3Nlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICh1bmtub3duTWlzc2VzKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2godGhpcy5jcmVhdGVFcnJvcignYXJyYXkuaW5jbHVkZXNSZXF1aXJlZEJvdGgnLCB7IGtub3duTWlzc2VzLCB1bmtub3duTWlzc2VzIH0sIHsga2V5OiBzdGF0ZS5rZXksIHBhdGg6IHN0YXRlLnBhdGggfSwgb3B0aW9ucykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2godGhpcy5jcmVhdGVFcnJvcignYXJyYXkuaW5jbHVkZXNSZXF1aXJlZEtub3ducycsIHsga25vd25NaXNzZXMgfSwgeyBrZXk6IHN0YXRlLmtleSwgcGF0aDogc3RhdGUucGF0aCB9LCBvcHRpb25zKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaCh0aGlzLmNyZWF0ZUVycm9yKCdhcnJheS5pbmNsdWRlc1JlcXVpcmVkVW5rbm93bnMnLCB7IHVua25vd25NaXNzZXMgfSwgeyBrZXk6IHN0YXRlLmtleSwgcGF0aDogc3RhdGUucGF0aCB9LCBvcHRpb25zKSk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIF9maWxsT3JkZXJlZEVycm9ycyhlcnJvcnMsIG9yZGVyZWRzLCBzdGF0ZSwgb3B0aW9ucykge1xuXG4gICAgICAgIGNvbnN0IHJlcXVpcmVkT3JkZXJlZHMgPSBbXTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9yZGVyZWRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBwcmVzZW5jZSA9IEhvZWsucmVhY2gob3JkZXJlZHNbaV0sICdfZmxhZ3MucHJlc2VuY2UnKTtcbiAgICAgICAgICAgIGlmIChwcmVzZW5jZSA9PT0gJ3JlcXVpcmVkJykge1xuICAgICAgICAgICAgICAgIHJlcXVpcmVkT3JkZXJlZHMucHVzaChvcmRlcmVkc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVxdWlyZWRPcmRlcmVkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpbGxNaXNzZWRFcnJvcnMoZXJyb3JzLCByZXF1aXJlZE9yZGVyZWRzLCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG5cbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgaW50ZXJuYWxzLkFycmF5KCk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEhvZWsgPSByZXF1aXJlKCdAaGFwaS9ob2VrJyk7XG5cbmNvbnN0IEFueSA9IHJlcXVpcmUoJy4uL2FueScpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbmludGVybmFscy5CaW5hcnkgPSBjbGFzcyBleHRlbmRzIEFueSB7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcblxuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl90eXBlID0gJ2JpbmFyeSc7XG4gICAgfVxuXG4gICAgX2Jhc2UodmFsdWUsIHN0YXRlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgb3B0aW9ucy5jb252ZXJ0KSB7XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnZhbHVlID0gQnVmZmVyLmZyb20odmFsdWUsIHRoaXMuX2ZsYWdzLmVuY29kaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC5lcnJvcnMgPSBCdWZmZXIuaXNCdWZmZXIocmVzdWx0LnZhbHVlKSA/IG51bGwgOiB0aGlzLmNyZWF0ZUVycm9yKCdiaW5hcnkuYmFzZScsIG51bGwsIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBlbmNvZGluZyhlbmNvZGluZykge1xuXG4gICAgICAgIEhvZWsuYXNzZXJ0KEJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSwgJ0ludmFsaWQgZW5jb2Rpbmc6JywgZW5jb2RpbmcpO1xuXG4gICAgICAgIGlmICh0aGlzLl9mbGFncy5lbmNvZGluZyA9PT0gZW5jb2RpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBvYmouX2ZsYWdzLmVuY29kaW5nID0gZW5jb2Rpbmc7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgbWluKGxpbWl0KSB7XG5cbiAgICAgICAgSG9lay5hc3NlcnQoTnVtYmVyLmlzU2FmZUludGVnZXIobGltaXQpICYmIGxpbWl0ID49IDAsICdsaW1pdCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlcicpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl90ZXN0KCdtaW4nLCBsaW1pdCwgZnVuY3Rpb24gKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucykge1xuXG4gICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID49IGxpbWl0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVFcnJvcignYmluYXJ5Lm1pbicsIHsgbGltaXQsIHZhbHVlIH0sIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgbWF4KGxpbWl0KSB7XG5cbiAgICAgICAgSG9lay5hc3NlcnQoTnVtYmVyLmlzU2FmZUludGVnZXIobGltaXQpICYmIGxpbWl0ID49IDAsICdsaW1pdCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlcicpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl90ZXN0KCdtYXgnLCBsaW1pdCwgZnVuY3Rpb24gKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucykge1xuXG4gICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoIDw9IGxpbWl0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVFcnJvcignYmluYXJ5Lm1heCcsIHsgbGltaXQsIHZhbHVlIH0sIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgbGVuZ3RoKGxpbWl0KSB7XG5cbiAgICAgICAgSG9lay5hc3NlcnQoTnVtYmVyLmlzU2FmZUludGVnZXIobGltaXQpICYmIGxpbWl0ID49IDAsICdsaW1pdCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlcicpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl90ZXN0KCdsZW5ndGgnLCBsaW1pdCwgZnVuY3Rpb24gKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucykge1xuXG4gICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09PSBsaW1pdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoJ2JpbmFyeS5sZW5ndGgnLCB7IGxpbWl0LCB2YWx1ZSB9LCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBpbnRlcm5hbHMuQmluYXJ5KCk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEhvZWsgPSByZXF1aXJlKCdAaGFwaS9ob2VrJyk7XG5cbmNvbnN0IEFueSA9IHJlcXVpcmUoJy4uL2FueScpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICBTZXQ6IHJlcXVpcmUoJy4uLy4uL3NldCcpXG59O1xuXG5cbmludGVybmFscy5Cb29sZWFuID0gY2xhc3MgZXh0ZW5kcyBBbnkge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuXG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX3R5cGUgPSAnYm9vbGVhbic7XG4gICAgICAgIHRoaXMuX2ZsYWdzLmluc2Vuc2l0aXZlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5faW5uZXIudHJ1dGh5U2V0ID0gbmV3IGludGVybmFscy5TZXQoKTtcbiAgICAgICAgdGhpcy5faW5uZXIuZmFsc3lTZXQgPSBuZXcgaW50ZXJuYWxzLlNldCgpO1xuICAgIH1cblxuICAgIF9iYXNlKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucykge1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgIG9wdGlvbnMuY29udmVydCkge1xuXG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemVkID0gdGhpcy5fZmxhZ3MuaW5zZW5zaXRpdmUgPyB2YWx1ZS50b0xvd2VyQ2FzZSgpIDogdmFsdWU7XG4gICAgICAgICAgICByZXN1bHQudmFsdWUgPSAobm9ybWFsaXplZCA9PT0gJ3RydWUnID8gdHJ1ZVxuICAgICAgICAgICAgICAgIDogKG5vcm1hbGl6ZWQgPT09ICdmYWxzZScgPyBmYWxzZSA6IHZhbHVlKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHJlc3VsdC52YWx1ZSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICByZXN1bHQudmFsdWUgPSAodGhpcy5faW5uZXIudHJ1dGh5U2V0Lmhhcyh2YWx1ZSwgbnVsbCwgbnVsbCwgdGhpcy5fZmxhZ3MuaW5zZW5zaXRpdmUpID8gdHJ1ZVxuICAgICAgICAgICAgICAgIDogKHRoaXMuX2lubmVyLmZhbHN5U2V0Lmhhcyh2YWx1ZSwgbnVsbCwgbnVsbCwgdGhpcy5fZmxhZ3MuaW5zZW5zaXRpdmUpID8gZmFsc2UgOiB2YWx1ZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0LmVycm9ycyA9ICh0eXBlb2YgcmVzdWx0LnZhbHVlID09PSAnYm9vbGVhbicpID8gbnVsbCA6IHRoaXMuY3JlYXRlRXJyb3IoJ2Jvb2xlYW4uYmFzZScsIHsgdmFsdWUgfSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHRydXRoeSguLi52YWx1ZXMpIHtcblxuICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIHZhbHVlcyA9IEhvZWsuZmxhdHRlbih2YWx1ZXMpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZXNbaV07XG5cbiAgICAgICAgICAgIEhvZWsuYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQsICdDYW5ub3QgY2FsbCB0cnV0aHkgd2l0aCB1bmRlZmluZWQnKTtcbiAgICAgICAgICAgIG9iai5faW5uZXIudHJ1dGh5U2V0LmFkZCh2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIGZhbHN5KC4uLnZhbHVlcykge1xuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgdmFsdWVzID0gSG9lay5mbGF0dGVuKHZhbHVlcyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1tpXTtcblxuICAgICAgICAgICAgSG9lay5hc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCwgJ0Nhbm5vdCBjYWxsIGZhbHN5IHdpdGggdW5kZWZpbmVkJyk7XG4gICAgICAgICAgICBvYmouX2lubmVyLmZhbHN5U2V0LmFkZCh2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIGluc2Vuc2l0aXZlKGVuYWJsZWQpIHtcblxuICAgICAgICBjb25zdCBpbnNlbnNpdGl2ZSA9IGVuYWJsZWQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiAhIWVuYWJsZWQ7XG5cbiAgICAgICAgaWYgKHRoaXMuX2ZsYWdzLmluc2Vuc2l0aXZlID09PSBpbnNlbnNpdGl2ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIG9iai5fZmxhZ3MuaW5zZW5zaXRpdmUgPSBpbnNlbnNpdGl2ZTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBkZXNjcmliZSgpIHtcblxuICAgICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IHN1cGVyLmRlc2NyaWJlKCk7XG4gICAgICAgIGRlc2NyaXB0aW9uLnRydXRoeSA9IFt0cnVlLCAuLi50aGlzLl9pbm5lci50cnV0aHlTZXQudmFsdWVzKCldO1xuICAgICAgICBkZXNjcmlwdGlvbi5mYWxzeSA9IFtmYWxzZSwgLi4udGhpcy5faW5uZXIuZmFsc3lTZXQudmFsdWVzKCldO1xuICAgICAgICByZXR1cm4gZGVzY3JpcHRpb247XG4gICAgfVxufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBpbnRlcm5hbHMuQm9vbGVhbigpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBIb2VrID0gcmVxdWlyZSgnQGhhcGkvaG9laycpO1xuXG5jb25zdCBBbnkgPSByZXF1aXJlKCcuLi9hbnknKTtcbmNvbnN0IFJlZiA9IHJlcXVpcmUoJy4uLy4uL3JlZicpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5pbnRlcm5hbHMuaXNvRGF0ZSA9IC9eKD86Wy0rXVxcZHsyfSk/KD86XFxkezR9KD8hXFxkezJ9XFxiKSkoPzooLT8pKD86KD86MFsxLTldfDFbMC0yXSkoPzpcXDEoPzpbMTJdXFxkfDBbMS05XXwzWzAxXSkpP3xXKD86WzAtNF1cXGR8NVswLTJdKSg/Oi0/WzEtN10pP3woPzowMFsxLTldfDBbMS05XVxcZHxbMTJdXFxkezJ9fDMoPzpbMC01XVxcZHw2WzEtNl0pKSkoPyFbVF0kfFtUXVtcXGRdK1okKSg/OltUXFxzXSg/Oig/Oig/OlswMV1cXGR8MlswLTNdKSg/Oig6PylbMC01XVxcZCk/fDI0XFw6PzAwKSg/OlsuLF1cXGQrKD8hOikpPykoPzpcXDJbMC01XVxcZCg/OlsuLF1cXGQrKT8pPyg/OltaXXwoPzpbKy1dKSg/OlswMV1cXGR8MlswLTNdKSg/Ojo/WzAtNV1cXGQpPyk/KT8pPyQvO1xuaW50ZXJuYWxzLmludmFsaWREYXRlID0gbmV3IERhdGUoJycpO1xuaW50ZXJuYWxzLmlzSXNvRGF0ZSA9ICgoKSA9PiB7XG5cbiAgICBjb25zdCBpc29TdHJpbmcgPSBpbnRlcm5hbHMuaXNvRGF0ZS50b1N0cmluZygpO1xuXG4gICAgcmV0dXJuIChkYXRlKSA9PiB7XG5cbiAgICAgICAgcmV0dXJuIGRhdGUgJiYgKGRhdGUudG9TdHJpbmcoKSA9PT0gaXNvU3RyaW5nKTtcbiAgICB9O1xufSkoKTtcblxuaW50ZXJuYWxzLkRhdGUgPSBjbGFzcyBleHRlbmRzIEFueSB7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcblxuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl90eXBlID0gJ2RhdGUnO1xuICAgIH1cblxuICAgIF9iYXNlKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucykge1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgIHZhbHVlOiAob3B0aW9ucy5jb252ZXJ0ICYmIGludGVybmFscy5EYXRlLnRvRGF0ZSh2YWx1ZSwgdGhpcy5fZmxhZ3MuZm9ybWF0LCB0aGlzLl9mbGFncy50aW1lc3RhbXAsIHRoaXMuX2ZsYWdzLm11bHRpcGxpZXIpKSB8fCB2YWx1ZVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChyZXN1bHQudmFsdWUgaW5zdGFuY2VvZiBEYXRlICYmICFpc05hTihyZXN1bHQudmFsdWUuZ2V0VGltZSgpKSkge1xuICAgICAgICAgICAgcmVzdWx0LmVycm9ycyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIW9wdGlvbnMuY29udmVydCkge1xuICAgICAgICAgICAgcmVzdWx0LmVycm9ycyA9IHRoaXMuY3JlYXRlRXJyb3IoJ2RhdGUuc3RyaWN0JywgeyB2YWx1ZSB9LCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgdHlwZTtcbiAgICAgICAgICAgIGlmIChpbnRlcm5hbHMuaXNJc29EYXRlKHRoaXMuX2ZsYWdzLmZvcm1hdCkpIHtcbiAgICAgICAgICAgICAgICB0eXBlID0gJ2lzb0RhdGUnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fZmxhZ3MudGltZXN0YW1wKSB7XG4gICAgICAgICAgICAgICAgdHlwZSA9IGB0aW1lc3RhbXAuJHt0aGlzLl9mbGFncy50aW1lc3RhbXB9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHR5cGUgPSAnYmFzZSc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc3VsdC5lcnJvcnMgPSB0aGlzLmNyZWF0ZUVycm9yKGBkYXRlLiR7dHlwZX1gLCB7IHZhbHVlIH0sIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgc3RhdGljIHRvRGF0ZSh2YWx1ZSwgZm9ybWF0LCB0aW1lc3RhbXAsIG11bHRpcGxpZXIpIHtcblxuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICAgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHZhbHVlKSAmJiBpc0Zpbml0ZSh2YWx1ZSkpKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IGlzSXNvRGF0ZSA9IGZvcm1hdCAmJiBpbnRlcm5hbHMuaXNJc29EYXRlKGZvcm1hdCk7XG4gICAgICAgICAgICBpZiAoIWlzSXNvRGF0ZSAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgICAgICAvXlsrLV0/XFxkKyhcXC5cXGQrKT8kLy50ZXN0KHZhbHVlKSkge1xuXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IGRhdGU7XG4gICAgICAgICAgICBpZiAoaXNJc29EYXRlKSB7XG4gICAgICAgICAgICAgICAgZGF0ZSA9IGZvcm1hdC50ZXN0KHZhbHVlKSA/IG5ldyBEYXRlKHZhbHVlLnRvU3RyaW5nKCkpIDogaW50ZXJuYWxzLmludmFsaWREYXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGltZXN0YW1wKSB7XG4gICAgICAgICAgICAgICAgZGF0ZSA9IC9eXFxzKiQvLnRlc3QodmFsdWUpID8gaW50ZXJuYWxzLmludmFsaWREYXRlIDogbmV3IERhdGUodmFsdWUgKiBtdWx0aXBsaWVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghaXNOYU4oZGF0ZS5nZXRUaW1lKCkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpc28oKSB7XG5cbiAgICAgICAgaWYgKHRoaXMuX2ZsYWdzLmZvcm1hdCA9PT0gaW50ZXJuYWxzLmlzb0RhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBvYmouX2ZsYWdzLmZvcm1hdCA9IGludGVybmFscy5pc29EYXRlO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIHRpbWVzdGFtcCh0eXBlID0gJ2phdmFzY3JpcHQnKSB7XG5cbiAgICAgICAgY29uc3QgYWxsb3dlZCA9IFsnamF2YXNjcmlwdCcsICd1bml4J107XG4gICAgICAgIEhvZWsuYXNzZXJ0KGFsbG93ZWQuaW5jbHVkZXModHlwZSksICdcInR5cGVcIiBtdXN0IGJlIG9uZSBvZiBcIicgKyBhbGxvd2VkLmpvaW4oJ1wiLCBcIicpICsgJ1wiJyk7XG5cbiAgICAgICAgaWYgKHRoaXMuX2ZsYWdzLnRpbWVzdGFtcCA9PT0gdHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIG9iai5fZmxhZ3MudGltZXN0YW1wID0gdHlwZTtcbiAgICAgICAgb2JqLl9mbGFncy5tdWx0aXBsaWVyID0gdHlwZSA9PT0gJ3VuaXgnID8gMTAwMCA6IDE7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX2lzSXNvRGF0ZSh2YWx1ZSkge1xuXG4gICAgICAgIHJldHVybiBpbnRlcm5hbHMuaXNvRGF0ZS50ZXN0KHZhbHVlKTtcbiAgICB9XG5cbn07XG5cbmludGVybmFscy5jb21wYXJlID0gZnVuY3Rpb24gKHR5cGUsIGNvbXBhcmUpIHtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoZGF0ZSkge1xuXG4gICAgICAgIGNvbnN0IGlzTm93ID0gZGF0ZSA9PT0gJ25vdyc7XG4gICAgICAgIGNvbnN0IGlzUmVmID0gUmVmLmlzUmVmKGRhdGUpO1xuXG4gICAgICAgIGlmICghaXNOb3cgJiYgIWlzUmVmKSB7XG4gICAgICAgICAgICBkYXRlID0gaW50ZXJuYWxzLkRhdGUudG9EYXRlKGRhdGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgSG9lay5hc3NlcnQoZGF0ZSwgJ0ludmFsaWQgZGF0ZSBmb3JtYXQnKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fdGVzdCh0eXBlLCBkYXRlLCBmdW5jdGlvbiAodmFsdWUsIHN0YXRlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgICAgIGxldCBjb21wYXJlVG87XG4gICAgICAgICAgICBpZiAoaXNOb3cpIHtcbiAgICAgICAgICAgICAgICBjb21wYXJlVG8gPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNSZWYpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWZWYWx1ZSA9IGRhdGUoc3RhdGUucmVmZXJlbmNlIHx8IHN0YXRlLnBhcmVudCwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgY29tcGFyZVRvID0gaW50ZXJuYWxzLkRhdGUudG9EYXRlKHJlZlZhbHVlKTtcblxuICAgICAgICAgICAgICAgIGlmICghY29tcGFyZVRvKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKCdkYXRlLnJlZicsIHsgcmVmOiBkYXRlLCB2YWx1ZTogcmVmVmFsdWUgfSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbXBhcmVUbyA9IGNvbXBhcmVUby5nZXRUaW1lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb21wYXJlVG8gPSBkYXRlLmdldFRpbWUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNvbXBhcmUodmFsdWUuZ2V0VGltZSgpLCBjb21wYXJlVG8pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVFcnJvcignZGF0ZS4nICsgdHlwZSwgeyBsaW1pdDogbmV3IERhdGUoY29tcGFyZVRvKSwgdmFsdWUgfSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9O1xufTtcblxuXG5pbnRlcm5hbHMuRGF0ZS5wcm90b3R5cGUubWluID0gaW50ZXJuYWxzLmNvbXBhcmUoJ21pbicsICh2YWx1ZSwgZGF0ZSkgPT4gdmFsdWUgPj0gZGF0ZSk7XG5pbnRlcm5hbHMuRGF0ZS5wcm90b3R5cGUubWF4ID0gaW50ZXJuYWxzLmNvbXBhcmUoJ21heCcsICh2YWx1ZSwgZGF0ZSkgPT4gdmFsdWUgPD0gZGF0ZSk7XG5pbnRlcm5hbHMuRGF0ZS5wcm90b3R5cGUuZ3JlYXRlciA9IGludGVybmFscy5jb21wYXJlKCdncmVhdGVyJywgKHZhbHVlLCBkYXRlKSA9PiB2YWx1ZSA+IGRhdGUpO1xuaW50ZXJuYWxzLkRhdGUucHJvdG90eXBlLmxlc3MgPSBpbnRlcm5hbHMuY29tcGFyZSgnbGVzcycsICh2YWx1ZSwgZGF0ZSkgPT4gdmFsdWUgPCBkYXRlKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBpbnRlcm5hbHMuRGF0ZSgpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBIb2VrID0gcmVxdWlyZSgnQGhhcGkvaG9laycpO1xuXG5jb25zdCBPYmplY3RUeXBlID0gcmVxdWlyZSgnLi4vb2JqZWN0Jyk7XG5jb25zdCBSZWYgPSByZXF1aXJlKCcuLi8uLi9yZWYnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5pbnRlcm5hbHMuRnVuYyA9IGNsYXNzIGV4dGVuZHMgT2JqZWN0VHlwZS5jb25zdHJ1Y3RvciB7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcblxuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9mbGFncy5mdW5jID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBhcml0eShuKSB7XG5cbiAgICAgICAgSG9lay5hc3NlcnQoTnVtYmVyLmlzU2FmZUludGVnZXIobikgJiYgbiA+PSAwLCAnbiBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlcicpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl90ZXN0KCdhcml0eScsIG4sIGZ1bmN0aW9uICh2YWx1ZSwgc3RhdGUsIG9wdGlvbnMpIHtcblxuICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoJ2Z1bmN0aW9uLmFyaXR5JywgeyBuIH0sIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgbWluQXJpdHkobikge1xuXG4gICAgICAgIEhvZWsuYXNzZXJ0KE51bWJlci5pc1NhZmVJbnRlZ2VyKG4pICYmIG4gPiAwLCAnbiBtdXN0IGJlIGEgc3RyaWN0IHBvc2l0aXZlIGludGVnZXInKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fdGVzdCgnbWluQXJpdHknLCBuLCBmdW5jdGlvbiAodmFsdWUsIHN0YXRlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPj0gbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoJ2Z1bmN0aW9uLm1pbkFyaXR5JywgeyBuIH0sIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgbWF4QXJpdHkobikge1xuXG4gICAgICAgIEhvZWsuYXNzZXJ0KE51bWJlci5pc1NhZmVJbnRlZ2VyKG4pICYmIG4gPj0gMCwgJ24gbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXInKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fdGVzdCgnbWF4QXJpdHknLCBuLCBmdW5jdGlvbiAodmFsdWUsIHN0YXRlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPD0gbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoJ2Z1bmN0aW9uLm1heEFyaXR5JywgeyBuIH0sIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmVmKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLl90ZXN0KCdyZWYnLCBudWxsLCBmdW5jdGlvbiAodmFsdWUsIHN0YXRlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgICAgIGlmIChSZWYuaXNSZWYodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVFcnJvcignZnVuY3Rpb24ucmVmJywgeyB2YWx1ZSB9LCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGNsYXNzKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLl90ZXN0KCdjbGFzcycsIG51bGwsIGZ1bmN0aW9uICh2YWx1ZSwgc3RhdGUsIG9wdGlvbnMpIHtcblxuICAgICAgICAgICAgaWYgKCgvXlxccypjbGFzc1xccy8pLnRlc3QodmFsdWUudG9TdHJpbmcoKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKCdmdW5jdGlvbi5jbGFzcycsIHsgdmFsdWUgfSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBpbnRlcm5hbHMuRnVuYygpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBIb2VrID0gcmVxdWlyZSgnQGhhcGkvaG9laycpO1xuXG5jb25zdCBBbnkgPSByZXF1aXJlKCcuLi9hbnknKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5pbnRlcm5hbHMuTGF6eSA9IGNsYXNzIGV4dGVuZHMgQW55IHtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuXG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX3R5cGUgPSAnbGF6eSc7XG4gICAgICAgIHRoaXMuX2ZsYWdzLm9uY2UgPSB0cnVlO1xuICAgICAgICB0aGlzLl9jYWNoZSA9IG51bGw7XG4gICAgfVxuXG4gICAgX2luaXQoZm4sIG9wdGlvbnMpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5zZXQoZm4sIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIF9iYXNlKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucykge1xuXG4gICAgICAgIGxldCBzY2hlbWE7XG4gICAgICAgIGlmICh0aGlzLl9jYWNoZSkge1xuICAgICAgICAgICAgc2NoZW1hID0gdGhpcy5fY2FjaGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB7IHZhbHVlIH07XG4gICAgICAgICAgICBjb25zdCBsYXp5ID0gdGhpcy5fZmxhZ3MubGF6eTtcblxuICAgICAgICAgICAgaWYgKCFsYXp5KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmVycm9ycyA9IHRoaXMuY3JlYXRlRXJyb3IoJ2xhenkuYmFzZScsIG51bGwsIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzY2hlbWEgPSBsYXp5KCk7XG5cbiAgICAgICAgICAgIGlmICghKHNjaGVtYSBpbnN0YW5jZW9mIEFueSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuZXJyb3JzID0gdGhpcy5jcmVhdGVFcnJvcignbGF6eS5zY2hlbWEnLCB7IHNjaGVtYSB9LCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuX2ZsYWdzLm9uY2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZSA9IHNjaGVtYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzY2hlbWEuX3ZhbGlkYXRlKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgc2V0KGZuLCBvcHRpb25zKSB7XG5cbiAgICAgICAgSG9lay5hc3NlcnQodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nLCAnWW91IG11c3QgcHJvdmlkZSBhIGZ1bmN0aW9uIGFzIGZpcnN0IGFyZ3VtZW50Jyk7XG4gICAgICAgIEhvZWsuYXNzZXJ0KG9wdGlvbnMgPT09IHVuZGVmaW5lZCB8fCAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkob3B0aW9ucykpLCBgT3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdGApO1xuXG4gICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCB1bmtub3duT3B0aW9ucyA9IE9iamVjdC5rZXlzKG9wdGlvbnMpLmZpbHRlcigoa2V5KSA9PiAhWydvbmNlJ10uaW5jbHVkZXMoa2V5KSk7XG4gICAgICAgICAgICBIb2VrLmFzc2VydCh1bmtub3duT3B0aW9ucy5sZW5ndGggPT09IDAsIGBPcHRpb25zIGNvbnRhaW4gdW5rbm93biBrZXlzOiAke3Vua25vd25PcHRpb25zfWApO1xuICAgICAgICAgICAgSG9lay5hc3NlcnQob3B0aW9ucy5vbmNlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIG9wdGlvbnMub25jZSA9PT0gJ2Jvb2xlYW4nLCAnT3B0aW9uIFwib25jZVwiIG11c3QgYmUgYSBib29sZWFuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIG9iai5fZmxhZ3MubGF6eSA9IGZuO1xuXG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMub25jZSAhPT0gb2JqLl9mbGFncy5vbmNlKSB7XG4gICAgICAgICAgICBvYmouX2ZsYWdzLm9uY2UgPSBvcHRpb25zLm9uY2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgaW50ZXJuYWxzLkxhenkoKTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgSG9layA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsnKTtcblxuY29uc3QgQW55ID0gcmVxdWlyZSgnLi4vYW55Jyk7XG5jb25zdCBSZWYgPSByZXF1aXJlKCcuLi8uLi9yZWYnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7XG4gICAgcHJlY2lzaW9uUng6IC8oPzpcXC4oXFxkKykpPyg/OltlRV0oWystXT9cXGQrKSk/JC8sXG4gICAgbm9ybWFsaXplRXhwb25lbnQoc3RyKSB7XG5cbiAgICAgICAgcmV0dXJuIHN0clxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcLj8wK2UvLCAnZScpXG4gICAgICAgICAgICAucmVwbGFjZSgvZVxcKy8sICdlJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9eXFwrLywgJycpXG4gICAgICAgICAgICAucmVwbGFjZSgvXigtPykwKyhbMS05XSkvLCAnJDEkMicpO1xuICAgIH0sXG4gICAgbm9ybWFsaXplRGVjaW1hbChzdHIpIHtcblxuICAgICAgICBzdHIgPSBzdHJcbiAgICAgICAgICAgIC5yZXBsYWNlKC9eXFwrLywgJycpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFwuMCskLywgJycpXG4gICAgICAgICAgICAucmVwbGFjZSgvXigtPykwKyhbMS05XSkvLCAnJDEkMicpO1xuXG4gICAgICAgIGlmIChzdHIuaW5jbHVkZXMoJy4nKSAmJiBzdHIuZW5kc1dpdGgoJzAnKSkge1xuICAgICAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UoLzArJC8sICcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMuTnVtYmVyID0gY2xhc3MgZXh0ZW5kcyBBbnkge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG5cbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fdHlwZSA9ICdudW1iZXInO1xuICAgICAgICB0aGlzLl9mbGFncy51bnNhZmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faW52YWxpZHMuYWRkKEluZmluaXR5KTtcbiAgICAgICAgdGhpcy5faW52YWxpZHMuYWRkKC1JbmZpbml0eSk7XG4gICAgfVxuXG4gICAgX2Jhc2UodmFsdWUsIHN0YXRlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICAgICAgZXJyb3JzOiBudWxsLFxuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgb3B0aW9ucy5jb252ZXJ0KSB7XG5cbiAgICAgICAgICAgIGNvbnN0IG1hdGNoZXMgPSB2YWx1ZS5tYXRjaCgvXlxccypbKy1dP1xcZCsoPzpcXC5cXGQrKT8oPzplKFsrLV0/XFxkKykpP1xccyokL2kpO1xuICAgICAgICAgICAgaWYgKG1hdGNoZXMpIHtcblxuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudHJpbSgpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9mbGFncy51bnNhZmUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlLmluY2x1ZGVzKCdlJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnRlcm5hbHMubm9ybWFsaXplRXhwb25lbnQoYCR7cmVzdWx0LnZhbHVlIC8gTWF0aC5wb3coMTAsIG1hdGNoZXNbMV0pfWUke21hdGNoZXNbMV19YCkgIT09IGludGVybmFscy5ub3JtYWxpemVFeHBvbmVudCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuZXJyb3JzID0gdGhpcy5jcmVhdGVFcnJvcignbnVtYmVyLnVuc2FmZScsIHsgdmFsdWUgfSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnZhbHVlLnRvU3RyaW5nKCkgIT09IGludGVybmFscy5ub3JtYWxpemVEZWNpbWFsKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5lcnJvcnMgPSB0aGlzLmNyZWF0ZUVycm9yKCdudW1iZXIudW5zYWZlJywgeyB2YWx1ZSB9LCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGlzTnVtYmVyID0gdHlwZW9mIHJlc3VsdC52YWx1ZSA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHJlc3VsdC52YWx1ZSk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuY29udmVydCAmJiAncHJlY2lzaW9uJyBpbiB0aGlzLl9mbGFncyAmJiBpc051bWJlcikge1xuXG4gICAgICAgICAgICAvLyBUaGlzIGlzIGNvbmNlcHR1YWxseSBlcXVpdmFsZW50IHRvIHVzaW5nIHRvRml4ZWQgYnV0IGl0IHNob3VsZCBiZSBtdWNoIGZhc3RlclxuICAgICAgICAgICAgY29uc3QgcHJlY2lzaW9uID0gTWF0aC5wb3coMTAsIHRoaXMuX2ZsYWdzLnByZWNpc2lvbik7XG4gICAgICAgICAgICByZXN1bHQudmFsdWUgPSBNYXRoLnJvdW5kKHJlc3VsdC52YWx1ZSAqIHByZWNpc2lvbikgLyBwcmVjaXNpb247XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNOdW1iZXIpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fZmxhZ3MudW5zYWZlICYmXG4gICAgICAgICAgICAgICAgKHZhbHVlID4gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgfHwgdmFsdWUgPCBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUikpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuZXJyb3JzID0gdGhpcy5jcmVhdGVFcnJvcignbnVtYmVyLnVuc2FmZScsIHsgdmFsdWUgfSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LmVycm9ycyA9IHRoaXMuY3JlYXRlRXJyb3IoJ251bWJlci5iYXNlJywgeyB2YWx1ZSB9LCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIG11bHRpcGxlKGJhc2UpIHtcblxuICAgICAgICBjb25zdCBpc1JlZiA9IFJlZi5pc1JlZihiYXNlKTtcblxuICAgICAgICBpZiAoIWlzUmVmKSB7XG4gICAgICAgICAgICBIb2VrLmFzc2VydCh0eXBlb2YgYmFzZSA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUoYmFzZSksICdtdWx0aXBsZSBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gICAgICAgICAgICBIb2VrLmFzc2VydChiYXNlID4gMCwgJ211bHRpcGxlIG11c3QgYmUgZ3JlYXRlciB0aGFuIDAnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl90ZXN0KCdtdWx0aXBsZScsIGJhc2UsIGZ1bmN0aW9uICh2YWx1ZSwgc3RhdGUsIG9wdGlvbnMpIHtcblxuICAgICAgICAgICAgY29uc3QgZGl2aXNvciA9IGlzUmVmID8gYmFzZShzdGF0ZS5yZWZlcmVuY2UgfHwgc3RhdGUucGFyZW50LCBvcHRpb25zKSA6IGJhc2U7XG5cbiAgICAgICAgICAgIGlmIChpc1JlZiAmJiAodHlwZW9mIGRpdmlzb3IgIT09ICdudW1iZXInIHx8ICFpc0Zpbml0ZShkaXZpc29yKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVFcnJvcignbnVtYmVyLnJlZicsIHsgcmVmOiBiYXNlLmtleSB9LCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSAlIGRpdmlzb3IgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKCdudW1iZXIubXVsdGlwbGUnLCB7IG11bHRpcGxlOiBiYXNlLCB2YWx1ZSB9LCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGludGVnZXIoKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Rlc3QoJ2ludGVnZXInLCB1bmRlZmluZWQsIGZ1bmN0aW9uICh2YWx1ZSwgc3RhdGUsIG9wdGlvbnMpIHtcblxuICAgICAgICAgICAgcmV0dXJuIE1hdGgudHJ1bmModmFsdWUpIC0gdmFsdWUgPT09IDAgPyB2YWx1ZSA6IHRoaXMuY3JlYXRlRXJyb3IoJ251bWJlci5pbnRlZ2VyJywgeyB2YWx1ZSB9LCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHVuc2FmZShlbmFibGVkID0gdHJ1ZSkge1xuXG4gICAgICAgIEhvZWsuYXNzZXJ0KHR5cGVvZiBlbmFibGVkID09PSAnYm9vbGVhbicsICdlbmFibGVkIG11c3QgYmUgYSBib29sZWFuJyk7XG5cbiAgICAgICAgaWYgKHRoaXMuX2ZsYWdzLnVuc2FmZSA9PT0gZW5hYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIG9iai5fZmxhZ3MudW5zYWZlID0gZW5hYmxlZDtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBuZWdhdGl2ZSgpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5fdGVzdCgnbmVnYXRpdmUnLCB1bmRlZmluZWQsIGZ1bmN0aW9uICh2YWx1ZSwgc3RhdGUsIG9wdGlvbnMpIHtcblxuICAgICAgICAgICAgaWYgKHZhbHVlIDwgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoJ251bWJlci5uZWdhdGl2ZScsIHsgdmFsdWUgfSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwb3NpdGl2ZSgpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5fdGVzdCgncG9zaXRpdmUnLCB1bmRlZmluZWQsIGZ1bmN0aW9uICh2YWx1ZSwgc3RhdGUsIG9wdGlvbnMpIHtcblxuICAgICAgICAgICAgaWYgKHZhbHVlID4gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoJ251bWJlci5wb3NpdGl2ZScsIHsgdmFsdWUgfSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwcmVjaXNpb24obGltaXQpIHtcblxuICAgICAgICBIb2VrLmFzc2VydChOdW1iZXIuaXNTYWZlSW50ZWdlcihsaW1pdCksICdsaW1pdCBtdXN0IGJlIGFuIGludGVnZXInKTtcbiAgICAgICAgSG9lay5hc3NlcnQoISgncHJlY2lzaW9uJyBpbiB0aGlzLl9mbGFncyksICdwcmVjaXNpb24gYWxyZWFkeSBzZXQnKTtcblxuICAgICAgICBjb25zdCBvYmogPSB0aGlzLl90ZXN0KCdwcmVjaXNpb24nLCBsaW1pdCwgZnVuY3Rpb24gKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucykge1xuXG4gICAgICAgICAgICBjb25zdCBwbGFjZXMgPSB2YWx1ZS50b1N0cmluZygpLm1hdGNoKGludGVybmFscy5wcmVjaXNpb25SeCk7XG4gICAgICAgICAgICBjb25zdCBkZWNpbWFscyA9IE1hdGgubWF4KChwbGFjZXNbMV0gPyBwbGFjZXNbMV0ubGVuZ3RoIDogMCkgLSAocGxhY2VzWzJdID8gcGFyc2VJbnQocGxhY2VzWzJdLCAxMCkgOiAwKSwgMCk7XG4gICAgICAgICAgICBpZiAoZGVjaW1hbHMgPD0gbGltaXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKCdudW1iZXIucHJlY2lzaW9uJywgeyBsaW1pdCwgdmFsdWUgfSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICB9KTtcblxuICAgICAgICBvYmouX2ZsYWdzLnByZWNpc2lvbiA9IGxpbWl0O1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIHBvcnQoKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Rlc3QoJ3BvcnQnLCB1bmRlZmluZWQsIGZ1bmN0aW9uICh2YWx1ZSwgc3RhdGUsIG9wdGlvbnMpIHtcblxuICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcih2YWx1ZSkgfHwgdmFsdWUgPCAwIHx8IHZhbHVlID4gNjU1MzUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVFcnJvcignbnVtYmVyLnBvcnQnLCB7IHZhbHVlIH0sIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9KTtcbiAgICB9XG5cbn07XG5cblxuaW50ZXJuYWxzLmNvbXBhcmUgPSBmdW5jdGlvbiAodHlwZSwgY29tcGFyZSkge1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChsaW1pdCkge1xuXG4gICAgICAgIGNvbnN0IGlzUmVmID0gUmVmLmlzUmVmKGxpbWl0KTtcbiAgICAgICAgY29uc3QgaXNOdW1iZXIgPSB0eXBlb2YgbGltaXQgPT09ICdudW1iZXInICYmICFpc05hTihsaW1pdCk7XG5cbiAgICAgICAgSG9lay5hc3NlcnQoaXNOdW1iZXIgfHwgaXNSZWYsICdsaW1pdCBtdXN0IGJlIGEgbnVtYmVyIG9yIHJlZmVyZW5jZScpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl90ZXN0KHR5cGUsIGxpbWl0LCBmdW5jdGlvbiAodmFsdWUsIHN0YXRlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgICAgIGxldCBjb21wYXJlVG87XG4gICAgICAgICAgICBpZiAoaXNSZWYpIHtcbiAgICAgICAgICAgICAgICBjb21wYXJlVG8gPSBsaW1pdChzdGF0ZS5yZWZlcmVuY2UgfHwgc3RhdGUucGFyZW50LCBvcHRpb25zKTtcblxuICAgICAgICAgICAgICAgIGlmICghKHR5cGVvZiBjb21wYXJlVG8gPT09ICdudW1iZXInICYmICFpc05hTihjb21wYXJlVG8pKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVFcnJvcignbnVtYmVyLnJlZicsIHsgcmVmOiBsaW1pdC5rZXkgfSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbXBhcmVUbyA9IGxpbWl0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY29tcGFyZSh2YWx1ZSwgY29tcGFyZVRvKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoJ251bWJlci4nICsgdHlwZSwgeyBsaW1pdDogY29tcGFyZVRvLCB2YWx1ZSB9LCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH07XG59O1xuXG5cbmludGVybmFscy5OdW1iZXIucHJvdG90eXBlLm1pbiA9IGludGVybmFscy5jb21wYXJlKCdtaW4nLCAodmFsdWUsIGxpbWl0KSA9PiB2YWx1ZSA+PSBsaW1pdCk7XG5pbnRlcm5hbHMuTnVtYmVyLnByb3RvdHlwZS5tYXggPSBpbnRlcm5hbHMuY29tcGFyZSgnbWF4JywgKHZhbHVlLCBsaW1pdCkgPT4gdmFsdWUgPD0gbGltaXQpO1xuaW50ZXJuYWxzLk51bWJlci5wcm90b3R5cGUuZ3JlYXRlciA9IGludGVybmFscy5jb21wYXJlKCdncmVhdGVyJywgKHZhbHVlLCBsaW1pdCkgPT4gdmFsdWUgPiBsaW1pdCk7XG5pbnRlcm5hbHMuTnVtYmVyLnByb3RvdHlwZS5sZXNzID0gaW50ZXJuYWxzLmNvbXBhcmUoJ2xlc3MnLCAodmFsdWUsIGxpbWl0KSA9PiB2YWx1ZSA8IGxpbWl0KTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBpbnRlcm5hbHMuTnVtYmVyKCk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEhvZWsgPSByZXF1aXJlKCdAaGFwaS9ob2VrJyk7XG5jb25zdCBUb3BvID0gcmVxdWlyZSgnQGhhcGkvdG9wbycpO1xuXG5jb25zdCBBbnkgPSByZXF1aXJlKCcuLi9hbnknKTtcbmNvbnN0IEVycm9ycyA9IHJlcXVpcmUoJy4uLy4uL2Vycm9ycycpO1xuY29uc3QgQ2FzdCA9IHJlcXVpcmUoJy4uLy4uL2Nhc3QnKTtcbmNvbnN0IFN0YXRlID0gcmVxdWlyZSgnLi4vc3RhdGUnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5pbnRlcm5hbHMuT2JqZWN0ID0gY2xhc3MgZXh0ZW5kcyBBbnkge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG5cbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fdHlwZSA9ICdvYmplY3QnO1xuICAgICAgICB0aGlzLl9pbm5lci5jaGlsZHJlbiA9IG51bGw7XG4gICAgICAgIHRoaXMuX2lubmVyLnJlbmFtZXMgPSBbXTtcbiAgICAgICAgdGhpcy5faW5uZXIuZGVwZW5kZW5jaWVzID0gW107XG4gICAgICAgIHRoaXMuX2lubmVyLnBhdHRlcm5zID0gW107XG4gICAgfVxuXG4gICAgX2luaXQoLi4uYXJncykge1xuXG4gICAgICAgIHJldHVybiBhcmdzLmxlbmd0aCA/IHRoaXMua2V5cyguLi5hcmdzKSA6IHRoaXM7XG4gICAgfVxuXG4gICAgX2Jhc2UodmFsdWUsIHN0YXRlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgbGV0IHRhcmdldCA9IHZhbHVlO1xuICAgICAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICAgICAgY29uc3QgZmluaXNoID0gKCkgPT4ge1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHZhbHVlOiB0YXJnZXQsXG4gICAgICAgICAgICAgICAgZXJyb3JzOiBlcnJvcnMubGVuZ3RoID8gZXJyb3JzIDogbnVsbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgb3B0aW9ucy5jb252ZXJ0KSB7XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiAxICYmXG4gICAgICAgICAgICAgICAgKHZhbHVlWzBdID09PSAneycgfHwgL15cXHMqXFx7Ly50ZXN0KHZhbHVlKSkpIHtcblxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gSlNPTi5wYXJzZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHR5cGUgPSB0aGlzLl9mbGFncy5mdW5jID8gJ2Z1bmN0aW9uJyA6ICdvYmplY3QnO1xuICAgICAgICBpZiAoIXZhbHVlIHx8XG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgIT09IHR5cGUgfHxcbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG5cbiAgICAgICAgICAgIGVycm9ycy5wdXNoKHRoaXMuY3JlYXRlRXJyb3IodHlwZSArICcuYmFzZScsIHsgdmFsdWUgfSwgc3RhdGUsIG9wdGlvbnMpKTtcbiAgICAgICAgICAgIHJldHVybiBmaW5pc2goKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNraXAgaWYgdGhlcmUgYXJlIG5vIG90aGVyIHJ1bGVzIHRvIHRlc3RcblxuICAgICAgICBpZiAoIXRoaXMuX2lubmVyLnJlbmFtZXMubGVuZ3RoICYmXG4gICAgICAgICAgICAhdGhpcy5faW5uZXIuZGVwZW5kZW5jaWVzLmxlbmd0aCAmJlxuICAgICAgICAgICAgIXRoaXMuX2lubmVyLmNoaWxkcmVuICYmICAgICAgICAgICAgICAgICAgICAvLyBudWxsIGFsbG93cyBhbnkga2V5c1xuICAgICAgICAgICAgIXRoaXMuX2lubmVyLnBhdHRlcm5zLmxlbmd0aCkge1xuXG4gICAgICAgICAgICB0YXJnZXQgPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBmaW5pc2goKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEVuc3VyZSB0YXJnZXQgaXMgYSBsb2NhbCBjb3B5IChwYXJzZWQpIG9yIHNoYWxsb3cgY29weVxuXG4gICAgICAgIGlmICh0YXJnZXQgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQgPSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHRhcmdldC5wcm90b3R5cGUgPSBIb2VrLmNsb25lKHZhbHVlLnByb3RvdHlwZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHZhbHVlS2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVLZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W3ZhbHVlS2V5c1tpXV0gPSB2YWx1ZVt2YWx1ZUtleXNbaV1dO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGFyZ2V0ID0gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZW5hbWUga2V5c1xuXG4gICAgICAgIGNvbnN0IHJlbmFtZWQgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9pbm5lci5yZW5hbWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCByZW5hbWUgPSB0aGlzLl9pbm5lci5yZW5hbWVzW2ldO1xuXG4gICAgICAgICAgICBpZiAocmVuYW1lLmlzUmVnRXhwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0S2V5cyA9IE9iamVjdC5rZXlzKHRhcmdldCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF0Y2hlZFRhcmdldEtleXMgPSBbXTtcblxuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGFyZ2V0S2V5cy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVuYW1lLmZyb20udGVzdCh0YXJnZXRLZXlzW2pdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZFRhcmdldEtleXMucHVzaCh0YXJnZXRLZXlzW2pdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IGFsbFVuZGVmaW5lZCA9IG1hdGNoZWRUYXJnZXRLZXlzLmV2ZXJ5KChrZXkpID0+IHRhcmdldFtrZXldID09PSB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgIGlmIChyZW5hbWUub3B0aW9ucy5pZ25vcmVVbmRlZmluZWQgJiYgYWxsVW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghcmVuYW1lLm9wdGlvbnMubXVsdGlwbGUgJiZcbiAgICAgICAgICAgICAgICAgICAgcmVuYW1lZFtyZW5hbWUudG9dKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2godGhpcy5jcmVhdGVFcnJvcignb2JqZWN0LnJlbmFtZS5yZWdleC5tdWx0aXBsZScsIHsgZnJvbTogbWF0Y2hlZFRhcmdldEtleXMsIHRvOiByZW5hbWUudG8gfSwgc3RhdGUsIG9wdGlvbnMpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpbmlzaCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0YXJnZXQsIHJlbmFtZS50bykgJiZcbiAgICAgICAgICAgICAgICAgICAgIXJlbmFtZS5vcHRpb25zLm92ZXJyaWRlICYmXG4gICAgICAgICAgICAgICAgICAgICFyZW5hbWVkW3JlbmFtZS50b10pIHtcblxuICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCh0aGlzLmNyZWF0ZUVycm9yKCdvYmplY3QucmVuYW1lLnJlZ2V4Lm92ZXJyaWRlJywgeyBmcm9tOiBtYXRjaGVkVGFyZ2V0S2V5cywgdG86IHJlbmFtZS50byB9LCBzdGF0ZSwgb3B0aW9ucykpO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmluaXNoKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoYWxsVW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0YXJnZXRbcmVuYW1lLnRvXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtyZW5hbWUudG9dID0gdGFyZ2V0W21hdGNoZWRUYXJnZXRLZXlzW21hdGNoZWRUYXJnZXRLZXlzLmxlbmd0aCAtIDFdXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZW5hbWVkW3JlbmFtZS50b10gPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFyZW5hbWUub3B0aW9ucy5hbGlhcykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG1hdGNoZWRUYXJnZXRLZXlzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGFyZ2V0W21hdGNoZWRUYXJnZXRLZXlzW2pdXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChyZW5hbWUub3B0aW9ucy5pZ25vcmVVbmRlZmluZWQgJiYgdGFyZ2V0W3JlbmFtZS5mcm9tXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghcmVuYW1lLm9wdGlvbnMubXVsdGlwbGUgJiZcbiAgICAgICAgICAgICAgICAgICAgcmVuYW1lZFtyZW5hbWUudG9dKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2godGhpcy5jcmVhdGVFcnJvcignb2JqZWN0LnJlbmFtZS5tdWx0aXBsZScsIHsgZnJvbTogcmVuYW1lLmZyb20sIHRvOiByZW5hbWUudG8gfSwgc3RhdGUsIG9wdGlvbnMpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpbmlzaCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0YXJnZXQsIHJlbmFtZS50bykgJiZcbiAgICAgICAgICAgICAgICAgICAgIXJlbmFtZS5vcHRpb25zLm92ZXJyaWRlICYmXG4gICAgICAgICAgICAgICAgICAgICFyZW5hbWVkW3JlbmFtZS50b10pIHtcblxuICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCh0aGlzLmNyZWF0ZUVycm9yKCdvYmplY3QucmVuYW1lLm92ZXJyaWRlJywgeyBmcm9tOiByZW5hbWUuZnJvbSwgdG86IHJlbmFtZS50byB9LCBzdGF0ZSwgb3B0aW9ucykpO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmluaXNoKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0W3JlbmFtZS5mcm9tXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0YXJnZXRbcmVuYW1lLnRvXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtyZW5hbWUudG9dID0gdGFyZ2V0W3JlbmFtZS5mcm9tXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZW5hbWVkW3JlbmFtZS50b10gPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFyZW5hbWUub3B0aW9ucy5hbGlhcykge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGFyZ2V0W3JlbmFtZS5mcm9tXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBWYWxpZGF0ZSBzY2hlbWFcblxuICAgICAgICBpZiAoIXRoaXMuX2lubmVyLmNoaWxkcmVuICYmICAgICAgICAgICAgLy8gbnVsbCBhbGxvd3MgYW55IGtleXNcbiAgICAgICAgICAgICF0aGlzLl9pbm5lci5wYXR0ZXJucy5sZW5ndGggJiZcbiAgICAgICAgICAgICF0aGlzLl9pbm5lci5kZXBlbmRlbmNpZXMubGVuZ3RoKSB7XG5cbiAgICAgICAgICAgIHJldHVybiBmaW5pc2goKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHVucHJvY2Vzc2VkID0gbmV3IFNldChPYmplY3Qua2V5cyh0YXJnZXQpKTtcblxuICAgICAgICBpZiAodGhpcy5faW5uZXIuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGNvbnN0IHN0cmlwUHJvcHMgPSBbXTtcblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9pbm5lci5jaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gdGhpcy5faW5uZXIuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gY2hpbGQua2V5O1xuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSB0YXJnZXRba2V5XTtcblxuICAgICAgICAgICAgICAgIHVucHJvY2Vzc2VkLmRlbGV0ZShrZXkpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYWxTdGF0ZSA9IG5ldyBTdGF0ZShrZXksIFsuLi5zdGF0ZS5wYXRoLCBrZXldLCB0YXJnZXQsIHN0YXRlLnJlZmVyZW5jZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gY2hpbGQuc2NoZW1hLl92YWxpZGF0ZShpdGVtLCBsb2NhbFN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmVycm9ycykge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCh0aGlzLmNyZWF0ZUVycm9yKCdvYmplY3QuY2hpbGQnLCB7IGtleSwgY2hpbGQ6IGNoaWxkLnNjaGVtYS5fZ2V0TGFiZWwoa2V5KSwgcmVhc29uOiByZXN1bHQuZXJyb3JzIH0sIGxvY2FsU3RhdGUsIG9wdGlvbnMpKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmluaXNoKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZC5zY2hlbWEuX2ZsYWdzLnN0cmlwIHx8IChyZXN1bHQudmFsdWUgPT09IHVuZGVmaW5lZCAmJiByZXN1bHQudmFsdWUgIT09IGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJpcFByb3BzLnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gcmVzdWx0LmZpbmFsVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocmVzdWx0LnZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0cmlwUHJvcHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGFyZ2V0W3N0cmlwUHJvcHNbaV1dO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVW5rbm93biBrZXlzXG5cbiAgICAgICAgaWYgKHVucHJvY2Vzc2VkLnNpemUgJiYgdGhpcy5faW5uZXIucGF0dGVybnMubGVuZ3RoKSB7XG5cbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHVucHJvY2Vzc2VkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYWxTdGF0ZSA9IG5ldyBTdGF0ZShrZXksIFsuLi5zdGF0ZS5wYXRoLCBrZXldLCB0YXJnZXQsIHN0YXRlLnJlZmVyZW5jZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IHRhcmdldFtrZXldO1xuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9pbm5lci5wYXR0ZXJucy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXR0ZXJuID0gdGhpcy5faW5uZXIucGF0dGVybnNbaV07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhdHRlcm4ucmVnZXggP1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0dGVybi5yZWdleC50ZXN0KGtleSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgIXBhdHRlcm4uc2NoZW1hLl92YWxpZGF0ZShrZXksIHN0YXRlLCB7IC4uLm9wdGlvbnMsIGFib3J0RWFybHk6dHJ1ZSB9KS5lcnJvcnMpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdW5wcm9jZXNzZWQuZGVsZXRlKGtleSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHBhdHRlcm4ucnVsZS5fdmFsaWRhdGUoaXRlbSwgbG9jYWxTdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmVycm9ycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKHRoaXMuY3JlYXRlRXJyb3IoJ29iamVjdC5jaGlsZCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZDogcGF0dGVybi5ydWxlLl9nZXRMYWJlbChrZXkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFzb246IHJlc3VsdC5lcnJvcnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBsb2NhbFN0YXRlLCBvcHRpb25zKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmaW5pc2goKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHVucHJvY2Vzc2VkLnNpemUgJiYgKHRoaXMuX2lubmVyLmNoaWxkcmVuIHx8IHRoaXMuX2lubmVyLnBhdHRlcm5zLmxlbmd0aCkpIHtcbiAgICAgICAgICAgIGlmICgob3B0aW9ucy5zdHJpcFVua25vd24gJiYgdGhpcy5fZmxhZ3MuYWxsb3dVbmtub3duICE9PSB0cnVlKSB8fFxuICAgICAgICAgICAgICAgIG9wdGlvbnMuc2tpcEZ1bmN0aW9ucykge1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgc3RyaXBVbmtub3duID0gb3B0aW9ucy5zdHJpcFVua25vd25cbiAgICAgICAgICAgICAgICAgICAgPyAob3B0aW9ucy5zdHJpcFVua25vd24gPT09IHRydWUgPyB0cnVlIDogISFvcHRpb25zLnN0cmlwVW5rbm93bi5vYmplY3RzKVxuICAgICAgICAgICAgICAgICAgICA6IGZhbHNlO1xuXG5cbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiB1bnByb2Nlc3NlZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RyaXBVbmtub3duKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGFyZ2V0W2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICB1bnByb2Nlc3NlZC5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdGFyZ2V0W2tleV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVucHJvY2Vzc2VkLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoKHRoaXMuX2ZsYWdzLmFsbG93VW5rbm93biAhPT0gdW5kZWZpbmVkID8gIXRoaXMuX2ZsYWdzLmFsbG93VW5rbm93biA6ICFvcHRpb25zLmFsbG93VW5rbm93bikpIHtcblxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdW5wcm9jZXNzZWRLZXkgb2YgdW5wcm9jZXNzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2godGhpcy5jcmVhdGVFcnJvcignb2JqZWN0LmFsbG93VW5rbm93bicsIHsgY2hpbGQ6IHVucHJvY2Vzc2VkS2V5LCB2YWx1ZTogdGFyZ2V0W3VucHJvY2Vzc2VkS2V5XSB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6IHVucHJvY2Vzc2VkS2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogWy4uLnN0YXRlLnBhdGgsIHVucHJvY2Vzc2VkS2V5XVxuICAgICAgICAgICAgICAgICAgICB9LCBvcHRpb25zLCB7fSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFZhbGlkYXRlIGRlcGVuZGVuY2llc1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5faW5uZXIuZGVwZW5kZW5jaWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBkZXAgPSB0aGlzLl9pbm5lci5kZXBlbmRlbmNpZXNbaV07XG4gICAgICAgICAgICBjb25zdCBoYXNLZXkgPSBkZXAua2V5ICE9PSBudWxsO1xuICAgICAgICAgICAgY29uc3Qgc3BsaXRLZXkgPSBoYXNLZXkgJiYgZGVwLmtleS5zcGxpdCgnLicpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxTdGF0ZSA9IGhhc0tleSA/IG5ldyBTdGF0ZShzcGxpdEtleVtzcGxpdEtleS5sZW5ndGggLSAxXSwgWy4uLnN0YXRlLnBhdGgsIC4uLnNwbGl0S2V5XSkgOiBuZXcgU3RhdGUobnVsbCwgc3RhdGUucGF0aCk7XG4gICAgICAgICAgICBjb25zdCBlcnIgPSBpbnRlcm5hbHNbZGVwLnR5cGVdLmNhbGwodGhpcywgZGVwLmtleSwgaGFzS2V5ICYmIEhvZWsucmVhY2godGFyZ2V0LCBkZXAua2V5LCB7IGZ1bmN0aW9uczogdHJ1ZSB9KSwgZGVwLnBlZXJzLCB0YXJnZXQsIGxvY2FsU3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9ycy5FcnIpIHtcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChlcnIpO1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpbmlzaCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmaW5pc2goKTtcbiAgICB9XG5cbiAgICBrZXlzKHNjaGVtYSkge1xuXG4gICAgICAgIEhvZWsuYXNzZXJ0KHNjaGVtYSA9PT0gbnVsbCB8fCBzY2hlbWEgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2Ygc2NoZW1hID09PSAnb2JqZWN0JywgJ09iamVjdCBzY2hlbWEgbXVzdCBiZSBhIHZhbGlkIG9iamVjdCcpO1xuICAgICAgICBIb2VrLmFzc2VydCghc2NoZW1hIHx8ICEoc2NoZW1hIGluc3RhbmNlb2YgQW55KSwgJ09iamVjdCBzY2hlbWEgY2Fubm90IGJlIGEgam9pIHNjaGVtYScpO1xuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcblxuICAgICAgICBpZiAoIXNjaGVtYSkge1xuICAgICAgICAgICAgb2JqLl9pbm5lci5jaGlsZHJlbiA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBPYmplY3Qua2V5cyhzY2hlbWEpO1xuXG4gICAgICAgIGlmICghY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICBvYmouX2lubmVyLmNoaWxkcmVuID0gW107XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdG9wbyA9IG5ldyBUb3BvKCk7XG4gICAgICAgIGlmIChvYmouX2lubmVyLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9iai5faW5uZXIuY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZCA9IG9iai5faW5uZXIuY2hpbGRyZW5baV07XG5cbiAgICAgICAgICAgICAgICAvLyBPbmx5IGFkZCB0aGUga2V5IGlmIHdlIGFyZSBub3QgZ29pbmcgdG8gcmVwbGFjZSBpdCBsYXRlclxuICAgICAgICAgICAgICAgIGlmICghY2hpbGRyZW4uaW5jbHVkZXMoY2hpbGQua2V5KSkge1xuICAgICAgICAgICAgICAgICAgICB0b3BvLmFkZChjaGlsZCwgeyBhZnRlcjogY2hpbGQuX3JlZnMsIGdyb3VwOiBjaGlsZC5rZXkgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgICBjb25zdCBjaGlsZCA9IHNjaGVtYVtrZXldO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjYXN0ID0gQ2FzdC5zY2hlbWEodGhpcy5fY3VycmVudEpvaSwgY2hpbGQpO1xuICAgICAgICAgICAgICAgIHRvcG8uYWRkKHsga2V5LCBzY2hlbWE6IGNhc3QgfSwgeyBhZnRlcjogY2FzdC5fcmVmcywgZ3JvdXA6IGtleSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChjYXN0RXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhc3RFcnIuaGFzT3duUHJvcGVydHkoJ3BhdGgnKSkge1xuICAgICAgICAgICAgICAgICAgICBjYXN0RXJyLnBhdGggPSBrZXkgKyAnLicgKyBjYXN0RXJyLnBhdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjYXN0RXJyLnBhdGggPSBrZXk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhyb3cgY2FzdEVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG9iai5faW5uZXIuY2hpbGRyZW4gPSB0b3BvLm5vZGVzO1xuXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgYXBwZW5kKHNjaGVtYSkge1xuICAgICAgICAvLyBTa2lwIGFueSBjaGFuZ2VzXG4gICAgICAgIGlmIChzY2hlbWEgPT09IG51bGwgfHwgc2NoZW1hID09PSB1bmRlZmluZWQgfHwgT2JqZWN0LmtleXMoc2NoZW1hKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMua2V5cyhzY2hlbWEpO1xuICAgIH1cblxuICAgIHVua25vd24oYWxsb3cpIHtcblxuICAgICAgICBjb25zdCB2YWx1ZSA9IGFsbG93ICE9PSBmYWxzZTtcblxuICAgICAgICBpZiAodGhpcy5fZmxhZ3MuYWxsb3dVbmtub3duID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIG9iai5fZmxhZ3MuYWxsb3dVbmtub3duID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgbGVuZ3RoKGxpbWl0KSB7XG5cbiAgICAgICAgSG9lay5hc3NlcnQoTnVtYmVyLmlzU2FmZUludGVnZXIobGltaXQpICYmIGxpbWl0ID49IDAsICdsaW1pdCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlcicpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl90ZXN0KCdsZW5ndGgnLCBsaW1pdCwgZnVuY3Rpb24gKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucykge1xuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aCA9PT0gbGltaXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKCdvYmplY3QubGVuZ3RoJywgeyBsaW1pdCwgdmFsdWUgfSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBtaW4obGltaXQpIHtcblxuICAgICAgICBIb2VrLmFzc2VydChOdW1iZXIuaXNTYWZlSW50ZWdlcihsaW1pdCkgJiYgbGltaXQgPj0gMCwgJ2xpbWl0IG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Rlc3QoJ21pbicsIGxpbWl0LCBmdW5jdGlvbiAodmFsdWUsIHN0YXRlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoID49IGxpbWl0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVFcnJvcignb2JqZWN0Lm1pbicsIHsgbGltaXQsIHZhbHVlIH0sIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgbWF4KGxpbWl0KSB7XG5cbiAgICAgICAgSG9lay5hc3NlcnQoTnVtYmVyLmlzU2FmZUludGVnZXIobGltaXQpICYmIGxpbWl0ID49IDAsICdsaW1pdCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlcicpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl90ZXN0KCdtYXgnLCBsaW1pdCwgZnVuY3Rpb24gKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucykge1xuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aCA8PSBsaW1pdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoJ29iamVjdC5tYXgnLCB7IGxpbWl0LCB2YWx1ZSB9LCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHBhdHRlcm4ocGF0dGVybiwgc2NoZW1hKSB7XG5cbiAgICAgICAgY29uc3QgaXNSZWdFeHAgPSBwYXR0ZXJuIGluc3RhbmNlb2YgUmVnRXhwO1xuICAgICAgICBIb2VrLmFzc2VydChpc1JlZ0V4cCB8fCBwYXR0ZXJuIGluc3RhbmNlb2YgQW55LCAncGF0dGVybiBtdXN0IGJlIGEgcmVnZXggb3Igc2NoZW1hJyk7XG4gICAgICAgIEhvZWsuYXNzZXJ0KHNjaGVtYSAhPT0gdW5kZWZpbmVkLCAnSW52YWxpZCBydWxlJyk7XG5cbiAgICAgICAgaWYgKGlzUmVnRXhwKSB7XG4gICAgICAgICAgICBIb2VrLmFzc2VydCghcGF0dGVybi5mbGFncy5pbmNsdWRlcygnZycpICYmICFwYXR0ZXJuLmZsYWdzLmluY2x1ZGVzKCd5JyksICdwYXR0ZXJuIHNob3VsZCBub3QgdXNlIGdsb2JhbCBvciBzdGlja3kgbW9kZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNjaGVtYSA9IENhc3Quc2NoZW1hKHRoaXMuX2N1cnJlbnRKb2ksIHNjaGVtYSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGNhc3RFcnIpIHtcbiAgICAgICAgICAgIGlmIChjYXN0RXJyLmhhc093blByb3BlcnR5KCdwYXRoJykpIHtcbiAgICAgICAgICAgICAgICBjYXN0RXJyLm1lc3NhZ2UgPSBgJHtjYXN0RXJyLm1lc3NhZ2V9KCR7Y2FzdEVyci5wYXRofSlgO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aHJvdyBjYXN0RXJyO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBpZiAoaXNSZWdFeHApIHtcbiAgICAgICAgICAgIG9iai5faW5uZXIucGF0dGVybnMucHVzaCh7IHJlZ2V4OiBwYXR0ZXJuLCBydWxlOiBzY2hlbWEgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYmouX2lubmVyLnBhdHRlcm5zLnB1c2goeyBzY2hlbWE6IHBhdHRlcm4sIHJ1bGU6IHNjaGVtYSB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgc2NoZW1hKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLl90ZXN0KCdzY2hlbWEnLCBudWxsLCBmdW5jdGlvbiAodmFsdWUsIHN0YXRlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFueSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoJ29iamVjdC5zY2hlbWEnLCBudWxsLCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHdpdGgoa2V5LCBwZWVycykge1xuXG4gICAgICAgIEhvZWsuYXNzZXJ0KGFyZ3VtZW50cy5sZW5ndGggPT09IDIsICdJbnZhbGlkIG51bWJlciBvZiBhcmd1bWVudHMsIGV4cGVjdGVkIDIuJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlcGVuZGVuY3koJ3dpdGgnLCBrZXksIHBlZXJzKTtcbiAgICB9XG5cbiAgICB3aXRob3V0KGtleSwgcGVlcnMpIHtcblxuICAgICAgICBIb2VrLmFzc2VydChhcmd1bWVudHMubGVuZ3RoID09PSAyLCAnSW52YWxpZCBudW1iZXIgb2YgYXJndW1lbnRzLCBleHBlY3RlZCAyLicpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9kZXBlbmRlbmN5KCd3aXRob3V0Jywga2V5LCBwZWVycyk7XG4gICAgfVxuXG4gICAgeG9yKC4uLnBlZXJzKSB7XG5cbiAgICAgICAgcGVlcnMgPSBIb2VrLmZsYXR0ZW4ocGVlcnMpO1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVwZW5kZW5jeSgneG9yJywgbnVsbCwgcGVlcnMpO1xuICAgIH1cblxuICAgIG94b3IoLi4ucGVlcnMpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5fZGVwZW5kZW5jeSgnb3hvcicsIG51bGwsIHBlZXJzKTtcbiAgICB9XG5cbiAgICBvciguLi5wZWVycykge1xuXG4gICAgICAgIHBlZXJzID0gSG9lay5mbGF0dGVuKHBlZXJzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlcGVuZGVuY3koJ29yJywgbnVsbCwgcGVlcnMpO1xuICAgIH1cblxuICAgIGFuZCguLi5wZWVycykge1xuXG4gICAgICAgIHBlZXJzID0gSG9lay5mbGF0dGVuKHBlZXJzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlcGVuZGVuY3koJ2FuZCcsIG51bGwsIHBlZXJzKTtcbiAgICB9XG5cbiAgICBuYW5kKC4uLnBlZXJzKSB7XG5cbiAgICAgICAgcGVlcnMgPSBIb2VrLmZsYXR0ZW4ocGVlcnMpO1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVwZW5kZW5jeSgnbmFuZCcsIG51bGwsIHBlZXJzKTtcbiAgICB9XG5cbiAgICByZXF1aXJlZEtleXMoLi4uY2hpbGRyZW4pIHtcblxuICAgICAgICBjaGlsZHJlbiA9IEhvZWsuZmxhdHRlbihjaGlsZHJlbik7XG4gICAgICAgIHJldHVybiB0aGlzLmFwcGx5RnVuY3Rpb25Ub0NoaWxkcmVuKGNoaWxkcmVuLCAncmVxdWlyZWQnKTtcbiAgICB9XG5cbiAgICBvcHRpb25hbEtleXMoLi4uY2hpbGRyZW4pIHtcblxuICAgICAgICBjaGlsZHJlbiA9IEhvZWsuZmxhdHRlbihjaGlsZHJlbik7XG4gICAgICAgIHJldHVybiB0aGlzLmFwcGx5RnVuY3Rpb25Ub0NoaWxkcmVuKGNoaWxkcmVuLCAnb3B0aW9uYWwnKTtcbiAgICB9XG5cbiAgICBmb3JiaWRkZW5LZXlzKC4uLmNoaWxkcmVuKSB7XG5cbiAgICAgICAgY2hpbGRyZW4gPSBIb2VrLmZsYXR0ZW4oY2hpbGRyZW4pO1xuICAgICAgICByZXR1cm4gdGhpcy5hcHBseUZ1bmN0aW9uVG9DaGlsZHJlbihjaGlsZHJlbiwgJ2ZvcmJpZGRlbicpO1xuICAgIH1cblxuICAgIHJlbmFtZShmcm9tLCB0bywgb3B0aW9ucykge1xuXG4gICAgICAgIEhvZWsuYXNzZXJ0KHR5cGVvZiBmcm9tID09PSAnc3RyaW5nJyB8fCBmcm9tIGluc3RhbmNlb2YgUmVnRXhwLCAnUmVuYW1lIG1pc3NpbmcgdGhlIGZyb20gYXJndW1lbnQnKTtcbiAgICAgICAgSG9lay5hc3NlcnQodHlwZW9mIHRvID09PSAnc3RyaW5nJywgJ1JlbmFtZSBtaXNzaW5nIHRoZSB0byBhcmd1bWVudCcpO1xuICAgICAgICBIb2VrLmFzc2VydCh0byAhPT0gZnJvbSwgJ0Nhbm5vdCByZW5hbWUga2V5IHRvIHNhbWUgbmFtZTonLCBmcm9tKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2lubmVyLnJlbmFtZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIEhvZWsuYXNzZXJ0KHRoaXMuX2lubmVyLnJlbmFtZXNbaV0uZnJvbSAhPT0gZnJvbSwgJ0Nhbm5vdCByZW5hbWUgdGhlIHNhbWUga2V5IG11bHRpcGxlIHRpbWVzJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG5cbiAgICAgICAgb2JqLl9pbm5lci5yZW5hbWVzLnB1c2goe1xuICAgICAgICAgICAgZnJvbSxcbiAgICAgICAgICAgIHRvLFxuICAgICAgICAgICAgb3B0aW9uczogSG9lay5hcHBseVRvRGVmYXVsdHMoaW50ZXJuYWxzLnJlbmFtZURlZmF1bHRzLCBvcHRpb25zIHx8IHt9KSxcbiAgICAgICAgICAgIGlzUmVnRXhwOiBmcm9tIGluc3RhbmNlb2YgUmVnRXhwXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgYXBwbHlGdW5jdGlvblRvQ2hpbGRyZW4oY2hpbGRyZW4sIGZuLCBhcmdzID0gW10sIHJvb3QpIHtcblxuICAgICAgICBjaGlsZHJlbiA9IFtdLmNvbmNhdChjaGlsZHJlbik7XG4gICAgICAgIEhvZWsuYXNzZXJ0KGNoaWxkcmVuLmxlbmd0aCA+IDAsICdleHBlY3RlZCBhdCBsZWFzdCBvbmUgY2hpbGRyZW4nKTtcblxuICAgICAgICBjb25zdCBncm91cGVkQ2hpbGRyZW4gPSBpbnRlcm5hbHMuZ3JvdXBDaGlsZHJlbihjaGlsZHJlbik7XG4gICAgICAgIGxldCBvYmo7XG5cbiAgICAgICAgaWYgKCcnIGluIGdyb3VwZWRDaGlsZHJlbikge1xuICAgICAgICAgICAgb2JqID0gdGhpc1tmbl0oLi4uYXJncyk7XG4gICAgICAgICAgICBkZWxldGUgZ3JvdXBlZENoaWxkcmVuWycnXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iaiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvYmouX2lubmVyLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICByb290ID0gcm9vdCA/IChyb290ICsgJy4nKSA6ICcnO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9iai5faW5uZXIuY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZCA9IG9iai5faW5uZXIuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgY29uc3QgZ3JvdXAgPSBncm91cGVkQ2hpbGRyZW5bY2hpbGQua2V5XTtcblxuICAgICAgICAgICAgICAgIGlmIChncm91cCkge1xuICAgICAgICAgICAgICAgICAgICBvYmouX2lubmVyLmNoaWxkcmVuW2ldID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBjaGlsZC5rZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBfcmVmczogY2hpbGQuX3JlZnMsXG4gICAgICAgICAgICAgICAgICAgICAgICBzY2hlbWE6IGNoaWxkLnNjaGVtYS5hcHBseUZ1bmN0aW9uVG9DaGlsZHJlbihncm91cCwgZm4sIGFyZ3MsIHJvb3QgKyBjaGlsZC5rZXkpXG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGdyb3VwZWRDaGlsZHJlbltjaGlsZC5rZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlbWFpbmluZyA9IE9iamVjdC5rZXlzKGdyb3VwZWRDaGlsZHJlbik7XG4gICAgICAgIEhvZWsuYXNzZXJ0KHJlbWFpbmluZy5sZW5ndGggPT09IDAsICd1bmtub3duIGtleShzKScsIHJlbWFpbmluZy5qb2luKCcsICcpKTtcblxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9kZXBlbmRlbmN5KHR5cGUsIGtleSwgcGVlcnMpIHtcblxuICAgICAgICBwZWVycyA9IFtdLmNvbmNhdChwZWVycyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGVlcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIEhvZWsuYXNzZXJ0KHR5cGVvZiBwZWVyc1tpXSA9PT0gJ3N0cmluZycsIHR5cGUsICdwZWVycyBtdXN0IGJlIGEgc3RyaW5nIG9yIGFycmF5IG9mIHN0cmluZ3MnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgb2JqLl9pbm5lci5kZXBlbmRlbmNpZXMucHVzaCh7IHR5cGUsIGtleSwgcGVlcnMgfSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgZGVzY3JpYmUoc2hhbGxvdykge1xuXG4gICAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gc3VwZXIuZGVzY3JpYmUoKTtcblxuICAgICAgICBpZiAoZGVzY3JpcHRpb24ucnVsZXMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVzY3JpcHRpb24ucnVsZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBydWxlID0gZGVzY3JpcHRpb24ucnVsZXNbaV07XG4gICAgICAgICAgICAgICAgLy8gQ292ZXJhZ2Ugb2ZmIGZvciBmdXR1cmUtcHJvb2YgZGVzY3JpcHRpb25zLCBvbmx5IG9iamVjdCgpLmFzc2VydCgpIGlzIHVzZSByaWdodCBub3dcbiAgICAgICAgICAgICAgICBpZiAoLyogJGxhYjpjb3ZlcmFnZTpvZmYkICovcnVsZS5hcmcgJiZcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHJ1bGUuYXJnID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICAgICAgICBydWxlLmFyZy5zY2hlbWEgJiZcbiAgICAgICAgICAgICAgICAgICAgcnVsZS5hcmcucmVmIC8qICRsYWI6Y292ZXJhZ2U6b24kICovKSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bGUuYXJnID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NoZW1hOiBydWxlLmFyZy5zY2hlbWEuZGVzY3JpYmUoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZjogcnVsZS5hcmcucmVmLnRvU3RyaW5nKClcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5faW5uZXIuY2hpbGRyZW4gJiZcbiAgICAgICAgICAgICFzaGFsbG93KSB7XG5cbiAgICAgICAgICAgIGRlc2NyaXB0aW9uLmNoaWxkcmVuID0ge307XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2lubmVyLmNoaWxkcmVuLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGQgPSB0aGlzLl9pbm5lci5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbi5jaGlsZHJlbltjaGlsZC5rZXldID0gY2hpbGQuc2NoZW1hLmRlc2NyaWJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5faW5uZXIuZGVwZW5kZW5jaWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgZGVzY3JpcHRpb24uZGVwZW5kZW5jaWVzID0gSG9lay5jbG9uZSh0aGlzLl9pbm5lci5kZXBlbmRlbmNpZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2lubmVyLnBhdHRlcm5zLmxlbmd0aCkge1xuICAgICAgICAgICAgZGVzY3JpcHRpb24ucGF0dGVybnMgPSBbXTtcblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9pbm5lci5wYXR0ZXJucy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhdHRlcm4gPSB0aGlzLl9pbm5lci5wYXR0ZXJuc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAocGF0dGVybi5yZWdleCkge1xuICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbi5wYXR0ZXJucy5wdXNoKHsgcmVnZXg6IHBhdHRlcm4ucmVnZXgudG9TdHJpbmcoKSwgcnVsZTogcGF0dGVybi5ydWxlLmRlc2NyaWJlKCkgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbi5wYXR0ZXJucy5wdXNoKHsgc2NoZW1hOiBwYXR0ZXJuLnNjaGVtYS5kZXNjcmliZSgpLCBydWxlOiBwYXR0ZXJuLnJ1bGUuZGVzY3JpYmUoKSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5faW5uZXIucmVuYW1lcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbi5yZW5hbWVzID0gSG9lay5jbG9uZSh0aGlzLl9pbm5lci5yZW5hbWVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkZXNjcmlwdGlvbjtcbiAgICB9XG5cbiAgICBhc3NlcnQocmVmLCBzY2hlbWEsIG1lc3NhZ2UpIHtcblxuICAgICAgICByZWYgPSBDYXN0LnJlZihyZWYpO1xuICAgICAgICBIb2VrLmFzc2VydChyZWYuaXNDb250ZXh0IHx8IHJlZi5kZXB0aCA+IDEsICdDYW5ub3QgdXNlIGFzc2VydGlvbnMgZm9yIHJvb3QgbGV2ZWwgcmVmZXJlbmNlcyAtIHVzZSBkaXJlY3Qga2V5IHJ1bGVzIGluc3RlYWQnKTtcbiAgICAgICAgbWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ3Bhc3MgdGhlIGFzc2VydGlvbiB0ZXN0JztcbiAgICAgICAgSG9lay5hc3NlcnQodHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnLCAnTWVzc2FnZSBtdXN0IGJlIGEgc3RyaW5nJyk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNjaGVtYSA9IENhc3Quc2NoZW1hKHRoaXMuX2N1cnJlbnRKb2ksIHNjaGVtYSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGNhc3RFcnIpIHtcbiAgICAgICAgICAgIGlmIChjYXN0RXJyLmhhc093blByb3BlcnR5KCdwYXRoJykpIHtcbiAgICAgICAgICAgICAgICBjYXN0RXJyLm1lc3NhZ2UgPSBgJHtjYXN0RXJyLm1lc3NhZ2V9KCR7Y2FzdEVyci5wYXRofSlgO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aHJvdyBjYXN0RXJyO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qga2V5ID0gcmVmLnBhdGhbcmVmLnBhdGgubGVuZ3RoIC0gMV07XG4gICAgICAgIGNvbnN0IHBhdGggPSByZWYucGF0aC5qb2luKCcuJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Rlc3QoJ2Fzc2VydCcsIHsgc2NoZW1hLCByZWYgfSwgZnVuY3Rpb24gKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucykge1xuXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBzY2hlbWEuX3ZhbGlkYXRlKHJlZih2YWx1ZSksIG51bGwsIG9wdGlvbnMsIHZhbHVlKTtcbiAgICAgICAgICAgIGlmICghcmVzdWx0LmVycm9ycykge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgbG9jYWxTdGF0ZSA9IG5ldyBTdGF0ZShrZXksIHJlZi5wYXRoLCBzdGF0ZS5wYXJlbnQsIHN0YXRlLnJlZmVyZW5jZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVFcnJvcignb2JqZWN0LmFzc2VydCcsIHsgcmVmOiBwYXRoLCBtZXNzYWdlIH0sIGxvY2FsU3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB0eXBlKGNvbnN0cnVjdG9yLCBuYW1lID0gY29uc3RydWN0b3IubmFtZSkge1xuXG4gICAgICAgIEhvZWsuYXNzZXJ0KHR5cGVvZiBjb25zdHJ1Y3RvciA9PT0gJ2Z1bmN0aW9uJywgJ3R5cGUgbXVzdCBiZSBhIGNvbnN0cnVjdG9yIGZ1bmN0aW9uJyk7XG4gICAgICAgIGNvbnN0IHR5cGVEYXRhID0ge1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGN0b3I6IGNvbnN0cnVjdG9yXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Rlc3QoJ3R5cGUnLCB0eXBlRGF0YSwgZnVuY3Rpb24gKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucykge1xuXG4gICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBjb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoJ29iamVjdC50eXBlJywgeyB0eXBlOiB0eXBlRGF0YS5uYW1lLCB2YWx1ZSB9LCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLnJlbmFtZURlZmF1bHRzID0ge1xuICAgIGFsaWFzOiBmYWxzZSwgICAgICAgICAgICAgICAgICAgLy8gS2VlcCBvbGQgdmFsdWUgaW4gcGxhY2VcbiAgICBtdWx0aXBsZTogZmFsc2UsICAgICAgICAgICAgICAgIC8vIEFsbG93IHJlbmFtaW5nIG11bHRpcGxlIGtleXMgaW50byB0aGUgc2FtZSB0YXJnZXRcbiAgICBvdmVycmlkZTogZmFsc2UgICAgICAgICAgICAgICAgIC8vIE92ZXJyaWRlcyBhbiBleGlzdGluZyBrZXlcbn07XG5cblxuaW50ZXJuYWxzLmdyb3VwQ2hpbGRyZW4gPSBmdW5jdGlvbiAoY2hpbGRyZW4pIHtcblxuICAgIGNoaWxkcmVuLnNvcnQoKTtcblxuICAgIGNvbnN0IGdyb3VwZWQgPSB7fTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgSG9lay5hc3NlcnQodHlwZW9mIGNoaWxkID09PSAnc3RyaW5nJywgJ2NoaWxkcmVuIG11c3QgYmUgc3RyaW5ncycpO1xuICAgICAgICBjb25zdCBncm91cCA9IGNoaWxkLnNwbGl0KCcuJylbMF07XG4gICAgICAgIGNvbnN0IGNoaWxkR3JvdXAgPSBncm91cGVkW2dyb3VwXSA9IChncm91cGVkW2dyb3VwXSB8fCBbXSk7XG4gICAgICAgIGNoaWxkR3JvdXAucHVzaChjaGlsZC5zdWJzdHJpbmcoZ3JvdXAubGVuZ3RoICsgMSkpO1xuICAgIH1cblxuICAgIHJldHVybiBncm91cGVkO1xufTtcblxuXG5pbnRlcm5hbHMua2V5c1RvTGFiZWxzID0gZnVuY3Rpb24gKHNjaGVtYSwga2V5cykge1xuXG4gICAgY29uc3QgY2hpbGRyZW4gPSBzY2hlbWEuX2lubmVyLmNoaWxkcmVuO1xuXG4gICAgaWYgKCFjaGlsZHJlbikge1xuICAgICAgICByZXR1cm4ga2V5cztcbiAgICB9XG5cbiAgICBjb25zdCBmaW5kTGFiZWwgPSBmdW5jdGlvbiAoa2V5KSB7XG5cbiAgICAgICAgY29uc3QgbWF0Y2hpbmdDaGlsZCA9IHNjaGVtYS5fY3VycmVudEpvaS5yZWFjaChzY2hlbWEsIGtleSk7XG4gICAgICAgIHJldHVybiBtYXRjaGluZ0NoaWxkID8gbWF0Y2hpbmdDaGlsZC5fZ2V0TGFiZWwoa2V5KSA6IGtleTtcbiAgICB9O1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoa2V5cykpIHtcbiAgICAgICAgcmV0dXJuIGtleXMubWFwKGZpbmRMYWJlbCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpbmRMYWJlbChrZXlzKTtcbn07XG5cblxuaW50ZXJuYWxzLndpdGggPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSwgcGVlcnMsIHBhcmVudCwgc3RhdGUsIG9wdGlvbnMpIHtcblxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBlZXJzLmxlbmd0aDsgKytpKSB7XG5cbiAgICAgICAgY29uc3QgcGVlciA9IHBlZXJzW2ldO1xuICAgICAgICBjb25zdCBrZXlzRXhpc3QgPSBIb2VrLnJlYWNoKHBhcmVudCwgcGVlciwgeyBmdW5jdGlvbnM6IHRydWUgfSk7XG4gICAgICAgIGlmIChrZXlzRXhpc3QgPT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVFcnJvcignb2JqZWN0LndpdGgnLCB7XG4gICAgICAgICAgICAgICAgbWFpbjoga2V5LFxuICAgICAgICAgICAgICAgIG1haW5XaXRoTGFiZWw6IGludGVybmFscy5rZXlzVG9MYWJlbHModGhpcywga2V5KSxcbiAgICAgICAgICAgICAgICBwZWVyLFxuICAgICAgICAgICAgICAgIHBlZXJXaXRoTGFiZWw6IGludGVybmFscy5rZXlzVG9MYWJlbHModGhpcywgcGVlcilcbiAgICAgICAgICAgIH0sIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLndpdGhvdXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSwgcGVlcnMsIHBhcmVudCwgc3RhdGUsIG9wdGlvbnMpIHtcblxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBlZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IHBlZXIgPSBwZWVyc1tpXTtcbiAgICAgICAgY29uc3Qga2V5c0V4aXN0ID0gSG9lay5yZWFjaChwYXJlbnQsIHBlZXIsIHsgZnVuY3Rpb25zOiB0cnVlIH0pO1xuICAgICAgICBpZiAoa2V5c0V4aXN0ICE9PSB1bmRlZmluZWQpIHtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoJ29iamVjdC53aXRob3V0Jywge1xuICAgICAgICAgICAgICAgIG1haW46IGtleSxcbiAgICAgICAgICAgICAgICBtYWluV2l0aExhYmVsOiBpbnRlcm5hbHMua2V5c1RvTGFiZWxzKHRoaXMsIGtleSksXG4gICAgICAgICAgICAgICAgcGVlcixcbiAgICAgICAgICAgICAgICBwZWVyV2l0aExhYmVsOiBpbnRlcm5hbHMua2V5c1RvTGFiZWxzKHRoaXMsIHBlZXIpXG4gICAgICAgICAgICB9LCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5cbmludGVybmFscy54b3IgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSwgcGVlcnMsIHBhcmVudCwgc3RhdGUsIG9wdGlvbnMpIHtcblxuICAgIGNvbnN0IHByZXNlbnQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBlZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IHBlZXIgPSBwZWVyc1tpXTtcbiAgICAgICAgY29uc3Qga2V5c0V4aXN0ID0gSG9lay5yZWFjaChwYXJlbnQsIHBlZXIsIHsgZnVuY3Rpb25zOiB0cnVlIH0pO1xuICAgICAgICBpZiAoa2V5c0V4aXN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHByZXNlbnQucHVzaChwZWVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwcmVzZW50Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgY29udGV4dCA9IHsgcGVlcnMsIHBlZXJzV2l0aExhYmVsczogaW50ZXJuYWxzLmtleXNUb0xhYmVscyh0aGlzLCBwZWVycykgfTtcblxuICAgIGlmIChwcmVzZW50Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVFcnJvcignb2JqZWN0Lm1pc3NpbmcnLCBjb250ZXh0LCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgY29udGV4dC5wcmVzZW50ID0gcHJlc2VudDtcbiAgICBjb250ZXh0LnByZXNlbnRXaXRoTGFiZWxzID0gaW50ZXJuYWxzLmtleXNUb0xhYmVscyh0aGlzLCBwcmVzZW50KTtcblxuICAgIHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKCdvYmplY3QueG9yJywgY29udGV4dCwgc3RhdGUsIG9wdGlvbnMpO1xufTtcblxuXG5pbnRlcm5hbHMub3hvciA9IGZ1bmN0aW9uIChrZXksIHZhbHVlLCBwZWVycywgcGFyZW50LCBzdGF0ZSwgb3B0aW9ucykge1xuXG4gICAgY29uc3QgcHJlc2VudCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGVlcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgcGVlciA9IHBlZXJzW2ldO1xuICAgICAgICBjb25zdCBrZXlzRXhpc3QgPSBIb2VrLnJlYWNoKHBhcmVudCwgcGVlciwgeyBmdW5jdGlvbnM6IHRydWUgfSk7XG4gICAgICAgIGlmIChrZXlzRXhpc3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcHJlc2VudC5wdXNoKHBlZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFwcmVzZW50Lmxlbmd0aCB8fFxuICAgICAgICBwcmVzZW50Lmxlbmd0aCA9PT0gMSkge1xuXG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBjb250ZXh0ID0geyBwZWVycywgcGVlcnNXaXRoTGFiZWxzOiBpbnRlcm5hbHMua2V5c1RvTGFiZWxzKHRoaXMsIHBlZXJzKSB9O1xuICAgIGNvbnRleHQucHJlc2VudCA9IHByZXNlbnQ7XG4gICAgY29udGV4dC5wcmVzZW50V2l0aExhYmVscyA9IGludGVybmFscy5rZXlzVG9MYWJlbHModGhpcywgcHJlc2VudCk7XG5cbiAgICByZXR1cm4gdGhpcy5jcmVhdGVFcnJvcignb2JqZWN0Lm94b3InLCBjb250ZXh0LCBzdGF0ZSwgb3B0aW9ucyk7XG59O1xuXG5cbmludGVybmFscy5vciA9IGZ1bmN0aW9uIChrZXksIHZhbHVlLCBwZWVycywgcGFyZW50LCBzdGF0ZSwgb3B0aW9ucykge1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwZWVycy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBwZWVyID0gcGVlcnNbaV07XG4gICAgICAgIGNvbnN0IGtleXNFeGlzdCA9IEhvZWsucmVhY2gocGFyZW50LCBwZWVyLCB7IGZ1bmN0aW9uczogdHJ1ZSB9KTtcbiAgICAgICAgaWYgKGtleXNFeGlzdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5jcmVhdGVFcnJvcignb2JqZWN0Lm1pc3NpbmcnLCB7XG4gICAgICAgIHBlZXJzLFxuICAgICAgICBwZWVyc1dpdGhMYWJlbHM6IGludGVybmFscy5rZXlzVG9MYWJlbHModGhpcywgcGVlcnMpXG4gICAgfSwgc3RhdGUsIG9wdGlvbnMpO1xufTtcblxuXG5pbnRlcm5hbHMuYW5kID0gZnVuY3Rpb24gKGtleSwgdmFsdWUsIHBlZXJzLCBwYXJlbnQsIHN0YXRlLCBvcHRpb25zKSB7XG5cbiAgICBjb25zdCBtaXNzaW5nID0gW107XG4gICAgY29uc3QgcHJlc2VudCA9IFtdO1xuICAgIGNvbnN0IGNvdW50ID0gcGVlcnMubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuICAgICAgICBjb25zdCBwZWVyID0gcGVlcnNbaV07XG4gICAgICAgIGNvbnN0IGtleXNFeGlzdCA9IEhvZWsucmVhY2gocGFyZW50LCBwZWVyLCB7IGZ1bmN0aW9uczogdHJ1ZSB9KTtcbiAgICAgICAgaWYgKGtleXNFeGlzdCA9PT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgICAgIG1pc3NpbmcucHVzaChwZWVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHByZXNlbnQucHVzaChwZWVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGFvbiA9IChtaXNzaW5nLmxlbmd0aCA9PT0gY291bnQgfHwgcHJlc2VudC5sZW5ndGggPT09IGNvdW50KTtcblxuICAgIGlmICghYW9uKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoJ29iamVjdC5hbmQnLCB7XG4gICAgICAgICAgICBwcmVzZW50LFxuICAgICAgICAgICAgcHJlc2VudFdpdGhMYWJlbHM6IGludGVybmFscy5rZXlzVG9MYWJlbHModGhpcywgcHJlc2VudCksXG4gICAgICAgICAgICBtaXNzaW5nLFxuICAgICAgICAgICAgbWlzc2luZ1dpdGhMYWJlbHM6IGludGVybmFscy5rZXlzVG9MYWJlbHModGhpcywgbWlzc2luZylcbiAgICAgICAgfSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLm5hbmQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSwgcGVlcnMsIHBhcmVudCwgc3RhdGUsIG9wdGlvbnMpIHtcblxuICAgIGNvbnN0IHByZXNlbnQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBlZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IHBlZXIgPSBwZWVyc1tpXTtcbiAgICAgICAgY29uc3Qga2V5c0V4aXN0ID0gSG9lay5yZWFjaChwYXJlbnQsIHBlZXIsIHsgZnVuY3Rpb25zOiB0cnVlIH0pO1xuICAgICAgICBpZiAoa2V5c0V4aXN0ICE9PSB1bmRlZmluZWQpIHtcblxuICAgICAgICAgICAgcHJlc2VudC5wdXNoKHBlZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgbWFpbiA9IHBlZXJzWzBdO1xuICAgIGNvbnN0IHZhbHVlcyA9IHBlZXJzLnNsaWNlKDEpO1xuICAgIGNvbnN0IGFsbFByZXNlbnQgPSAocHJlc2VudC5sZW5ndGggPT09IHBlZXJzLmxlbmd0aCk7XG4gICAgcmV0dXJuIGFsbFByZXNlbnQgPyB0aGlzLmNyZWF0ZUVycm9yKCdvYmplY3QubmFuZCcsIHtcbiAgICAgICAgbWFpbixcbiAgICAgICAgbWFpbldpdGhMYWJlbDogaW50ZXJuYWxzLmtleXNUb0xhYmVscyh0aGlzLCBtYWluKSxcbiAgICAgICAgcGVlcnM6IHZhbHVlcyxcbiAgICAgICAgcGVlcnNXaXRoTGFiZWxzOiBpbnRlcm5hbHMua2V5c1RvTGFiZWxzKHRoaXMsIHZhbHVlcylcbiAgICB9LCBzdGF0ZSwgb3B0aW9ucykgOiBudWxsO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBpbnRlcm5hbHMuT2JqZWN0KCk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKGtleSwgcGF0aCwgcGFyZW50LCByZWZlcmVuY2UpIHtcblxuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHRoaXMucmVmZXJlbmNlID0gcmVmZXJlbmNlO1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IE5ldCA9IHJlcXVpcmUoJ25ldCcpO1xuXG5jb25zdCBBZGRyZXNzID0gcmVxdWlyZSgnQGhhcGkvYWRkcmVzcycpO1xuY29uc3QgSG9layA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsnKTtcblxuY29uc3QgQW55ID0gcmVxdWlyZSgnLi4vYW55Jyk7XG5jb25zdCBSZWYgPSByZXF1aXJlKCcuLi8uLi9yZWYnKTtcbmNvbnN0IEpvaURhdGUgPSByZXF1aXJlKCcuLi9kYXRlJyk7XG5cbmNvbnN0IFVyaSA9IHJlcXVpcmUoJy4vdXJpJyk7XG5jb25zdCBJcCA9IHJlcXVpcmUoJy4vaXAnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7XG4gICAgdXJpUmVnZXg6IFVyaS5jcmVhdGVVcmlSZWdleCgpLFxuICAgIGlwUmVnZXg6IElwLmNyZWF0ZUlwUmVnZXgoWydpcHY0JywgJ2lwdjYnLCAnaXB2ZnV0dXJlJ10sICdvcHRpb25hbCcpLFxuICAgIGd1aWRCcmFja2V0czoge1xuICAgICAgICAneyc6ICd9JywgJ1snOiAnXScsICcoJzogJyknLCAnJzogJydcbiAgICB9LFxuICAgIGd1aWRWZXJzaW9uczoge1xuICAgICAgICB1dWlkdjE6ICcxJyxcbiAgICAgICAgdXVpZHYyOiAnMicsXG4gICAgICAgIHV1aWR2MzogJzMnLFxuICAgICAgICB1dWlkdjQ6ICc0JyxcbiAgICAgICAgdXVpZHY1OiAnNSdcbiAgICB9LFxuICAgIGNpZHJQcmVzZW5jZXM6IFsncmVxdWlyZWQnLCAnb3B0aW9uYWwnLCAnZm9yYmlkZGVuJ10sXG4gICAgbm9ybWFsaXphdGlvbkZvcm1zOiBbJ05GQycsICdORkQnLCAnTkZLQycsICdORktEJ11cbn07XG5cblxuaW50ZXJuYWxzLlN0cmluZyA9IGNsYXNzIGV4dGVuZHMgQW55IHtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuXG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX3R5cGUgPSAnc3RyaW5nJztcbiAgICAgICAgdGhpcy5faW52YWxpZHMuYWRkKCcnKTtcbiAgICB9XG5cbiAgICBfYmFzZSh2YWx1ZSwgc3RhdGUsIG9wdGlvbnMpIHtcblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgb3B0aW9ucy5jb252ZXJ0KSB7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9mbGFncy5ub3JtYWxpemUpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLm5vcm1hbGl6ZSh0aGlzLl9mbGFncy5ub3JtYWxpemUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5fZmxhZ3MuY2FzZSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gKHRoaXMuX2ZsYWdzLmNhc2UgPT09ICd1cHBlcicgPyB2YWx1ZS50b0xvY2FsZVVwcGVyQ2FzZSgpIDogdmFsdWUudG9Mb2NhbGVMb3dlckNhc2UoKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9mbGFncy50cmltKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50cmltKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9pbm5lci5yZXBsYWNlbWVudHMpIHtcblxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5faW5uZXIucmVwbGFjZW1lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcGxhY2VtZW50ID0gdGhpcy5faW5uZXIucmVwbGFjZW1lbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UocmVwbGFjZW1lbnQucGF0dGVybiwgcmVwbGFjZW1lbnQucmVwbGFjZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuX2ZsYWdzLnRydW5jYXRlKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl90ZXN0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXN0ID0gdGhpcy5fdGVzdHNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZXN0Lm5hbWUgPT09ICdtYXgnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDAsIHRlc3QuYXJnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5fZmxhZ3MuYnl0ZUFsaWduZWQgJiYgdmFsdWUubGVuZ3RoICUgMiAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gYDAke3ZhbHVlfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBlcnJvcnM6ICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSA/IG51bGwgOiB0aGlzLmNyZWF0ZUVycm9yKCdzdHJpbmcuYmFzZScsIHsgdmFsdWUgfSwgc3RhdGUsIG9wdGlvbnMpXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgaW5zZW5zaXRpdmUoKSB7XG5cbiAgICAgICAgaWYgKHRoaXMuX2ZsYWdzLmluc2Vuc2l0aXZlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgb2JqLl9mbGFncy5pbnNlbnNpdGl2ZSA9IHRydWU7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgY3JlZGl0Q2FyZCgpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5fdGVzdCgnY3JlZGl0Q2FyZCcsIHVuZGVmaW5lZCwgZnVuY3Rpb24gKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucykge1xuXG4gICAgICAgICAgICBsZXQgaSA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgIGxldCBzdW0gPSAwO1xuICAgICAgICAgICAgbGV0IG11bCA9IDE7XG5cbiAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGFyID0gdmFsdWUuY2hhckF0KGkpICogbXVsO1xuICAgICAgICAgICAgICAgIHN1bSA9IHN1bSArIChjaGFyIC0gKGNoYXIgPiA5KSAqIDkpO1xuICAgICAgICAgICAgICAgIG11bCA9IG11bCBeIDM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGNoZWNrID0gKHN1bSAlIDEwID09PSAwKSAmJiAoc3VtID4gMCk7XG4gICAgICAgICAgICByZXR1cm4gY2hlY2sgPyB2YWx1ZSA6IHRoaXMuY3JlYXRlRXJyb3IoJ3N0cmluZy5jcmVkaXRDYXJkJywgeyB2YWx1ZSB9LCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJlZ2V4KHBhdHRlcm4sIHBhdHRlcm5PcHRpb25zKSB7XG5cbiAgICAgICAgSG9lay5hc3NlcnQocGF0dGVybiBpbnN0YW5jZW9mIFJlZ0V4cCwgJ3BhdHRlcm4gbXVzdCBiZSBhIFJlZ0V4cCcpO1xuICAgICAgICBIb2VrLmFzc2VydCghcGF0dGVybi5mbGFncy5pbmNsdWRlcygnZycpICYmICFwYXR0ZXJuLmZsYWdzLmluY2x1ZGVzKCd5JyksICdwYXR0ZXJuIHNob3VsZCBub3QgdXNlIGdsb2JhbCBvciBzdGlja3kgbW9kZScpO1xuXG4gICAgICAgIGNvbnN0IHBhdHRlcm5PYmplY3QgPSB7IHBhdHRlcm4gfTtcblxuICAgICAgICBpZiAodHlwZW9mIHBhdHRlcm5PcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcGF0dGVybk9iamVjdC5uYW1lID0gcGF0dGVybk9wdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHBhdHRlcm5PcHRpb25zID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcGF0dGVybk9iamVjdC5pbnZlcnQgPSAhIXBhdHRlcm5PcHRpb25zLmludmVydDtcblxuICAgICAgICAgICAgaWYgKHBhdHRlcm5PcHRpb25zLm5hbWUpIHtcbiAgICAgICAgICAgICAgICBwYXR0ZXJuT2JqZWN0Lm5hbWUgPSBwYXR0ZXJuT3B0aW9ucy5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZXJyb3JDb2RlID0gWydzdHJpbmcucmVnZXgnLCBwYXR0ZXJuT2JqZWN0LmludmVydCA/ICcuaW52ZXJ0JyA6ICcnLCBwYXR0ZXJuT2JqZWN0Lm5hbWUgPyAnLm5hbWUnIDogJy5iYXNlJ10uam9pbignJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Rlc3QoJ3JlZ2V4JywgcGF0dGVybk9iamVjdCwgZnVuY3Rpb24gKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucykge1xuXG4gICAgICAgICAgICBjb25zdCBwYXR0ZXJuTWF0Y2ggPSBwYXR0ZXJuT2JqZWN0LnBhdHRlcm4udGVzdCh2YWx1ZSk7XG5cbiAgICAgICAgICAgIGlmIChwYXR0ZXJuTWF0Y2ggXiBwYXR0ZXJuT2JqZWN0LmludmVydCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoZXJyb3JDb2RlLCB7IG5hbWU6IHBhdHRlcm5PYmplY3QubmFtZSwgcGF0dGVybjogcGF0dGVybk9iamVjdC5wYXR0ZXJuLCB2YWx1ZSB9LCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGFscGhhbnVtKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLl90ZXN0KCdhbHBoYW51bScsIHVuZGVmaW5lZCwgZnVuY3Rpb24gKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucykge1xuXG4gICAgICAgICAgICBpZiAoL15bYS16QS1aMC05XSskLy50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoJ3N0cmluZy5hbHBoYW51bScsIHsgdmFsdWUgfSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB0b2tlbigpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5fdGVzdCgndG9rZW4nLCB1bmRlZmluZWQsIGZ1bmN0aW9uICh2YWx1ZSwgc3RhdGUsIG9wdGlvbnMpIHtcblxuICAgICAgICAgICAgaWYgKC9eXFx3KyQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVFcnJvcignc3RyaW5nLnRva2VuJywgeyB2YWx1ZSB9LCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGVtYWlsKHZhbGlkYXRpb25PcHRpb25zKSB7XG5cbiAgICAgICAgaWYgKHZhbGlkYXRpb25PcHRpb25zKSB7XG4gICAgICAgICAgICBIb2VrLmFzc2VydCh0eXBlb2YgdmFsaWRhdGlvbk9wdGlvbnMgPT09ICdvYmplY3QnLCAnZW1haWwgb3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdCcpO1xuXG4gICAgICAgICAgICAvLyBNaWdyYXRpb24gdmFsaWRhdGlvbiBmb3IgdW5zdXBwb3J0ZWQgb3B0aW9uc1xuXG4gICAgICAgICAgICBIb2VrLmFzc2VydCh2YWxpZGF0aW9uT3B0aW9ucy5jaGVja0ROUyA9PT0gdW5kZWZpbmVkLCAnY2hlY2tETlMgb3B0aW9uIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgICAgIEhvZWsuYXNzZXJ0KHZhbGlkYXRpb25PcHRpb25zLmVycm9yTGV2ZWwgPT09IHVuZGVmaW5lZCwgJ2Vycm9yTGV2ZWwgb3B0aW9uIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgICAgIEhvZWsuYXNzZXJ0KHZhbGlkYXRpb25PcHRpb25zLm1pbkRvbWFpbkF0b21zID09PSB1bmRlZmluZWQsICdtaW5Eb21haW5BdG9tcyBvcHRpb24gaXMgbm90IHN1cHBvcnRlZCwgdXNlIG1pbkRvbWFpblNlZ21lbnRzIGluc3RlYWQnKTtcbiAgICAgICAgICAgIEhvZWsuYXNzZXJ0KHZhbGlkYXRpb25PcHRpb25zLnRsZEJsYWNrbGlzdCA9PT0gdW5kZWZpbmVkLCAndGxkQmxhY2tsaXN0IG9wdGlvbiBpcyBub3Qgc3VwcG9ydGVkLCB1c2UgdGxkcy5kZW55IGluc3RlYWQnKTtcbiAgICAgICAgICAgIEhvZWsuYXNzZXJ0KHZhbGlkYXRpb25PcHRpb25zLnRsZFdoaXRlbGlzdCA9PT0gdW5kZWZpbmVkLCAndGxkV2hpdGVsaXN0IG9wdGlvbiBpcyBub3Qgc3VwcG9ydGVkLCB1c2UgdGxkcy5hbGxvdyBpbnN0ZWFkJyk7XG5cbiAgICAgICAgICAgIC8vIFZhbGlkYXRlIG9wdGlvbnNcblxuICAgICAgICAgICAgaWYgKHZhbGlkYXRpb25PcHRpb25zLnRsZHMgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgdmFsaWRhdGlvbk9wdGlvbnMudGxkcyA9PT0gJ29iamVjdCcpIHtcblxuICAgICAgICAgICAgICAgIEhvZWsuYXNzZXJ0KHZhbGlkYXRpb25PcHRpb25zLnRsZHMuYWxsb3cgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uT3B0aW9ucy50bGRzLmFsbG93ID09PSBmYWxzZSB8fFxuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uT3B0aW9ucy50bGRzLmFsbG93ID09PSB0cnVlIHx8XG4gICAgICAgICAgICAgICAgICAgIEFycmF5LmlzQXJyYXkodmFsaWRhdGlvbk9wdGlvbnMudGxkcy5hbGxvdykgfHxcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbk9wdGlvbnMudGxkcy5hbGxvdyBpbnN0YW5jZW9mIFNldCwgJ3RsZHMuYWxsb3cgbXVzdCBiZSBhbiBhcnJheSwgU2V0LCBvciBib29sZWFuJyk7XG5cbiAgICAgICAgICAgICAgICBIb2VrLmFzc2VydCh2YWxpZGF0aW9uT3B0aW9ucy50bGRzLmRlbnkgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAgICAgICBBcnJheS5pc0FycmF5KHZhbGlkYXRpb25PcHRpb25zLnRsZHMuZGVueSkgfHxcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbk9wdGlvbnMudGxkcy5kZW55IGluc3RhbmNlb2YgU2V0LCAndGxkcy5kZW55IG11c3QgYmUgYW4gYXJyYXkgb3IgU2V0Jyk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBub3JtYWxpemVUYWJsZSA9ICh0YWJsZSkgPT4ge1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWJsZSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgdGFibGUgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFibGUgaW5zdGFuY2VvZiBTZXQpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhYmxlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTZXQodGFibGUpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICB2YWxpZGF0aW9uT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIHZhbGlkYXRpb25PcHRpb25zKTsgICAgICAgLy8gU2hhbGxvdyBjbG9uZWRcbiAgICAgICAgICAgICAgICB2YWxpZGF0aW9uT3B0aW9ucy50bGRzID0ge1xuICAgICAgICAgICAgICAgICAgICBhbGxvdzogbm9ybWFsaXplVGFibGUodmFsaWRhdGlvbk9wdGlvbnMudGxkcy5hbGxvdyksXG4gICAgICAgICAgICAgICAgICAgIGRlbnk6IG5vcm1hbGl6ZVRhYmxlKHZhbGlkYXRpb25PcHRpb25zLnRsZHMuZGVueSlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBIb2VrLmFzc2VydCh2YWxpZGF0aW9uT3B0aW9ucy5taW5Eb21haW5TZWdtZW50cyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgICAgTnVtYmVyLmlzU2FmZUludGVnZXIodmFsaWRhdGlvbk9wdGlvbnMubWluRG9tYWluU2VnbWVudHMpICYmIHZhbGlkYXRpb25PcHRpb25zLm1pbkRvbWFpblNlZ21lbnRzID4gMCwgJ21pbkRvbWFpblNlZ21lbnRzIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fdGVzdCgnZW1haWwnLCB2YWxpZGF0aW9uT3B0aW9ucywgZnVuY3Rpb24gKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucykge1xuXG4gICAgICAgICAgICBpZiAoQWRkcmVzcy5lbWFpbC5pc1ZhbGlkKHZhbHVlLCB2YWxpZGF0aW9uT3B0aW9ucykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKCdzdHJpbmcuZW1haWwnLCB7IHZhbHVlIH0sIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgaXAoaXBPcHRpb25zID0ge30pIHtcblxuICAgICAgICBsZXQgcmVnZXggPSBpbnRlcm5hbHMuaXBSZWdleDtcbiAgICAgICAgSG9lay5hc3NlcnQodHlwZW9mIGlwT3B0aW9ucyA9PT0gJ29iamVjdCcsICdvcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0Jyk7XG5cbiAgICAgICAgaWYgKGlwT3B0aW9ucy5jaWRyKSB7XG4gICAgICAgICAgICBIb2VrLmFzc2VydCh0eXBlb2YgaXBPcHRpb25zLmNpZHIgPT09ICdzdHJpbmcnLCAnY2lkciBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgICAgICAgICBpcE9wdGlvbnMuY2lkciA9IGlwT3B0aW9ucy5jaWRyLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgICAgIEhvZWsuYXNzZXJ0KEhvZWsuY29udGFpbihpbnRlcm5hbHMuY2lkclByZXNlbmNlcywgaXBPcHRpb25zLmNpZHIpLCAnY2lkciBtdXN0IGJlIG9uZSBvZiAnICsgaW50ZXJuYWxzLmNpZHJQcmVzZW5jZXMuam9pbignLCAnKSk7XG5cbiAgICAgICAgICAgIC8vIElmIHdlIG9ubHkgcmVjZWl2ZWQgYSBgY2lkcmAgc2V0dGluZywgY3JlYXRlIGEgcmVnZXggZm9yIGl0LiBCdXQgd2UgZG9uJ3QgbmVlZCB0byBjcmVhdGUgb25lIGlmIGBjaWRyYCBpcyBcIm9wdGlvbmFsXCIgc2luY2UgdGhhdCBpcyB0aGUgZGVmYXVsdFxuICAgICAgICAgICAgaWYgKCFpcE9wdGlvbnMudmVyc2lvbiAmJiBpcE9wdGlvbnMuY2lkciAhPT0gJ29wdGlvbmFsJykge1xuICAgICAgICAgICAgICAgIHJlZ2V4ID0gSXAuY3JlYXRlSXBSZWdleChbJ2lwdjQnLCAnaXB2NicsICdpcHZmdXR1cmUnXSwgaXBPcHRpb25zLmNpZHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAvLyBTZXQgb3VyIGRlZmF1bHQgY2lkciBzdHJhdGVneVxuICAgICAgICAgICAgaXBPcHRpb25zLmNpZHIgPSAnb3B0aW9uYWwnO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHZlcnNpb25zO1xuICAgICAgICBpZiAoaXBPcHRpb25zLnZlcnNpb24pIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShpcE9wdGlvbnMudmVyc2lvbikpIHtcbiAgICAgICAgICAgICAgICBpcE9wdGlvbnMudmVyc2lvbiA9IFtpcE9wdGlvbnMudmVyc2lvbl07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIEhvZWsuYXNzZXJ0KGlwT3B0aW9ucy52ZXJzaW9uLmxlbmd0aCA+PSAxLCAndmVyc2lvbiBtdXN0IGhhdmUgYXQgbGVhc3QgMSB2ZXJzaW9uIHNwZWNpZmllZCcpO1xuXG4gICAgICAgICAgICB2ZXJzaW9ucyA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpcE9wdGlvbnMudmVyc2lvbi5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGxldCB2ZXJzaW9uID0gaXBPcHRpb25zLnZlcnNpb25baV07XG4gICAgICAgICAgICAgICAgSG9lay5hc3NlcnQodHlwZW9mIHZlcnNpb24gPT09ICdzdHJpbmcnLCAndmVyc2lvbiBhdCBwb3NpdGlvbiAnICsgaSArICcgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgICAgICAgICAgICAgIHZlcnNpb24gPSB2ZXJzaW9uLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgSG9lay5hc3NlcnQoSXAudmVyc2lvbnNbdmVyc2lvbl0sICd2ZXJzaW9uIGF0IHBvc2l0aW9uICcgKyBpICsgJyBtdXN0IGJlIG9uZSBvZiAnICsgT2JqZWN0LmtleXMoSXAudmVyc2lvbnMpLmpvaW4oJywgJykpO1xuICAgICAgICAgICAgICAgIHZlcnNpb25zLnB1c2godmVyc2lvbik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBoYXZlIGEgc2V0IG9mIHZlcnNpb25zXG4gICAgICAgICAgICB2ZXJzaW9ucyA9IEFycmF5LmZyb20obmV3IFNldCh2ZXJzaW9ucykpO1xuXG4gICAgICAgICAgICByZWdleCA9IElwLmNyZWF0ZUlwUmVnZXgodmVyc2lvbnMsIGlwT3B0aW9ucy5jaWRyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl90ZXN0KCdpcCcsIGlwT3B0aW9ucywgZnVuY3Rpb24gKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucykge1xuXG4gICAgICAgICAgICBpZiAocmVnZXgudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh2ZXJzaW9ucykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKCdzdHJpbmcuaXBWZXJzaW9uJywgeyB2YWx1ZSwgY2lkcjogaXBPcHRpb25zLmNpZHIsIHZlcnNpb246IHZlcnNpb25zIH0sIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoJ3N0cmluZy5pcCcsIHsgdmFsdWUsIGNpZHI6IGlwT3B0aW9ucy5jaWRyIH0sIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdXJpKHVyaU9wdGlvbnMpIHtcblxuICAgICAgICBsZXQgY3VzdG9tU2NoZW1lID0gJyc7XG4gICAgICAgIGxldCBhbGxvd1JlbGF0aXZlID0gZmFsc2U7XG4gICAgICAgIGxldCByZWxhdGl2ZU9ubHkgPSBmYWxzZTtcbiAgICAgICAgbGV0IGFsbG93UXVlcnlTcXVhcmVCcmFja2V0cyA9IGZhbHNlO1xuICAgICAgICBsZXQgcmVnZXggPSBpbnRlcm5hbHMudXJpUmVnZXg7XG5cbiAgICAgICAgaWYgKHVyaU9wdGlvbnMpIHtcbiAgICAgICAgICAgIEhvZWsuYXNzZXJ0KHR5cGVvZiB1cmlPcHRpb25zID09PSAnb2JqZWN0JywgJ29wdGlvbnMgbXVzdCBiZSBhbiBvYmplY3QnKTtcblxuICAgICAgICAgICAgY29uc3QgdW5rbm93bk9wdGlvbnMgPSBPYmplY3Qua2V5cyh1cmlPcHRpb25zKS5maWx0ZXIoKGtleSkgPT4gIVsnc2NoZW1lJywgJ2FsbG93UmVsYXRpdmUnLCAncmVsYXRpdmVPbmx5JywgJ2FsbG93UXVlcnlTcXVhcmVCcmFja2V0cyddLmluY2x1ZGVzKGtleSkpO1xuICAgICAgICAgICAgSG9lay5hc3NlcnQodW5rbm93bk9wdGlvbnMubGVuZ3RoID09PSAwLCBgb3B0aW9ucyBjb250YWluIHVua25vd24ga2V5czogJHt1bmtub3duT3B0aW9uc31gKTtcblxuICAgICAgICAgICAgaWYgKHVyaU9wdGlvbnMuc2NoZW1lKSB7XG4gICAgICAgICAgICAgICAgSG9lay5hc3NlcnQodXJpT3B0aW9ucy5zY2hlbWUgaW5zdGFuY2VvZiBSZWdFeHAgfHwgdHlwZW9mIHVyaU9wdGlvbnMuc2NoZW1lID09PSAnc3RyaW5nJyB8fCBBcnJheS5pc0FycmF5KHVyaU9wdGlvbnMuc2NoZW1lKSwgJ3NjaGVtZSBtdXN0IGJlIGEgUmVnRXhwLCBTdHJpbmcsIG9yIEFycmF5Jyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodXJpT3B0aW9ucy5zY2hlbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHVyaU9wdGlvbnMuc2NoZW1lID0gW3VyaU9wdGlvbnMuc2NoZW1lXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBIb2VrLmFzc2VydCh1cmlPcHRpb25zLnNjaGVtZS5sZW5ndGggPj0gMSwgJ3NjaGVtZSBtdXN0IGhhdmUgYXQgbGVhc3QgMSBzY2hlbWUgc3BlY2lmaWVkJyk7XG5cbiAgICAgICAgICAgICAgICAvLyBGbGF0dGVuIHRoZSBhcnJheSBpbnRvIGEgc3RyaW5nIHRvIGJlIHVzZWQgdG8gbWF0Y2ggdGhlIHNjaGVtZXMuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB1cmlPcHRpb25zLnNjaGVtZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzY2hlbWUgPSB1cmlPcHRpb25zLnNjaGVtZVtpXTtcbiAgICAgICAgICAgICAgICAgICAgSG9lay5hc3NlcnQoc2NoZW1lIGluc3RhbmNlb2YgUmVnRXhwIHx8IHR5cGVvZiBzY2hlbWUgPT09ICdzdHJpbmcnLCAnc2NoZW1lIGF0IHBvc2l0aW9uICcgKyBpICsgJyBtdXN0IGJlIGEgUmVnRXhwIG9yIFN0cmluZycpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCBPUiBzZXBhcmF0b3JzIGlmIGEgdmFsdWUgYWxyZWFkeSBleGlzdHNcbiAgICAgICAgICAgICAgICAgICAgY3VzdG9tU2NoZW1lID0gY3VzdG9tU2NoZW1lICsgKGN1c3RvbVNjaGVtZSA/ICd8JyA6ICcnKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBzb21lb25lIHdhbnRzIHRvIG1hdGNoIEhUVFAgb3IgSFRUUFMgZm9yIGV4YW1wbGUgdGhlbiB3ZSBuZWVkIHRvIHN1cHBvcnQgYm90aCBSZWdFeHAgYW5kIFN0cmluZyBzbyB3ZSBkb24ndCBlc2NhcGUgdGhlaXIgcGF0dGVybiB1bmtub3dpbmdseS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjaGVtZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VzdG9tU2NoZW1lID0gY3VzdG9tU2NoZW1lICsgc2NoZW1lLnNvdXJjZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEhvZWsuYXNzZXJ0KC9bYS16QS1aXVthLXpBLVowLTkrLVxcLl0qLy50ZXN0KHNjaGVtZSksICdzY2hlbWUgYXQgcG9zaXRpb24gJyArIGkgKyAnIG11c3QgYmUgYSB2YWxpZCBzY2hlbWUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1c3RvbVNjaGVtZSA9IGN1c3RvbVNjaGVtZSArIEhvZWsuZXNjYXBlUmVnZXgoc2NoZW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHVyaU9wdGlvbnMuYWxsb3dSZWxhdGl2ZSkge1xuICAgICAgICAgICAgICAgIGFsbG93UmVsYXRpdmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodXJpT3B0aW9ucy5yZWxhdGl2ZU9ubHkpIHtcbiAgICAgICAgICAgICAgICByZWxhdGl2ZU9ubHkgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodXJpT3B0aW9ucy5hbGxvd1F1ZXJ5U3F1YXJlQnJhY2tldHMpIHtcbiAgICAgICAgICAgICAgICBhbGxvd1F1ZXJ5U3F1YXJlQnJhY2tldHMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGN1c3RvbVNjaGVtZSB8fCBhbGxvd1JlbGF0aXZlIHx8IHJlbGF0aXZlT25seSB8fCBhbGxvd1F1ZXJ5U3F1YXJlQnJhY2tldHMpIHtcbiAgICAgICAgICAgIHJlZ2V4ID0gVXJpLmNyZWF0ZVVyaVJlZ2V4KGN1c3RvbVNjaGVtZSwgYWxsb3dSZWxhdGl2ZSwgcmVsYXRpdmVPbmx5LCBhbGxvd1F1ZXJ5U3F1YXJlQnJhY2tldHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Rlc3QoJ3VyaScsIHVyaU9wdGlvbnMsIGZ1bmN0aW9uICh2YWx1ZSwgc3RhdGUsIG9wdGlvbnMpIHtcblxuICAgICAgICAgICAgaWYgKHJlZ2V4LnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocmVsYXRpdmVPbmx5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoJ3N0cmluZy51cmlSZWxhdGl2ZU9ubHknLCB7IHZhbHVlIH0sIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGN1c3RvbVNjaGVtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKCdzdHJpbmcudXJpQ3VzdG9tU2NoZW1lJywgeyBzY2hlbWU6IGN1c3RvbVNjaGVtZSwgdmFsdWUgfSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVFcnJvcignc3RyaW5nLnVyaScsIHsgdmFsdWUgfSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBpc29EYXRlKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLl90ZXN0KCdpc29EYXRlJywgdW5kZWZpbmVkLCBmdW5jdGlvbiAodmFsdWUsIHN0YXRlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgICAgIGlmIChKb2lEYXRlLl9pc0lzb0RhdGUodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zLmNvbnZlcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IGQgPSBuZXcgRGF0ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFpc05hTihkLmdldFRpbWUoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQudG9JU09TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKCdzdHJpbmcuaXNvRGF0ZScsIHsgdmFsdWUgfSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBndWlkKGd1aWRPcHRpb25zKSB7XG5cbiAgICAgICAgbGV0IHZlcnNpb25OdW1iZXJzID0gJyc7XG5cbiAgICAgICAgaWYgKGd1aWRPcHRpb25zICYmIGd1aWRPcHRpb25zLnZlcnNpb24pIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShndWlkT3B0aW9ucy52ZXJzaW9uKSkge1xuICAgICAgICAgICAgICAgIGd1aWRPcHRpb25zLnZlcnNpb24gPSBbZ3VpZE9wdGlvbnMudmVyc2lvbl07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIEhvZWsuYXNzZXJ0KGd1aWRPcHRpb25zLnZlcnNpb24ubGVuZ3RoID49IDEsICd2ZXJzaW9uIG11c3QgaGF2ZSBhdCBsZWFzdCAxIHZhbGlkIHZlcnNpb24gc3BlY2lmaWVkJyk7XG4gICAgICAgICAgICBjb25zdCB2ZXJzaW9ucyA9IG5ldyBTZXQoKTtcblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBndWlkT3B0aW9ucy52ZXJzaW9uLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgbGV0IHZlcnNpb24gPSBndWlkT3B0aW9ucy52ZXJzaW9uW2ldO1xuICAgICAgICAgICAgICAgIEhvZWsuYXNzZXJ0KHR5cGVvZiB2ZXJzaW9uID09PSAnc3RyaW5nJywgJ3ZlcnNpb24gYXQgcG9zaXRpb24gJyArIGkgKyAnIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICAgICAgICAgICAgICB2ZXJzaW9uID0gdmVyc2lvbi50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZlcnNpb25OdW1iZXIgPSBpbnRlcm5hbHMuZ3VpZFZlcnNpb25zW3ZlcnNpb25dO1xuICAgICAgICAgICAgICAgIEhvZWsuYXNzZXJ0KHZlcnNpb25OdW1iZXIsICd2ZXJzaW9uIGF0IHBvc2l0aW9uICcgKyBpICsgJyBtdXN0IGJlIG9uZSBvZiAnICsgT2JqZWN0LmtleXMoaW50ZXJuYWxzLmd1aWRWZXJzaW9ucykuam9pbignLCAnKSk7XG4gICAgICAgICAgICAgICAgSG9lay5hc3NlcnQoISh2ZXJzaW9ucy5oYXModmVyc2lvbk51bWJlcikpLCAndmVyc2lvbiBhdCBwb3NpdGlvbiAnICsgaSArICcgbXVzdCBub3QgYmUgYSBkdXBsaWNhdGUuJyk7XG5cbiAgICAgICAgICAgICAgICB2ZXJzaW9uTnVtYmVycyArPSB2ZXJzaW9uTnVtYmVyO1xuICAgICAgICAgICAgICAgIHZlcnNpb25zLmFkZCh2ZXJzaW9uTnVtYmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGd1aWRSZWdleCA9IG5ldyBSZWdFeHAoYF4oW1xcXFxbe1xcXFwoXT8pWzAtOUEtRl17OH0oWzotXT8pWzAtOUEtRl17NH1cXFxcMj9bJHt2ZXJzaW9uTnVtYmVycyB8fCAnMC05QS1GJ31dWzAtOUEtRl17M31cXFxcMj9bJHt2ZXJzaW9uTnVtYmVycyA/ICc4OUFCJyA6ICcwLTlBLUYnfV1bMC05QS1GXXszfVxcXFwyP1swLTlBLUZdezEyfShbXFxcXF19XFxcXCldPykkYCwgJ2knKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fdGVzdCgnZ3VpZCcsIGd1aWRPcHRpb25zLCBmdW5jdGlvbiAodmFsdWUsIHN0YXRlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdHMgPSBndWlkUmVnZXguZXhlYyh2YWx1ZSk7XG5cbiAgICAgICAgICAgIGlmICghcmVzdWx0cykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKCdzdHJpbmcuZ3VpZCcsIHsgdmFsdWUgfSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBNYXRjaGluZyBicmFjZXNcbiAgICAgICAgICAgIGlmIChpbnRlcm5hbHMuZ3VpZEJyYWNrZXRzW3Jlc3VsdHNbMV1dICE9PSByZXN1bHRzW3Jlc3VsdHMubGVuZ3RoIC0gMV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVFcnJvcignc3RyaW5nLmd1aWQnLCB7IHZhbHVlIH0sIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBoZXgoaGV4T3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgSG9lay5hc3NlcnQodHlwZW9mIGhleE9wdGlvbnMgPT09ICdvYmplY3QnLCAnaGV4IG9wdGlvbnMgbXVzdCBiZSBhbiBvYmplY3QnKTtcbiAgICAgICAgSG9lay5hc3NlcnQodHlwZW9mIGhleE9wdGlvbnMuYnl0ZUFsaWduZWQgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBoZXhPcHRpb25zLmJ5dGVBbGlnbmVkID09PSAnYm9vbGVhbicsXG4gICAgICAgICAgICAnYnl0ZUFsaWduZWQgbXVzdCBiZSBib29sZWFuJyk7XG5cbiAgICAgICAgY29uc3QgYnl0ZUFsaWduZWQgPSBoZXhPcHRpb25zLmJ5dGVBbGlnbmVkID09PSB0cnVlO1xuICAgICAgICBjb25zdCByZWdleCA9IC9eW2EtZjAtOV0rJC9pO1xuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuX3Rlc3QoJ2hleCcsIHJlZ2V4LCBmdW5jdGlvbiAodmFsdWUsIHN0YXRlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgICAgIGlmIChyZWdleC50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGlmIChieXRlQWxpZ25lZCAmJiB2YWx1ZS5sZW5ndGggJSAyICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKCdzdHJpbmcuaGV4QWxpZ24nLCB7IHZhbHVlIH0sIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKCdzdHJpbmcuaGV4JywgeyB2YWx1ZSB9LCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChieXRlQWxpZ25lZCkge1xuICAgICAgICAgICAgb2JqLl9mbGFncy5ieXRlQWxpZ25lZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIGJhc2U2NChiYXNlNjRPcHRpb25zID0ge30pIHtcblxuICAgICAgICAvLyBWYWxpZGF0aW9uLlxuICAgICAgICBIb2VrLmFzc2VydCh0eXBlb2YgYmFzZTY0T3B0aW9ucyA9PT0gJ29iamVjdCcsICdiYXNlNjQgb3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICAgICAgICBIb2VrLmFzc2VydCh0eXBlb2YgYmFzZTY0T3B0aW9ucy5wYWRkaW5nUmVxdWlyZWQgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBiYXNlNjRPcHRpb25zLnBhZGRpbmdSZXF1aXJlZCA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgICAgICAgJ3BhZGRpbmdSZXF1aXJlZCBtdXN0IGJlIGJvb2xlYW4nKTtcblxuICAgICAgICAvLyBEZXRlcm1pbmUgaWYgcGFkZGluZyBpcyByZXF1aXJlZC5cbiAgICAgICAgY29uc3QgcGFkZGluZ1JlcXVpcmVkID0gYmFzZTY0T3B0aW9ucy5wYWRkaW5nUmVxdWlyZWQgPT09IGZhbHNlID9cbiAgICAgICAgICAgIGJhc2U2NE9wdGlvbnMucGFkZGluZ1JlcXVpcmVkXG4gICAgICAgICAgICA6IGJhc2U2NE9wdGlvbnMucGFkZGluZ1JlcXVpcmVkIHx8IHRydWU7XG5cbiAgICAgICAgLy8gU2V0IHZhbGlkYXRpb24gYmFzZWQgb24gcHJlZmVyZW5jZS5cbiAgICAgICAgY29uc3QgcmVnZXggPSBwYWRkaW5nUmVxdWlyZWQgP1xuICAgICAgICAgICAgLy8gUGFkZGluZyBpcyByZXF1aXJlZC5cbiAgICAgICAgICAgIC9eKD86W0EtWmEtejAtOStcXC9dezJ9W0EtWmEtejAtOStcXC9dezJ9KSooPzpbQS1aYS16MC05K1xcL117Mn09PXxbQS1aYS16MC05K1xcL117M309KT8kL1xuICAgICAgICAgICAgLy8gUGFkZGluZyBpcyBvcHRpb25hbC5cbiAgICAgICAgICAgIDogL14oPzpbQS1aYS16MC05K1xcL117Mn1bQS1aYS16MC05K1xcL117Mn0pKig/OltBLVphLXowLTkrXFwvXXsyfSg9PSk/fFtBLVphLXowLTkrXFwvXXszfT0/KT8kLztcblxuICAgICAgICByZXR1cm4gdGhpcy5fdGVzdCgnYmFzZTY0JywgcmVnZXgsIGZ1bmN0aW9uICh2YWx1ZSwgc3RhdGUsIG9wdGlvbnMpIHtcblxuICAgICAgICAgICAgaWYgKHJlZ2V4LnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVFcnJvcignc3RyaW5nLmJhc2U2NCcsIHsgdmFsdWUgfSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBkYXRhVXJpKGRhdGFVcmlPcHRpb25zID0ge30pIHtcblxuICAgICAgICBjb25zdCByZWdleCA9IC9eZGF0YTpbXFx3Ky4tXStcXC9bXFx3Ky4tXSs7KChjaGFyc2V0PVtcXHctXSt8YmFzZTY0KSwpPyguKikkLztcblxuICAgICAgICAvLyBEZXRlcm1pbmUgaWYgcGFkZGluZyBpcyByZXF1aXJlZC5cbiAgICAgICAgY29uc3QgcGFkZGluZ1JlcXVpcmVkID0gZGF0YVVyaU9wdGlvbnMucGFkZGluZ1JlcXVpcmVkID09PSBmYWxzZSA/XG4gICAgICAgICAgICBkYXRhVXJpT3B0aW9ucy5wYWRkaW5nUmVxdWlyZWRcbiAgICAgICAgICAgIDogZGF0YVVyaU9wdGlvbnMucGFkZGluZ1JlcXVpcmVkIHx8IHRydWU7XG5cbiAgICAgICAgY29uc3QgYmFzZTY0cmVnZXggPSBwYWRkaW5nUmVxdWlyZWQgP1xuICAgICAgICAgICAgL14oPzpbQS1aYS16MC05K1xcL117NH0pKig/OltBLVphLXowLTkrXFwvXXsyfT09fFtBLVphLXowLTkrXFwvXXszfT0pPyQvXG4gICAgICAgICAgICA6IC9eKD86W0EtWmEtejAtOStcXC9dezR9KSooPzpbQS1aYS16MC05K1xcL117Mn0oPT0pP3xbQS1aYS16MC05K1xcL117M309Pyk/JC87XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Rlc3QoJ2RhdGFVcmknLCByZWdleCwgZnVuY3Rpb24gKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucykge1xuXG4gICAgICAgICAgICBjb25zdCBtYXRjaGVzID0gdmFsdWUubWF0Y2gocmVnZXgpO1xuXG4gICAgICAgICAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICAgICAgICAgIGlmICghbWF0Y2hlc1syXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoZXNbMl0gIT09ICdiYXNlNjQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoYmFzZTY0cmVnZXgudGVzdChtYXRjaGVzWzNdKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVFcnJvcignc3RyaW5nLmRhdGFVcmknLCB7IHZhbHVlIH0sIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgaG9zdG5hbWUoKSB7XG5cbiAgICAgICAgY29uc3QgcmVnZXggPSAvXigoW2EtekEtWjAtOV18W2EtekEtWjAtOV1bYS16QS1aMC05XFwtXSpbYS16QS1aMC05XSlcXC4pKihbQS1aYS16MC05XXxbQS1aYS16MC05XVtBLVphLXowLTlcXC1dKltBLVphLXowLTldKSQvO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl90ZXN0KCdob3N0bmFtZScsIHVuZGVmaW5lZCwgZnVuY3Rpb24gKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucykge1xuXG4gICAgICAgICAgICBpZiAoKHZhbHVlLmxlbmd0aCA8PSAyNTUgJiYgcmVnZXgudGVzdCh2YWx1ZSkpIHx8XG4gICAgICAgICAgICAgICAgTmV0LmlzSVB2Nih2YWx1ZSkpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoJ3N0cmluZy5ob3N0bmFtZScsIHsgdmFsdWUgfSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBub3JtYWxpemUoZm9ybSA9ICdORkMnKSB7XG5cbiAgICAgICAgSG9lay5hc3NlcnQoSG9lay5jb250YWluKGludGVybmFscy5ub3JtYWxpemF0aW9uRm9ybXMsIGZvcm0pLCAnbm9ybWFsaXphdGlvbiBmb3JtIG11c3QgYmUgb25lIG9mICcgKyBpbnRlcm5hbHMubm9ybWFsaXphdGlvbkZvcm1zLmpvaW4oJywgJykpO1xuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuX3Rlc3QoJ25vcm1hbGl6ZScsIGZvcm0sIGZ1bmN0aW9uICh2YWx1ZSwgc3RhdGUsIG9wdGlvbnMpIHtcblxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuY29udmVydCB8fFxuICAgICAgICAgICAgICAgIHZhbHVlID09PSB2YWx1ZS5ub3JtYWxpemUoZm9ybSkpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoJ3N0cmluZy5ub3JtYWxpemUnLCB7IHZhbHVlLCBmb3JtIH0sIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgb2JqLl9mbGFncy5ub3JtYWxpemUgPSBmb3JtO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIGxvd2VyY2FzZSgpIHtcblxuICAgICAgICBjb25zdCBvYmogPSB0aGlzLl90ZXN0KCdsb3dlcmNhc2UnLCB1bmRlZmluZWQsIGZ1bmN0aW9uICh2YWx1ZSwgc3RhdGUsIG9wdGlvbnMpIHtcblxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuY29udmVydCB8fFxuICAgICAgICAgICAgICAgIHZhbHVlID09PSB2YWx1ZS50b0xvY2FsZUxvd2VyQ2FzZSgpKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKCdzdHJpbmcubG93ZXJjYXNlJywgeyB2YWx1ZSB9LCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG9iai5fZmxhZ3MuY2FzZSA9ICdsb3dlcic7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgdXBwZXJjYXNlKCkge1xuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuX3Rlc3QoJ3VwcGVyY2FzZScsIHVuZGVmaW5lZCwgZnVuY3Rpb24gKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucykge1xuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5jb252ZXJ0IHx8XG4gICAgICAgICAgICAgICAgdmFsdWUgPT09IHZhbHVlLnRvTG9jYWxlVXBwZXJDYXNlKCkpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoJ3N0cmluZy51cHBlcmNhc2UnLCB7IHZhbHVlIH0sIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgb2JqLl9mbGFncy5jYXNlID0gJ3VwcGVyJztcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICB0cmltKGVuYWJsZWQgPSB0cnVlKSB7XG5cbiAgICAgICAgSG9lay5hc3NlcnQodHlwZW9mIGVuYWJsZWQgPT09ICdib29sZWFuJywgJ29wdGlvbiBtdXN0IGJlIGEgYm9vbGVhbicpO1xuXG4gICAgICAgIGlmICgodGhpcy5fZmxhZ3MudHJpbSAmJiBlbmFibGVkKSB8fCAoIXRoaXMuX2ZsYWdzLnRyaW0gJiYgIWVuYWJsZWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBvYmo7XG4gICAgICAgIGlmIChlbmFibGVkKSB7XG4gICAgICAgICAgICBvYmogPSB0aGlzLl90ZXN0KCd0cmltJywgdW5kZWZpbmVkLCBmdW5jdGlvbiAodmFsdWUsIHN0YXRlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5jb252ZXJ0IHx8XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID09PSB2YWx1ZS50cmltKCkpIHtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoJ3N0cmluZy50cmltJywgeyB2YWx1ZSB9LCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iaiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgICAgIG9iai5fdGVzdHMgPSBvYmouX3Rlc3RzLmZpbHRlcigodGVzdCkgPT4gdGVzdC5uYW1lICE9PSAndHJpbScpO1xuICAgICAgICB9XG5cbiAgICAgICAgb2JqLl9mbGFncy50cmltID0gZW5hYmxlZDtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICByZXBsYWNlKHBhdHRlcm4sIHJlcGxhY2VtZW50KSB7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwYXR0ZXJuID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcGF0dGVybiA9IG5ldyBSZWdFeHAoSG9lay5lc2NhcGVSZWdleChwYXR0ZXJuKSwgJ2cnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIEhvZWsuYXNzZXJ0KHBhdHRlcm4gaW5zdGFuY2VvZiBSZWdFeHAsICdwYXR0ZXJuIG11c3QgYmUgYSBSZWdFeHAnKTtcbiAgICAgICAgSG9lay5hc3NlcnQodHlwZW9mIHJlcGxhY2VtZW50ID09PSAnc3RyaW5nJywgJ3JlcGxhY2VtZW50IG11c3QgYmUgYSBTdHJpbmcnKTtcblxuICAgICAgICAvLyBUaGlzIGNhbiBub3QgYmUgY29uc2lkZXJlIGEgdGVzdCBsaWtlIHRyaW0sIHdlIGNhbid0IFwicmVqZWN0XCJcbiAgICAgICAgLy8gYW55dGhpbmcgZnJvbSB0aGlzIHJ1bGUsIHNvIGp1c3QgY2xvbmUgdGhlIGN1cnJlbnQgb2JqZWN0XG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcblxuICAgICAgICBpZiAoIW9iai5faW5uZXIucmVwbGFjZW1lbnRzKSB7XG4gICAgICAgICAgICBvYmouX2lubmVyLnJlcGxhY2VtZW50cyA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgb2JqLl9pbm5lci5yZXBsYWNlbWVudHMucHVzaCh7XG4gICAgICAgICAgICBwYXR0ZXJuLFxuICAgICAgICAgICAgcmVwbGFjZW1lbnRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICB0cnVuY2F0ZShlbmFibGVkKSB7XG5cbiAgICAgICAgY29uc3QgdmFsdWUgPSBlbmFibGVkID09PSB1bmRlZmluZWQgPyB0cnVlIDogISFlbmFibGVkO1xuXG4gICAgICAgIGlmICh0aGlzLl9mbGFncy50cnVuY2F0ZSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBvYmouX2ZsYWdzLnRydW5jYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG59O1xuXG5pbnRlcm5hbHMuY29tcGFyZSA9IGZ1bmN0aW9uICh0eXBlLCBjb21wYXJlKSB7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKGxpbWl0LCBlbmNvZGluZykge1xuXG4gICAgICAgIGNvbnN0IGlzUmVmID0gUmVmLmlzUmVmKGxpbWl0KTtcblxuICAgICAgICBIb2VrLmFzc2VydCgoTnVtYmVyLmlzU2FmZUludGVnZXIobGltaXQpICYmIGxpbWl0ID49IDApIHx8IGlzUmVmLCAnbGltaXQgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIgb3IgcmVmZXJlbmNlJyk7XG4gICAgICAgIEhvZWsuYXNzZXJ0KCFlbmNvZGluZyB8fCBCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZyksICdJbnZhbGlkIGVuY29kaW5nOicsIGVuY29kaW5nKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fdGVzdCh0eXBlLCBsaW1pdCwgZnVuY3Rpb24gKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucykge1xuXG4gICAgICAgICAgICBsZXQgY29tcGFyZVRvO1xuICAgICAgICAgICAgaWYgKGlzUmVmKSB7XG4gICAgICAgICAgICAgICAgY29tcGFyZVRvID0gbGltaXQoc3RhdGUucmVmZXJlbmNlIHx8IHN0YXRlLnBhcmVudCwgb3B0aW9ucyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGNvbXBhcmVUbykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoJ3N0cmluZy5yZWYnLCB7IHJlZjogbGltaXQsIHZhbHVlOiBjb21wYXJlVG8gfSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbXBhcmVUbyA9IGxpbWl0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY29tcGFyZSh2YWx1ZSwgY29tcGFyZVRvLCBlbmNvZGluZykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKCdzdHJpbmcuJyArIHR5cGUsIHsgbGltaXQ6IGNvbXBhcmVUbywgdmFsdWUsIGVuY29kaW5nIH0sIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn07XG5cblxuaW50ZXJuYWxzLlN0cmluZy5wcm90b3R5cGUubWluID0gaW50ZXJuYWxzLmNvbXBhcmUoJ21pbicsICh2YWx1ZSwgbGltaXQsIGVuY29kaW5nKSA9PiB7XG5cbiAgICBjb25zdCBsZW5ndGggPSBlbmNvZGluZyA/IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbHVlLCBlbmNvZGluZykgOiB2YWx1ZS5sZW5ndGg7XG4gICAgcmV0dXJuIGxlbmd0aCA+PSBsaW1pdDtcbn0pO1xuXG5cbmludGVybmFscy5TdHJpbmcucHJvdG90eXBlLm1heCA9IGludGVybmFscy5jb21wYXJlKCdtYXgnLCAodmFsdWUsIGxpbWl0LCBlbmNvZGluZykgPT4ge1xuXG4gICAgY29uc3QgbGVuZ3RoID0gZW5jb2RpbmcgPyBCdWZmZXIuYnl0ZUxlbmd0aCh2YWx1ZSwgZW5jb2RpbmcpIDogdmFsdWUubGVuZ3RoO1xuICAgIHJldHVybiBsZW5ndGggPD0gbGltaXQ7XG59KTtcblxuXG5pbnRlcm5hbHMuU3RyaW5nLnByb3RvdHlwZS5sZW5ndGggPSBpbnRlcm5hbHMuY29tcGFyZSgnbGVuZ3RoJywgKHZhbHVlLCBsaW1pdCwgZW5jb2RpbmcpID0+IHtcblxuICAgIGNvbnN0IGxlbmd0aCA9IGVuY29kaW5nID8gQnVmZmVyLmJ5dGVMZW5ndGgodmFsdWUsIGVuY29kaW5nKSA6IHZhbHVlLmxlbmd0aDtcbiAgICByZXR1cm4gbGVuZ3RoID09PSBsaW1pdDtcbn0pO1xuXG4vLyBBbGlhc2VzXG5cbmludGVybmFscy5TdHJpbmcucHJvdG90eXBlLnV1aWQgPSBpbnRlcm5hbHMuU3RyaW5nLnByb3RvdHlwZS5ndWlkO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBpbnRlcm5hbHMuU3RyaW5nKCk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IFJGQzM5ODYgPSByZXF1aXJlKCcuL3JmYzM5ODYnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7XG4gICAgSXA6IHtcbiAgICAgICAgY2lkcnM6IHtcbiAgICAgICAgICAgIGlwdjQ6IHtcbiAgICAgICAgICAgICAgICByZXF1aXJlZDogJ1xcXFwvKD86JyArIFJGQzM5ODYuaXB2NENpZHIgKyAnKScsXG4gICAgICAgICAgICAgICAgb3B0aW9uYWw6ICcoPzpcXFxcLyg/OicgKyBSRkMzOTg2LmlwdjRDaWRyICsgJykpPycsXG4gICAgICAgICAgICAgICAgZm9yYmlkZGVuOiAnJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlwdjY6IHtcbiAgICAgICAgICAgICAgICByZXF1aXJlZDogJ1xcXFwvJyArIFJGQzM5ODYuaXB2NkNpZHIsXG4gICAgICAgICAgICAgICAgb3B0aW9uYWw6ICcoPzpcXFxcLycgKyBSRkMzOTg2LmlwdjZDaWRyICsgJyk/JyxcbiAgICAgICAgICAgICAgICBmb3JiaWRkZW46ICcnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXB2ZnV0dXJlOiB7XG4gICAgICAgICAgICAgICAgcmVxdWlyZWQ6ICdcXFxcLycgKyBSRkMzOTg2LmlwdjZDaWRyLFxuICAgICAgICAgICAgICAgIG9wdGlvbmFsOiAnKD86XFxcXC8nICsgUkZDMzk4Ni5pcHY2Q2lkciArICcpPycsXG4gICAgICAgICAgICAgICAgZm9yYmlkZGVuOiAnJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB2ZXJzaW9uczoge1xuICAgICAgICAgICAgaXB2NDogUkZDMzk4Ni5JUHY0YWRkcmVzcyxcbiAgICAgICAgICAgIGlwdjY6IFJGQzM5ODYuSVB2NmFkZHJlc3MsXG4gICAgICAgICAgICBpcHZmdXR1cmU6IFJGQzM5ODYuSVB2RnV0dXJlXG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5cbmludGVybmFscy5JcC5jcmVhdGVJcFJlZ2V4ID0gZnVuY3Rpb24gKHZlcnNpb25zLCBjaWRyKSB7XG5cbiAgICBsZXQgcmVnZXg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2ZXJzaW9ucy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCB2ZXJzaW9uID0gdmVyc2lvbnNbaV07XG4gICAgICAgIGlmICghcmVnZXgpIHtcbiAgICAgICAgICAgIHJlZ2V4ID0gJ14oPzonICsgaW50ZXJuYWxzLklwLnZlcnNpb25zW3ZlcnNpb25dICsgaW50ZXJuYWxzLklwLmNpZHJzW3ZlcnNpb25dW2NpZHJdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVnZXggKz0gJ3wnICsgaW50ZXJuYWxzLklwLnZlcnNpb25zW3ZlcnNpb25dICsgaW50ZXJuYWxzLklwLmNpZHJzW3ZlcnNpb25dW2NpZHJdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBSZWdFeHAocmVnZXggKyAnKSQnKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaW50ZXJuYWxzLklwO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBpbnRlcm5hbHMgPSB7XG4gICAgcmZjMzk4Njoge31cbn07XG5cblxuaW50ZXJuYWxzLmdlbmVyYXRlID0gZnVuY3Rpb24gKCkge1xuXG4gICAgLyoqXG4gICAgICogZWxlbWVudHMgc2VwYXJhdGVkIGJ5IGZvcndhcmQgc2xhc2ggKFwiL1wiKSBhcmUgYWx0ZXJuYXRpdmVzLlxuICAgICAqL1xuICAgIGNvbnN0IG9yID0gJ3wnO1xuXG4gICAgLyoqXG4gICAgICogUnVsZSB0byBzdXBwb3J0IHplcm8tcGFkZGVkIGFkZHJlc3Nlcy5cbiAgICAgKi9cbiAgICBjb25zdCB6ZXJvUGFkID0gJzA/JztcblxuICAgIC8qKlxuICAgICAqIERJR0lUID0gJXgzMC0zOSA7IDAtOVxuICAgICAqL1xuICAgIGNvbnN0IGRpZ2l0ID0gJzAtOSc7XG4gICAgY29uc3QgZGlnaXRPbmx5ID0gJ1snICsgZGlnaXQgKyAnXSc7XG5cbiAgICAvKipcbiAgICAgKiBBTFBIQSA9ICV4NDEtNUEgLyAleDYxLTdBICAgOyBBLVogLyBhLXpcbiAgICAgKi9cbiAgICBjb25zdCBhbHBoYSA9ICdhLXpBLVonO1xuICAgIGNvbnN0IGFscGhhT25seSA9ICdbJyArIGFscGhhICsgJ10nO1xuXG4gICAgLyoqXG4gICAgICogSVB2NFxuICAgICAqIGNpZHIgICAgICAgPSBESUdJVCAgICAgICAgICAgICAgICA7IDAtOVxuICAgICAqICAgICAgICAgICAgLyAleDMxLTMyIERJR0lUICAgICAgICAgOyAxMC0yOVxuICAgICAqICAgICAgICAgICAgLyBcIjNcIiAleDMwLTMyICAgICAgICAgICA7IDMwLTMyXG4gICAgICovXG4gICAgaW50ZXJuYWxzLnJmYzM5ODYuaXB2NENpZHIgPSBkaWdpdE9ubHkgKyBvciArICdbMS0yXScgKyBkaWdpdE9ubHkgKyBvciArICczJyArICdbMC0yXSc7XG5cbiAgICAvKipcbiAgICAgKiBJUHY2XG4gICAgICogY2lkciAgICAgICA9IERJR0lUICAgICAgICAgICAgICAgICA7IDAtOVxuICAgICAqICAgICAgICAgICAgLyAleDMxLTM5IERJR0lUICAgICAgICAgOyAxMC05OVxuICAgICAqICAgICAgICAgICAgLyBcIjFcIiAleDAtMSBESUdJVCAgICAgICA7IDEwMC0xMTlcbiAgICAgKiAgICAgICAgICAgIC8gXCIxMlwiICV4MC04ICAgICAgICAgICAgOyAxMjAtMTI4XG4gICAgICovXG4gICAgaW50ZXJuYWxzLnJmYzM5ODYuaXB2NkNpZHIgPSAnKD86JyArIHplcm9QYWQgKyB6ZXJvUGFkICsgZGlnaXRPbmx5ICsgb3IgKyB6ZXJvUGFkICsgJ1sxLTldJyArIGRpZ2l0T25seSArIG9yICsgJzEnICsgJ1swMV0nICsgZGlnaXRPbmx5ICsgb3IgKyAnMTJbMC04XSknO1xuXG4gICAgLyoqXG4gICAgICogSEVYRElHID0gRElHSVQgLyBcIkFcIiAvIFwiQlwiIC8gXCJDXCIgLyBcIkRcIiAvIFwiRVwiIC8gXCJGXCJcbiAgICAgKi9cbiAgICBjb25zdCBoZXhEaWdpdCA9IGRpZ2l0ICsgJ0EtRmEtZic7XG4gICAgY29uc3QgaGV4RGlnaXRPbmx5ID0gJ1snICsgaGV4RGlnaXQgKyAnXSc7XG5cbiAgICAvKipcbiAgICAgKiB1bnJlc2VydmVkID0gQUxQSEEgLyBESUdJVCAvIFwiLVwiIC8gXCIuXCIgLyBcIl9cIiAvIFwiflwiXG4gICAgICovXG4gICAgY29uc3QgdW5yZXNlcnZlZCA9IGFscGhhICsgZGlnaXQgKyAnLVxcXFwuX34nO1xuXG4gICAgLyoqXG4gICAgICogc3ViLWRlbGltcyA9IFwiIVwiIC8gXCIkXCIgLyBcIiZcIiAvIFwiJ1wiIC8gXCIoXCIgLyBcIilcIiAvIFwiKlwiIC8gXCIrXCIgLyBcIixcIiAvIFwiO1wiIC8gXCI9XCJcbiAgICAgKi9cbiAgICBjb25zdCBzdWJEZWxpbXMgPSAnIVxcXFwkJlxcJ1xcXFwoXFxcXClcXFxcKlxcXFwrLDs9JztcblxuICAgIC8qKlxuICAgICAqIHBjdC1lbmNvZGVkID0gXCIlXCIgSEVYRElHIEhFWERJR1xuICAgICAqL1xuICAgIGNvbnN0IHBjdEVuY29kZWQgPSAnJScgKyBoZXhEaWdpdDtcblxuICAgIC8qKlxuICAgICAqIHBjaGFyID0gdW5yZXNlcnZlZCAvIHBjdC1lbmNvZGVkIC8gc3ViLWRlbGltcyAvIFwiOlwiIC8gXCJAXCJcbiAgICAgKi9cbiAgICBjb25zdCBwY2hhciA9IHVucmVzZXJ2ZWQgKyBwY3RFbmNvZGVkICsgc3ViRGVsaW1zICsgJzpAJztcbiAgICBjb25zdCBwY2hhck9ubHkgPSAnWycgKyBwY2hhciArICddJztcblxuICAgIC8qKlxuICAgICAqIHNxdWFyZUJyYWNrZXRzIGV4YW1wbGU6IFtdXG4gICAgICovXG4gICAgY29uc3Qgc3F1YXJlQnJhY2tldHMgPSAnXFxcXFtcXFxcXSc7XG5cbiAgICAvKipcbiAgICAgKiBkZWMtb2N0ZXQgICA9IERJR0lUICAgICAgICAgICAgICAgICA7IDAtOVxuICAgICAqICAgICAgICAgICAgLyAleDMxLTM5IERJR0lUICAgICAgICAgOyAxMC05OVxuICAgICAqICAgICAgICAgICAgLyBcIjFcIiAyRElHSVQgICAgICAgICAgICA7IDEwMC0xOTlcbiAgICAgKiAgICAgICAgICAgIC8gXCIyXCIgJXgzMC0zNCBESUdJVCAgICAgOyAyMDAtMjQ5XG4gICAgICogICAgICAgICAgICAvIFwiMjVcIiAleDMwLTM1ICAgICAgICAgIDsgMjUwLTI1NVxuICAgICAqL1xuICAgIGNvbnN0IGRlY09jdGVjdCA9ICcoPzonICsgemVyb1BhZCArIHplcm9QYWQgKyBkaWdpdE9ubHkgKyBvciArIHplcm9QYWQgKyAnWzEtOV0nICsgZGlnaXRPbmx5ICsgb3IgKyAnMScgKyBkaWdpdE9ubHkgKyBkaWdpdE9ubHkgKyBvciArICcyJyArICdbMC00XScgKyBkaWdpdE9ubHkgKyBvciArICcyNScgKyAnWzAtNV0pJztcblxuICAgIC8qKlxuICAgICAqIElQdjRhZGRyZXNzID0gZGVjLW9jdGV0IFwiLlwiIGRlYy1vY3RldCBcIi5cIiBkZWMtb2N0ZXQgXCIuXCIgZGVjLW9jdGV0XG4gICAgICovXG4gICAgaW50ZXJuYWxzLnJmYzM5ODYuSVB2NGFkZHJlc3MgPSAnKD86JyArIGRlY09jdGVjdCArICdcXFxcLil7M30nICsgZGVjT2N0ZWN0O1xuXG4gICAgLyoqXG4gICAgICogaDE2ID0gMSo0SEVYRElHIDsgMTYgYml0cyBvZiBhZGRyZXNzIHJlcHJlc2VudGVkIGluIGhleGFkZWNpbWFsXG4gICAgICogbHMzMiA9ICggaDE2IFwiOlwiIGgxNiApIC8gSVB2NGFkZHJlc3MgOyBsZWFzdC1zaWduaWZpY2FudCAzMiBiaXRzIG9mIGFkZHJlc3NcbiAgICAgKiBJUHY2YWRkcmVzcyA9ICAgICAgICAgICAgICAgICAgICAgICAgICAgIDYoIGgxNiBcIjpcIiApIGxzMzJcbiAgICAgKiAgICAgICAgICAgICAvICAgICAgICAgICAgICAgICAgICAgICBcIjo6XCIgNSggaDE2IFwiOlwiICkgbHMzMlxuICAgICAqICAgICAgICAgICAgIC8gWyAgICAgICAgICAgICAgIGgxNiBdIFwiOjpcIiA0KCBoMTYgXCI6XCIgKSBsczMyXG4gICAgICogICAgICAgICAgICAgLyBbICoxKCBoMTYgXCI6XCIgKSBoMTYgXSBcIjo6XCIgMyggaDE2IFwiOlwiICkgbHMzMlxuICAgICAqICAgICAgICAgICAgIC8gWyAqMiggaDE2IFwiOlwiICkgaDE2IF0gXCI6OlwiIDIoIGgxNiBcIjpcIiApIGxzMzJcbiAgICAgKiAgICAgICAgICAgICAvIFsgKjMoIGgxNiBcIjpcIiApIGgxNiBdIFwiOjpcIiAgICBoMTYgXCI6XCIgICBsczMyXG4gICAgICogICAgICAgICAgICAgLyBbICo0KCBoMTYgXCI6XCIgKSBoMTYgXSBcIjo6XCIgICAgICAgICAgICAgIGxzMzJcbiAgICAgKiAgICAgICAgICAgICAvIFsgKjUoIGgxNiBcIjpcIiApIGgxNiBdIFwiOjpcIiAgICAgICAgICAgICAgaDE2XG4gICAgICogICAgICAgICAgICAgLyBbICo2KCBoMTYgXCI6XCIgKSBoMTYgXSBcIjo6XCJcbiAgICAgKi9cbiAgICBjb25zdCBoMTYgPSBoZXhEaWdpdE9ubHkgKyAnezEsNH0nO1xuICAgIGNvbnN0IGxzMzIgPSAnKD86JyArIGgxNiArICc6JyArIGgxNiArICd8JyArIGludGVybmFscy5yZmMzOTg2LklQdjRhZGRyZXNzICsgJyknO1xuICAgIGNvbnN0IElQdjZTaXhIZXggPSAnKD86JyArIGgxNiArICc6KXs2fScgKyBsczMyO1xuICAgIGNvbnN0IElQdjZGaXZlSGV4ID0gJzo6KD86JyArIGgxNiArICc6KXs1fScgKyBsczMyO1xuICAgIGNvbnN0IElQdjZGb3VySGV4ID0gJyg/OicgKyBoMTYgKyAnKT86Oig/OicgKyBoMTYgKyAnOil7NH0nICsgbHMzMjtcbiAgICBjb25zdCBJUHY2VGhyZWVIZXggPSAnKD86KD86JyArIGgxNiArICc6KXswLDF9JyArIGgxNiArICcpPzo6KD86JyArIGgxNiArICc6KXszfScgKyBsczMyO1xuICAgIGNvbnN0IElQdjZUd29IZXggPSAnKD86KD86JyArIGgxNiArICc6KXswLDJ9JyArIGgxNiArICcpPzo6KD86JyArIGgxNiArICc6KXsyfScgKyBsczMyO1xuICAgIGNvbnN0IElQdjZPbmVIZXggPSAnKD86KD86JyArIGgxNiArICc6KXswLDN9JyArIGgxNiArICcpPzo6JyArIGgxNiArICc6JyArIGxzMzI7XG4gICAgY29uc3QgSVB2Nk5vbmVIZXggPSAnKD86KD86JyArIGgxNiArICc6KXswLDR9JyArIGgxNiArICcpPzo6JyArIGxzMzI7XG4gICAgY29uc3QgSVB2Nk5vbmVIZXgyID0gJyg/Oig/OicgKyBoMTYgKyAnOil7MCw1fScgKyBoMTYgKyAnKT86OicgKyBoMTY7XG4gICAgY29uc3QgSVB2Nk5vbmVIZXgzID0gJyg/Oig/OicgKyBoMTYgKyAnOil7MCw2fScgKyBoMTYgKyAnKT86Oic7XG4gICAgaW50ZXJuYWxzLnJmYzM5ODYuSVB2NmFkZHJlc3MgPSAnKD86JyArIElQdjZTaXhIZXggKyBvciArIElQdjZGaXZlSGV4ICsgb3IgKyBJUHY2Rm91ckhleCArIG9yICsgSVB2NlRocmVlSGV4ICsgb3IgKyBJUHY2VHdvSGV4ICsgb3IgKyBJUHY2T25lSGV4ICsgb3IgKyBJUHY2Tm9uZUhleCArIG9yICsgSVB2Nk5vbmVIZXgyICsgb3IgKyBJUHY2Tm9uZUhleDMgKyAnKSc7XG5cbiAgICAvKipcbiAgICAgKiBJUHZGdXR1cmUgPSBcInZcIiAxKkhFWERJRyBcIi5cIiAxKiggdW5yZXNlcnZlZCAvIHN1Yi1kZWxpbXMgLyBcIjpcIiApXG4gICAgICovXG4gICAgaW50ZXJuYWxzLnJmYzM5ODYuSVB2RnV0dXJlID0gJ3YnICsgaGV4RGlnaXRPbmx5ICsgJytcXFxcLlsnICsgdW5yZXNlcnZlZCArIHN1YkRlbGltcyArICc6XSsnO1xuXG4gICAgLyoqXG4gICAgICogc2NoZW1lID0gQUxQSEEgKiggQUxQSEEgLyBESUdJVCAvIFwiK1wiIC8gXCItXCIgLyBcIi5cIiApXG4gICAgICovXG4gICAgaW50ZXJuYWxzLnJmYzM5ODYuc2NoZW1lID0gYWxwaGFPbmx5ICsgJ1snICsgYWxwaGEgKyBkaWdpdCArICcrLVxcXFwuXSonO1xuXG4gICAgLyoqXG4gICAgICogdXNlcmluZm8gPSAqKCB1bnJlc2VydmVkIC8gcGN0LWVuY29kZWQgLyBzdWItZGVsaW1zIC8gXCI6XCIgKVxuICAgICAqL1xuICAgIGNvbnN0IHVzZXJpbmZvID0gJ1snICsgdW5yZXNlcnZlZCArIHBjdEVuY29kZWQgKyBzdWJEZWxpbXMgKyAnOl0qJztcblxuICAgIC8qKlxuICAgICAqIElQLWxpdGVyYWwgPSBcIltcIiAoIElQdjZhZGRyZXNzIC8gSVB2RnV0dXJlICApIFwiXVwiXG4gICAgICovXG4gICAgY29uc3QgSVBMaXRlcmFsID0gJ1xcXFxbKD86JyArIGludGVybmFscy5yZmMzOTg2LklQdjZhZGRyZXNzICsgb3IgKyBpbnRlcm5hbHMucmZjMzk4Ni5JUHZGdXR1cmUgKyAnKVxcXFxdJztcblxuICAgIC8qKlxuICAgICAqIHJlZy1uYW1lID0gKiggdW5yZXNlcnZlZCAvIHBjdC1lbmNvZGVkIC8gc3ViLWRlbGltcyApXG4gICAgICovXG4gICAgY29uc3QgcmVnTmFtZSA9ICdbJyArIHVucmVzZXJ2ZWQgKyBwY3RFbmNvZGVkICsgc3ViRGVsaW1zICsgJ117MCwyNTV9JztcblxuICAgIC8qKlxuICAgICAqIGhvc3QgPSBJUC1saXRlcmFsIC8gSVB2NGFkZHJlc3MgLyByZWctbmFtZVxuICAgICAqL1xuICAgIGNvbnN0IGhvc3QgPSAnKD86JyArIElQTGl0ZXJhbCArIG9yICsgaW50ZXJuYWxzLnJmYzM5ODYuSVB2NGFkZHJlc3MgKyBvciArIHJlZ05hbWUgKyAnKSc7XG5cbiAgICAvKipcbiAgICAgKiBwb3J0ID0gKkRJR0lUXG4gICAgICovXG4gICAgY29uc3QgcG9ydCA9IGRpZ2l0T25seSArICcqJztcblxuICAgIC8qKlxuICAgICAqIGF1dGhvcml0eSAgID0gWyB1c2VyaW5mbyBcIkBcIiBdIGhvc3QgWyBcIjpcIiBwb3J0IF1cbiAgICAgKi9cbiAgICBjb25zdCBhdXRob3JpdHkgPSAnKD86JyArIHVzZXJpbmZvICsgJ0ApPycgKyBob3N0ICsgJyg/OjonICsgcG9ydCArICcpPyc7XG5cbiAgICAvKipcbiAgICAgKiBzZWdtZW50ICAgICAgID0gKnBjaGFyXG4gICAgICogc2VnbWVudC1ueiAgICA9IDEqcGNoYXJcbiAgICAgKiBwYXRoICAgICAgICAgID0gcGF0aC1hYmVtcHR5ICAgIDsgYmVnaW5zIHdpdGggXCIvXCIgb3IgaXMgZW1wdHlcbiAgICAgKiAgICAgICAgICAgICAgIC8gcGF0aC1hYnNvbHV0ZSAgIDsgYmVnaW5zIHdpdGggXCIvXCIgYnV0IG5vdCBcIi8vXCJcbiAgICAgKiAgICAgICAgICAgICAgIC8gcGF0aC1ub3NjaGVtZSAgIDsgYmVnaW5zIHdpdGggYSBub24tY29sb24gc2VnbWVudFxuICAgICAqICAgICAgICAgICAgICAgLyBwYXRoLXJvb3RsZXNzICAgOyBiZWdpbnMgd2l0aCBhIHNlZ21lbnRcbiAgICAgKiAgICAgICAgICAgICAgIC8gcGF0aC1lbXB0eSAgICAgIDsgemVybyBjaGFyYWN0ZXJzXG4gICAgICogcGF0aC1hYmVtcHR5ICA9ICooIFwiL1wiIHNlZ21lbnQgKVxuICAgICAqIHBhdGgtYWJzb2x1dGUgPSBcIi9cIiBbIHNlZ21lbnQtbnogKiggXCIvXCIgc2VnbWVudCApIF1cbiAgICAgKiBwYXRoLXJvb3RsZXNzID0gc2VnbWVudC1ueiAqKCBcIi9cIiBzZWdtZW50IClcbiAgICAgKi9cbiAgICBjb25zdCBzZWdtZW50ID0gcGNoYXJPbmx5ICsgJyonO1xuICAgIGNvbnN0IHNlZ21lbnROeiA9IHBjaGFyT25seSArICcrJztcbiAgICBjb25zdCBzZWdtZW50TnpOYyA9ICdbJyArIHVucmVzZXJ2ZWQgKyBwY3RFbmNvZGVkICsgc3ViRGVsaW1zICsgJ0AnICsgJ10rJztcbiAgICBjb25zdCBwYXRoRW1wdHkgPSAnJztcbiAgICBjb25zdCBwYXRoQWJFbXB0eSA9ICcoPzpcXFxcLycgKyBzZWdtZW50ICsgJykqJztcbiAgICBjb25zdCBwYXRoQWJzb2x1dGUgPSAnXFxcXC8oPzonICsgc2VnbWVudE56ICsgcGF0aEFiRW1wdHkgKyAnKT8nO1xuICAgIGNvbnN0IHBhdGhSb290bGVzcyA9IHNlZ21lbnROeiArIHBhdGhBYkVtcHR5O1xuICAgIGNvbnN0IHBhdGhOb1NjaGVtZSA9IHNlZ21lbnROek5jICsgcGF0aEFiRW1wdHk7XG5cbiAgICAvKipcbiAgICAgKiBoaWVyLXBhcnQgPSBcIi8vXCIgYXV0aG9yaXR5IHBhdGhcbiAgICAgKi9cbiAgICBpbnRlcm5hbHMucmZjMzk4Ni5oaWVyUGFydCA9ICcoPzonICsgJyg/OlxcXFwvXFxcXC8nICsgYXV0aG9yaXR5ICsgcGF0aEFiRW1wdHkgKyAnKScgKyBvciArIHBhdGhBYnNvbHV0ZSArIG9yICsgcGF0aFJvb3RsZXNzICsgJyknO1xuXG4gICAgLyoqXG4gICAgICogcmVsYXRpdmUtcGFydCA9IFwiLy9cIiBhdXRob3JpdHkgcGF0aC1hYmVtcHR5XG4gICAgICogICAgICAgICAgICAgICAgIC8gcGF0aC1hYnNvbHV0ZVxuICAgICAqICAgICAgICAgICAgICAgICAvIHBhdGgtbm9zY2hlbWVcbiAgICAgKiAgICAgICAgICAgICAgICAgLyBwYXRoLWVtcHR5XG4gICAgICovXG4gICAgaW50ZXJuYWxzLnJmYzM5ODYucmVsYXRpdmVSZWYgPSAnKD86JyArICcoPzpcXFxcL1xcXFwvJyArIGF1dGhvcml0eSArIHBhdGhBYkVtcHR5ICArICcpJyArIG9yICsgcGF0aEFic29sdXRlICsgb3IgKyBwYXRoTm9TY2hlbWUgKyBvciArIHBhdGhFbXB0eSArICcpJztcblxuICAgIC8qKlxuICAgICAqIHF1ZXJ5ID0gKiggcGNoYXIgLyBcIi9cIiAvIFwiP1wiIClcbiAgICAgKi9cbiAgICBpbnRlcm5hbHMucmZjMzk4Ni5xdWVyeSA9ICdbJyArIHBjaGFyICsgJ1xcXFwvXFxcXD9dKig/PSN8JCknOyAvL0ZpbmlzaCBtYXRjaGluZyBlaXRoZXIgYXQgdGhlIGZyYWdtZW50IHBhcnQgb3IgZW5kIG9mIHRoZSBsaW5lLlxuXG4gICAgLyoqXG4gICAgICogcXVlcnkgPSAqKCBwY2hhciAvIFwiW1wiIC8gXCJdXCIgLyBcIi9cIiAvIFwiP1wiIClcbiAgICAgKi9cbiAgICBpbnRlcm5hbHMucmZjMzk4Ni5xdWVyeVdpdGhTcXVhcmVCcmFja2V0cyA9ICdbJyArIHBjaGFyICsgc3F1YXJlQnJhY2tldHMgKyAnXFxcXC9cXFxcP10qKD89I3wkKSc7IC8vRmluaXNoIG1hdGNoaW5nIGVpdGhlciBhdCB0aGUgZnJhZ21lbnQgcGFydCBvciBlbmQgb2YgdGhlIGxpbmUuXG5cbiAgICAvKipcbiAgICAgKiBmcmFnbWVudCA9ICooIHBjaGFyIC8gXCIvXCIgLyBcIj9cIiApXG4gICAgICovXG4gICAgaW50ZXJuYWxzLnJmYzM5ODYuZnJhZ21lbnQgPSAnWycgKyBwY2hhciArICdcXFxcL1xcXFw/XSonO1xufTtcblxuXG5pbnRlcm5hbHMuZ2VuZXJhdGUoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBpbnRlcm5hbHMucmZjMzk4NjtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgUkZDMzk4NiA9IHJlcXVpcmUoJy4vcmZjMzk4NicpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICBVcmk6IHtcbiAgICAgICAgY3JlYXRlVXJpUmVnZXg6IGZ1bmN0aW9uIChvcHRpb25hbFNjaGVtZSwgYWxsb3dSZWxhdGl2ZSwgcmVsYXRpdmVPbmx5LCBhbGxvd1F1ZXJ5U3F1YXJlQnJhY2tldHMpIHtcblxuICAgICAgICAgICAgbGV0IHNjaGVtZSA9IFJGQzM5ODYuc2NoZW1lO1xuICAgICAgICAgICAgbGV0IHByZWZpeDtcblxuICAgICAgICAgICAgaWYgKHJlbGF0aXZlT25seSkge1xuICAgICAgICAgICAgICAgIHByZWZpeCA9ICcoPzonICsgUkZDMzk4Ni5yZWxhdGl2ZVJlZiArICcpJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIHdlcmUgcGFzc2VkIGEgc2NoZW1lLCB1c2UgaXQgaW5zdGVhZCBvZiB0aGUgZ2VuZXJpYyBvbmVcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9uYWxTY2hlbWUpIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBIYXZlIHRvIHB1dCB0aGlzIGluIGEgbm9uLWNhcHR1cmluZyBncm91cCB0byBoYW5kbGUgdGhlIE9SIHN0YXRlbWVudHNcbiAgICAgICAgICAgICAgICAgICAgc2NoZW1lID0gJyg/OicgKyBvcHRpb25hbFNjaGVtZSArICcpJztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCB3aXRoU2NoZW1lID0gJyg/OicgKyBzY2hlbWUgKyAnOicgKyBSRkMzOTg2LmhpZXJQYXJ0ICsgJyknO1xuXG4gICAgICAgICAgICAgICAgcHJlZml4ID0gYWxsb3dSZWxhdGl2ZSA/ICcoPzonICsgd2l0aFNjaGVtZSArICd8JyArIFJGQzM5ODYucmVsYXRpdmVSZWYgKyAnKScgOiB3aXRoU2NoZW1lO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFVSSSA9IHNjaGVtZSBcIjpcIiBoaWVyLXBhcnQgWyBcIj9cIiBxdWVyeSBdIFsgXCIjXCIgZnJhZ21lbnQgXVxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIE9SXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogcmVsYXRpdmUtcmVmID0gcmVsYXRpdmUtcGFydCBbIFwiP1wiIHF1ZXJ5IF0gWyBcIiNcIiBmcmFnbWVudCBdXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKCdeJyArIHByZWZpeCArICcoPzpcXFxcPycgKyAoYWxsb3dRdWVyeVNxdWFyZUJyYWNrZXRzID8gUkZDMzk4Ni5xdWVyeVdpdGhTcXVhcmVCcmFja2V0cyA6IFJGQzM5ODYucXVlcnkpICsgJyk/JyArICcoPzojJyArIFJGQzM5ODYuZnJhZ21lbnQgKyAnKT8kJyk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGludGVybmFscy5Vcmk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IFV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cbmNvbnN0IEhvZWsgPSByZXF1aXJlKCdAaGFwaS9ob2VrJyk7XG5cbmNvbnN0IEFueSA9IHJlcXVpcmUoJy4uL2FueScpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbmludGVybmFscy5NYXAgPSBjbGFzcyBleHRlbmRzIE1hcCB7XG5cbiAgICBzbGljZSgpIHtcblxuICAgICAgICByZXR1cm4gbmV3IGludGVybmFscy5NYXAodGhpcyk7XG4gICAgfVxuXG4gICAgdG9TdHJpbmcoKSB7XG5cbiAgICAgICAgcmV0dXJuIFV0aWwuaW5zcGVjdCh0aGlzKTtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5TeW1ib2wgPSBjbGFzcyBleHRlbmRzIEFueSB7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcblxuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl90eXBlID0gJ3N5bWJvbCc7XG4gICAgICAgIHRoaXMuX2lubmVyLm1hcCA9IG5ldyBpbnRlcm5hbHMuTWFwKCk7XG4gICAgfVxuXG4gICAgX2Jhc2UodmFsdWUsIHN0YXRlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuY29udmVydCkge1xuICAgICAgICAgICAgY29uc3QgbG9va3VwID0gdGhpcy5faW5uZXIubWFwLmdldCh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAobG9va3VwKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBsb29rdXA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9mbGFncy5hbGxvd09ubHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzOiAodHlwZW9mIHZhbHVlID09PSAnc3ltYm9sJykgPyBudWxsIDogdGhpcy5jcmVhdGVFcnJvcignc3ltYm9sLm1hcCcsIHsgdmFsdWUsIG1hcDogdGhpcy5faW5uZXIubWFwIH0sIHN0YXRlLCBvcHRpb25zKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBlcnJvcnM6ICh0eXBlb2YgdmFsdWUgPT09ICdzeW1ib2wnKSA/IG51bGwgOiB0aGlzLmNyZWF0ZUVycm9yKCdzeW1ib2wuYmFzZScsIHsgdmFsdWUgfSwgc3RhdGUsIG9wdGlvbnMpXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgbWFwKGl0ZXJhYmxlKSB7XG5cbiAgICAgICAgaWYgKGl0ZXJhYmxlICYmICFpdGVyYWJsZVtTeW1ib2wuaXRlcmF0b3JdICYmIHR5cGVvZiBpdGVyYWJsZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGl0ZXJhYmxlID0gT2JqZWN0LmVudHJpZXMoaXRlcmFibGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgSG9lay5hc3NlcnQoaXRlcmFibGUgJiYgaXRlcmFibGVbU3ltYm9sLml0ZXJhdG9yXSwgJ0l0ZXJhYmxlIG11c3QgYmUgYW4gaXRlcmFibGUgb3Igb2JqZWN0Jyk7XG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcblxuICAgICAgICBjb25zdCBzeW1ib2xzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgaXRlcmFibGUpIHtcbiAgICAgICAgICAgIEhvZWsuYXNzZXJ0KGVudHJ5ICYmIGVudHJ5W1N5bWJvbC5pdGVyYXRvcl0sICdFbnRyeSBtdXN0IGJlIGFuIGl0ZXJhYmxlJyk7XG4gICAgICAgICAgICBjb25zdCBba2V5LCB2YWx1ZV0gPSBlbnRyeTtcblxuICAgICAgICAgICAgSG9lay5hc3NlcnQodHlwZW9mIGtleSAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIGtleSAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Yga2V5ICE9PSAnc3ltYm9sJywgJ0tleSBtdXN0IG5vdCBiZSBhbiBvYmplY3QsIGZ1bmN0aW9uLCBvciBTeW1ib2wnKTtcbiAgICAgICAgICAgIEhvZWsuYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PT0gJ3N5bWJvbCcsICdWYWx1ZSBtdXN0IGJlIGEgU3ltYm9sJyk7XG4gICAgICAgICAgICBvYmouX2lubmVyLm1hcC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICBzeW1ib2xzLnB1c2godmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9iai52YWxpZCguLi5zeW1ib2xzKTtcbiAgICB9XG5cbiAgICBkZXNjcmliZSgpIHtcblxuICAgICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IHN1cGVyLmRlc2NyaWJlKCk7XG4gICAgICAgIGRlc2NyaXB0aW9uLm1hcCA9IG5ldyBNYXAodGhpcy5faW5uZXIubWFwKTtcbiAgICAgICAgcmV0dXJuIGRlc2NyaXB0aW9uO1xuICAgIH1cbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgaW50ZXJuYWxzLlN5bWJvbCgpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBzZXR0aW5nc0NhY2hlOiBTeW1ib2woJ3NldHRpbmdzQ2FjaGUnKVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgaW50ZXJuYWxzID0ge1xuICAgIHN5bWJvbHM6IG5ldyBNYXAoKVxufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmdW5jdGlvbiAoc3ViamVjdCkge1xuXG4gICAgbGV0IHN5bWJvbCA9IGludGVybmFscy5zeW1ib2xzLmdldChzdWJqZWN0KTtcbiAgICBpZiAoc3ltYm9sKSB7XG4gICAgICAgIHJldHVybiBzeW1ib2w7XG4gICAgfVxuXG4gICAgc3ltYm9sID0gU3ltYm9sKHN1YmplY3QpO1xuICAgIGludGVybmFscy5zeW1ib2xzLnNldChzdWJqZWN0LCBzeW1ib2wpO1xuXG4gICAgcmV0dXJuIHN5bWJvbDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEhvZWsgPSByZXF1aXJlKCdAaGFwaS9ob2VrJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBUb3BvIHtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuXG4gICAgICAgIHRoaXMuX2l0ZW1zID0gW107XG4gICAgICAgIHRoaXMubm9kZXMgPSBbXTtcbiAgICB9XG5cbiAgICBhZGQobm9kZXMsIG9wdGlvbnMpIHtcblxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICAvLyBWYWxpZGF0ZSBydWxlc1xuXG4gICAgICAgIGNvbnN0IGJlZm9yZSA9IFtdLmNvbmNhdChvcHRpb25zLmJlZm9yZSB8fCBbXSk7XG4gICAgICAgIGNvbnN0IGFmdGVyID0gW10uY29uY2F0KG9wdGlvbnMuYWZ0ZXIgfHwgW10pO1xuICAgICAgICBjb25zdCBncm91cCA9IG9wdGlvbnMuZ3JvdXAgfHwgJz8nO1xuICAgICAgICBjb25zdCBzb3J0ID0gb3B0aW9ucy5zb3J0IHx8IDA7ICAgICAgICAgICAgICAgICAgIC8vIFVzZWQgZm9yIG1lcmdpbmcgb25seVxuXG4gICAgICAgIEhvZWsuYXNzZXJ0KCFiZWZvcmUuaW5jbHVkZXMoZ3JvdXApLCBgSXRlbSBjYW5ub3QgY29tZSBiZWZvcmUgaXRzZWxmOiAke2dyb3VwfWApO1xuICAgICAgICBIb2VrLmFzc2VydCghYmVmb3JlLmluY2x1ZGVzKCc/JyksICdJdGVtIGNhbm5vdCBjb21lIGJlZm9yZSB1bmFzc29jaWF0ZWQgaXRlbXMnKTtcbiAgICAgICAgSG9lay5hc3NlcnQoIWFmdGVyLmluY2x1ZGVzKGdyb3VwKSwgYEl0ZW0gY2Fubm90IGNvbWUgYWZ0ZXIgaXRzZWxmOiAke2dyb3VwfWApO1xuICAgICAgICBIb2VrLmFzc2VydCghYWZ0ZXIuaW5jbHVkZXMoJz8nKSwgJ0l0ZW0gY2Fubm90IGNvbWUgYWZ0ZXIgdW5hc3NvY2lhdGVkIGl0ZW1zJyk7XG5cbiAgICAgICAgKFtdLmNvbmNhdChub2RlcykpLmZvckVhY2goKG5vZGUsIGkpID0+IHtcblxuICAgICAgICAgICAgY29uc3QgaXRlbSA9IHtcbiAgICAgICAgICAgICAgICBzZXE6IHRoaXMuX2l0ZW1zLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBzb3J0LFxuICAgICAgICAgICAgICAgIGJlZm9yZSxcbiAgICAgICAgICAgICAgICBhZnRlcixcbiAgICAgICAgICAgICAgICBncm91cCxcbiAgICAgICAgICAgICAgICBub2RlXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLl9pdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBJbnNlcnQgZXZlbnRcblxuICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuX3NvcnQoKTtcbiAgICAgICAgSG9lay5hc3NlcnQoIWVycm9yLCAnaXRlbScsIChncm91cCAhPT0gJz8nID8gYGFkZGVkIGludG8gZ3JvdXAgJHtncm91cH1gIDogJycpLCAnY3JlYXRlZCBhIGRlcGVuZGVuY2llcyBlcnJvcicpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVzO1xuICAgIH1cblxuICAgIG1lcmdlKG90aGVycykge1xuXG4gICAgICAgIG90aGVycyA9IFtdLmNvbmNhdChvdGhlcnMpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG90aGVycy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29uc3Qgb3RoZXIgPSBvdGhlcnNbaV07XG4gICAgICAgICAgICBpZiAob3RoZXIpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG90aGVyLl9pdGVtcy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gT2JqZWN0LmFzc2lnbih7fSwgb3RoZXIuX2l0ZW1zW2pdKTsgICAgICAgIC8vIFNoYWxsb3cgY2xvbmVkXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2l0ZW1zLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU29ydCBpdGVtc1xuXG4gICAgICAgIHRoaXMuX2l0ZW1zLnNvcnQoaW50ZXJuYWxzLm1lcmdlU29ydCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5faXRlbXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHRoaXMuX2l0ZW1zW2ldLnNlcSA9IGk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuX3NvcnQoKTtcbiAgICAgICAgSG9lay5hc3NlcnQoIWVycm9yLCAnbWVyZ2UgY3JlYXRlZCBhIGRlcGVuZGVuY2llcyBlcnJvcicpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVzO1xuICAgIH1cblxuICAgIF9zb3J0KCkge1xuXG4gICAgICAgIC8vIENvbnN0cnVjdCBncmFwaFxuXG4gICAgICAgIGNvbnN0IGdyYXBoID0ge307XG4gICAgICAgIGNvbnN0IGdyYXBoQWZ0ZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTsgLy8gQSBwcm90b3R5cGUgY2FuIGJ1bmdsZSBsb29rdXBzIHcvIGZhbHNlIHBvc2l0aXZlc1xuICAgICAgICBjb25zdCBncm91cHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5faXRlbXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLl9pdGVtc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IHNlcSA9IGl0ZW0uc2VxOyAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVbmlxdWUgYWNyb3NzIGFsbCBpdGVtc1xuICAgICAgICAgICAgY29uc3QgZ3JvdXAgPSBpdGVtLmdyb3VwO1xuXG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgR3JvdXBzXG5cbiAgICAgICAgICAgIGdyb3Vwc1tncm91cF0gPSBncm91cHNbZ3JvdXBdIHx8IFtdO1xuICAgICAgICAgICAgZ3JvdXBzW2dyb3VwXS5wdXNoKHNlcSk7XG5cbiAgICAgICAgICAgIC8vIEJ1aWxkIGludGVybWVkaWFyeSBncmFwaCB1c2luZyAnYmVmb3JlJ1xuXG4gICAgICAgICAgICBncmFwaFtzZXFdID0gaXRlbS5iZWZvcmU7XG5cbiAgICAgICAgICAgIC8vIEJ1aWxkIHNlY29uZCBpbnRlcm1lZGlhcnkgZ3JhcGggd2l0aCAnYWZ0ZXInXG5cbiAgICAgICAgICAgIGNvbnN0IGFmdGVyID0gaXRlbS5hZnRlcjtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgYWZ0ZXIubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICBncmFwaEFmdGVyc1thZnRlcltqXV0gPSAoZ3JhcGhBZnRlcnNbYWZ0ZXJbal1dIHx8IFtdKS5jb25jYXQoc2VxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEV4cGFuZCBpbnRlcm1lZGlhcnkgZ3JhcGhcblxuICAgICAgICBsZXQgZ3JhcGhOb2RlcyA9IE9iamVjdC5rZXlzKGdyYXBoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBncmFwaE5vZGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gZ3JhcGhOb2Rlc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IGV4cGFuZGVkR3JvdXBzID0gW107XG5cbiAgICAgICAgICAgIGNvbnN0IGdyYXBoTm9kZUl0ZW1zID0gT2JqZWN0LmtleXMoZ3JhcGhbbm9kZV0pO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBncmFwaE5vZGVJdGVtcy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGdyb3VwID0gZ3JhcGhbbm9kZV1bZ3JhcGhOb2RlSXRlbXNbal1dO1xuICAgICAgICAgICAgICAgIGdyb3Vwc1tncm91cF0gPSBncm91cHNbZ3JvdXBdIHx8IFtdO1xuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBncm91cHNbZ3JvdXBdLmxlbmd0aDsgKytrKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cGFuZGVkR3JvdXBzLnB1c2goZ3JvdXBzW2dyb3VwXVtrXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBncmFwaFtub2RlXSA9IGV4cGFuZGVkR3JvdXBzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTWVyZ2UgaW50ZXJtZWRpYXJ5IGdyYXBoIHVzaW5nIGdyYXBoQWZ0ZXJzIGludG8gZmluYWwgZ3JhcGhcblxuICAgICAgICBjb25zdCBhZnRlck5vZGVzID0gT2JqZWN0LmtleXMoZ3JhcGhBZnRlcnMpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFmdGVyTm9kZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGdyb3VwID0gYWZ0ZXJOb2Rlc1tpXTtcblxuICAgICAgICAgICAgaWYgKGdyb3Vwc1tncm91cF0pIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGdyb3Vwc1tncm91cF0ubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IGdyb3Vwc1tncm91cF1bal07XG4gICAgICAgICAgICAgICAgICAgIGdyYXBoW25vZGVdID0gZ3JhcGhbbm9kZV0uY29uY2F0KGdyYXBoQWZ0ZXJzW2dyb3VwXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29tcGlsZSBhbmNlc3RvcnNcblxuICAgICAgICBsZXQgY2hpbGRyZW47XG4gICAgICAgIGNvbnN0IGFuY2VzdG9ycyA9IHt9O1xuICAgICAgICBncmFwaE5vZGVzID0gT2JqZWN0LmtleXMoZ3JhcGgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdyYXBoTm9kZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBncmFwaE5vZGVzW2ldO1xuICAgICAgICAgICAgY2hpbGRyZW4gPSBncmFwaFtub2RlXTtcblxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjaGlsZHJlbi5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgIGFuY2VzdG9yc1tjaGlsZHJlbltqXV0gPSAoYW5jZXN0b3JzW2NoaWxkcmVuW2pdXSB8fCBbXSkuY29uY2F0KG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVG9wbyBzb3J0XG5cbiAgICAgICAgY29uc3QgdmlzaXRlZCA9IHt9O1xuICAgICAgICBjb25zdCBzb3J0ZWQgPSBbXTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2l0ZW1zLmxlbmd0aDsgKytpKSB7ICAgICAgICAgIC8vIFJlYWxseSBsb29waW5nIHRocnUgaXRlbS5zZXEgdmFsdWVzIG91dCBvZiBvcmRlclxuICAgICAgICAgICAgbGV0IG5leHQgPSBpO1xuXG4gICAgICAgICAgICBpZiAoYW5jZXN0b3JzW2ldKSB7XG4gICAgICAgICAgICAgICAgbmV4dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLl9pdGVtcy5sZW5ndGg7ICsraikgeyAgLy8gQXMgYWJvdmUsIHRoZXNlIGFyZSBpdGVtLnNlcSB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZpc2l0ZWRbal0gPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhbmNlc3RvcnNbal0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuY2VzdG9yc1tqXSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2hvdWxkU2VlQ291bnQgPSBhbmNlc3RvcnNbal0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBsZXQgc2VlbkNvdW50ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBzaG91bGRTZWVDb3VudDsgKytrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmlzaXRlZFthbmNlc3RvcnNbal1ba11dKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKytzZWVuQ291bnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VlbkNvdW50ID09PSBzaG91bGRTZWVDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCA9IGo7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG5leHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2aXNpdGVkW25leHRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzb3J0ZWQucHVzaChuZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzb3J0ZWQubGVuZ3RoICE9PSB0aGlzLl9pdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoJ0ludmFsaWQgZGVwZW5kZW5jaWVzJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzZXFJbmRleCA9IHt9O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2l0ZW1zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5faXRlbXNbaV07XG4gICAgICAgICAgICBzZXFJbmRleFtpdGVtLnNlcV0gPSBpdGVtO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc29ydGVkTm9kZXMgPSBbXTtcbiAgICAgICAgdGhpcy5faXRlbXMgPSBzb3J0ZWQubWFwKCh2YWx1ZSkgPT4ge1xuXG4gICAgICAgICAgICBjb25zdCBzb3J0ZWRJdGVtID0gc2VxSW5kZXhbdmFsdWVdO1xuICAgICAgICAgICAgc29ydGVkTm9kZXMucHVzaChzb3J0ZWRJdGVtLm5vZGUpO1xuICAgICAgICAgICAgcmV0dXJuIHNvcnRlZEl0ZW07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMubm9kZXMgPSBzb3J0ZWROb2RlcztcbiAgICB9XG59O1xuXG5pbnRlcm5hbHMubWVyZ2VTb3J0ID0gKGEsIGIpID0+IHtcblxuICAgIHJldHVybiBhLnNvcnQgPT09IGIuc29ydCA/IDAgOiAoYS5zb3J0IDwgYi5zb3J0ID8gLTEgOiAxKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IFR5cGVzID0gcmVxdWlyZSgnLi90eXBlcycpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICBtaXNtYXRjaGVkOiBudWxsXG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaiwgcmVmLCBvcHRpb25zKSB7XG5cbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7IHByb3RvdHlwZTogdHJ1ZSB9LCBvcHRpb25zKTtcblxuICAgIHJldHVybiAhIWludGVybmFscy5pc0RlZXBFcXVhbChvYmosIHJlZiwgb3B0aW9ucywgW10pO1xufTtcblxuXG5pbnRlcm5hbHMuaXNEZWVwRXF1YWwgPSBmdW5jdGlvbiAob2JqLCByZWYsIG9wdGlvbnMsIHNlZW4pIHtcblxuICAgIGlmIChvYmogPT09IHJlZikgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29waWVkIGZyb20gRGVlcC1lcWwsIGNvcHlyaWdodChjKSAyMDEzIEpha2UgTHVlciwgamFrZUBhbG9naWNhbHBhcmFkb3guY29tLCBNSVQgTGljZW5zZWQsIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFpanMvZGVlcC1lcWxcbiAgICAgICAgcmV0dXJuIG9iaiAhPT0gMCB8fCAxIC8gb2JqID09PSAxIC8gcmVmO1xuICAgIH1cblxuICAgIGNvbnN0IHR5cGUgPSB0eXBlb2Ygb2JqO1xuXG4gICAgaWYgKHR5cGUgIT09IHR5cGVvZiByZWYpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICh0eXBlICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICBvYmogPT09IG51bGwgfHxcbiAgICAgICAgcmVmID09PSBudWxsKSB7XG5cbiAgICAgICAgcmV0dXJuIG9iaiAhPT0gb2JqICYmIHJlZiAhPT0gcmVmOyAgICAgICAgICAgICAgICAgIC8vIE5hTlxuICAgIH1cblxuICAgIGNvbnN0IGluc3RhbmNlVHlwZSA9IGludGVybmFscy5nZXRTaGFyZWRUeXBlKG9iaiwgcmVmLCAhIW9wdGlvbnMucHJvdG90eXBlKTtcbiAgICBzd2l0Y2ggKGluc3RhbmNlVHlwZSkge1xuICAgICAgICBjYXNlIFR5cGVzLmJ1ZmZlcjpcbiAgICAgICAgICAgIHJldHVybiBCdWZmZXIucHJvdG90eXBlLmVxdWFscy5jYWxsKG9iaiwgcmVmKTtcbiAgICAgICAgY2FzZSBUeXBlcy5wcm9taXNlOlxuICAgICAgICAgICAgcmV0dXJuIG9iaiA9PT0gcmVmO1xuICAgICAgICBjYXNlIFR5cGVzLnJlZ2V4OlxuICAgICAgICAgICAgcmV0dXJuIG9iai50b1N0cmluZygpID09PSByZWYudG9TdHJpbmcoKTtcbiAgICAgICAgY2FzZSBpbnRlcm5hbHMubWlzbWF0Y2hlZDpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gc2Vlbi5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICBpZiAoc2VlbltpXS5pc1NhbWUob2JqLCByZWYpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBwcmV2aW91cyBjb21wYXJpc29uIGZhaWxlZCwgaXQgd291bGQgaGF2ZSBzdG9wcGVkIGV4ZWN1dGlvblxuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2Vlbi5wdXNoKG5ldyBpbnRlcm5hbHMuU2VlbkVudHJ5KG9iaiwgcmVmKSk7XG5cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gISFpbnRlcm5hbHMuaXNEZWVwRXF1YWxPYmooaW5zdGFuY2VUeXBlLCBvYmosIHJlZiwgb3B0aW9ucywgc2Vlbik7XG4gICAgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICBzZWVuLnBvcCgpO1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLmdldFNoYXJlZFR5cGUgPSBmdW5jdGlvbiAob2JqLCByZWYsIGNoZWNrUHJvdG90eXBlKSB7XG5cbiAgICBpZiAoY2hlY2tQcm90b3R5cGUpIHtcbiAgICAgICAgaWYgKE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopICE9PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocmVmKSkge1xuICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5taXNtYXRjaGVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFR5cGVzLmdldEludGVybmFsUHJvdG8ob2JqKTtcbiAgICB9XG5cbiAgICBjb25zdCB0eXBlID0gVHlwZXMuZ2V0SW50ZXJuYWxQcm90byhvYmopO1xuICAgIGlmICh0eXBlICE9PSBUeXBlcy5nZXRJbnRlcm5hbFByb3RvKHJlZikpIHtcbiAgICAgICAgcmV0dXJuIGludGVybmFscy5taXNtYXRjaGVkO1xuICAgIH1cblxuICAgIHJldHVybiB0eXBlO1xufTtcblxuXG5pbnRlcm5hbHMudmFsdWVPZiA9IGZ1bmN0aW9uIChvYmopIHtcblxuICAgIGNvbnN0IG9ialZhbHVlT2YgPSBvYmoudmFsdWVPZjtcbiAgICBpZiAob2JqVmFsdWVPZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG9ialZhbHVlT2YuY2FsbChvYmopO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiBlcnI7XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMuaGFzT3duRW51bWVyYWJsZVByb3BlcnR5ID0gZnVuY3Rpb24gKG9iaiwga2V5KSB7XG5cbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iaiwga2V5KTtcbn07XG5cblxuaW50ZXJuYWxzLmlzU2V0U2ltcGxlRXF1YWwgPSBmdW5jdGlvbiAob2JqLCByZWYpIHtcblxuICAgIGZvciAoY29uc3QgZW50cnkgb2Ygb2JqKSB7XG4gICAgICAgIGlmICghcmVmLmhhcyhlbnRyeSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufTtcblxuXG5pbnRlcm5hbHMuaXNEZWVwRXF1YWxPYmogPSBmdW5jdGlvbiAoaW5zdGFuY2VUeXBlLCBvYmosIHJlZiwgb3B0aW9ucywgc2Vlbikge1xuXG4gICAgY29uc3QgeyBpc0RlZXBFcXVhbCwgdmFsdWVPZiwgaGFzT3duRW51bWVyYWJsZVByb3BlcnR5IH0gPSBpbnRlcm5hbHM7XG4gICAgY29uc3QgeyBrZXlzLCBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgfSA9IE9iamVjdDtcblxuICAgIGlmIChpbnN0YW5jZVR5cGUgPT09IFR5cGVzLmFycmF5KSB7XG4gICAgICAgIGlmIChvcHRpb25zLnBhcnQpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIGFueSBpbmRleCBtYXRjaCBhbnkgb3RoZXIgaW5kZXhcblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvYmoubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvYmpWYWx1ZSA9IG9ialtpXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHJlZi5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNEZWVwRXF1YWwob2JqVmFsdWUsIHJlZltqXSwgb3B0aW9ucywgc2VlbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKG9iai5sZW5ndGggIT09IHJlZi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb2JqLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc0RlZXBFcXVhbChvYmpbaV0sIHJlZltpXSwgb3B0aW9ucywgc2VlbikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoaW5zdGFuY2VUeXBlID09PSBUeXBlcy5zZXQpIHtcbiAgICAgICAgaWYgKG9iai5zaXplICE9PSByZWYuc2l6ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpbnRlcm5hbHMuaXNTZXRTaW1wbGVFcXVhbChvYmosIHJlZikpIHtcblxuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGRlZXAgZXF1YWxpdHlcblxuICAgICAgICAgICAgY29uc3QgcmVmMiA9IG5ldyBTZXQocmVmKTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgb2JqRW50cnkgb2Ygb2JqKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlZjIuZGVsZXRlKG9iakVudHJ5KSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHJlZkVudHJ5IG9mIHJlZjIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRGVlcEVxdWFsKG9iakVudHJ5LCByZWZFbnRyeSwgb3B0aW9ucywgc2VlbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZjIuZGVsZXRlKHJlZkVudHJ5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFmb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGluc3RhbmNlVHlwZSA9PT0gVHlwZXMubWFwKSB7XG4gICAgICAgIGlmIChvYmouc2l6ZSAhPT0gcmVmLnNpemUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIG9iaikge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIXJlZi5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFpc0RlZXBFcXVhbCh2YWx1ZSwgcmVmLmdldChrZXkpLCBvcHRpb25zLCBzZWVuKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChpbnN0YW5jZVR5cGUgPT09IFR5cGVzLmVycm9yKSB7XG4gICAgICAgIC8vIEFsd2F5cyBjaGVjayBuYW1lIGFuZCBtZXNzYWdlXG5cbiAgICAgICAgaWYgKG9iai5uYW1lICE9PSByZWYubmFtZSB8fCBvYmoubWVzc2FnZSAhPT0gcmVmLm1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIENoZWNrIC52YWx1ZU9mKClcblxuICAgIGNvbnN0IHZhbHVlT2ZPYmogPSB2YWx1ZU9mKG9iaik7XG4gICAgY29uc3QgdmFsdWVPZlJlZiA9IHZhbHVlT2YocmVmKTtcbiAgICBpZiAoIShvYmogPT09IHZhbHVlT2ZPYmogJiYgcmVmID09PSB2YWx1ZU9mUmVmKSAmJlxuICAgICAgICAhaXNEZWVwRXF1YWwodmFsdWVPZk9iaiwgdmFsdWVPZlJlZiwgb3B0aW9ucywgc2VlbikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIENoZWNrIHByb3BlcnRpZXNcblxuICAgIGNvbnN0IG9iaktleXMgPSBrZXlzKG9iaik7XG4gICAgaWYgKCFvcHRpb25zLnBhcnQgJiZcbiAgICAgICAgb2JqS2V5cy5sZW5ndGggIT09IGtleXMocmVmKS5sZW5ndGgpIHtcblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvYmpLZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IG9iaktleXNbaV07XG5cbiAgICAgICAgaWYgKCFoYXNPd25FbnVtZXJhYmxlUHJvcGVydHkocmVmLCBrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzRGVlcEVxdWFsKG9ialtrZXldLCByZWZba2V5XSwgb3B0aW9ucywgc2VlbikpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIENoZWNrIHN5bWJvbHNcblxuICAgIGlmIChvcHRpb25zLnN5bWJvbHMgIT09IGZhbHNlKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEZWZhdWx0cyB0byB0cnVlXG4gICAgICAgIGNvbnN0IG9ialN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqKTtcbiAgICAgICAgY29uc3QgcmVmU3ltYm9scyA9IG5ldyBTZXQoZ2V0T3duUHJvcGVydHlTeW1ib2xzKHJlZikpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb2JqU3ltYm9scy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gb2JqU3ltYm9sc1tpXTtcblxuICAgICAgICAgICAgaWYgKGhhc093bkVudW1lcmFibGVQcm9wZXJ0eShvYmosIGtleSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWhhc093bkVudW1lcmFibGVQcm9wZXJ0eShyZWYsIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghaXNEZWVwRXF1YWwob2JqW2tleV0sIHJlZltrZXldLCBvcHRpb25zLCBzZWVuKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaGFzT3duRW51bWVyYWJsZVByb3BlcnR5KHJlZiwga2V5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVmU3ltYm9scy5kZWxldGUoa2V5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHJlZlN5bWJvbHMpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25FbnVtZXJhYmxlUHJvcGVydHkocmVmLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5cbmludGVybmFscy5TZWVuRW50cnkgPSBjbGFzcyB7XG5cbiAgICBjb25zdHJ1Y3RvcihvYmosIHJlZikge1xuXG4gICAgICAgIHRoaXMub2JqID0gb2JqO1xuICAgICAgICB0aGlzLnJlZiA9IHJlZjtcbiAgICB9XG5cbiAgICBpc1NhbWUob2JqLCByZWYpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5vYmogPT09IG9iaiAmJiB0aGlzLnJlZiA9PT0gcmVmO1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbmV4cG9ydHMuZXNjYXBlSHRtbCA9IGZ1bmN0aW9uIChpbnB1dCkge1xuXG4gICAgaWYgKCFpbnB1dCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgbGV0IGVzY2FwZWQgPSAnJztcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyArK2kpIHtcblxuICAgICAgICBjb25zdCBjaGFyQ29kZSA9IGlucHV0LmNoYXJDb2RlQXQoaSk7XG5cbiAgICAgICAgaWYgKGludGVybmFscy5pc1NhZmUoY2hhckNvZGUpKSB7XG4gICAgICAgICAgICBlc2NhcGVkICs9IGlucHV0W2ldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZXNjYXBlZCArPSBpbnRlcm5hbHMuZXNjYXBlSHRtbENoYXIoY2hhckNvZGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGVzY2FwZWQ7XG59O1xuXG5cbmV4cG9ydHMuZXNjYXBlSnNvbiA9IGZ1bmN0aW9uIChpbnB1dCkge1xuXG4gICAgaWYgKCFpbnB1dCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgY29uc3QgbGVzc1RoYW4gPSAweDNDO1xuICAgIGNvbnN0IGdyZWF0ZXJUaGFuID0gMHgzRTtcbiAgICBjb25zdCBhbmRTeW1ib2wgPSAweDI2O1xuICAgIGNvbnN0IGxpbmVTZXBlcmF0b3IgPSAweDIwMjg7XG5cbiAgICAvLyByZXBsYWNlIG1ldGhvZFxuICAgIGxldCBjaGFyQ29kZTtcbiAgICByZXR1cm4gaW5wdXQucmVwbGFjZSgvWzw+JlxcdTIwMjhcXHUyMDI5XS9nLCAobWF0Y2gpID0+IHtcblxuICAgICAgICBjaGFyQ29kZSA9IG1hdGNoLmNoYXJDb2RlQXQoMCk7XG5cbiAgICAgICAgaWYgKGNoYXJDb2RlID09PSBsZXNzVGhhbikge1xuICAgICAgICAgICAgcmV0dXJuICdcXFxcdTAwM2MnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoYXJDb2RlID09PSBncmVhdGVyVGhhbikge1xuICAgICAgICAgICAgcmV0dXJuICdcXFxcdTAwM2UnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoYXJDb2RlID09PSBhbmRTeW1ib2wpIHtcbiAgICAgICAgICAgIHJldHVybiAnXFxcXHUwMDI2JztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjaGFyQ29kZSA9PT0gbGluZVNlcGVyYXRvcikge1xuICAgICAgICAgICAgcmV0dXJuICdcXFxcdTIwMjgnO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICdcXFxcdTIwMjknO1xuICAgIH0pO1xufTtcblxuXG5pbnRlcm5hbHMuZXNjYXBlSHRtbENoYXIgPSBmdW5jdGlvbiAoY2hhckNvZGUpIHtcblxuICAgIGNvbnN0IG5hbWVkRXNjYXBlID0gaW50ZXJuYWxzLm5hbWVkSHRtbFtjaGFyQ29kZV07XG4gICAgaWYgKHR5cGVvZiBuYW1lZEVzY2FwZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIG5hbWVkRXNjYXBlO1xuICAgIH1cblxuICAgIGlmIChjaGFyQ29kZSA+PSAyNTYpIHtcbiAgICAgICAgcmV0dXJuICcmIycgKyBjaGFyQ29kZSArICc7JztcbiAgICB9XG5cbiAgICBjb25zdCBoZXhWYWx1ZSA9IEJ1ZmZlci5mcm9tKFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpLCAnYXNjaWknKS50b1N0cmluZygnaGV4Jyk7XG4gICAgcmV0dXJuIGAmI3gke2hleFZhbHVlfTtgO1xufTtcblxuXG5pbnRlcm5hbHMuaXNTYWZlID0gZnVuY3Rpb24gKGNoYXJDb2RlKSB7XG5cbiAgICByZXR1cm4gKHR5cGVvZiBpbnRlcm5hbHMuc2FmZUNoYXJDb2Rlc1tjaGFyQ29kZV0gIT09ICd1bmRlZmluZWQnKTtcbn07XG5cblxuaW50ZXJuYWxzLm5hbWVkSHRtbCA9IHtcbiAgICAnMzgnOiAnJmFtcDsnLFxuICAgICc2MCc6ICcmbHQ7JyxcbiAgICAnNjInOiAnJmd0OycsXG4gICAgJzM0JzogJyZxdW90OycsXG4gICAgJzE2MCc6ICcmbmJzcDsnLFxuICAgICcxNjInOiAnJmNlbnQ7JyxcbiAgICAnMTYzJzogJyZwb3VuZDsnLFxuICAgICcxNjQnOiAnJmN1cnJlbjsnLFxuICAgICcxNjknOiAnJmNvcHk7JyxcbiAgICAnMTc0JzogJyZyZWc7J1xufTtcblxuXG5pbnRlcm5hbHMuc2FmZUNoYXJDb2RlcyA9IChmdW5jdGlvbiAoKSB7XG5cbiAgICBjb25zdCBzYWZlID0ge307XG5cbiAgICBmb3IgKGxldCBpID0gMzI7IGkgPCAxMjM7ICsraSkge1xuXG4gICAgICAgIGlmICgoaSA+PSA5NykgfHwgICAgICAgICAgICAgICAgICAgIC8vIGEtelxuICAgICAgICAgICAgKGkgPj0gNjUgJiYgaSA8PSA5MCkgfHwgICAgICAgICAvLyBBLVpcbiAgICAgICAgICAgIChpID49IDQ4ICYmIGkgPD0gNTcpIHx8ICAgICAgICAgLy8gMC05XG4gICAgICAgICAgICBpID09PSAzMiB8fCAgICAgICAgICAgICAgICAgICAgIC8vIHNwYWNlXG4gICAgICAgICAgICBpID09PSA0NiB8fCAgICAgICAgICAgICAgICAgICAgIC8vIC5cbiAgICAgICAgICAgIGkgPT09IDQ0IHx8ICAgICAgICAgICAgICAgICAgICAgLy8gLFxuICAgICAgICAgICAgaSA9PT0gNDUgfHwgICAgICAgICAgICAgICAgICAgICAvLyAtXG4gICAgICAgICAgICBpID09PSA1OCB8fCAgICAgICAgICAgICAgICAgICAgIC8vIDpcbiAgICAgICAgICAgIGkgPT09IDk1KSB7ICAgICAgICAgICAgICAgICAgICAgLy8gX1xuXG4gICAgICAgICAgICBzYWZlW2ldID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzYWZlO1xufSgpKTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgRGVlcEVxdWFsID0gcmVxdWlyZSgnLi9kZWVwLWVxdWFsJyk7XG5jb25zdCBFc2NhcGUgPSByZXF1aXJlKCcuL2VzY2FwZScpO1xuY29uc3QgVHlwZXMgPSByZXF1aXJlKCcuL3R5cGVzJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge1xuICAgIG5lZWRzUHJvdG9IYWNrOiBuZXcgU2V0KFtUeXBlcy5zZXQsIFR5cGVzLm1hcCwgVHlwZXMud2Vha1NldCwgVHlwZXMud2Vha01hcF0pXG59O1xuXG5cbi8vIERlZXAgb2JqZWN0IG9yIGFycmF5IGNvbXBhcmlzb25cblxuZXhwb3J0cy5kZWVwRXF1YWwgPSBEZWVwRXF1YWw7XG5cblxuLy8gQ2xvbmUgb2JqZWN0IG9yIGFycmF5XG5cbmV4cG9ydHMuY2xvbmUgPSBmdW5jdGlvbiAob2JqLCBvcHRpb25zID0ge30sIF9zZWVuID0gbnVsbCkge1xuXG4gICAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnIHx8XG4gICAgICAgIG9iaiA9PT0gbnVsbCkge1xuXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgbGV0IGNsb25lID0gZXhwb3J0cy5jbG9uZTtcbiAgICBsZXQgc2VlbiA9IF9zZWVuO1xuXG4gICAgaWYgKG9wdGlvbnMuc2hhbGxvdykge1xuICAgICAgICBpZiAob3B0aW9ucy5zaGFsbG93ICE9PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmNsb25lV2l0aFNoYWxsb3cob2JqLCBvcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNsb25lID0gKHZhbHVlKSA9PiB2YWx1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHNlZW4gPSBzZWVuIHx8IG5ldyBNYXAoKTtcblxuICAgICAgICBjb25zdCBsb29rdXAgPSBzZWVuLmdldChvYmopO1xuICAgICAgICBpZiAobG9va3VwKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9va3VwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgYmFzZVByb3RvID0gVHlwZXMuZ2V0SW50ZXJuYWxQcm90byhvYmopO1xuICAgIGxldCBuZXdPYmo7XG5cbiAgICBzd2l0Y2ggKGJhc2VQcm90bykge1xuICAgICAgICBjYXNlIFR5cGVzLmJ1ZmZlcjpcbiAgICAgICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShvYmopO1xuXG4gICAgICAgIGNhc2UgVHlwZXMuZGF0ZTpcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShvYmouZ2V0VGltZSgpKTtcblxuICAgICAgICBjYXNlIFR5cGVzLnJlZ2V4OlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAob2JqKTtcblxuICAgICAgICBjYXNlIFR5cGVzLmFycmF5OlxuICAgICAgICAgICAgbmV3T2JqID0gW107XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaWYgKG9wdGlvbnMucHJvdG90eXBlICE9PSBmYWxzZSkgeyAgICAgICAgICAgICAgLy8gRGVmYXVsdHMgdG8gdHJ1ZVxuICAgICAgICAgICAgICAgIGNvbnN0IHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaik7XG4gICAgICAgICAgICAgICAgaWYgKHByb3RvICYmXG4gICAgICAgICAgICAgICAgICAgIHByb3RvLmlzSW1tdXRhYmxlKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJuYWxzLm5lZWRzUHJvdG9IYWNrLmhhcyhiYXNlUHJvdG8pKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld09iaiA9IG5ldyBwcm90by5jb25zdHJ1Y3RvcigpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJvdG8gIT09IGJhc2VQcm90bykge1xuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKG5ld09iaiwgcHJvdG8pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuZXdPYmogPSBPYmplY3QuY3JlYXRlKHByb3RvKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpbnRlcm5hbHMubmVlZHNQcm90b0hhY2suaGFzKGJhc2VQcm90bykpIHtcbiAgICAgICAgICAgICAgICBuZXdPYmogPSBuZXcgYmFzZVByb3RvLmNvbnN0cnVjdG9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXdPYmogPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2Vlbikge1xuICAgICAgICBzZWVuLnNldChvYmosIG5ld09iaik7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2V0IHNlZW4sIHNpbmNlIG9iaiBjb3VsZCByZWN1cnNlXG4gICAgfVxuXG4gICAgaWYgKGJhc2VQcm90byA9PT0gVHlwZXMuc2V0KSB7XG4gICAgICAgIGZvciAoY29uc3QgdmFsdWUgb2Ygb2JqKSB7XG4gICAgICAgICAgICBuZXdPYmouYWRkKGNsb25lKHZhbHVlLCBvcHRpb25zLCBzZWVuKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoYmFzZVByb3RvID09PSBUeXBlcy5tYXApIHtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2Ygb2JqKSB7XG4gICAgICAgICAgICBuZXdPYmouc2V0KGtleSwgY2xvbmUodmFsdWUsIG9wdGlvbnMsIHNlZW4pKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGtleXMgPSBpbnRlcm5hbHMua2V5cyhvYmosIG9wdGlvbnMpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChiYXNlUHJvdG8gPT09IFR5cGVzLmFycmF5ICYmXG4gICAgICAgICAgICBrZXkgPT09ICdsZW5ndGgnKSB7XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpO1xuICAgICAgICBpZiAoZGVzY3JpcHRvciAmJlxuICAgICAgICAgICAgKGRlc2NyaXB0b3IuZ2V0IHx8IGRlc2NyaXB0b3Iuc2V0KSkge1xuXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2NyaXB0b3IpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZGVzY3JpcHRvciA/IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA6IHRydWUsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBjbG9uZShvYmpba2V5XSwgb3B0aW9ucywgc2VlbilcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGJhc2VQcm90byA9PT0gVHlwZXMuYXJyYXkpIHtcbiAgICAgICAgbmV3T2JqLmxlbmd0aCA9IG9iai5sZW5ndGg7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld09iajtcbn07XG5cblxuaW50ZXJuYWxzLmtleXMgPSBmdW5jdGlvbiAob2JqLCBvcHRpb25zID0ge30pIHtcblxuICAgIHJldHVybiBvcHRpb25zLnN5bWJvbHMgIT09IGZhbHNlID8gUmVmbGVjdC5vd25LZXlzKG9iaikgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopOyAgLy8gRGVmYXVsdHMgdG8gdHJ1ZVxufTtcblxuXG5pbnRlcm5hbHMuY2xvbmVXaXRoU2hhbGxvdyA9IGZ1bmN0aW9uIChzb3VyY2UsIG9wdGlvbnMpIHtcblxuICAgIGNvbnN0IGtleXMgPSBvcHRpb25zLnNoYWxsb3c7XG4gICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpO1xuICAgIG9wdGlvbnMuc2hhbGxvdyA9IGZhbHNlO1xuXG4gICAgY29uc3Qgc3RvcmFnZSA9IGludGVybmFscy5zdG9yZShzb3VyY2UsIGtleXMpOyAgICAvLyBNb3ZlIHNoYWxsb3cgY29weSBpdGVtcyB0byBzdG9yYWdlXG4gICAgY29uc3QgY29weSA9IGV4cG9ydHMuY2xvbmUoc291cmNlLCBvcHRpb25zKTsgICAgICAvLyBEZWVwIGNvcHkgdGhlIHJlc3RcbiAgICBpbnRlcm5hbHMucmVzdG9yZShjb3B5LCBzb3VyY2UsIHN0b3JhZ2UpOyAgICAgICAgIC8vIFNoYWxsb3cgY29weSB0aGUgc3RvcmVkIGl0ZW1zIGFuZCByZXN0b3JlXG4gICAgcmV0dXJuIGNvcHk7XG59O1xuXG5cbmludGVybmFscy5zdG9yZSA9IGZ1bmN0aW9uIChzb3VyY2UsIGtleXMpIHtcblxuICAgIGNvbnN0IHN0b3JhZ2UgPSBuZXcgTWFwKCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZXhwb3J0cy5yZWFjaChzb3VyY2UsIGtleSk7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnIHx8XG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcblxuICAgICAgICAgICAgc3RvcmFnZS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICBpbnRlcm5hbHMucmVhY2hTZXQoc291cmNlLCBrZXksIHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3RvcmFnZTtcbn07XG5cblxuaW50ZXJuYWxzLnJlc3RvcmUgPSBmdW5jdGlvbiAoY29weSwgc291cmNlLCBzdG9yYWdlKSB7XG5cbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBzdG9yYWdlKSB7XG4gICAgICAgIGludGVybmFscy5yZWFjaFNldChjb3B5LCBrZXksIHZhbHVlKTtcbiAgICAgICAgaW50ZXJuYWxzLnJlYWNoU2V0KHNvdXJjZSwga2V5LCB2YWx1ZSk7XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMucmVhY2hTZXQgPSBmdW5jdGlvbiAob2JqLCBrZXksIHZhbHVlKSB7XG5cbiAgICBjb25zdCBwYXRoID0gQXJyYXkuaXNBcnJheShrZXkpID8ga2V5IDoga2V5LnNwbGl0KCcuJyk7XG4gICAgbGV0IHJlZiA9IG9iajtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3Qgc2VnbWVudCA9IHBhdGhbaV07XG4gICAgICAgIGlmIChpICsgMSA9PT0gcGF0aC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJlZltzZWdtZW50XSA9IHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVmID0gcmVmW3NlZ21lbnRdO1xuICAgIH1cbn07XG5cblxuLy8gTWVyZ2UgYWxsIHRoZSBwcm9wZXJ0aWVzIG9mIHNvdXJjZSBpbnRvIHRhcmdldCwgc291cmNlIHdpbnMgaW4gY29uZmxpY3QsIGFuZCBieSBkZWZhdWx0IG51bGwgYW5kIHVuZGVmaW5lZCBmcm9tIHNvdXJjZSBhcmUgYXBwbGllZFxuXG5leHBvcnRzLm1lcmdlID0gZnVuY3Rpb24gKHRhcmdldCwgc291cmNlLCBvcHRpb25zKSB7XG5cbiAgICBleHBvcnRzLmFzc2VydCh0YXJnZXQgJiYgdHlwZW9mIHRhcmdldCA9PT0gJ29iamVjdCcsICdJbnZhbGlkIHRhcmdldCB2YWx1ZTogbXVzdCBiZSBhbiBvYmplY3QnKTtcbiAgICBleHBvcnRzLmFzc2VydChzb3VyY2UgPT09IG51bGwgfHwgc291cmNlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHNvdXJjZSA9PT0gJ29iamVjdCcsICdJbnZhbGlkIHNvdXJjZSB2YWx1ZTogbXVzdCBiZSBudWxsLCB1bmRlZmluZWQsIG9yIGFuIG9iamVjdCcpO1xuXG4gICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7IG51bGxPdmVycmlkZTogdHJ1ZSwgbWVyZ2VBcnJheXM6IHRydWUgfSwgb3B0aW9ucyk7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShzb3VyY2UpKSB7XG4gICAgICAgIGV4cG9ydHMuYXNzZXJ0KEFycmF5LmlzQXJyYXkodGFyZ2V0KSwgJ0Nhbm5vdCBtZXJnZSBhcnJheSBvbnRvIGFuIG9iamVjdCcpO1xuICAgICAgICBpZiAoIW9wdGlvbnMubWVyZ2VBcnJheXMpIHtcbiAgICAgICAgICAgIHRhcmdldC5sZW5ndGggPSAwOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNdXN0IG5vdCBjaGFuZ2UgdGFyZ2V0IGFzc2lnbm1lbnRcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc291cmNlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB0YXJnZXQucHVzaChleHBvcnRzLmNsb25lKHNvdXJjZVtpXSwgeyBzeW1ib2xzOiBvcHRpb25zLnN5bWJvbHMgfSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICBjb25zdCBrZXlzID0gaW50ZXJuYWxzLmtleXMoc291cmNlLCBvcHRpb25zKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgaWYgKGtleSA9PT0gJ19fcHJvdG9fXycgfHxcbiAgICAgICAgICAgICFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSB7XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdmFsdWUgPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgaWYgKHZhbHVlICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG5cbiAgICAgICAgICAgIGlmICghdGFyZ2V0W2tleV0gfHxcbiAgICAgICAgICAgICAgICB0eXBlb2YgdGFyZ2V0W2tleV0gIT09ICdvYmplY3QnIHx8XG4gICAgICAgICAgICAgICAgKEFycmF5LmlzQXJyYXkodGFyZ2V0W2tleV0pICE9PSBBcnJheS5pc0FycmF5KHZhbHVlKSkgfHxcbiAgICAgICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIERhdGUgfHxcbiAgICAgICAgICAgICAgICBCdWZmZXIuaXNCdWZmZXIodmFsdWUpIHx8XG4gICAgICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcblxuICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gZXhwb3J0cy5jbG9uZSh2YWx1ZSwgeyBzeW1ib2xzOiBvcHRpb25zLnN5bWJvbHMgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBleHBvcnRzLm1lcmdlKHRhcmdldFtrZXldLCB2YWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IG51bGwgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXhwbGljaXQgdG8gcHJlc2VydmUgZW1wdHkgc3RyaW5nc1xuXG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMubnVsbE92ZXJyaWRlKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG59O1xuXG5cbi8vIEFwcGx5IHNvdXJjZSB0byBhIGNvcHkgb2YgdGhlIGRlZmF1bHRzXG5cbmV4cG9ydHMuYXBwbHlUb0RlZmF1bHRzID0gZnVuY3Rpb24gKGRlZmF1bHRzLCBzb3VyY2UsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgZXhwb3J0cy5hc3NlcnQoZGVmYXVsdHMgJiYgdHlwZW9mIGRlZmF1bHRzID09PSAnb2JqZWN0JywgJ0ludmFsaWQgZGVmYXVsdHMgdmFsdWU6IG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gICAgZXhwb3J0cy5hc3NlcnQoIXNvdXJjZSB8fCBzb3VyY2UgPT09IHRydWUgfHwgdHlwZW9mIHNvdXJjZSA9PT0gJ29iamVjdCcsICdJbnZhbGlkIHNvdXJjZSB2YWx1ZTogbXVzdCBiZSB0cnVlLCBmYWxzeSBvciBhbiBvYmplY3QnKTtcbiAgICBleHBvcnRzLmFzc2VydCh0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcsICdJbnZhbGlkIG9wdGlvbnM6IG11c3QgYmUgYW4gb2JqZWN0Jyk7XG5cbiAgICBpZiAoIXNvdXJjZSkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgbm8gc291cmNlLCByZXR1cm4gbnVsbFxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5zaGFsbG93KSB7XG4gICAgICAgIHJldHVybiBpbnRlcm5hbHMuYXBwbHlUb0RlZmF1bHRzV2l0aFNoYWxsb3coZGVmYXVsdHMsIHNvdXJjZSwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgY29uc3QgY29weSA9IGV4cG9ydHMuY2xvbmUoZGVmYXVsdHMpO1xuXG4gICAgaWYgKHNvdXJjZSA9PT0gdHJ1ZSkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHNvdXJjZSBpcyBzZXQgdG8gdHJ1ZSwgdXNlIGRlZmF1bHRzXG4gICAgICAgIHJldHVybiBjb3B5O1xuICAgIH1cblxuICAgIGNvbnN0IG51bGxPdmVycmlkZSA9IG9wdGlvbnMubnVsbE92ZXJyaWRlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm51bGxPdmVycmlkZSA6IGZhbHNlO1xuICAgIHJldHVybiBleHBvcnRzLm1lcmdlKGNvcHksIHNvdXJjZSwgeyBudWxsT3ZlcnJpZGUsIG1lcmdlQXJyYXlzOiBmYWxzZSB9KTtcbn07XG5cblxuaW50ZXJuYWxzLmFwcGx5VG9EZWZhdWx0c1dpdGhTaGFsbG93ID0gZnVuY3Rpb24gKGRlZmF1bHRzLCBzb3VyY2UsIG9wdGlvbnMpIHtcblxuICAgIGNvbnN0IGtleXMgPSBvcHRpb25zLnNoYWxsb3c7XG4gICAgZXhwb3J0cy5hc3NlcnQoQXJyYXkuaXNBcnJheShrZXlzKSwgJ0ludmFsaWQga2V5cycpO1xuXG4gICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpO1xuICAgIG9wdGlvbnMuc2hhbGxvdyA9IGZhbHNlO1xuXG4gICAgY29uc3QgY29weSA9IGV4cG9ydHMuY2xvbmUoZGVmYXVsdHMsIHsgc2hhbGxvdzoga2V5cyB9KTtcblxuICAgIGlmIChzb3VyY2UgPT09IHRydWUpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBzb3VyY2UgaXMgc2V0IHRvIHRydWUsIHVzZSBkZWZhdWx0c1xuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9XG5cbiAgICBjb25zdCBzdG9yYWdlID0gaW50ZXJuYWxzLnN0b3JlKHNvdXJjZSwga2V5cyk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTW92ZSBzaGFsbG93IGNvcHkgaXRlbXMgdG8gc3RvcmFnZVxuICAgIGV4cG9ydHMubWVyZ2UoY29weSwgc291cmNlLCB7IG1lcmdlQXJyYXlzOiBmYWxzZSwgbnVsbE92ZXJyaWRlOiBmYWxzZSB9KTsgICAvLyBEZWVwIGNvcHkgdGhlIHJlc3RcbiAgICBpbnRlcm5hbHMucmVzdG9yZShjb3B5LCBzb3VyY2UsIHN0b3JhZ2UpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2hhbGxvdyBjb3B5IHRoZSBzdG9yZWQgaXRlbXMgYW5kIHJlc3RvcmVcbiAgICByZXR1cm4gY29weTtcbn07XG5cblxuLy8gRmluZCB0aGUgY29tbW9uIHVuaXF1ZSBpdGVtcyBpbiB0d28gYXJyYXlzXG5cbmV4cG9ydHMuaW50ZXJzZWN0ID0gZnVuY3Rpb24gKGFycmF5MSwgYXJyYXkyLCBvcHRpb25zID0ge30pIHtcblxuICAgIGlmICghYXJyYXkxIHx8XG4gICAgICAgICFhcnJheTIpIHtcblxuICAgICAgICByZXR1cm4gKG9wdGlvbnMuZmlyc3QgPyBudWxsIDogW10pO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbW1vbiA9IFtdO1xuICAgIGNvbnN0IGhhc2ggPSAoQXJyYXkuaXNBcnJheShhcnJheTEpID8gbmV3IFNldChhcnJheTEpIDogYXJyYXkxKTtcbiAgICBjb25zdCBmb3VuZCA9IG5ldyBTZXQoKTtcbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIGFycmF5Mikge1xuICAgICAgICBpZiAoaW50ZXJuYWxzLmhhcyhoYXNoLCB2YWx1ZSkgJiZcbiAgICAgICAgICAgICFmb3VuZC5oYXModmFsdWUpKSB7XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmZpcnN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb21tb24ucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICBmb3VuZC5hZGQodmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIChvcHRpb25zLmZpcnN0ID8gbnVsbCA6IGNvbW1vbik7XG59O1xuXG5cbmludGVybmFscy5oYXMgPSBmdW5jdGlvbiAocmVmLCBrZXkpIHtcblxuICAgIGlmICh0eXBlb2YgcmVmLmhhcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gcmVmLmhhcyhrZXkpO1xuICAgIH1cblxuICAgIHJldHVybiByZWZba2V5XSAhPT0gdW5kZWZpbmVkO1xufTtcblxuXG4vLyBUZXN0IGlmIHRoZSByZWZlcmVuY2UgY29udGFpbnMgdGhlIHZhbHVlc1xuXG5leHBvcnRzLmNvbnRhaW4gPSBmdW5jdGlvbiAocmVmLCB2YWx1ZXMsIG9wdGlvbnMgPSB7fSkgeyAgICAgICAgLy8gb3B0aW9uczogeyBkZWVwLCBvbmNlLCBvbmx5LCBwYXJ0LCBzeW1ib2xzIH1cblxuICAgIC8qXG4gICAgICAgIHN0cmluZyAtPiBzdHJpbmcocylcbiAgICAgICAgYXJyYXkgLT4gaXRlbShzKVxuICAgICAgICBvYmplY3QgLT4ga2V5KHMpXG4gICAgICAgIG9iamVjdCAtPiBvYmplY3QgKGtleTp2YWx1ZSlcbiAgICAqL1xuXG4gICAgbGV0IHZhbHVlUGFpcnMgPSBudWxsO1xuICAgIGlmICh0eXBlb2YgcmVmID09PSAnb2JqZWN0JyAmJlxuICAgICAgICB0eXBlb2YgdmFsdWVzID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAhQXJyYXkuaXNBcnJheShyZWYpICYmXG4gICAgICAgICFBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcblxuICAgICAgICB2YWx1ZVBhaXJzID0gdmFsdWVzO1xuICAgICAgICBjb25zdCBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh2YWx1ZXMpLmZpbHRlcihPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmJpbmQodmFsdWVzKSk7XG4gICAgICAgIHZhbHVlcyA9IFsuLi5PYmplY3Qua2V5cyh2YWx1ZXMpLCAuLi5zeW1ib2xzXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhbHVlcyA9IFtdLmNvbmNhdCh2YWx1ZXMpO1xuICAgIH1cblxuICAgIGV4cG9ydHMuYXNzZXJ0KHR5cGVvZiByZWYgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiByZWYgPT09ICdvYmplY3QnLCAnUmVmZXJlbmNlIG11c3QgYmUgc3RyaW5nIG9yIGFuIG9iamVjdCcpO1xuICAgIGV4cG9ydHMuYXNzZXJ0KHZhbHVlcy5sZW5ndGgsICdWYWx1ZXMgYXJyYXkgY2Fubm90IGJlIGVtcHR5Jyk7XG5cbiAgICBsZXQgY29tcGFyZTtcbiAgICBsZXQgY29tcGFyZUZsYWdzO1xuICAgIGlmIChvcHRpb25zLmRlZXApIHtcbiAgICAgICAgY29tcGFyZSA9IGV4cG9ydHMuZGVlcEVxdWFsO1xuXG4gICAgICAgIGNvbnN0IGhhc09ubHkgPSBvcHRpb25zLm9ubHkgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgaGFzUGFydCA9IG9wdGlvbnMucGFydCAhPT0gdW5kZWZpbmVkO1xuXG4gICAgICAgIGNvbXBhcmVGbGFncyA9IHtcbiAgICAgICAgICAgIHByb3RvdHlwZTogaGFzT25seSA/IG9wdGlvbnMub25seSA6IGhhc1BhcnQgPyAhb3B0aW9ucy5wYXJ0IDogZmFsc2UsXG4gICAgICAgICAgICBwYXJ0OiBoYXNPbmx5ID8gIW9wdGlvbnMub25seSA6IGhhc1BhcnQgPyBvcHRpb25zLnBhcnQgOiBmYWxzZVxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29tcGFyZSA9IChhLCBiKSA9PiBhID09PSBiO1xuICAgIH1cblxuICAgIGxldCBtaXNzZXMgPSBmYWxzZTtcbiAgICBjb25zdCBtYXRjaGVzID0gbmV3IEFycmF5KHZhbHVlcy5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF0Y2hlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBtYXRjaGVzW2ldID0gMDtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHJlZiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgbGV0IHBhdHRlcm4gPSAnKCc7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1tpXTtcbiAgICAgICAgICAgIGV4cG9ydHMuYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycsICdDYW5ub3QgY29tcGFyZSBzdHJpbmcgcmVmZXJlbmNlIHRvIG5vbi1zdHJpbmcgdmFsdWUnKTtcbiAgICAgICAgICAgIHBhdHRlcm4gKz0gKGkgPyAnfCcgOiAnJykgKyBleHBvcnRzLmVzY2FwZVJlZ2V4KHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlZ2V4ID0gbmV3IFJlZ0V4cChwYXR0ZXJuICsgJyknLCAnZycpO1xuICAgICAgICBjb25zdCBsZWZ0b3ZlcnMgPSByZWYucmVwbGFjZShyZWdleCwgKCQwLCAkMSkgPT4ge1xuXG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHZhbHVlcy5pbmRleE9mKCQxKTtcbiAgICAgICAgICAgICsrbWF0Y2hlc1tpbmRleF07XG4gICAgICAgICAgICByZXR1cm4gJyc7ICAgICAgICAgIC8vIFJlbW92ZSBmcm9tIHN0cmluZ1xuICAgICAgICB9KTtcblxuICAgICAgICBtaXNzZXMgPSAhIWxlZnRvdmVycztcbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShyZWYpKSB7XG4gICAgICAgIGNvbnN0IG9ubHlPbmNlID0gISEob3B0aW9ucy5vbmx5ICYmIG9wdGlvbnMub25jZSk7XG4gICAgICAgIGlmIChvbmx5T25jZSAmJiByZWYubGVuZ3RoICE9PSB2YWx1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlZi5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgbGV0IG1hdGNoZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdmFsdWVzLmxlbmd0aCAmJiBtYXRjaGVkID09PSBmYWxzZTsgKytqKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFvbmx5T25jZSB8fCBtYXRjaGVzW2pdID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZWQgPSBjb21wYXJlKHZhbHVlc1tqXSwgcmVmW2ldLCBjb21wYXJlRmxhZ3MpICYmIGo7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobWF0Y2hlZCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICArK21hdGNoZXNbbWF0Y2hlZF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtaXNzZXMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBrZXlzID0gaW50ZXJuYWxzLmtleXMocmVmLCBvcHRpb25zKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgY29uc3QgcG9zID0gdmFsdWVzLmluZGV4T2Yoa2V5KTtcbiAgICAgICAgICAgIGlmIChwb3MgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlUGFpcnMgJiZcbiAgICAgICAgICAgICAgICAgICAgIWNvbXBhcmUodmFsdWVQYWlyc1trZXldLCByZWZba2V5XSwgY29tcGFyZUZsYWdzKSkge1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICArK21hdGNoZXNbcG9zXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1pc3NlcyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5vbmx5KSB7XG4gICAgICAgIGlmIChtaXNzZXMgfHwgIW9wdGlvbnMub25jZSkge1xuICAgICAgICAgICAgcmV0dXJuICFtaXNzZXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgcmVzdWx0ID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXRjaGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdCB8fCAhIW1hdGNoZXNbaV07XG4gICAgICAgIGlmICgob3B0aW9ucy5vbmNlICYmIG1hdGNoZXNbaV0gPiAxKSB8fFxuICAgICAgICAgICAgKCFvcHRpb25zLnBhcnQgJiYgIW1hdGNoZXNbaV0pKSB7XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8vIEZsYXR0ZW4gYXJyYXlcblxuZXhwb3J0cy5mbGF0dGVuID0gZnVuY3Rpb24gKGFycmF5LCB0YXJnZXQpIHtcblxuICAgIGNvbnN0IHJlc3VsdCA9IHRhcmdldCB8fCBbXTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyYXlbaV0pKSB7XG4gICAgICAgICAgICBleHBvcnRzLmZsYXR0ZW4oYXJyYXlbaV0sIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChhcnJheVtpXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG4vLyBDb252ZXJ0IGFuIG9iamVjdCBrZXkgY2hhaW4gc3RyaW5nICgnYS5iLmMnKSB0byByZWZlcmVuY2UgKG9iamVjdFthXVtiXVtjXSlcblxuZXhwb3J0cy5yZWFjaCA9IGZ1bmN0aW9uIChvYmosIGNoYWluLCBvcHRpb25zKSB7XG5cbiAgICBpZiAoY2hhaW4gPT09IGZhbHNlIHx8XG4gICAgICAgIGNoYWluID09PSBudWxsIHx8XG4gICAgICAgIGNoYWluID09PSB1bmRlZmluZWQpIHtcblxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgb3B0aW9ucyA9IHsgc2VwYXJhdG9yOiBvcHRpb25zIH07XG4gICAgfVxuXG4gICAgY29uc3QgaXNDaGFpbkFycmF5ID0gQXJyYXkuaXNBcnJheShjaGFpbik7XG5cbiAgICBleHBvcnRzLmFzc2VydCghaXNDaGFpbkFycmF5IHx8ICFvcHRpb25zLnNlcGFyYXRvciwgJ1NlcGFyYXRvciBvcHRpb24gbm8gdmFsaWQgZm9yIGFycmF5LWJhc2VkIGNoYWluJyk7XG5cbiAgICBjb25zdCBwYXRoID0gaXNDaGFpbkFycmF5ID8gY2hhaW4gOiBjaGFpbi5zcGxpdChvcHRpb25zLnNlcGFyYXRvciB8fCAnLicpO1xuICAgIGxldCByZWYgPSBvYmo7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGxldCBrZXkgPSBwYXRoW2ldO1xuICAgICAgICBjb25zdCB0eXBlID0gb3B0aW9ucy5pdGVyYWJsZXMgJiYgaW50ZXJuYWxzLml0ZXJhYmxlcyhyZWYpO1xuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlZikgfHxcbiAgICAgICAgICAgIHR5cGUgPT09ICdzZXQnKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IG51bWJlciA9IE51bWJlcihrZXkpO1xuICAgICAgICAgICAgaWYgKE51bWJlci5pc0ludGVnZXIobnVtYmVyKSkge1xuICAgICAgICAgICAgICAgIGtleSA9IG51bWJlciA8IDAgPyByZWYubGVuZ3RoICsgbnVtYmVyIDogbnVtYmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFyZWYgfHxcbiAgICAgICAgICAgIHR5cGVvZiByZWYgPT09ICdmdW5jdGlvbicgJiYgb3B0aW9ucy5mdW5jdGlvbnMgPT09IGZhbHNlIHx8ICAgICAgICAgLy8gRGVmYXVsdHMgdG8gdHJ1ZVxuICAgICAgICAgICAgIXR5cGUgJiYgcmVmW2tleV0gPT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgICAgICBleHBvcnRzLmFzc2VydCghb3B0aW9ucy5zdHJpY3QgfHwgaSArIDEgPT09IHBhdGgubGVuZ3RoLCAnTWlzc2luZyBzZWdtZW50Jywga2V5LCAnaW4gcmVhY2ggcGF0aCAnLCBjaGFpbik7XG4gICAgICAgICAgICBleHBvcnRzLmFzc2VydCh0eXBlb2YgcmVmID09PSAnb2JqZWN0JyB8fCBvcHRpb25zLmZ1bmN0aW9ucyA9PT0gdHJ1ZSB8fCB0eXBlb2YgcmVmICE9PSAnZnVuY3Rpb24nLCAnSW52YWxpZCBzZWdtZW50Jywga2V5LCAnaW4gcmVhY2ggcGF0aCAnLCBjaGFpbik7XG4gICAgICAgICAgICByZWYgPSBvcHRpb25zLmRlZmF1bHQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdHlwZSkge1xuICAgICAgICAgICAgcmVmID0gcmVmW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ3NldCcpIHtcbiAgICAgICAgICAgIHJlZiA9IFsuLi5yZWZdW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7ICAvLyB0eXBlID09PSAnbWFwJ1xuICAgICAgICAgICAgcmVmID0gcmVmLmdldChrZXkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlZjtcbn07XG5cblxuaW50ZXJuYWxzLml0ZXJhYmxlcyA9IGZ1bmN0aW9uIChyZWYpIHtcblxuICAgIGlmIChyZWYgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgcmV0dXJuICdzZXQnO1xuICAgIH1cblxuICAgIGlmIChyZWYgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgcmV0dXJuICdtYXAnO1xuICAgIH1cbn07XG5cblxuZXhwb3J0cy5yZWFjaFRlbXBsYXRlID0gZnVuY3Rpb24gKG9iaiwgdGVtcGxhdGUsIG9wdGlvbnMpIHtcblxuICAgIHJldHVybiB0ZW1wbGF0ZS5yZXBsYWNlKC97KFtefV0rKX0vZywgKCQwLCBjaGFpbikgPT4ge1xuXG4gICAgICAgIGNvbnN0IHZhbHVlID0gZXhwb3J0cy5yZWFjaChvYmosIGNoYWluLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsID8gJycgOiB2YWx1ZSk7XG4gICAgfSk7XG59O1xuXG5cbmV4cG9ydHMuYXNzZXJ0ID0gZnVuY3Rpb24gKGNvbmRpdGlvbiwgLi4uYXJncykge1xuXG4gICAgaWYgKGNvbmRpdGlvbikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAxICYmXG4gICAgICAgIGFyZ3NbMF0gaW5zdGFuY2VvZiBFcnJvcikge1xuXG4gICAgICAgIHRocm93IGFyZ3NbMF07XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IGV4cG9ydHMuRXJyb3IoYXJncyk7XG59O1xuXG5cbmV4cG9ydHMuRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcblxuICAgIGNvbnN0cnVjdG9yKGFyZ3MpIHtcblxuICAgICAgICBjb25zdCBtc2dzID0gYXJnc1xuICAgICAgICAgICAgLmZpbHRlcigoYXJnKSA9PiBhcmcgIT09ICcnKVxuICAgICAgICAgICAgLm1hcCgoYXJnKSA9PiB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgPyBhcmcgOiBhcmcgaW5zdGFuY2VvZiBFcnJvciA/IGFyZy5tZXNzYWdlIDogZXhwb3J0cy5zdHJpbmdpZnkoYXJnKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIHN1cGVyKG1zZ3Muam9pbignICcpIHx8ICdVbmtub3duIGVycm9yJyk7XG4gICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIGV4cG9ydHMuYXNzZXJ0KTtcbiAgICB9XG59O1xuXG5cbmV4cG9ydHMuQmVuY2ggPSBjbGFzcyB7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcblxuICAgICAgICB0aGlzLnRzID0gMDtcbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgIH1cblxuICAgIHJlc2V0KCkge1xuXG4gICAgICAgIHRoaXMudHMgPSBleHBvcnRzLkJlbmNoLm5vdygpO1xuICAgIH1cblxuICAgIGVsYXBzZWQoKSB7XG5cbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuQmVuY2gubm93KCkgLSB0aGlzLnRzO1xuICAgIH1cblxuICAgIHN0YXRpYyBub3coKSB7XG5cbiAgICAgICAgY29uc3QgdHMgPSBwcm9jZXNzLmhydGltZSgpO1xuICAgICAgICByZXR1cm4gKHRzWzBdICogMWUzKSArICh0c1sxXSAvIDFlNik7XG4gICAgfVxufTtcblxuXG4vLyBFc2NhcGUgc3RyaW5nIGZvciBSZWdleCBjb25zdHJ1Y3Rpb25cblxuZXhwb3J0cy5lc2NhcGVSZWdleCA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcblxuICAgIC8vIEVzY2FwZSBeJC4qKy0/PSE6fFxcLygpW117fSxcbiAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL1tcXF5cXCRcXC5cXCpcXCtcXC1cXD9cXD1cXCFcXDpcXHxcXFxcXFwvXFwoXFwpXFxbXFxdXFx7XFx9XFwsXS9nLCAnXFxcXCQmJyk7XG59O1xuXG5cbi8vIEVzY2FwZSBhdHRyaWJ1dGUgdmFsdWUgZm9yIHVzZSBpbiBIVFRQIGhlYWRlclxuXG5leHBvcnRzLmVzY2FwZUhlYWRlckF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChhdHRyaWJ1dGUpIHtcblxuICAgIC8vIEFsbG93ZWQgdmFsdWUgY2hhcmFjdGVyczogISMkJSYnKCkqKywtLi86Ozw9Pj9AW11eX2B7fH1+IGFuZCBzcGFjZSwgYS16LCBBLVosIDAtOSwgXFwsIFwiXG5cbiAgICBleHBvcnRzLmFzc2VydCgvXlsgXFx3XFwhI1xcJCUmJ1xcKFxcKVxcKlxcKyxcXC1cXC5cXC9cXDo7PFxcPT5cXD9AXFxbXFxdXFxeYFxce1xcfFxcfX5cXFwiXFxcXF0qJC8udGVzdChhdHRyaWJ1dGUpLCAnQmFkIGF0dHJpYnV0ZSB2YWx1ZSAoJyArIGF0dHJpYnV0ZSArICcpJyk7XG5cbiAgICByZXR1cm4gYXR0cmlidXRlLnJlcGxhY2UoL1xcXFwvZywgJ1xcXFxcXFxcJykucmVwbGFjZSgvXFxcIi9nLCAnXFxcXFwiJyk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFc2NhcGUgcXVvdGVzIGFuZCBzbGFzaFxufTtcblxuXG5leHBvcnRzLmVzY2FwZUh0bWwgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG5cbiAgICByZXR1cm4gRXNjYXBlLmVzY2FwZUh0bWwoc3RyaW5nKTtcbn07XG5cblxuZXhwb3J0cy5lc2NhcGVKc29uID0gZnVuY3Rpb24gKHN0cmluZykge1xuXG4gICAgcmV0dXJuIEVzY2FwZS5lc2NhcGVKc29uKHN0cmluZyk7XG59O1xuXG5cbmV4cG9ydHMub25jZSA9IGZ1bmN0aW9uIChtZXRob2QpIHtcblxuICAgIGlmIChtZXRob2QuX2hvZWtPbmNlKSB7XG4gICAgICAgIHJldHVybiBtZXRob2Q7XG4gICAgfVxuXG4gICAgbGV0IG9uY2UgPSBmYWxzZTtcbiAgICBjb25zdCB3cmFwcGVkID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcblxuICAgICAgICBpZiAoIW9uY2UpIHtcbiAgICAgICAgICAgIG9uY2UgPSB0cnVlO1xuICAgICAgICAgICAgbWV0aG9kKC4uLmFyZ3MpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHdyYXBwZWQuX2hvZWtPbmNlID0gdHJ1ZTtcbiAgICByZXR1cm4gd3JhcHBlZDtcbn07XG5cblxuZXhwb3J0cy5pZ25vcmUgPSBmdW5jdGlvbiAoKSB7IH07XG5cblxuZXhwb3J0cy5zdHJpbmdpZnkgPSBmdW5jdGlvbiAoLi4uYXJncykge1xuXG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5LmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiAnW0Nhbm5vdCBkaXNwbGF5IG9iamVjdDogJyArIGVyci5tZXNzYWdlICsgJ10nO1xuICAgIH1cbn07XG5cblxuZXhwb3J0cy53YWl0ID0gZnVuY3Rpb24gKHRpbWVvdXQpIHtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCB0aW1lb3V0KSk7XG59O1xuXG5cbmV4cG9ydHMuYmxvY2sgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoZXhwb3J0cy5pZ25vcmUpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0ge1xuICAgIGFycmF5OiBBcnJheS5wcm90b3R5cGUsXG4gICAgYnVmZmVyOiBCdWZmZXIucHJvdG90eXBlLFxuICAgIGRhdGU6IERhdGUucHJvdG90eXBlLFxuICAgIGVycm9yOiBFcnJvci5wcm90b3R5cGUsXG4gICAgZ2VuZXJpYzogT2JqZWN0LnByb3RvdHlwZSxcbiAgICBtYXA6IE1hcC5wcm90b3R5cGUsXG4gICAgcHJvbWlzZTogUHJvbWlzZS5wcm90b3R5cGUsXG4gICAgcmVnZXg6IFJlZ0V4cC5wcm90b3R5cGUsXG4gICAgc2V0OiBTZXQucHJvdG90eXBlLFxuICAgIHdlYWtNYXA6IFdlYWtNYXAucHJvdG90eXBlLFxuICAgIHdlYWtTZXQ6IFdlYWtTZXQucHJvdG90eXBlXG59O1xuXG5cbmludGVybmFscy50eXBlTWFwID0gbmV3IE1hcChbXG4gICAgWydbb2JqZWN0IEVycm9yXScsIGV4cG9ydHMuZXJyb3JdLFxuICAgIFsnW29iamVjdCBNYXBdJywgZXhwb3J0cy5tYXBdLFxuICAgIFsnW29iamVjdCBQcm9taXNlXScsIGV4cG9ydHMucHJvbWlzZV0sXG4gICAgWydbb2JqZWN0IFNldF0nLCBleHBvcnRzLnNldF0sXG4gICAgWydbb2JqZWN0IFdlYWtNYXBdJywgZXhwb3J0cy53ZWFrTWFwXSxcbiAgICBbJ1tvYmplY3QgV2Vha1NldF0nLCBleHBvcnRzLndlYWtTZXRdXG5dKTtcblxuXG5leHBvcnRzLmdldEludGVybmFsUHJvdG8gPSBmdW5jdGlvbiAob2JqKSB7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLmFycmF5O1xuICAgIH1cblxuICAgIGlmIChvYmogaW5zdGFuY2VvZiBCdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuYnVmZmVyO1xuICAgIH1cblxuICAgIGlmIChvYmogaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLmRhdGU7XG4gICAgfVxuXG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5yZWdleDtcbiAgICB9XG5cbiAgICBjb25zdCBvYmpOYW1lID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaik7XG4gICAgcmV0dXJuIGludGVybmFscy50eXBlTWFwLmdldChvYmpOYW1lKSB8fCBleHBvcnRzLmdlbmVyaWM7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiAvW1xcdTAwMWJcXHUwMDliXVtbKCkjOz9dKig/OlswLTldezEsNH0oPzo7WzAtOV17MCw0fSkqKT9bMC05QS1QUlpjZi1ucXJ5PT48XS9nO1xufTtcbiIsIlxuLy8gJ3BhcnNlJyBhY2NlcHRzIGEgc3RyaW5nIHRoYXQgaXMgZXhwZWN0ZWQgdG8gYmUgdGhlIHN0ZG91dCBzdHJlYW0gb2YgYW5cbi8vIG9zYXNjcmlwdCBpbnZvY2F0aW9uLiBJdCByZWFkcyB0aGUgZmlzdCBjaGFyIG9mIHRoZSBzdHJpbmcgdG8gZGV0ZXJtaW5lXG4vLyB0aGUgZGF0YS10eXBlIG9mIHRoZSByZXN1bHQsIGFuZCBjcmVhdGVzIHRoZSBhcHByb3ByaWF0ZSB0eXBlIHBhcnNlci5cbmV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbihzdHIpIHtcbiAgaWYgKHN0ci5sZW5ndGggPT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuICBcbiAgdmFyIHJ0biA9IHBhcnNlRnJvbUZpcnN0UmVtYWluaW5nLmNhbGwoe1xuICAgIHZhbHVlOiBzdHIsXG4gICAgaW5kZXg6IDBcbiAgfSk7XG4gIHJldHVybiBydG47XG59XG5cbi8vIEF0dGVtcHMgdG8gZGV0ZXJtaW5lIHRoZSBkYXRhIHR5cGUgb2YgdGhlIG5leHQgcGFydCBvZiB0aGUgU3RyaW5nIHRvXG4vLyBwYXJzZS4gVGhlICd0aGlzJyB2YWx1ZSBoYXMgYSBPYmplY3Qgd2l0aCAndmFsdWUnIGFzIHRoZSBBcHBsZVNjcmlwdFxuLy8gc3RyaW5nIHRvIHBhcnNlLCBhbmQgJ2luZGV4JyBhcyB0aGUgcG9pbnRlciB0byB0aGUgY3VycmVudCBwb3NpdGlvblxuLy8gb2YgcGFyc2luZyBpbiB0aGUgU3RyaW5nLiBUaGlzIEZ1bmN0aW9uIGRvZXMgbm90IG5lZWQgdG8gYmUgZXhwb3J0ZWQ/Pz9cbmZ1bmN0aW9uIHBhcnNlRnJvbUZpcnN0UmVtYWluaW5nKCkge1xuICB2YXIgY3VyID0gdGhpcy52YWx1ZVt0aGlzLmluZGV4XTtcbiAgc3dpdGNoKGN1cikge1xuICAgIGNhc2UgJ3snOlxuICAgICAgcmV0dXJuIGV4cG9ydHMuQXJyYXlQYXJzZXIuY2FsbCh0aGlzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ1wiJzpcbiAgICAgIHJldHVybiBleHBvcnRzLlN0cmluZ1BhcnNlci5jYWxsKHRoaXMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYSc6XG4gICAgICBpZiAodGhpcy52YWx1ZS5zdWJzdHJpbmcodGhpcy5pbmRleCwgdGhpcy5pbmRleCs1KSA9PSAnYWxpYXMnKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLkFsaWFzUGFyc2VyLmNhbGwodGhpcyk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICfCqyc6XG4gICAgICBpZiAodGhpcy52YWx1ZS5zdWJzdHJpbmcodGhpcy5pbmRleCwgdGhpcy5pbmRleCs1KSA9PSAnwqtkYXRhJykge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5EYXRhUGFyc2VyLmNhbGwodGhpcyk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgfVxuICBpZiAoIWlzTmFOKGN1cikpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5OdW1iZXJQYXJzZXIuY2FsbCh0aGlzKTtcbiAgfVxuICByZXR1cm4gZXhwb3J0cy5VbmRlZmluZWRQYXJzZXIuY2FsbCh0aGlzKTtcbn1cblxuLy8gUGFyc2VzIGFuIEFwcGxlU2NyaXB0IFwiYWxpYXNcIiwgd2hpY2ggaXMgcmVhbGx5IGp1c3QgYSByZWZlcmVuY2UgdG8gYVxuLy8gbG9jYXRpb24gb24gdGhlIGZpbGVzeXN0ZW0sIGJ1dCBmb3JtYXR0ZWQga2luZGEgd2VpcmRseS5cbmV4cG9ydHMuQWxpYXNQYXJzZXIgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5pbmRleCArPSA2O1xuICByZXR1cm4gXCIvVm9sdW1lcy9cIiArIGV4cG9ydHMuU3RyaW5nUGFyc2VyLmNhbGwodGhpcykucmVwbGFjZSgvOi9nLCBcIi9cIik7XG59XG5cbi8vIFBhcnNlcyBhbiBBcHBsZVNjcmlwdCBBcnJheS4gV2hpY2ggbG9va3MgbGlrZSB7fSwgaW5zdGVhZCBvZiBKYXZhU2NyaXB0J3MgW10uXG5leHBvcnRzLkFycmF5UGFyc2VyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBydG4gPSBbXSxcbiAgICBjdXIgPSB0aGlzLnZhbHVlWysrdGhpcy5pbmRleF07XG4gIHdoaWxlIChjdXIgIT0gJ30nKSB7XG4gICAgcnRuLnB1c2gocGFyc2VGcm9tRmlyc3RSZW1haW5pbmcuY2FsbCh0aGlzKSk7XG4gICAgaWYgKHRoaXMudmFsdWVbdGhpcy5pbmRleF0gPT0gJywnKSB0aGlzLmluZGV4ICs9IDI7XG4gICAgY3VyID0gdGhpcy52YWx1ZVt0aGlzLmluZGV4XTtcbiAgfVxuICB0aGlzLmluZGV4Kys7XG4gIHJldHVybiBydG47XG59XG5cbi8vIFBhcnNlcyDCq2RhdGEgwrsgcmVzdWx0cyBpbnRvIG5hdGl2ZSBCdWZmZXIgaW5zdGFuY2VzLlxuZXhwb3J0cy5EYXRhUGFyc2VyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBib2R5ID0gZXhwb3J0cy5VbmRlZmluZWRQYXJzZXIuY2FsbCh0aGlzKTtcbiAgYm9keSA9IGJvZHkuc3Vic3RyaW5nKDYsIGJvZHkubGVuZ3RoLTEpO1xuICB2YXIgdHlwZSA9IGJvZHkuc3Vic3RyaW5nKDAsNCk7XG4gIGJvZHkgPSBib2R5LnN1YnN0cmluZyg0LCBib2R5Lmxlbmd0aCk7XG4gIHZhciBidWYgPSBuZXcgQnVmZmVyKGJvZHkubGVuZ3RoLzIpO1xuICB2YXIgY291bnQgPSAwO1xuICBmb3IgKHZhciBpPTAsIGw9Ym9keS5sZW5ndGg7IGk8bDsgaSArPSAyKSB7XG4gICAgYnVmW2NvdW50KytdID0gcGFyc2VJbnQoYm9keVtpXStib2R5W2krMV0sIDE2KTtcbiAgfVxuICBidWYudHlwZSA9IHR5cGU7XG4gIHJldHVybiBidWY7XG59XG5cbi8vIFBhcnNlcyBhbiBBcHBsZVNjcmlwdCBOdW1iZXIgaW50byBhIG5hdGl2ZSBKYXZhU2NyaXB0IE51bWJlciBpbnN0YW5jZS5cbmV4cG9ydHMuTnVtYmVyUGFyc2VyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBOdW1iZXIoZXhwb3J0cy5VbmRlZmluZWRQYXJzZXIuY2FsbCh0aGlzKSk7XG59XG5cbi8vIFBhcnNlcyBhIHN0YW5kYXJkIEFwcGxlU2NyaXB0IFN0cmluZy4gV2hpY2ggc3RhcnRzIGFuZCBlbmRzIHdpdGggXCJcIiBjaGFycy5cbi8vIFRoZSBcXCBjaGFyIGlzIHRoZSBlc2NhcGUgY2hhcmFjdGVyLCBzbyBhbnl0aGluZyBhZnRlciB0aGF0IGlzIGEgdmFsaWQgcGFydFxuLy8gb2YgdGhlIHJlc3VsdGluZyBTdHJpbmcuXG5leHBvcnRzLlN0cmluZ1BhcnNlciA9IGZ1bmN0aW9uKHN0cikge1xuICB2YXIgcnRuID0gXCJcIixcbiAgICBlbmQgPSArK3RoaXMuaW5kZXgsXG4gICAgY3VyID0gdGhpcy52YWx1ZVtlbmQrK107XG4gIHdoaWxlKGN1ciAhPSAnXCInKSB7XG4gICAgaWYgKGN1ciA9PSAnXFxcXCcpIHtcbiAgICAgIHJ0biArPSB0aGlzLnZhbHVlLnN1YnN0cmluZyh0aGlzLmluZGV4LCBlbmQtMSk7XG4gICAgICB0aGlzLmluZGV4ID0gZW5kKys7XG4gICAgfVxuICAgIGN1ciA9IHRoaXMudmFsdWVbZW5kKytdO1xuICB9XG4gIHJ0biArPSB0aGlzLnZhbHVlLnN1YnN0cmluZyh0aGlzLmluZGV4LCBlbmQtMSk7XG4gIHRoaXMuaW5kZXggPSBlbmQ7XG4gIHJldHVybiBydG47XG59XG5cbi8vIFdoZW4gdGhlIFwicGFyc2VGcm9tRmlyc3RSZW1haW5pbmdcIiBmdW5jdGlvbiBjYW4ndCBmaWd1cmUgb3V0IHRoZSBkYXRhIHR5cGVcbi8vIG9mIFwic3RyXCIsIHRoZW4gdGhlIFVuZGVmaW5lZFBhcnNlciBpcyB1c2VkLiBJdCBjcmFtcyBldmVyeXRoaW5nIGl0IHNlZXNcbi8vIGludG8gYSBTdHJpbmcsIHVudGlsIGl0IGZpbmRzIGEgJywnIG9yIGEgJ30nIG9yIGl0IHJlYWNoZXMgdGhlIGVuZCBvZiBkYXRhLlxudmFyIEVORF9PRl9UT0tFTiA9IC99fCx8XFxuLztcbmV4cG9ydHMuVW5kZWZpbmVkUGFyc2VyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBlbmQgPSB0aGlzLmluZGV4LCBjdXIgPSB0aGlzLnZhbHVlW2VuZCsrXTtcbiAgd2hpbGUgKCFFTkRfT0ZfVE9LRU4udGVzdChjdXIpKSB7XG4gICAgY3VyID0gdGhpcy52YWx1ZVtlbmQrK107XG4gIH1cbiAgdmFyIHJ0biA9IHRoaXMudmFsdWUuc3Vic3RyaW5nKHRoaXMuaW5kZXgsIGVuZC0xKTtcbiAgdGhpcy5pbmRleCA9IGVuZC0xO1xuICByZXR1cm4gcnRuO1xufVxuIiwidmFyIHNwYXduID0gcmVxdWlyZShcImNoaWxkX3Byb2Nlc3NcIikuc3Bhd247XG5leHBvcnRzLlBhcnNlcnMgPSByZXF1aXJlKFwiLi9hcHBsZXNjcmlwdC1wYXJzZXJcIik7XG52YXIgcGFyc2UgPSBleHBvcnRzLlBhcnNlcnMucGFyc2U7XG5cbi8vIFBhdGggdG8gJ29zYXNjcmlwdCcuIEJ5IGRlZmF1bHQgc2VhcmNoIFBBVEguXG5leHBvcnRzLm9zYXNjcmlwdCA9IFwib3Nhc2NyaXB0XCI7XG5cbi8vIEV4ZWN1dGUgYSAqLmFwcGxlc2NyaXB0IGZpbGUuXG5leHBvcnRzLmV4ZWNGaWxlID0gZnVuY3Rpb24gZXhlY0ZpbGUoZmlsZSwgYXJncywgY2FsbGJhY2spIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGFyZ3MpKSB7XG4gICAgY2FsbGJhY2sgPSBhcmdzO1xuICAgIGFyZ3MgPSBbXTtcbiAgfVxuICByZXR1cm4gcnVuQXBwbGVzY3JpcHQoZmlsZSwgYXJncywgY2FsbGJhY2spO1xufVxuXG4vLyBFeGVjdXRlIGEgU3RyaW5nIGFzIEFwcGxlU2NyaXB0LlxuZXhwb3J0cy5leGVjU3RyaW5nID0gZnVuY3Rpb24gZXhlY1N0cmluZyhzdHIsIGNhbGxiYWNrKSB7XG4gIHJldHVybiBydW5BcHBsZXNjcmlwdChzdHIsIGNhbGxiYWNrKTtcbn1cblxuXG5cbmZ1bmN0aW9uIHJ1bkFwcGxlc2NyaXB0KHN0ck9yUGF0aCwgYXJncywgY2FsbGJhY2spIHtcbiAgdmFyIGlzU3RyaW5nID0gZmFsc2U7XG4gIGlmICghQXJyYXkuaXNBcnJheShhcmdzKSkge1xuICAgIGNhbGxiYWNrID0gYXJncztcbiAgICBhcmdzID0gW107XG4gICAgaXNTdHJpbmcgPSB0cnVlO1xuICB9XG5cbiAgLy8gYXJncyBnZXQgYWRkZWQgdG8gdGhlIGVuZCBvZiB0aGUgYXJncyBhcnJheVxuICBhcmdzLnB1c2goXCItc3NcIik7IC8vIFRvIG91dHB1dCBtYWNoaW5lLXJlYWRhYmxlIHRleHQuXG4gIGlmICghaXNTdHJpbmcpIHtcbiAgICAvLyBUaGUgbmFtZSBvZiB0aGUgZmlsZSBpcyB0aGUgZmluYWwgYXJnIGlmICdleGVjRmlsZScgd2FzIGNhbGxlZC5cbiAgICBhcmdzLnB1c2goc3RyT3JQYXRoKTtcbiAgfVxuICB2YXIgaW50ZXJwcmV0ZXIgPSBzcGF3bihleHBvcnRzLm9zYXNjcmlwdCwgYXJncyk7XG5cbiAgYnVmZmVyQm9keShpbnRlcnByZXRlci5zdGRvdXQpO1xuICBidWZmZXJCb2R5KGludGVycHJldGVyLnN0ZGVycik7XG5cbiAgaW50ZXJwcmV0ZXIub24oJ2V4aXQnLCBmdW5jdGlvbihjb2RlKSB7XG4gICAgdmFyIHJlc3VsdCA9IHBhcnNlKGludGVycHJldGVyLnN0ZG91dC5ib2R5KTtcbiAgICB2YXIgZXJyO1xuICAgIGlmIChjb2RlKSB7XG4gICAgICAvLyBJZiB0aGUgZXhpdCBjb2RlIHdhcyBzb21ldGhpbmcgb3RoZXIgdGhhbiAwLCB3ZSdyZSBnb25uYVxuICAgICAgLy8gcmV0dXJuIGFuIEVycm9yIG9iamVjdC5cbiAgICAgIGVyciA9IG5ldyBFcnJvcihpbnRlcnByZXRlci5zdGRlcnIuYm9keSk7XG4gICAgICBlcnIuYXBwbGVTY3JpcHQgPSBzdHJPclBhdGg7XG4gICAgICBlcnIuZXhpdENvZGUgPSBjb2RlO1xuICAgIH1cbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrKGVyciwgcmVzdWx0LCBpbnRlcnByZXRlci5zdGRlcnIuYm9keSk7XG4gICAgfVxuICB9KTtcblxuICBpZiAoaXNTdHJpbmcpIHtcbiAgICAvLyBXcml0ZSB0aGUgZ2l2ZW4gYXBwbGVzY3JpcHQgU3RyaW5nIHRvIHN0ZGluIGlmICdleGVjU3RyaW5nJyB3YXMgY2FsbGVkLlxuICAgIGludGVycHJldGVyLnN0ZGluLndyaXRlKHN0ck9yUGF0aCk7XG4gICAgaW50ZXJwcmV0ZXIuc3RkaW4uZW5kKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYnVmZmVyQm9keShzdHJlYW0pIHtcbiAgc3RyZWFtLmJvZHkgPSBcIlwiO1xuICBzdHJlYW0uc2V0RW5jb2RpbmcoXCJ1dGY4XCIpO1xuICBzdHJlYW0ub24oXCJkYXRhXCIsIGZ1bmN0aW9uKGNodW5rKSB7IHN0cmVhbS5ib2R5ICs9IGNodW5rOyB9KTtcbn1cbiIsInZhciBmaWxlQmFzZWRVdGlsaXRpZXMsIHVudGlsZGlmeTtcblxudW50aWxkaWZ5ID0gcmVxdWlyZSgndW50aWxkaWZ5Jyk7XG5cbmZpbGVCYXNlZFV0aWxpdGllcyA9IHJlcXVpcmUoJy4vZmlsZUJhc2VkVXRpbGl0aWVzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gIC8qIFB1YmxpYyAqL1xuICBlbmFibGU6IGZ1bmN0aW9uKGFyZykge1xuICAgIHZhciBhcHBOYW1lLCBhcHBQYXRoLCBkYXRhLCBoaWRkZW5BcmcsIGlzSGlkZGVuT25MYXVuY2g7XG4gICAgYXBwTmFtZSA9IGFyZy5hcHBOYW1lLCBhcHBQYXRoID0gYXJnLmFwcFBhdGgsIGlzSGlkZGVuT25MYXVuY2ggPSBhcmcuaXNIaWRkZW5PbkxhdW5jaDtcbiAgICBoaWRkZW5BcmcgPSBpc0hpZGRlbk9uTGF1bmNoID8gJyAtLWhpZGRlbicgOiAnJztcbiAgICBkYXRhID0gXCJbRGVza3RvcCBFbnRyeV1cXG5UeXBlPUFwcGxpY2F0aW9uXFxuVmVyc2lvbj0xLjBcXG5OYW1lPVwiICsgYXBwTmFtZSArIFwiXFxuQ29tbWVudD1cIiArIGFwcE5hbWUgKyBcInN0YXJ0dXAgc2NyaXB0XFxuRXhlYz1cIiArIGFwcFBhdGggKyBoaWRkZW5BcmcgKyBcIlxcblN0YXJ0dXBOb3RpZnk9ZmFsc2VcXG5UZXJtaW5hbD1mYWxzZVwiO1xuICAgIHJldHVybiBmaWxlQmFzZWRVdGlsaXRpZXMuY3JlYXRlRmlsZSh7XG4gICAgICBkYXRhOiBkYXRhLFxuICAgICAgZGlyZWN0b3J5OiB0aGlzLmdldERpcmVjdG9yeSgpLFxuICAgICAgZmlsZVBhdGg6IHRoaXMuZ2V0RmlsZVBhdGgoYXBwTmFtZSlcbiAgICB9KTtcbiAgfSxcbiAgZGlzYWJsZTogZnVuY3Rpb24oYXBwTmFtZSkge1xuICAgIHJldHVybiBmaWxlQmFzZWRVdGlsaXRpZXMucmVtb3ZlRmlsZSh0aGlzLmdldEZpbGVQYXRoKGFwcE5hbWUpKTtcbiAgfSxcbiAgaXNFbmFibGVkOiBmdW5jdGlvbihhcHBOYW1lKSB7XG4gICAgcmV0dXJuIGZpbGVCYXNlZFV0aWxpdGllcy5pc0VuYWJsZWQodGhpcy5nZXRGaWxlUGF0aChhcHBOYW1lKSk7XG4gIH0sXG5cbiAgLyogUHJpdmF0ZSAqL1xuICBnZXREaXJlY3Rvcnk6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB1bnRpbGRpZnkoJ34vLmNvbmZpZy9hdXRvc3RhcnQvJyk7XG4gIH0sXG4gIGdldEZpbGVQYXRoOiBmdW5jdGlvbihhcHBOYW1lKSB7XG4gICAgcmV0dXJuIFwiXCIgKyAodGhpcy5nZXREaXJlY3RvcnkoKSkgKyBhcHBOYW1lICsgXCIuZGVza3RvcFwiO1xuICB9XG59O1xuIiwidmFyIGFwcGxlc2NyaXB0LCBmaWxlQmFzZWRVdGlsaXRpZXMsIHVudGlsZGlmeSxcbiAgaW5kZXhPZiA9IFtdLmluZGV4T2YgfHwgZnVuY3Rpb24oaXRlbSkgeyBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7IGlmIChpIGluIHRoaXMgJiYgdGhpc1tpXSA9PT0gaXRlbSkgcmV0dXJuIGk7IH0gcmV0dXJuIC0xOyB9O1xuXG5hcHBsZXNjcmlwdCA9IHJlcXVpcmUoJ2FwcGxlc2NyaXB0Jyk7XG5cbnVudGlsZGlmeSA9IHJlcXVpcmUoJ3VudGlsZGlmeScpO1xuXG5maWxlQmFzZWRVdGlsaXRpZXMgPSByZXF1aXJlKCcuL2ZpbGVCYXNlZFV0aWxpdGllcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICAvKiBQdWJsaWMgKi9cbiAgZW5hYmxlOiBmdW5jdGlvbihhcmcpIHtcbiAgICB2YXIgYXBwTmFtZSwgYXBwUGF0aCwgZGF0YSwgaXNIaWRkZW5PbkxhdW5jaCwgaXNIaWRkZW5WYWx1ZSwgbWFjLCBwcm9ncmFtQXJndW1lbnRzLCBwcm9ncmFtQXJndW1lbnRzU2VjdGlvbiwgcHJvcGVydGllcztcbiAgICBhcHBOYW1lID0gYXJnLmFwcE5hbWUsIGFwcFBhdGggPSBhcmcuYXBwUGF0aCwgaXNIaWRkZW5PbkxhdW5jaCA9IGFyZy5pc0hpZGRlbk9uTGF1bmNoLCBtYWMgPSBhcmcubWFjO1xuICAgIGlmIChtYWMudXNlTGF1bmNoQWdlbnQpIHtcbiAgICAgIHByb2dyYW1Bcmd1bWVudHMgPSBbYXBwUGF0aF07XG4gICAgICBpZiAoaXNIaWRkZW5PbkxhdW5jaCkge1xuICAgICAgICBwcm9ncmFtQXJndW1lbnRzLnB1c2goJy0taGlkZGVuJyk7XG4gICAgICB9XG4gICAgICBwcm9ncmFtQXJndW1lbnRzU2VjdGlvbiA9IHByb2dyYW1Bcmd1bWVudHMubWFwKGZ1bmN0aW9uKGFyZ3VtZW50KSB7XG4gICAgICAgIHJldHVybiBcIiAgICA8c3RyaW5nPlwiICsgYXJndW1lbnQgKyBcIjwvc3RyaW5nPlwiO1xuICAgICAgfSkuam9pbignXFxuJyk7XG4gICAgICBkYXRhID0gXCI8P3htbCB2ZXJzaW9uPVxcXCIxLjBcXFwiIGVuY29kaW5nPVxcXCJVVEYtOFxcXCI/PlxcbjwhRE9DVFlQRSBwbGlzdCBQVUJMSUMgXFxcIi0vL0FwcGxlLy9EVEQgUExJU1QgMS4wLy9FTlxcXCIgXFxcImh0dHA6Ly93d3cuYXBwbGUuY29tL0RURHMvUHJvcGVydHlMaXN0LTEuMC5kdGRcXFwiPlxcbjxwbGlzdCB2ZXJzaW9uPVxcXCIxLjBcXFwiPlxcbjxkaWN0PlxcbiAgPGtleT5MYWJlbDwva2V5PlxcbiAgPHN0cmluZz5cIiArIGFwcE5hbWUgKyBcIjwvc3RyaW5nPlxcbiAgPGtleT5Qcm9ncmFtQXJndW1lbnRzPC9rZXk+XFxuICA8YXJyYXk+XFxuICBcIiArIHByb2dyYW1Bcmd1bWVudHNTZWN0aW9uICsgXCJcXG4gIDwvYXJyYXk+XFxuICA8a2V5PlJ1bkF0TG9hZDwva2V5PlxcbiAgPHRydWUvPlxcbjwvZGljdD5cXG48L3BsaXN0PlwiO1xuICAgICAgcmV0dXJuIGZpbGVCYXNlZFV0aWxpdGllcy5jcmVhdGVGaWxlKHtcbiAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgZGlyZWN0b3J5OiB0aGlzLmdldERpcmVjdG9yeSgpLFxuICAgICAgICBmaWxlUGF0aDogdGhpcy5nZXRGaWxlUGF0aChhcHBOYW1lKVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlzSGlkZGVuVmFsdWUgPSBpc0hpZGRlbk9uTGF1bmNoID8gJ3RydWUnIDogJ2ZhbHNlJztcbiAgICBwcm9wZXJ0aWVzID0gXCJ7cGF0aDpcXFwiXCIgKyBhcHBQYXRoICsgXCJcXFwiLCBoaWRkZW46XCIgKyBpc0hpZGRlblZhbHVlICsgXCIsIG5hbWU6XFxcIlwiICsgYXBwTmFtZSArIFwiXFxcIn1cIjtcbiAgICByZXR1cm4gdGhpcy5leGVjQXBwbGVzY3JpcHRDb21tYW5kKFwibWFrZSBsb2dpbiBpdGVtIGF0IGVuZCB3aXRoIHByb3BlcnRpZXMgXCIgKyBwcm9wZXJ0aWVzKTtcbiAgfSxcbiAgZGlzYWJsZTogZnVuY3Rpb24oYXBwTmFtZSwgbWFjKSB7XG4gICAgaWYgKG1hYy51c2VMYXVuY2hBZ2VudCkge1xuICAgICAgcmV0dXJuIGZpbGVCYXNlZFV0aWxpdGllcy5yZW1vdmVGaWxlKHRoaXMuZ2V0RmlsZVBhdGgoYXBwTmFtZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5leGVjQXBwbGVzY3JpcHRDb21tYW5kKFwiZGVsZXRlIGxvZ2luIGl0ZW0gXFxcIlwiICsgYXBwTmFtZSArIFwiXFxcIlwiKTtcbiAgfSxcbiAgaXNFbmFibGVkOiBmdW5jdGlvbihhcHBOYW1lLCBtYWMpIHtcbiAgICBpZiAobWFjLnVzZUxhdW5jaEFnZW50KSB7XG4gICAgICByZXR1cm4gZmlsZUJhc2VkVXRpbGl0aWVzLmlzRW5hYmxlZCh0aGlzLmdldEZpbGVQYXRoKGFwcE5hbWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZXhlY0FwcGxlc2NyaXB0Q29tbWFuZCgnZ2V0IHRoZSBuYW1lIG9mIGV2ZXJ5IGxvZ2luIGl0ZW0nKS50aGVuKGZ1bmN0aW9uKGxvZ2luSXRlbXMpIHtcbiAgICAgIHJldHVybiAobG9naW5JdGVtcyAhPSBudWxsKSAmJiBpbmRleE9mLmNhbGwobG9naW5JdGVtcywgYXBwTmFtZSkgPj0gMDtcbiAgICB9KTtcbiAgfSxcblxuICAvKiBQcml2YXRlICovXG4gIGV4ZWNBcHBsZXNjcmlwdENvbW1hbmQ6IGZ1bmN0aW9uKGNvbW1hbmRTdWZmaXgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICByZXR1cm4gYXBwbGVzY3JpcHQuZXhlY1N0cmluZyhcInRlbGwgYXBwbGljYXRpb24gXFxcIlN5c3RlbSBFdmVudHNcXFwiIHRvIFwiICsgY29tbWFuZFN1ZmZpeCwgZnVuY3Rpb24oZXJyLCByZXN1bHQpIHtcbiAgICAgICAgaWYgKGVyciAhPSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNvbHZlKHJlc3VsdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSxcbiAgZ2V0RGlyZWN0b3J5OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdW50aWxkaWZ5KCd+L0xpYnJhcnkvTGF1bmNoQWdlbnRzLycpO1xuICB9LFxuICBnZXRGaWxlUGF0aDogZnVuY3Rpb24oYXBwTmFtZSkge1xuICAgIHJldHVybiBcIlwiICsgKHRoaXMuZ2V0RGlyZWN0b3J5KCkpICsgYXBwTmFtZSArIFwiLnBsaXN0XCI7XG4gIH1cbn07XG4iLCJ2YXIgV2lucmVnLCBmcywgcGF0aCwgcmVnS2V5O1xuXG5mcyA9IHJlcXVpcmUoJ2ZzJyk7XG5cbnBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5cbldpbnJlZyA9IHJlcXVpcmUoJ3dpbnJlZycpO1xuXG5yZWdLZXkgPSBuZXcgV2lucmVnKHtcbiAgaGl2ZTogV2lucmVnLkhLQ1UsXG4gIGtleTogJ1xcXFxTb2Z0d2FyZVxcXFxNaWNyb3NvZnRcXFxcV2luZG93c1xcXFxDdXJyZW50VmVyc2lvblxcXFxSdW4nXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgLyogUHVibGljICovXG4gIGVuYWJsZTogZnVuY3Rpb24oYXJnKSB7XG4gICAgdmFyIGFwcE5hbWUsIGFwcFBhdGgsIGlzSGlkZGVuT25MYXVuY2g7XG4gICAgYXBwTmFtZSA9IGFyZy5hcHBOYW1lLCBhcHBQYXRoID0gYXJnLmFwcFBhdGgsIGlzSGlkZGVuT25MYXVuY2ggPSBhcmcuaXNIaWRkZW5PbkxhdW5jaDtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgYXJncywgcGF0aFRvQXV0b0xhdW5jaGVkQXBwLCByZWYsIHVwZGF0ZURvdEV4ZTtcbiAgICAgIHBhdGhUb0F1dG9MYXVuY2hlZEFwcCA9IGFwcFBhdGg7XG4gICAgICBhcmdzID0gJyc7XG4gICAgICB1cGRhdGVEb3RFeGUgPSBwYXRoLmpvaW4ocGF0aC5kaXJuYW1lKHByb2Nlc3MuZXhlY1BhdGgpLCAnLi4nLCAndXBkYXRlLmV4ZScpO1xuICAgICAgaWYgKCgoKHJlZiA9IHByb2Nlc3MudmVyc2lvbnMpICE9IG51bGwgPyByZWYuZWxlY3Ryb24gOiB2b2lkIDApICE9IG51bGwpICYmIGZzLmV4aXN0c1N5bmModXBkYXRlRG90RXhlKSkge1xuICAgICAgICBwYXRoVG9BdXRvTGF1bmNoZWRBcHAgPSB1cGRhdGVEb3RFeGU7XG4gICAgICAgIGFyZ3MgPSBcIiAtLXByb2Nlc3NTdGFydCBcXFwiXCIgKyAocGF0aC5iYXNlbmFtZShwcm9jZXNzLmV4ZWNQYXRoKSkgKyBcIlxcXCJcIjtcbiAgICAgICAgaWYgKGlzSGlkZGVuT25MYXVuY2gpIHtcbiAgICAgICAgICBhcmdzICs9ICcgLS1wcm9jZXNzLXN0YXJ0LWFyZ3MgXCItLWhpZGRlblwiJztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzSGlkZGVuT25MYXVuY2gpIHtcbiAgICAgICAgICBhcmdzICs9ICcgLS1oaWRkZW4nO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVnS2V5LnNldChhcHBOYW1lLCBXaW5yZWcuUkVHX1NaLCBcIlxcXCJcIiArIHBhdGhUb0F1dG9MYXVuY2hlZEFwcCArIFwiXFxcIlwiICsgYXJncywgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgIGlmIChlcnIgIT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzb2x2ZSgpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0sXG4gIGRpc2FibGU6IGZ1bmN0aW9uKGFwcE5hbWUpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICByZXR1cm4gcmVnS2V5LnJlbW92ZShhcHBOYW1lLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgaWYgKGVyciAhPSBudWxsKSB7XG4gICAgICAgICAgaWYgKGVyci5tZXNzYWdlLmluZGV4T2YoJ1RoZSBzeXN0ZW0gd2FzIHVuYWJsZSB0byBmaW5kIHRoZSBzcGVjaWZpZWQgcmVnaXN0cnkga2V5IG9yIHZhbHVlJykgIT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzb2x2ZSgpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0sXG4gIGlzRW5hYmxlZDogZnVuY3Rpb24oYXBwTmFtZSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHJldHVybiByZWdLZXkuZ2V0KGFwcE5hbWUsIGZ1bmN0aW9uKGVyciwgaXRlbSkge1xuICAgICAgICBpZiAoZXJyICE9IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZShmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc29sdmUoaXRlbSAhPSBudWxsKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59O1xuIiwidmFyIGZzLCBta2RpcnA7XG5cbmZzID0gcmVxdWlyZSgnZnMnKTtcblxubWtkaXJwID0gcmVxdWlyZSgnbWtkaXJwJyk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gIC8qIFB1YmxpYyAqL1xuICBjcmVhdGVGaWxlOiBmdW5jdGlvbihhcmcpIHtcbiAgICB2YXIgZGF0YSwgZGlyZWN0b3J5LCBmaWxlUGF0aDtcbiAgICBkaXJlY3RvcnkgPSBhcmcuZGlyZWN0b3J5LCBmaWxlUGF0aCA9IGFyZy5maWxlUGF0aCwgZGF0YSA9IGFyZy5kYXRhO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHJldHVybiBta2RpcnAoZGlyZWN0b3J5LCBmdW5jdGlvbihta2RpckVycikge1xuICAgICAgICBpZiAobWtkaXJFcnIgIT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiByZWplY3QobWtkaXJFcnIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmcy53cml0ZUZpbGUoZmlsZVBhdGgsIGRhdGEsIGZ1bmN0aW9uKHdyaXRlRXJyKSB7XG4gICAgICAgICAgaWYgKHdyaXRlRXJyICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiByZWplY3Qod3JpdGVFcnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9LFxuICBpc0VuYWJsZWQ6IGZ1bmN0aW9uKGZpbGVQYXRoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChmdW5jdGlvbihfdGhpcykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICByZXR1cm4gZnMuc3RhdChmaWxlUGF0aCwgZnVuY3Rpb24oZXJyLCBzdGF0KSB7XG4gICAgICAgICAgaWYgKGVyciAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXNvbHZlKHN0YXQgIT0gbnVsbCk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9KSh0aGlzKSk7XG4gIH0sXG4gIHJlbW92ZUZpbGU6IGZ1bmN0aW9uKGZpbGVQYXRoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChmdW5jdGlvbihfdGhpcykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICByZXR1cm4gZnMuc3RhdChmaWxlUGF0aCwgZnVuY3Rpb24oc3RhdEVycikge1xuICAgICAgICAgIGlmIChzdGF0RXJyICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmcy51bmxpbmsoZmlsZVBhdGgsIGZ1bmN0aW9uKHVubGlua0Vycikge1xuICAgICAgICAgICAgaWYgKHVubGlua0VyciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIHJldHVybiByZWplY3QodW5saW5rRXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9KSh0aGlzKSk7XG4gIH1cbn07XG4iLCJ2YXIgQXV0b0xhdW5jaCwgaXNQYXRoQWJzb2x1dGUsXG4gIGJpbmQgPSBmdW5jdGlvbihmbiwgbWUpeyByZXR1cm4gZnVuY3Rpb24oKXsgcmV0dXJuIGZuLmFwcGx5KG1lLCBhcmd1bWVudHMpOyB9OyB9O1xuXG5pc1BhdGhBYnNvbHV0ZSA9IHJlcXVpcmUoJ3BhdGgtaXMtYWJzb2x1dGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBBdXRvTGF1bmNoID0gKGZ1bmN0aW9uKCkge1xuXG4gIC8qIFB1YmxpYyAqL1xuICBmdW5jdGlvbiBBdXRvTGF1bmNoKGFyZykge1xuICAgIHZhciBpc0hpZGRlbiwgbWFjLCBuYW1lLCBwYXRoLCB2ZXJzaW9ucztcbiAgICBuYW1lID0gYXJnLm5hbWUsIGlzSGlkZGVuID0gYXJnLmlzSGlkZGVuLCBtYWMgPSBhcmcubWFjLCBwYXRoID0gYXJnLnBhdGg7XG4gICAgdGhpcy5maXhPcHRzID0gYmluZCh0aGlzLmZpeE9wdHMsIHRoaXMpO1xuICAgIHRoaXMuaXNFbmFibGVkID0gYmluZCh0aGlzLmlzRW5hYmxlZCwgdGhpcyk7XG4gICAgdGhpcy5kaXNhYmxlID0gYmluZCh0aGlzLmRpc2FibGUsIHRoaXMpO1xuICAgIHRoaXMuZW5hYmxlID0gYmluZCh0aGlzLmVuYWJsZSwgdGhpcyk7XG4gICAgaWYgKG5hbWUgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBzcGVjaWZ5IGEgbmFtZScpO1xuICAgIH1cbiAgICB0aGlzLm9wdHMgPSB7XG4gICAgICBhcHBOYW1lOiBuYW1lLFxuICAgICAgaXNIaWRkZW5PbkxhdW5jaDogaXNIaWRkZW4gIT0gbnVsbCA/IGlzSGlkZGVuIDogZmFsc2UsXG4gICAgICBtYWM6IG1hYyAhPSBudWxsID8gbWFjIDoge31cbiAgICB9O1xuICAgIHZlcnNpb25zID0gdHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiYgcHJvY2VzcyAhPT0gbnVsbCA/IHByb2Nlc3MudmVyc2lvbnMgOiB2b2lkIDA7XG4gICAgaWYgKHBhdGggIT0gbnVsbCkge1xuICAgICAgaWYgKCFpc1BhdGhBYnNvbHV0ZShwYXRoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhdGggbXVzdCBiZSBhYnNvbHV0ZScpO1xuICAgICAgfVxuICAgICAgdGhpcy5vcHRzLmFwcFBhdGggPSBwYXRoO1xuICAgIH0gZWxzZSBpZiAoKHZlcnNpb25zICE9IG51bGwpICYmICgodmVyc2lvbnMubncgIT0gbnVsbCkgfHwgKHZlcnNpb25zWydub2RlLXdlYmtpdCddICE9IG51bGwpIHx8ICh2ZXJzaW9ucy5lbGVjdHJvbiAhPSBudWxsKSkpIHtcbiAgICAgIHRoaXMub3B0cy5hcHBQYXRoID0gcHJvY2Vzcy5leGVjUGF0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBnaXZlIGEgcGF0aCAodGhpcyBpcyBvbmx5IGF1dG8tZGV0ZWN0ZWQgZm9yIE5XLmpzIGFuZCBFbGVjdHJvbiBhcHBzKScpO1xuICAgIH1cbiAgICB0aGlzLmZpeE9wdHMoKTtcbiAgICB0aGlzLmFwaSA9IG51bGw7XG4gICAgaWYgKC9ed2luLy50ZXN0KHByb2Nlc3MucGxhdGZvcm0pKSB7XG4gICAgICB0aGlzLmFwaSA9IHJlcXVpcmUoJy4vQXV0b0xhdW5jaFdpbmRvd3MnKTtcbiAgICB9IGVsc2UgaWYgKC9kYXJ3aW4vLnRlc3QocHJvY2Vzcy5wbGF0Zm9ybSkpIHtcbiAgICAgIHRoaXMuYXBpID0gcmVxdWlyZSgnLi9BdXRvTGF1bmNoTWFjJyk7XG4gICAgfSBlbHNlIGlmICgvbGludXgvLnRlc3QocHJvY2Vzcy5wbGF0Zm9ybSkpIHtcbiAgICAgIHRoaXMuYXBpID0gcmVxdWlyZSgnLi9BdXRvTGF1bmNoTGludXgnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBwbGF0Zm9ybScpO1xuICAgIH1cbiAgfVxuXG4gIEF1dG9MYXVuY2gucHJvdG90eXBlLmVuYWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmFwaS5lbmFibGUodGhpcy5vcHRzKTtcbiAgfTtcblxuICBBdXRvTGF1bmNoLnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuYXBpLmRpc2FibGUodGhpcy5vcHRzLmFwcE5hbWUsIHRoaXMub3B0cy5tYWMpO1xuICB9O1xuXG4gIEF1dG9MYXVuY2gucHJvdG90eXBlLmlzRW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmFwaS5pc0VuYWJsZWQodGhpcy5vcHRzLmFwcE5hbWUsIHRoaXMub3B0cy5tYWMpO1xuICB9O1xuXG5cbiAgLyogUHJpdmF0ZSAqL1xuXG4gIEF1dG9MYXVuY2gucHJvdG90eXBlLmZpeE1hY0V4ZWNQYXRoID0gZnVuY3Rpb24ocGF0aCwgbWFjT3B0aW9ucykge1xuICAgIHBhdGggPSBwYXRoLnJlcGxhY2UoLyheLis/W15cXC9dKz9cXC5hcHApXFwvQ29udGVudHNcXC8oRnJhbWV3b3Jrc1xcLygoXFwxfFteXFwvXSs/KSBIZWxwZXIpXFwuYXBwXFwvQ29udGVudHNcXC9NYWNPU1xcL1xcM3xNYWNPU1xcL0VsZWN0cm9uKS8sICckMScpO1xuICAgIGlmICghbWFjT3B0aW9ucy51c2VMYXVuY2hBZ2VudCkge1xuICAgICAgcGF0aCA9IHBhdGgucmVwbGFjZSgvXFwuYXBwXFwvQ29udGVudHNcXC9NYWNPU1xcL1teXFwvXSokLywgJy5hcHAnKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhdGg7XG4gIH07XG5cbiAgQXV0b0xhdW5jaC5wcm90b3R5cGUuZml4T3B0cyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0ZW1wUGF0aDtcbiAgICB0aGlzLm9wdHMuYXBwUGF0aCA9IHRoaXMub3B0cy5hcHBQYXRoLnJlcGxhY2UoL1xcLyQvLCAnJyk7XG4gICAgaWYgKC9kYXJ3aW4vLnRlc3QocHJvY2Vzcy5wbGF0Zm9ybSkpIHtcbiAgICAgIHRoaXMub3B0cy5hcHBQYXRoID0gdGhpcy5maXhNYWNFeGVjUGF0aCh0aGlzLm9wdHMuYXBwUGF0aCwgdGhpcy5vcHRzLm1hYyk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdHMuYXBwUGF0aC5pbmRleE9mKCcvJykgIT09IC0xKSB7XG4gICAgICB0ZW1wUGF0aCA9IHRoaXMub3B0cy5hcHBQYXRoLnNwbGl0KCcvJyk7XG4gICAgICB0aGlzLm9wdHMuYXBwTmFtZSA9IHRlbXBQYXRoW3RlbXBQYXRoLmxlbmd0aCAtIDFdO1xuICAgIH0gZWxzZSBpZiAodGhpcy5vcHRzLmFwcFBhdGguaW5kZXhPZignXFxcXCcpICE9PSAtMSkge1xuICAgICAgdGVtcFBhdGggPSB0aGlzLm9wdHMuYXBwUGF0aC5zcGxpdCgnXFxcXCcpO1xuICAgICAgdGhpcy5vcHRzLmFwcE5hbWUgPSB0ZW1wUGF0aFt0ZW1wUGF0aC5sZW5ndGggLSAxXTtcbiAgICAgIHRoaXMub3B0cy5hcHBOYW1lID0gdGhpcy5vcHRzLmFwcE5hbWUuc3Vic3RyKDAsIHRoaXMub3B0cy5hcHBOYW1lLmxlbmd0aCAtICcuZXhlJy5sZW5ndGgpO1xuICAgIH1cbiAgICBpZiAoL2Rhcndpbi8udGVzdChwcm9jZXNzLnBsYXRmb3JtKSkge1xuICAgICAgaWYgKHRoaXMub3B0cy5hcHBOYW1lLmluZGV4T2YoJy5hcHAnLCB0aGlzLm9wdHMuYXBwTmFtZS5sZW5ndGggLSAnLmFwcCcubGVuZ3RoKSAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0cy5hcHBOYW1lID0gdGhpcy5vcHRzLmFwcE5hbWUuc3Vic3RyKDAsIHRoaXMub3B0cy5hcHBOYW1lLmxlbmd0aCAtICcuYXBwJy5sZW5ndGgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICByZXR1cm4gQXV0b0xhdW5jaDtcblxufSkoKTtcbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gYmFsYW5jZWQ7XG5mdW5jdGlvbiBiYWxhbmNlZChhLCBiLCBzdHIpIHtcbiAgaWYgKGEgaW5zdGFuY2VvZiBSZWdFeHApIGEgPSBtYXliZU1hdGNoKGEsIHN0cik7XG4gIGlmIChiIGluc3RhbmNlb2YgUmVnRXhwKSBiID0gbWF5YmVNYXRjaChiLCBzdHIpO1xuXG4gIHZhciByID0gcmFuZ2UoYSwgYiwgc3RyKTtcblxuICByZXR1cm4gciAmJiB7XG4gICAgc3RhcnQ6IHJbMF0sXG4gICAgZW5kOiByWzFdLFxuICAgIHByZTogc3RyLnNsaWNlKDAsIHJbMF0pLFxuICAgIGJvZHk6IHN0ci5zbGljZShyWzBdICsgYS5sZW5ndGgsIHJbMV0pLFxuICAgIHBvc3Q6IHN0ci5zbGljZShyWzFdICsgYi5sZW5ndGgpXG4gIH07XG59XG5cbmZ1bmN0aW9uIG1heWJlTWF0Y2gocmVnLCBzdHIpIHtcbiAgdmFyIG0gPSBzdHIubWF0Y2gocmVnKTtcbiAgcmV0dXJuIG0gPyBtWzBdIDogbnVsbDtcbn1cblxuYmFsYW5jZWQucmFuZ2UgPSByYW5nZTtcbmZ1bmN0aW9uIHJhbmdlKGEsIGIsIHN0cikge1xuICB2YXIgYmVncywgYmVnLCBsZWZ0LCByaWdodCwgcmVzdWx0O1xuICB2YXIgYWkgPSBzdHIuaW5kZXhPZihhKTtcbiAgdmFyIGJpID0gc3RyLmluZGV4T2YoYiwgYWkgKyAxKTtcbiAgdmFyIGkgPSBhaTtcblxuICBpZiAoYWkgPj0gMCAmJiBiaSA+IDApIHtcbiAgICBiZWdzID0gW107XG4gICAgbGVmdCA9IHN0ci5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaSA+PSAwICYmICFyZXN1bHQpIHtcbiAgICAgIGlmIChpID09IGFpKSB7XG4gICAgICAgIGJlZ3MucHVzaChpKTtcbiAgICAgICAgYWkgPSBzdHIuaW5kZXhPZihhLCBpICsgMSk7XG4gICAgICB9IGVsc2UgaWYgKGJlZ3MubGVuZ3RoID09IDEpIHtcbiAgICAgICAgcmVzdWx0ID0gWyBiZWdzLnBvcCgpLCBiaSBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmVnID0gYmVncy5wb3AoKTtcbiAgICAgICAgaWYgKGJlZyA8IGxlZnQpIHtcbiAgICAgICAgICBsZWZ0ID0gYmVnO1xuICAgICAgICAgIHJpZ2h0ID0gYmk7XG4gICAgICAgIH1cblxuICAgICAgICBiaSA9IHN0ci5pbmRleE9mKGIsIGkgKyAxKTtcbiAgICAgIH1cblxuICAgICAgaSA9IGFpIDwgYmkgJiYgYWkgPj0gMCA/IGFpIDogYmk7XG4gICAgfVxuXG4gICAgaWYgKGJlZ3MubGVuZ3RoKSB7XG4gICAgICByZXN1bHQgPSBbIGxlZnQsIHJpZ2h0IF07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbiIsInZhciBDaGFpbnNhdyA9IHJlcXVpcmUoJ2NoYWluc2F3Jyk7XG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIEJ1ZmZlcnMgPSByZXF1aXJlKCdidWZmZXJzJyk7XG52YXIgVmFycyA9IHJlcXVpcmUoJy4vbGliL3ZhcnMuanMnKTtcbnZhciBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKS5TdHJlYW07XG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChidWZPckVtLCBldmVudE5hbWUpIHtcbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKGJ1Zk9yRW0pKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLnBhcnNlKGJ1Zk9yRW0pO1xuICAgIH1cbiAgICBcbiAgICB2YXIgcyA9IGV4cG9ydHMuc3RyZWFtKCk7XG4gICAgaWYgKGJ1Zk9yRW0gJiYgYnVmT3JFbS5waXBlKSB7XG4gICAgICAgIGJ1Zk9yRW0ucGlwZShzKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYnVmT3JFbSkge1xuICAgICAgICBidWZPckVtLm9uKGV2ZW50TmFtZSB8fCAnZGF0YScsIGZ1bmN0aW9uIChidWYpIHtcbiAgICAgICAgICAgIHMud3JpdGUoYnVmKTtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBidWZPckVtLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzLmVuZCgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHM7XG59O1xuXG5leHBvcnRzLnN0cmVhbSA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgIGlmIChpbnB1dCkgcmV0dXJuIGV4cG9ydHMuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICBcbiAgICB2YXIgcGVuZGluZyA9IG51bGw7XG4gICAgZnVuY3Rpb24gZ2V0Qnl0ZXMgKGJ5dGVzLCBjYiwgc2tpcCkge1xuICAgICAgICBwZW5kaW5nID0ge1xuICAgICAgICAgICAgYnl0ZXMgOiBieXRlcyxcbiAgICAgICAgICAgIHNraXAgOiBza2lwLFxuICAgICAgICAgICAgY2IgOiBmdW5jdGlvbiAoYnVmKSB7XG4gICAgICAgICAgICAgICAgcGVuZGluZyA9IG51bGw7XG4gICAgICAgICAgICAgICAgY2IoYnVmKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIGRpc3BhdGNoKCk7XG4gICAgfVxuICAgIFxuICAgIHZhciBvZmZzZXQgPSBudWxsO1xuICAgIGZ1bmN0aW9uIGRpc3BhdGNoICgpIHtcbiAgICAgICAgaWYgKCFwZW5kaW5nKSB7XG4gICAgICAgICAgICBpZiAoY2F1Z2h0RW5kKSBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHBlbmRpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHBlbmRpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBieXRlcyA9IG9mZnNldCArIHBlbmRpbmcuYnl0ZXM7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChidWZmZXJzLmxlbmd0aCA+PSBieXRlcykge1xuICAgICAgICAgICAgICAgIHZhciBidWY7XG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZiA9IGJ1ZmZlcnMuc3BsaWNlKDAsIGJ5dGVzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwZW5kaW5nLnNraXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZiA9IGJ1Zi5zbGljZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXBlbmRpbmcuc2tpcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVmID0gYnVmZmVycy5zbGljZShvZmZzZXQsIGJ5dGVzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBieXRlcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKHBlbmRpbmcuc2tpcCkge1xuICAgICAgICAgICAgICAgICAgICBwZW5kaW5nLmNiKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwZW5kaW5nLmNiKGJ1Zik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIGZ1bmN0aW9uIGJ1aWxkZXIgKHNhdykge1xuICAgICAgICBmdW5jdGlvbiBuZXh0ICgpIHsgaWYgKCFkb25lKSBzYXcubmV4dCgpIH1cbiAgICAgICAgXG4gICAgICAgIHZhciBzZWxmID0gd29yZHMoZnVuY3Rpb24gKGJ5dGVzLCBjYikge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgZ2V0Qnl0ZXMoYnl0ZXMsIGZ1bmN0aW9uIChidWYpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFycy5zZXQobmFtZSwgY2IoYnVmKSk7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgc2VsZi50YXAgPSBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgICAgIHNhdy5uZXN0KGNiLCB2YXJzLnN0b3JlKTtcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIHNlbGYuaW50byA9IGZ1bmN0aW9uIChrZXksIGNiKSB7XG4gICAgICAgICAgICBpZiAoIXZhcnMuZ2V0KGtleSkpIHZhcnMuc2V0KGtleSwge30pO1xuICAgICAgICAgICAgdmFyIHBhcmVudCA9IHZhcnM7XG4gICAgICAgICAgICB2YXJzID0gVmFycyhwYXJlbnQuZ2V0KGtleSkpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBzYXcubmVzdChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY2IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRhcChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhcnMgPSBwYXJlbnQ7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCB2YXJzLnN0b3JlKTtcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIHNlbGYuZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXJzLnN0b3JlID0ge307XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICBzZWxmLmxvb3AgPSBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgICAgIHZhciBlbmQgPSBmYWxzZTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgc2F3Lm5lc3QoZmFsc2UsIGZ1bmN0aW9uIGxvb3AgKCkge1xuICAgICAgICAgICAgICAgIHRoaXMudmFycyA9IHZhcnMuc3RvcmU7XG4gICAgICAgICAgICAgICAgY2IuY2FsbCh0aGlzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGVuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICB9LCB2YXJzLnN0b3JlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRhcChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbmQpIHNhdy5uZXh0KClcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBsb29wLmNhbGwodGhpcylcbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICAgICAgfSwgdmFycy5zdG9yZSk7XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICBzZWxmLmJ1ZmZlciA9IGZ1bmN0aW9uIChuYW1lLCBieXRlcykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBieXRlcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBieXRlcyA9IHZhcnMuZ2V0KGJ5dGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZ2V0Qnl0ZXMoYnl0ZXMsIGZ1bmN0aW9uIChidWYpIHtcbiAgICAgICAgICAgICAgICB2YXJzLnNldChuYW1lLCBidWYpO1xuICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgc2VsZi5za2lwID0gZnVuY3Rpb24gKGJ5dGVzKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGJ5dGVzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGJ5dGVzID0gdmFycy5nZXQoYnl0ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBnZXRCeXRlcyhieXRlcywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgc2VsZi5zY2FuID0gZnVuY3Rpb24gZmluZCAobmFtZSwgc2VhcmNoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNlYXJjaCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBzZWFyY2ggPSBuZXcgQnVmZmVyKHNlYXJjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghQnVmZmVyLmlzQnVmZmVyKHNlYXJjaCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NlYXJjaCBtdXN0IGJlIGEgQnVmZmVyIG9yIGEgc3RyaW5nJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciB0YWtlbiA9IDA7XG4gICAgICAgICAgICBwZW5kaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBwb3MgPSBidWZmZXJzLmluZGV4T2Yoc2VhcmNoLCBvZmZzZXQgKyB0YWtlbik7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSBwb3Mtb2Zmc2V0LXRha2VuO1xuICAgICAgICAgICAgICAgIGlmIChwb3MgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHBlbmRpbmcgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpZiAob2Zmc2V0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhcnMuc2V0KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVycy5zbGljZShvZmZzZXQsIG9mZnNldCArIHRha2VuICsgaSlcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgKz0gdGFrZW4gKyBpICsgc2VhcmNoLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhcnMuc2V0KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVycy5zbGljZSgwLCB0YWtlbiArIGkpXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVycy5zcGxpY2UoMCwgdGFrZW4gKyBpICsgc2VhcmNoLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGkgPSBNYXRoLm1heChidWZmZXJzLmxlbmd0aCAtIHNlYXJjaC5sZW5ndGggLSBvZmZzZXQgLSB0YWtlbiwgMCk7XG5cdFx0XHRcdH1cbiAgICAgICAgICAgICAgICB0YWtlbiArPSBpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGRpc3BhdGNoKCk7XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICBzZWxmLnBlZWsgPSBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgICAgICBzYXcubmVzdChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY2IuY2FsbCh0aGlzLCB2YXJzLnN0b3JlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRhcChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG4gICAgXG4gICAgdmFyIHN0cmVhbSA9IENoYWluc2F3LmxpZ2h0KGJ1aWxkZXIpO1xuICAgIHN0cmVhbS53cml0YWJsZSA9IHRydWU7XG4gICAgXG4gICAgdmFyIGJ1ZmZlcnMgPSBCdWZmZXJzKCk7XG4gICAgXG4gICAgc3RyZWFtLndyaXRlID0gZnVuY3Rpb24gKGJ1Zikge1xuICAgICAgICBidWZmZXJzLnB1c2goYnVmKTtcbiAgICAgICAgZGlzcGF0Y2goKTtcbiAgICB9O1xuICAgIFxuICAgIHZhciB2YXJzID0gVmFycygpO1xuICAgIFxuICAgIHZhciBkb25lID0gZmFsc2UsIGNhdWdodEVuZCA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNhdWdodEVuZCA9IHRydWU7XG4gICAgfTtcbiAgICBcbiAgICBzdHJlYW0ucGlwZSA9IFN0cmVhbS5wcm90b3R5cGUucGlwZTtcbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhFdmVudEVtaXR0ZXIucHJvdG90eXBlKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHN0cmVhbVtuYW1lXSA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGVbbmFtZV07XG4gICAgfSk7XG4gICAgXG4gICAgcmV0dXJuIHN0cmVhbTtcbn07XG5cbmV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbiBwYXJzZSAoYnVmZmVyKSB7XG4gICAgdmFyIHNlbGYgPSB3b3JkcyhmdW5jdGlvbiAoYnl0ZXMsIGNiKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgaWYgKG9mZnNldCArIGJ5dGVzIDw9IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYnVmID0gYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgYnl0ZXMpO1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSBieXRlcztcbiAgICAgICAgICAgICAgICB2YXJzLnNldChuYW1lLCBjYihidWYpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhcnMuc2V0KG5hbWUsIG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgXG4gICAgdmFyIG9mZnNldCA9IDA7XG4gICAgdmFyIHZhcnMgPSBWYXJzKCk7XG4gICAgc2VsZi52YXJzID0gdmFycy5zdG9yZTtcbiAgICBcbiAgICBzZWxmLnRhcCA9IGZ1bmN0aW9uIChjYikge1xuICAgICAgICBjYi5jYWxsKHNlbGYsIHZhcnMuc3RvcmUpO1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuICAgIFxuICAgIHNlbGYuaW50byA9IGZ1bmN0aW9uIChrZXksIGNiKSB7XG4gICAgICAgIGlmICghdmFycy5nZXQoa2V5KSkge1xuICAgICAgICAgICAgdmFycy5zZXQoa2V5LCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhcmVudCA9IHZhcnM7XG4gICAgICAgIHZhcnMgPSBWYXJzKHBhcmVudC5nZXQoa2V5KSk7XG4gICAgICAgIGNiLmNhbGwoc2VsZiwgdmFycy5zdG9yZSk7XG4gICAgICAgIHZhcnMgPSBwYXJlbnQ7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG4gICAgXG4gICAgc2VsZi5sb29wID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgIHZhciBlbmQgPSBmYWxzZTtcbiAgICAgICAgdmFyIGVuZGVyID0gZnVuY3Rpb24gKCkgeyBlbmQgPSB0cnVlIH07XG4gICAgICAgIHdoaWxlIChlbmQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBjYi5jYWxsKHNlbGYsIGVuZGVyLCB2YXJzLnN0b3JlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuICAgIFxuICAgIHNlbGYuYnVmZmVyID0gZnVuY3Rpb24gKG5hbWUsIHNpemUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzaXplID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgc2l6ZSA9IHZhcnMuZ2V0KHNpemUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBidWYgPSBidWZmZXIuc2xpY2Uob2Zmc2V0LCBNYXRoLm1pbihidWZmZXIubGVuZ3RoLCBvZmZzZXQgKyBzaXplKSk7XG4gICAgICAgIG9mZnNldCArPSBzaXplO1xuICAgICAgICB2YXJzLnNldChuYW1lLCBidWYpO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcbiAgICBcbiAgICBzZWxmLnNraXAgPSBmdW5jdGlvbiAoYnl0ZXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBieXRlcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGJ5dGVzID0gdmFycy5nZXQoYnl0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIG9mZnNldCArPSBieXRlcztcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG4gICAgXG4gICAgc2VsZi5zY2FuID0gZnVuY3Rpb24gKG5hbWUsIHNlYXJjaCkge1xuICAgICAgICBpZiAodHlwZW9mIHNlYXJjaCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHNlYXJjaCA9IG5ldyBCdWZmZXIoc2VhcmNoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghQnVmZmVyLmlzQnVmZmVyKHNlYXJjaCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2VhcmNoIG11c3QgYmUgYSBCdWZmZXIgb3IgYSBzdHJpbmcnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXJzLnNldChuYW1lLCBudWxsKTtcbiAgICAgICAgXG4gICAgICAgIC8vIHNpbXBsZSBidXQgc2xvdyBzdHJpbmcgc2VhcmNoXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpICsgb2Zmc2V0IDw9IGJ1ZmZlci5sZW5ndGggLSBzZWFyY2gubGVuZ3RoICsgMTsgaSsrKSB7XG4gICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICAgIHZhciBqID0gMDtcbiAgICAgICAgICAgICAgICBqIDwgc2VhcmNoLmxlbmd0aCAmJiBidWZmZXJbb2Zmc2V0K2kral0gPT09IHNlYXJjaFtqXTtcbiAgICAgICAgICAgICAgICBqKytcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoaiA9PT0gc2VhcmNoLmxlbmd0aCkgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHZhcnMuc2V0KG5hbWUsIGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIGkpKTtcbiAgICAgICAgb2Zmc2V0ICs9IGkgKyBzZWFyY2gubGVuZ3RoO1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuICAgIFxuICAgIHNlbGYucGVlayA9IGZ1bmN0aW9uIChjYikge1xuICAgICAgICB2YXIgd2FzID0gb2Zmc2V0O1xuICAgICAgICBjYi5jYWxsKHNlbGYsIHZhcnMuc3RvcmUpO1xuICAgICAgICBvZmZzZXQgPSB3YXM7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG4gICAgXG4gICAgc2VsZi5mbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFycy5zdG9yZSA9IHt9O1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuICAgIFxuICAgIHNlbGYuZW9mID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gb2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGg7XG4gICAgfTtcbiAgICBcbiAgICByZXR1cm4gc2VsZjtcbn07XG5cbi8vIGNvbnZlcnQgYnl0ZSBzdHJpbmdzIHRvIHVuc2lnbmVkIGxpdHRsZSBlbmRpYW4gbnVtYmVyc1xuZnVuY3Rpb24gZGVjb2RlTEV1IChieXRlcykge1xuICAgIHZhciBhY2MgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYWNjICs9IE1hdGgucG93KDI1NixpKSAqIGJ5dGVzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gYWNjO1xufVxuXG4vLyBjb252ZXJ0IGJ5dGUgc3RyaW5ncyB0byB1bnNpZ25lZCBiaWcgZW5kaWFuIG51bWJlcnNcbmZ1bmN0aW9uIGRlY29kZUJFdSAoYnl0ZXMpIHtcbiAgICB2YXIgYWNjID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFjYyArPSBNYXRoLnBvdygyNTYsIGJ5dGVzLmxlbmd0aCAtIGkgLSAxKSAqIGJ5dGVzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gYWNjO1xufVxuXG4vLyBjb252ZXJ0IGJ5dGUgc3RyaW5ncyB0byBzaWduZWQgYmlnIGVuZGlhbiBudW1iZXJzXG5mdW5jdGlvbiBkZWNvZGVCRXMgKGJ5dGVzKSB7XG4gICAgdmFyIHZhbCA9IGRlY29kZUJFdShieXRlcyk7XG4gICAgaWYgKChieXRlc1swXSAmIDB4ODApID09IDB4ODApIHtcbiAgICAgICAgdmFsIC09IE1hdGgucG93KDI1NiwgYnl0ZXMubGVuZ3RoKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbDtcbn1cblxuLy8gY29udmVydCBieXRlIHN0cmluZ3MgdG8gc2lnbmVkIGxpdHRsZSBlbmRpYW4gbnVtYmVyc1xuZnVuY3Rpb24gZGVjb2RlTEVzIChieXRlcykge1xuICAgIHZhciB2YWwgPSBkZWNvZGVMRXUoYnl0ZXMpO1xuICAgIGlmICgoYnl0ZXNbYnl0ZXMubGVuZ3RoIC0gMV0gJiAweDgwKSA9PSAweDgwKSB7XG4gICAgICAgIHZhbCAtPSBNYXRoLnBvdygyNTYsIGJ5dGVzLmxlbmd0aCk7XG4gICAgfVxuICAgIHJldHVybiB2YWw7XG59XG5cbmZ1bmN0aW9uIHdvcmRzIChkZWNvZGUpIHtcbiAgICB2YXIgc2VsZiA9IHt9O1xuICAgIFxuICAgIFsgMSwgMiwgNCwgOCBdLmZvckVhY2goZnVuY3Rpb24gKGJ5dGVzKSB7XG4gICAgICAgIHZhciBiaXRzID0gYnl0ZXMgKiA4O1xuICAgICAgICBcbiAgICAgICAgc2VsZlsnd29yZCcgKyBiaXRzICsgJ2xlJ11cbiAgICAgICAgPSBzZWxmWyd3b3JkJyArIGJpdHMgKyAnbHUnXVxuICAgICAgICA9IGRlY29kZShieXRlcywgZGVjb2RlTEV1KTtcbiAgICAgICAgXG4gICAgICAgIHNlbGZbJ3dvcmQnICsgYml0cyArICdscyddXG4gICAgICAgID0gZGVjb2RlKGJ5dGVzLCBkZWNvZGVMRXMpO1xuICAgICAgICBcbiAgICAgICAgc2VsZlsnd29yZCcgKyBiaXRzICsgJ2JlJ11cbiAgICAgICAgPSBzZWxmWyd3b3JkJyArIGJpdHMgKyAnYnUnXVxuICAgICAgICA9IGRlY29kZShieXRlcywgZGVjb2RlQkV1KTtcbiAgICAgICAgXG4gICAgICAgIHNlbGZbJ3dvcmQnICsgYml0cyArICdicyddXG4gICAgICAgID0gZGVjb2RlKGJ5dGVzLCBkZWNvZGVCRXMpO1xuICAgIH0pO1xuICAgIFxuICAgIC8vIHdvcmQ4YmUobikgPT0gd29yZDhsZShuKSBmb3IgYWxsIG5cbiAgICBzZWxmLndvcmQ4ID0gc2VsZi53b3JkOHUgPSBzZWxmLndvcmQ4YmU7XG4gICAgc2VsZi53b3JkOHMgPSBzZWxmLndvcmQ4YnM7XG4gICAgXG4gICAgcmV0dXJuIHNlbGY7XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdG9yZSkge1xuICAgIGZ1bmN0aW9uIGdldHNldCAobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIG5vZGUgPSB2YXJzLnN0b3JlO1xuICAgICAgICB2YXIga2V5cyA9IG5hbWUuc3BsaXQoJy4nKTtcbiAgICAgICAga2V5cy5zbGljZSgwLC0xKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICBpZiAobm9kZVtrXSA9PT0gdW5kZWZpbmVkKSBub2RlW2tdID0ge307XG4gICAgICAgICAgICBub2RlID0gbm9kZVtrXVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGtleSA9IGtleXNba2V5cy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGVba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICB2YXIgdmFycyA9IHtcbiAgICAgICAgZ2V0IDogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRzZXQobmFtZSk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCA6IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGdldHNldChuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIHN0b3JlIDogc3RvcmUgfHwge30sXG4gICAgfTtcbiAgICByZXR1cm4gdmFycztcbn07XG4iLCJcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcnIsc2VhcmNoLGNvbXBhcml0b3IpIHtcbiAgaWYoIWFycikgcmV0dXJuIC0xO1xuICAvLyBhcyBsb25nIGFzIGl0IGhhcyBhIGxlbmd0aCBpIHdpbGwgdHJ5IGFuZCBpdHRlcmF0ZSBvdmVyIGl0LlxuICBpZihhcnIubGVuZ3RoID09PSB1bmRlZmluZWQpIHJldHVybiAtMTtcbiAgXG4gIGlmKCFjb21wYXJpdG9yKSBjb21wYXJpdG9yID0gbW9kdWxlLmV4cG9ydHMuX2RlZmF1bHRDb21wYXJpdG9yKCk7XG5cbiAgcmV0dXJuIGJzKGFycixzZWFyY2gsY29tcGFyaXRvcik7XG59XG5cbm1vZHVsZS5leHBvcnRzLmZpcnN0ID0gZnVuY3Rpb24oYXJyLHNlYXJjaCxjb21wYXJpdG9yKSB7XG4gIHJldHVybiBtb2R1bGUuZXhwb3J0cy5jbG9zZXN0KGFycixzZWFyY2gse2V4aXN0czp0cnVlfSxjb21wYXJpdG9yKTtcbn1cblxubW9kdWxlLmV4cG9ydHMubGFzdCA9IGZ1bmN0aW9uKGFycixzZWFyY2gsY29tcGFyaXRvcikge1xuICByZXR1cm4gbW9kdWxlLmV4cG9ydHMuY2xvc2VzdChhcnIsc2VhcmNoLHtleGlzdHM6dHJ1ZSxlbmQ6dHJ1ZX0sY29tcGFyaXRvcik7XG59XG5cbm1vZHVsZS5leHBvcnRzLmNsb3Nlc3QgPSBmdW5jdGlvbihhcnIsc2VhcmNoLG9wdHMsY29tcGFyaXRvcikge1xuXG4gIGlmKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29tcGFyaXRvciA9IG9wdHM7XG4gICAgb3B0cyA9IHt9O1xuICB9XG5cbiAgaWYoYXJyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xO1xuICBpZihhcnIubGVuZ3RoID09PSAxKSByZXR1cm4gMDtcblxuICBvcHRzID0gb3B0c3x8e307XG4gIGlmKCFjb21wYXJpdG9yKSBjb21wYXJpdG9yID0gdGhpcy5fZGVmYXVsdENvbXBhcml0b3IoKTtcbiAgXG4gIHZhciBjbG9zZXN0ID0gYnNjbG9zZXN0KGFyciwgc2VhcmNoLCBjb21wYXJpdG9yLCBvcHRzLmVuZCwgb3B0cy5leGlzdHM/ZmFsc2U6dHJ1ZSk7XG5cbiAgaWYoY2xvc2VzdCA+IGFyci5sZW5ndGgtMSkgY2xvc2VzdCA9IGFyci5sZW5ndGgtMTtcbiAgZWxzZSBpZihjbG9zZXN0IDwgMCkgY2xvc2VzdCA9IDA7XG5cbiAgcmV0dXJuIGNsb3Nlc3Q7XG59XG5cbi8vIGluc2VydHMgZWxlbWVudCBpbnRvIHRoZSBjb3JyZWN0IHNvcnRlZCBzcG90IGludG8gdGhlIGFycmF5XG5tb2R1bGUuZXhwb3J0cy5pbnNlcnQgPSBmdW5jdGlvbihhcnIsc2VhcmNoLG9wdHMsY29tcGFyaXRvcil7IFxuXG4gIGlmKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29tcGFyaXRvciA9IG9wdHM7XG4gICAgb3B0cyA9IHt9O1xuICB9XG5cbiAgb3B0cyA9IG9wdHN8fHt9O1xuICBpZighY29tcGFyaXRvcikgY29tcGFyaXRvciA9IG1vZHVsZS5leHBvcnRzLl9kZWZhdWx0Q29tcGFyaXRvcigpO1xuICBpZighYXJyLmxlbmd0aCkge1xuICAgIGFyclswXSA9IHNlYXJjaDtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHZhciBjbG9zZXN0ID0gbW9kdWxlLmV4cG9ydHMuY2xvc2VzdChhcnIsc2VhcmNoLGNvbXBhcml0b3IpO1xuXG4gIHZhciBjbXAgPSBjb21wYXJpdG9yKGFycltjbG9zZXN0XSxzZWFyY2gpO1xuICBpZihjbXAgPCAwKSB7Ly9sZXNzXG4gICAgYXJyLnNwbGljZSgrK2Nsb3Nlc3QsMCxzZWFyY2gpO1xuICB9IGVsc2UgaWYoY21wID4gMCl7IFxuICAgIGFyci5zcGxpY2UoY2xvc2VzdCwwLHNlYXJjaCk7XG4gIH0gZWxzZSB7XG4gICAgaWYob3B0cy51bmlxdWUpe1xuICAgICAgYXJyW2Nsb3Nlc3RdID0gc2VhcmNoO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpbSBlcXVhbC4gdGhpcyB2YWx1ZSBzaG91bGQgYmUgYXBwZW5kZWQgdG8gdGhlIGxpc3Qgb2YgZXhpc3Rpbmcgc2FtZSBzb3J0ZWQgdmFsdWVzLlxuICAgICAgd2hpbGUoY29tcGFyaXRvcihhcnJbY2xvc2VzdF0sc2VhcmNoKSA9PT0gMCl7XG4gICAgICAgIGlmKGNsb3Nlc3QgPj0gYXJyLmxlbmd0aC0xKSBicmVhaztcbiAgICAgICAgY2xvc2VzdCsrO1xuICAgICAgfVxuXG4gICAgICBhcnIuc3BsaWNlKGNsb3Nlc3QsMCxzZWFyY2gpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY2xvc2VzdDtcbn1cblxuLy8gdGhpcyBtZXRob2QgcmV0dXJucyB0aGUgc3RhcnQgYW5kIGVuZCBpbmRpY2llcyBvZiBhIHJhbmdlLiBbc3RhcnQsZW5kXVxubW9kdWxlLmV4cG9ydHMucmFuZ2UgPSBmdW5jdGlvbihhcnIsZnJvbSx0byxjb21wYXJpdG9yKSB7XG4gIGlmKCFjb21wYXJpdG9yKSBjb21wYXJpdG9yID0gbW9kdWxlLmV4cG9ydHMuX2RlZmF1bHRDb21wYXJpdG9yKCk7XG5cbiAgdmFyIGZyb21pID0gbW9kdWxlLmV4cG9ydHMuY2xvc2VzdChhcnIsZnJvbSxjb21wYXJpdG9yKTtcblxuICB2YXIgdG9pID0gbW9kdWxlLmV4cG9ydHMuY2xvc2VzdChhcnIsdG8se2VuZDp0cnVlfSxjb21wYXJpdG9yKTtcblxuICAvLyB0aGlzIGlzIGEgaGFjay4gXG4gIC8vIGkgc2hvdWxkIGJlIGFibGUgdG8gZml4IHRoZSBhbGdvcml0aG0gYW5kIGdlbmVyYXRlIGEgY29ycmVjdCByYW5nZS5cblxuICB3aGlsZShmcm9taSA8PSB0b2kpeyBcbiAgICBpZihjb21wYXJpdG9yKGFycltmcm9taV0sZnJvbSkgPiAtMSkgYnJlYWs7XG5cbiAgICBmcm9taSsrXG4gIH1cblxuICB3aGlsZSh0b2kgPj0gZnJvbWkpeyBcbiAgICBpZihjb21wYXJpdG9yKGFyclt0b2ldLHRvKSA8IDEpIGJyZWFrO1xuICAgIHRvaS0tO1xuICB9XG5cbiAgcmV0dXJuIFtmcm9taSx0b2ldO1xufVxuXG4vLyB0aGlzIG1ldGhvZCByZXR1cm5zIHRoZSB2YWx1ZXMgb2YgYSByYW5nZTtcbm1vZHVsZS5leHBvcnRzLnJhbmdlVmFsdWUgPSBmdW5jdGlvbihhcnIsZnJvbSx0byxjb21wYXJpdG9yKXtcbiAgdmFyIHJhbmdlID0gbW9kdWxlLmV4cG9ydHMucmFuZ2UoYXJyLGZyb20sdG8sY29tcGFyaXRvcik7XG4gIHJldHVybiBhcnIuc2xpY2UocmFuZ2VbMF0scmFuZ2VbMV0rMSk7XG59XG5cbi8vXG5tb2R1bGUuZXhwb3J0cy5pbmRleE9iamVjdCA9IGZ1bmN0aW9uKG8sZXh0cmFjdG9yKSB7XG4gIHZhciBpbmRleCA9IFtdO1xuICBcbiAgT2JqZWN0LmtleXMobykuZm9yRWFjaChmdW5jdGlvbihrKXtcbiAgICBpbmRleC5wdXNoKHtrOmssdjpleHRyYWN0b3Iob1trXSl9KTtcbiAgfSk7XG5cbiAgcmV0dXJuIGluZGV4LnNvcnQoZnVuY3Rpb24obzEsbzIpe1xuICAgIHJldHVybiBvMS52IC0gbzIudjtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzLmNtcCA9IGZ1bmN0aW9uKHYxLHYyKXtcbiAgcmV0dXJuIHYxIC0gdjI7XG59XG5cbm1vZHVsZS5leHBvcnRzLl9kZWZhdWx0Q29tcGFyaXRvciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaW5kZXhNb2RlLGluZGV4TW9kZVNlYXJjaDtcbiAgcmV0dXJuIGZ1bmN0aW9uKHYsc2VhcmNoKXtcbiAgICAvLyBzdXBwb3J0IHRoZSBvYmplY3QgZm9ybWF0IG9mIGdlbmVyYXRlZCBpbmRleGVzXG4gICAgaWYoaW5kZXhNb2RlID09PSB1bmRlZmluZWQpe1xuICAgICAgaWYodHlwZW9mIHYgPT09ICdvYmplY3QnICYmIHYuaGFzT3duUHJvcGVydHkoJ3YnKSkgaW5kZXhNb2RlID0gdHJ1ZTtcbiAgICAgIGlmKHR5cGVvZiBzZWFyY2ggPT09ICdvYmplY3QnICYmIHNlYXJjaC5oYXNPd25Qcm9wZXJ0eSgndicpKSBpbmRleE1vZGVTZWFyY2ggPSB0cnVlXG4gICAgfVxuXG4gICAgaWYoaW5kZXhNb2RlKSB2ID0gdi52O1xuICAgIGlmKGluZGV4TW9kZVNlYXJjaCkgc2VhcmNoID0gc2VhcmNoLnY7XG5cbiAgICByZXR1cm4gdiAtIHNlYXJjaDtcbiAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLl9iaW5hcnlTZWFyY2ggPSBicztcbm1vZHVsZS5leHBvcnRzLl9iaW5hcnlTZWFyY2hDbG9zZXN0ID0gYnNjbG9zZXN0O1xuXG5mdW5jdGlvbiBicyhhcnIsIHNlYXJjaCwgY29tcGFyaXRvcikge1xuXG4gIHZhciBtYXggPSBhcnIubGVuZ3RoLTEsbWluID0gMCxtaWRkbGUsY21wO1xuICAvLyBjb250aW51ZSBzZWFyY2hpbmcgd2hpbGUga2V5IG1heSBleGlzdFxuICB3aGlsZSAobWF4ID49IG1pbikge1xuICAgIG1pZGRsZSA9IG1pZChtaW4sIG1heCk7XG5cbiAgICBjbXAgPSBjb21wYXJpdG9yKGFyclttaWRkbGVdLHNlYXJjaCxtaWRkbGUpO1xuXG4gICAgaWYgKGNtcCA8IDApIHtcbiAgICAgIG1pbiA9IG1pZGRsZSArIDE7XG4gICAgfSBlbHNlIGlmIChjbXAgPiAwKSB7XG4gICAgICBtYXggPSBtaWRkbGUgLSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbWlkZGxlO1xuICAgIH1cbiAgfVxuICAvLyBrZXkgbm90IGZvdW5kXG4gIHJldHVybiAtMTtcbn1cblxuZnVuY3Rpb24gYnNjbG9zZXN0KGFyciwgc2VhcmNoLCBjb21wYXJpdG9yLCBpbnZlcnQsIGNsb3Nlc3QpIHtcbiAgdmFyIG1pZHMgPSB7fVxuICAsIG1pbiA9IDAsbWF4ID0gYXJyLmxlbmd0aC0xLG1pZGRsZSxjbXBcbiAgLCBzYW5pdHkgPSBhcnIubGVuZ3RoO1xuXG4gIHdoaWxlIChtaW4gPCBtYXgpIHtcbiAgICBtaWRkbGUgPSBtaWRDYXJlZnVsKG1pbiwgbWF4LG1pZHMpOyBcbiAgICBjbXAgPSBjb21wYXJpdG9yKGFyclttaWRkbGVdLHNlYXJjaCxtaWRkbGUpO1xuICAgIGlmKGludmVydCl7XG4gICAgICBpZiAoY21wID4gMCltYXggPSBtaWRkbGUgLSAxO1xuICAgICAgZWxzZSBtaW4gPSBtaWRkbGU7ICAgXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjbXAgPCAwKW1pbiA9IG1pZGRsZSArIDE7XG4gICAgICBlbHNlIG1heCA9IG1pZGRsZTtcbiAgICB9XG4gICAgaWYoIS0tc2FuaXR5KSBicmVhaztcbiAgfVxuICAgXG4gIGlmIChtYXggPT0gbWluICYmIGNvbXBhcml0b3IoYXJyW21pbl0sc2VhcmNoKSA9PT0gMCkgcmV0dXJuIG1pbjtcbiAgXG4gIGlmKGNsb3Nlc3QpIHtcbiAgICB2YXIgbWF0Y2ggPSBjb21wYXJpdG9yKGFyclttaW5dLHNlYXJjaCk7XG4gICAgaWYobWluID09IGFyci5sZW5ndGgtMSAmJiBtYXRjaCA8IDApIHJldHVybiBtaW47XG4gICAgaWYobWluID09IDAgJiYgbWF0Y2ggPiAwKSByZXR1cm4gMDtcblxuICAgIHJldHVybiBjbG9zZXN0PyhpbnZlcnQ/bWluKzE6bWluLTEpOi0xO1xuICB9IFxuICByZXR1cm4gLTE7IFxufVxuXG5mdW5jdGlvbiBtaWQodjEsdjIpe1xuICByZXR1cm4gdjErTWF0aC5mbG9vcigodjItdjEpLzIpO1xufVxuXG5mdW5jdGlvbiBtaWRDYXJlZnVsKHYxLHYyLG1pZHMpe1xuICB2YXIgbWlkID0gdjErTWF0aC5mbG9vcigodjItdjEpLzIpO1xuICBpZihtaWRzW21pZF0pIG1pZCA9IHYxK01hdGguY2VpbCgodjItdjEpLzIpO1xuICBtaWRzW21pZF0gPSAxO1xuICByZXR1cm4gbWlkO1xufVxuIiwidmFyIGNvbmNhdE1hcCA9IHJlcXVpcmUoJ2NvbmNhdC1tYXAnKTtcbnZhciBiYWxhbmNlZCA9IHJlcXVpcmUoJ2JhbGFuY2VkLW1hdGNoJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwYW5kVG9wO1xuXG52YXIgZXNjU2xhc2ggPSAnXFwwU0xBU0gnK01hdGgucmFuZG9tKCkrJ1xcMCc7XG52YXIgZXNjT3BlbiA9ICdcXDBPUEVOJytNYXRoLnJhbmRvbSgpKydcXDAnO1xudmFyIGVzY0Nsb3NlID0gJ1xcMENMT1NFJytNYXRoLnJhbmRvbSgpKydcXDAnO1xudmFyIGVzY0NvbW1hID0gJ1xcMENPTU1BJytNYXRoLnJhbmRvbSgpKydcXDAnO1xudmFyIGVzY1BlcmlvZCA9ICdcXDBQRVJJT0QnK01hdGgucmFuZG9tKCkrJ1xcMCc7XG5cbmZ1bmN0aW9uIG51bWVyaWMoc3RyKSB7XG4gIHJldHVybiBwYXJzZUludChzdHIsIDEwKSA9PSBzdHJcbiAgICA/IHBhcnNlSW50KHN0ciwgMTApXG4gICAgOiBzdHIuY2hhckNvZGVBdCgwKTtcbn1cblxuZnVuY3Rpb24gZXNjYXBlQnJhY2VzKHN0cikge1xuICByZXR1cm4gc3RyLnNwbGl0KCdcXFxcXFxcXCcpLmpvaW4oZXNjU2xhc2gpXG4gICAgICAgICAgICAuc3BsaXQoJ1xcXFx7Jykuam9pbihlc2NPcGVuKVxuICAgICAgICAgICAgLnNwbGl0KCdcXFxcfScpLmpvaW4oZXNjQ2xvc2UpXG4gICAgICAgICAgICAuc3BsaXQoJ1xcXFwsJykuam9pbihlc2NDb21tYSlcbiAgICAgICAgICAgIC5zcGxpdCgnXFxcXC4nKS5qb2luKGVzY1BlcmlvZCk7XG59XG5cbmZ1bmN0aW9uIHVuZXNjYXBlQnJhY2VzKHN0cikge1xuICByZXR1cm4gc3RyLnNwbGl0KGVzY1NsYXNoKS5qb2luKCdcXFxcJylcbiAgICAgICAgICAgIC5zcGxpdChlc2NPcGVuKS5qb2luKCd7JylcbiAgICAgICAgICAgIC5zcGxpdChlc2NDbG9zZSkuam9pbignfScpXG4gICAgICAgICAgICAuc3BsaXQoZXNjQ29tbWEpLmpvaW4oJywnKVxuICAgICAgICAgICAgLnNwbGl0KGVzY1BlcmlvZCkuam9pbignLicpO1xufVxuXG5cbi8vIEJhc2ljYWxseSBqdXN0IHN0ci5zcGxpdChcIixcIiksIGJ1dCBoYW5kbGluZyBjYXNlc1xuLy8gd2hlcmUgd2UgaGF2ZSBuZXN0ZWQgYnJhY2VkIHNlY3Rpb25zLCB3aGljaCBzaG91bGQgYmVcbi8vIHRyZWF0ZWQgYXMgaW5kaXZpZHVhbCBtZW1iZXJzLCBsaWtlIHthLHtiLGN9LGR9XG5mdW5jdGlvbiBwYXJzZUNvbW1hUGFydHMoc3RyKSB7XG4gIGlmICghc3RyKVxuICAgIHJldHVybiBbJyddO1xuXG4gIHZhciBwYXJ0cyA9IFtdO1xuICB2YXIgbSA9IGJhbGFuY2VkKCd7JywgJ30nLCBzdHIpO1xuXG4gIGlmICghbSlcbiAgICByZXR1cm4gc3RyLnNwbGl0KCcsJyk7XG5cbiAgdmFyIHByZSA9IG0ucHJlO1xuICB2YXIgYm9keSA9IG0uYm9keTtcbiAgdmFyIHBvc3QgPSBtLnBvc3Q7XG4gIHZhciBwID0gcHJlLnNwbGl0KCcsJyk7XG5cbiAgcFtwLmxlbmd0aC0xXSArPSAneycgKyBib2R5ICsgJ30nO1xuICB2YXIgcG9zdFBhcnRzID0gcGFyc2VDb21tYVBhcnRzKHBvc3QpO1xuICBpZiAocG9zdC5sZW5ndGgpIHtcbiAgICBwW3AubGVuZ3RoLTFdICs9IHBvc3RQYXJ0cy5zaGlmdCgpO1xuICAgIHAucHVzaC5hcHBseShwLCBwb3N0UGFydHMpO1xuICB9XG5cbiAgcGFydHMucHVzaC5hcHBseShwYXJ0cywgcCk7XG5cbiAgcmV0dXJuIHBhcnRzO1xufVxuXG5mdW5jdGlvbiBleHBhbmRUb3Aoc3RyKSB7XG4gIGlmICghc3RyKVxuICAgIHJldHVybiBbXTtcblxuICAvLyBJIGRvbid0IGtub3cgd2h5IEJhc2ggNC4zIGRvZXMgdGhpcywgYnV0IGl0IGRvZXMuXG4gIC8vIEFueXRoaW5nIHN0YXJ0aW5nIHdpdGgge30gd2lsbCBoYXZlIHRoZSBmaXJzdCB0d28gYnl0ZXMgcHJlc2VydmVkXG4gIC8vIGJ1dCAqb25seSogYXQgdGhlIHRvcCBsZXZlbCwgc28ge30sYX1iIHdpbGwgbm90IGV4cGFuZCB0byBhbnl0aGluZyxcbiAgLy8gYnV0IGF7fSxifWMgd2lsbCBiZSBleHBhbmRlZCB0byBbYX1jLGFiY10uXG4gIC8vIE9uZSBjb3VsZCBhcmd1ZSB0aGF0IHRoaXMgaXMgYSBidWcgaW4gQmFzaCwgYnV0IHNpbmNlIHRoZSBnb2FsIG9mXG4gIC8vIHRoaXMgbW9kdWxlIGlzIHRvIG1hdGNoIEJhc2gncyBydWxlcywgd2UgZXNjYXBlIGEgbGVhZGluZyB7fVxuICBpZiAoc3RyLnN1YnN0cigwLCAyKSA9PT0gJ3t9Jykge1xuICAgIHN0ciA9ICdcXFxce1xcXFx9JyArIHN0ci5zdWJzdHIoMik7XG4gIH1cblxuICByZXR1cm4gZXhwYW5kKGVzY2FwZUJyYWNlcyhzdHIpLCB0cnVlKS5tYXAodW5lc2NhcGVCcmFjZXMpO1xufVxuXG5mdW5jdGlvbiBpZGVudGl0eShlKSB7XG4gIHJldHVybiBlO1xufVxuXG5mdW5jdGlvbiBlbWJyYWNlKHN0cikge1xuICByZXR1cm4gJ3snICsgc3RyICsgJ30nO1xufVxuZnVuY3Rpb24gaXNQYWRkZWQoZWwpIHtcbiAgcmV0dXJuIC9eLT8wXFxkLy50ZXN0KGVsKTtcbn1cblxuZnVuY3Rpb24gbHRlKGksIHkpIHtcbiAgcmV0dXJuIGkgPD0geTtcbn1cbmZ1bmN0aW9uIGd0ZShpLCB5KSB7XG4gIHJldHVybiBpID49IHk7XG59XG5cbmZ1bmN0aW9uIGV4cGFuZChzdHIsIGlzVG9wKSB7XG4gIHZhciBleHBhbnNpb25zID0gW107XG5cbiAgdmFyIG0gPSBiYWxhbmNlZCgneycsICd9Jywgc3RyKTtcbiAgaWYgKCFtIHx8IC9cXCQkLy50ZXN0KG0ucHJlKSkgcmV0dXJuIFtzdHJdO1xuXG4gIHZhciBpc051bWVyaWNTZXF1ZW5jZSA9IC9eLT9cXGQrXFwuXFwuLT9cXGQrKD86XFwuXFwuLT9cXGQrKT8kLy50ZXN0KG0uYm9keSk7XG4gIHZhciBpc0FscGhhU2VxdWVuY2UgPSAvXlthLXpBLVpdXFwuXFwuW2EtekEtWl0oPzpcXC5cXC4tP1xcZCspPyQvLnRlc3QobS5ib2R5KTtcbiAgdmFyIGlzU2VxdWVuY2UgPSBpc051bWVyaWNTZXF1ZW5jZSB8fCBpc0FscGhhU2VxdWVuY2U7XG4gIHZhciBpc09wdGlvbnMgPSBtLmJvZHkuaW5kZXhPZignLCcpID49IDA7XG4gIGlmICghaXNTZXF1ZW5jZSAmJiAhaXNPcHRpb25zKSB7XG4gICAgLy8ge2F9LGJ9XG4gICAgaWYgKG0ucG9zdC5tYXRjaCgvLC4qXFx9LykpIHtcbiAgICAgIHN0ciA9IG0ucHJlICsgJ3snICsgbS5ib2R5ICsgZXNjQ2xvc2UgKyBtLnBvc3Q7XG4gICAgICByZXR1cm4gZXhwYW5kKHN0cik7XG4gICAgfVxuICAgIHJldHVybiBbc3RyXTtcbiAgfVxuXG4gIHZhciBuO1xuICBpZiAoaXNTZXF1ZW5jZSkge1xuICAgIG4gPSBtLmJvZHkuc3BsaXQoL1xcLlxcLi8pO1xuICB9IGVsc2Uge1xuICAgIG4gPSBwYXJzZUNvbW1hUGFydHMobS5ib2R5KTtcbiAgICBpZiAobi5sZW5ndGggPT09IDEpIHtcbiAgICAgIC8vIHh7e2EsYn19eSA9PT4geHthfXkgeHtifXlcbiAgICAgIG4gPSBleHBhbmQoblswXSwgZmFsc2UpLm1hcChlbWJyYWNlKTtcbiAgICAgIGlmIChuLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICB2YXIgcG9zdCA9IG0ucG9zdC5sZW5ndGhcbiAgICAgICAgICA/IGV4cGFuZChtLnBvc3QsIGZhbHNlKVxuICAgICAgICAgIDogWycnXTtcbiAgICAgICAgcmV0dXJuIHBvc3QubWFwKGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICByZXR1cm4gbS5wcmUgKyBuWzBdICsgcDtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gYXQgdGhpcyBwb2ludCwgbiBpcyB0aGUgcGFydHMsIGFuZCB3ZSBrbm93IGl0J3Mgbm90IGEgY29tbWEgc2V0XG4gIC8vIHdpdGggYSBzaW5nbGUgZW50cnkuXG5cbiAgLy8gbm8gbmVlZCB0byBleHBhbmQgcHJlLCBzaW5jZSBpdCBpcyBndWFyYW50ZWVkIHRvIGJlIGZyZWUgb2YgYnJhY2Utc2V0c1xuICB2YXIgcHJlID0gbS5wcmU7XG4gIHZhciBwb3N0ID0gbS5wb3N0Lmxlbmd0aFxuICAgID8gZXhwYW5kKG0ucG9zdCwgZmFsc2UpXG4gICAgOiBbJyddO1xuXG4gIHZhciBOO1xuXG4gIGlmIChpc1NlcXVlbmNlKSB7XG4gICAgdmFyIHggPSBudW1lcmljKG5bMF0pO1xuICAgIHZhciB5ID0gbnVtZXJpYyhuWzFdKTtcbiAgICB2YXIgd2lkdGggPSBNYXRoLm1heChuWzBdLmxlbmd0aCwgblsxXS5sZW5ndGgpXG4gICAgdmFyIGluY3IgPSBuLmxlbmd0aCA9PSAzXG4gICAgICA/IE1hdGguYWJzKG51bWVyaWMoblsyXSkpXG4gICAgICA6IDE7XG4gICAgdmFyIHRlc3QgPSBsdGU7XG4gICAgdmFyIHJldmVyc2UgPSB5IDwgeDtcbiAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgaW5jciAqPSAtMTtcbiAgICAgIHRlc3QgPSBndGU7XG4gICAgfVxuICAgIHZhciBwYWQgPSBuLnNvbWUoaXNQYWRkZWQpO1xuXG4gICAgTiA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IHg7IHRlc3QoaSwgeSk7IGkgKz0gaW5jcikge1xuICAgICAgdmFyIGM7XG4gICAgICBpZiAoaXNBbHBoYVNlcXVlbmNlKSB7XG4gICAgICAgIGMgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpO1xuICAgICAgICBpZiAoYyA9PT0gJ1xcXFwnKVxuICAgICAgICAgIGMgPSAnJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGMgPSBTdHJpbmcoaSk7XG4gICAgICAgIGlmIChwYWQpIHtcbiAgICAgICAgICB2YXIgbmVlZCA9IHdpZHRoIC0gYy5sZW5ndGg7XG4gICAgICAgICAgaWYgKG5lZWQgPiAwKSB7XG4gICAgICAgICAgICB2YXIgeiA9IG5ldyBBcnJheShuZWVkICsgMSkuam9pbignMCcpO1xuICAgICAgICAgICAgaWYgKGkgPCAwKVxuICAgICAgICAgICAgICBjID0gJy0nICsgeiArIGMuc2xpY2UoMSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGMgPSB6ICsgYztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIE4ucHVzaChjKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgTiA9IGNvbmNhdE1hcChuLCBmdW5jdGlvbihlbCkgeyByZXR1cm4gZXhwYW5kKGVsLCBmYWxzZSkgfSk7XG4gIH1cblxuICBmb3IgKHZhciBqID0gMDsgaiA8IE4ubGVuZ3RoOyBqKyspIHtcbiAgICBmb3IgKHZhciBrID0gMDsgayA8IHBvc3QubGVuZ3RoOyBrKyspIHtcbiAgICAgIHZhciBleHBhbnNpb24gPSBwcmUgKyBOW2pdICsgcG9zdFtrXTtcbiAgICAgIGlmICghaXNUb3AgfHwgaXNTZXF1ZW5jZSB8fCBleHBhbnNpb24pXG4gICAgICAgIGV4cGFuc2lvbnMucHVzaChleHBhbnNpb24pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBleHBhbnNpb25zO1xufVxuXG4iLCJtb2R1bGUuZXhwb3J0cyA9IEJ1ZmZlcnM7XG5cbmZ1bmN0aW9uIEJ1ZmZlcnMgKGJ1ZnMpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQnVmZmVycykpIHJldHVybiBuZXcgQnVmZmVycyhidWZzKTtcbiAgICB0aGlzLmJ1ZmZlcnMgPSBidWZzIHx8IFtdO1xuICAgIHRoaXMubGVuZ3RoID0gdGhpcy5idWZmZXJzLnJlZHVjZShmdW5jdGlvbiAoc2l6ZSwgYnVmKSB7XG4gICAgICAgIHJldHVybiBzaXplICsgYnVmLmxlbmd0aFxuICAgIH0sIDApO1xufVxuXG5CdWZmZXJzLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGFyZ3VtZW50c1tpXSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RyaWVkIHRvIHB1c2ggYSBub24tYnVmZmVyJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGJ1ZiA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgdGhpcy5idWZmZXJzLnB1c2goYnVmKTtcbiAgICAgICAgdGhpcy5sZW5ndGggKz0gYnVmLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubGVuZ3RoO1xufTtcblxuQnVmZmVycy5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhcmd1bWVudHNbaV0pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUcmllZCB0byB1bnNoaWZ0IGEgbm9uLWJ1ZmZlcicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBidWYgPSBhcmd1bWVudHNbaV07XG4gICAgICAgIHRoaXMuYnVmZmVycy51bnNoaWZ0KGJ1Zik7XG4gICAgICAgIHRoaXMubGVuZ3RoICs9IGJ1Zi5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmxlbmd0aDtcbn07XG5cbkJ1ZmZlcnMucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoZHN0LCBkU3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gdGhpcy5zbGljZShzdGFydCwgZW5kKS5jb3B5KGRzdCwgZFN0YXJ0LCAwLCBlbmQgLSBzdGFydCk7XG59O1xuXG5CdWZmZXJzLnByb3RvdHlwZS5zcGxpY2UgPSBmdW5jdGlvbiAoaSwgaG93TWFueSkge1xuICAgIHZhciBidWZmZXJzID0gdGhpcy5idWZmZXJzO1xuICAgIHZhciBpbmRleCA9IGkgPj0gMCA/IGkgOiB0aGlzLmxlbmd0aCAtIGk7XG4gICAgdmFyIHJlcHMgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgXG4gICAgaWYgKGhvd01hbnkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBob3dNYW55ID0gdGhpcy5sZW5ndGggLSBpbmRleDtcbiAgICB9XG4gICAgZWxzZSBpZiAoaG93TWFueSA+IHRoaXMubGVuZ3RoIC0gaW5kZXgpIHtcbiAgICAgICAgaG93TWFueSA9IHRoaXMubGVuZ3RoIC0gaW5kZXg7XG4gICAgfVxuICAgIFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLmxlbmd0aCArPSByZXBzW2ldLmxlbmd0aDtcbiAgICB9XG4gICAgXG4gICAgdmFyIHJlbW92ZWQgPSBuZXcgQnVmZmVycygpO1xuICAgIHZhciBieXRlcyA9IDA7XG4gICAgXG4gICAgdmFyIHN0YXJ0Qnl0ZXMgPSAwO1xuICAgIGZvciAoXG4gICAgICAgIHZhciBpaSA9IDA7XG4gICAgICAgIGlpIDwgYnVmZmVycy5sZW5ndGggJiYgc3RhcnRCeXRlcyArIGJ1ZmZlcnNbaWldLmxlbmd0aCA8IGluZGV4O1xuICAgICAgICBpaSArK1xuICAgICkgeyBzdGFydEJ5dGVzICs9IGJ1ZmZlcnNbaWldLmxlbmd0aCB9XG4gICAgXG4gICAgaWYgKGluZGV4IC0gc3RhcnRCeXRlcyA+IDApIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gaW5kZXggLSBzdGFydEJ5dGVzO1xuICAgICAgICBcbiAgICAgICAgaWYgKHN0YXJ0ICsgaG93TWFueSA8IGJ1ZmZlcnNbaWldLmxlbmd0aCkge1xuICAgICAgICAgICAgcmVtb3ZlZC5wdXNoKGJ1ZmZlcnNbaWldLnNsaWNlKHN0YXJ0LCBzdGFydCArIGhvd01hbnkpKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIG9yaWcgPSBidWZmZXJzW2lpXTtcbiAgICAgICAgICAgIC8vdmFyIGJ1ZiA9IG5ldyBCdWZmZXIob3JpZy5sZW5ndGggLSBob3dNYW55KTtcbiAgICAgICAgICAgIHZhciBidWYwID0gbmV3IEJ1ZmZlcihzdGFydCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXJ0OyBpKyspIHtcbiAgICAgICAgICAgICAgICBidWYwW2ldID0gb3JpZ1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIGJ1ZjEgPSBuZXcgQnVmZmVyKG9yaWcubGVuZ3RoIC0gc3RhcnQgLSBob3dNYW55KTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBzdGFydCArIGhvd01hbnk7IGkgPCBvcmlnLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYnVmMVsgaSAtIGhvd01hbnkgLSBzdGFydCBdID0gb3JpZ1tpXVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAocmVwcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlcHNfID0gcmVwcy5zbGljZSgpO1xuICAgICAgICAgICAgICAgIHJlcHNfLnVuc2hpZnQoYnVmMCk7XG4gICAgICAgICAgICAgICAgcmVwc18ucHVzaChidWYxKTtcbiAgICAgICAgICAgICAgICBidWZmZXJzLnNwbGljZS5hcHBseShidWZmZXJzLCBbIGlpLCAxIF0uY29uY2F0KHJlcHNfKSk7XG4gICAgICAgICAgICAgICAgaWkgKz0gcmVwc18ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHJlcHMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJ1ZmZlcnMuc3BsaWNlKGlpLCAxLCBidWYwLCBidWYxKTtcbiAgICAgICAgICAgICAgICAvL2J1ZmZlcnNbaWldID0gYnVmO1xuICAgICAgICAgICAgICAgIGlpICs9IDI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZW1vdmVkLnB1c2goYnVmZmVyc1tpaV0uc2xpY2Uoc3RhcnQpKTtcbiAgICAgICAgICAgIGJ1ZmZlcnNbaWldID0gYnVmZmVyc1tpaV0uc2xpY2UoMCwgc3RhcnQpO1xuICAgICAgICAgICAgaWkgKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgaWYgKHJlcHMubGVuZ3RoID4gMCkge1xuICAgICAgICBidWZmZXJzLnNwbGljZS5hcHBseShidWZmZXJzLCBbIGlpLCAwIF0uY29uY2F0KHJlcHMpKTtcbiAgICAgICAgaWkgKz0gcmVwcy5sZW5ndGg7XG4gICAgfVxuICAgIFxuICAgIHdoaWxlIChyZW1vdmVkLmxlbmd0aCA8IGhvd01hbnkpIHtcbiAgICAgICAgdmFyIGJ1ZiA9IGJ1ZmZlcnNbaWldO1xuICAgICAgICB2YXIgbGVuID0gYnVmLmxlbmd0aDtcbiAgICAgICAgdmFyIHRha2UgPSBNYXRoLm1pbihsZW4sIGhvd01hbnkgLSByZW1vdmVkLmxlbmd0aCk7XG4gICAgICAgIFxuICAgICAgICBpZiAodGFrZSA9PT0gbGVuKSB7XG4gICAgICAgICAgICByZW1vdmVkLnB1c2goYnVmKTtcbiAgICAgICAgICAgIGJ1ZmZlcnMuc3BsaWNlKGlpLCAxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlbW92ZWQucHVzaChidWYuc2xpY2UoMCwgdGFrZSkpO1xuICAgICAgICAgICAgYnVmZmVyc1tpaV0gPSBidWZmZXJzW2lpXS5zbGljZSh0YWtlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICB0aGlzLmxlbmd0aCAtPSByZW1vdmVkLmxlbmd0aDtcbiAgICBcbiAgICByZXR1cm4gcmVtb3ZlZDtcbn07XG4gXG5CdWZmZXJzLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIChpLCBqKSB7XG4gICAgdmFyIGJ1ZmZlcnMgPSB0aGlzLmJ1ZmZlcnM7XG4gICAgaWYgKGogPT09IHVuZGVmaW5lZCkgaiA9IHRoaXMubGVuZ3RoO1xuICAgIGlmIChpID09PSB1bmRlZmluZWQpIGkgPSAwO1xuICAgIFxuICAgIGlmIChqID4gdGhpcy5sZW5ndGgpIGogPSB0aGlzLmxlbmd0aDtcbiAgICBcbiAgICB2YXIgc3RhcnRCeXRlcyA9IDA7XG4gICAgZm9yIChcbiAgICAgICAgdmFyIHNpID0gMDtcbiAgICAgICAgc2kgPCBidWZmZXJzLmxlbmd0aCAmJiBzdGFydEJ5dGVzICsgYnVmZmVyc1tzaV0ubGVuZ3RoIDw9IGk7XG4gICAgICAgIHNpICsrXG4gICAgKSB7IHN0YXJ0Qnl0ZXMgKz0gYnVmZmVyc1tzaV0ubGVuZ3RoIH1cbiAgICBcbiAgICB2YXIgdGFyZ2V0ID0gbmV3IEJ1ZmZlcihqIC0gaSk7XG4gICAgXG4gICAgdmFyIHRpID0gMDtcbiAgICBmb3IgKHZhciBpaSA9IHNpOyB0aSA8IGogLSBpICYmIGlpIDwgYnVmZmVycy5sZW5ndGg7IGlpKyspIHtcbiAgICAgICAgdmFyIGxlbiA9IGJ1ZmZlcnNbaWldLmxlbmd0aDtcbiAgICAgICAgXG4gICAgICAgIHZhciBzdGFydCA9IHRpID09PSAwID8gaSAtIHN0YXJ0Qnl0ZXMgOiAwO1xuICAgICAgICB2YXIgZW5kID0gdGkgKyBsZW4gPj0gaiAtIGlcbiAgICAgICAgICAgID8gTWF0aC5taW4oc3RhcnQgKyAoaiAtIGkpIC0gdGksIGxlbilcbiAgICAgICAgICAgIDogbGVuXG4gICAgICAgIDtcbiAgICAgICAgXG4gICAgICAgIGJ1ZmZlcnNbaWldLmNvcHkodGFyZ2V0LCB0aSwgc3RhcnQsIGVuZCk7XG4gICAgICAgIHRpICs9IGVuZCAtIHN0YXJ0O1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gdGFyZ2V0O1xufTtcblxuQnVmZmVycy5wcm90b3R5cGUucG9zID0gZnVuY3Rpb24gKGkpIHtcbiAgICBpZiAoaSA8IDAgfHwgaSA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdvb2InKTtcbiAgICB2YXIgbCA9IGksIGJpID0gMCwgYnUgPSBudWxsO1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgYnUgPSB0aGlzLmJ1ZmZlcnNbYmldO1xuICAgICAgICBpZiAobCA8IGJ1Lmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHtidWY6IGJpLCBvZmZzZXQ6IGx9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbCAtPSBidS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgYmkrKztcbiAgICB9XG59O1xuXG5CdWZmZXJzLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKGkpIHtcbiAgICB2YXIgcG9zID0gdGhpcy5wb3MoaSk7XG5cbiAgICByZXR1cm4gdGhpcy5idWZmZXJzW3Bvcy5idWZdLmdldChwb3Mub2Zmc2V0KTtcbn07XG5cbkJ1ZmZlcnMucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIHNldCAoaSwgYikge1xuICAgIHZhciBwb3MgPSB0aGlzLnBvcyhpKTtcblxuICAgIHJldHVybiB0aGlzLmJ1ZmZlcnNbcG9zLmJ1Zl0uc2V0KHBvcy5vZmZzZXQsIGIpO1xufTtcblxuQnVmZmVycy5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIChuZWVkbGUsIG9mZnNldCkge1xuICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgbmVlZGxlKSB7XG4gICAgICAgIG5lZWRsZSA9IG5ldyBCdWZmZXIobmVlZGxlKTtcbiAgICB9IGVsc2UgaWYgKG5lZWRsZSBpbnN0YW5jZW9mIEJ1ZmZlcikge1xuICAgICAgICAvLyBhbHJlYWR5IGEgYnVmZmVyXG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHR5cGUgZm9yIGEgc2VhcmNoIHN0cmluZycpO1xuICAgIH1cblxuICAgIGlmICghbmVlZGxlLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICB2YXIgaSA9IDAsIGogPSAwLCBtYXRjaCA9IDAsIG1zdGFydCwgcG9zID0gMDtcblxuICAgIC8vIHN0YXJ0IHNlYXJjaCBmcm9tIGEgcGFydGljdWxhciBwb2ludCBpbiB0aGUgdmlydHVhbCBidWZmZXJcbiAgICBpZiAob2Zmc2V0KSB7XG4gICAgICAgIHZhciBwID0gdGhpcy5wb3Mob2Zmc2V0KTtcbiAgICAgICAgaSA9IHAuYnVmO1xuICAgICAgICBqID0gcC5vZmZzZXQ7XG4gICAgICAgIHBvcyA9IG9mZnNldDtcbiAgICB9XG5cbiAgICAvLyBmb3IgZWFjaCBjaGFyYWN0ZXIgaW4gdmlydHVhbCBidWZmZXJcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIHdoaWxlIChqID49IHRoaXMuYnVmZmVyc1tpXS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGogPSAwO1xuICAgICAgICAgICAgaSsrO1xuXG4gICAgICAgICAgICBpZiAoaSA+PSB0aGlzLmJ1ZmZlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy8gc2VhcmNoIHN0cmluZyBub3QgZm91bmRcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2hhciA9IHRoaXMuYnVmZmVyc1tpXVtqXTtcblxuICAgICAgICBpZiAoY2hhciA9PSBuZWVkbGVbbWF0Y2hdKSB7XG4gICAgICAgICAgICAvLyBrZWVwIHRyYWNrIHdoZXJlIG1hdGNoIHN0YXJ0ZWRcbiAgICAgICAgICAgIGlmIChtYXRjaCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgbXN0YXJ0ID0ge1xuICAgICAgICAgICAgICAgICAgICBpOiBpLFxuICAgICAgICAgICAgICAgICAgICBqOiBqLFxuICAgICAgICAgICAgICAgICAgICBwb3M6IHBvc1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYXRjaCsrO1xuICAgICAgICAgICAgaWYgKG1hdGNoID09IG5lZWRsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyBmdWxsIG1hdGNoXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1zdGFydC5wb3M7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobWF0Y2ggIT0gMCkge1xuICAgICAgICAgICAgLy8gYSBwYXJ0aWFsIG1hdGNoIGVuZGVkLCBnbyBiYWNrIHRvIG1hdGNoIHN0YXJ0aW5nIHBvc2l0aW9uXG4gICAgICAgICAgICAvLyB0aGlzIHdpbGwgY29udGludWUgdGhlIHNlYXJjaCBhdCB0aGUgbmV4dCBjaGFyYWN0ZXJcbiAgICAgICAgICAgIGkgPSBtc3RhcnQuaTtcbiAgICAgICAgICAgIGogPSBtc3RhcnQuajtcbiAgICAgICAgICAgIHBvcyA9IG1zdGFydC5wb3M7XG4gICAgICAgICAgICBtYXRjaCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBqKys7XG4gICAgICAgIHBvcysrO1xuICAgIH1cbn07XG5cbkJ1ZmZlcnMucHJvdG90eXBlLnRvQnVmZmVyID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuc2xpY2UoKTtcbn1cblxuQnVmZmVycy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbihlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiB0aGlzLnNsaWNlKHN0YXJ0LCBlbmQpLnRvU3RyaW5nKGVuY29kaW5nKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gcHJlc2VydmVDYW1lbENhc2Uoc3RyKSB7XG5cdHZhciBpc0xhc3RDaGFyTG93ZXIgPSBmYWxzZTtcblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBjID0gc3RyLmNoYXJBdChpKTtcblxuXHRcdGlmIChpc0xhc3RDaGFyTG93ZXIgJiYgKC9bYS16QS1aXS8pLnRlc3QoYykgJiYgYy50b1VwcGVyQ2FzZSgpID09PSBjKSB7XG5cdFx0XHRzdHIgPSBzdHIuc3Vic3RyKDAsIGkpICsgJy0nICsgc3RyLnN1YnN0cihpKTtcblx0XHRcdGlzTGFzdENoYXJMb3dlciA9IGZhbHNlO1xuXHRcdFx0aSsrO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpc0xhc3RDaGFyTG93ZXIgPSAoYy50b0xvd2VyQ2FzZSgpID09PSBjKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gc3RyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIHN0ciA9IFtdLm1hcC5jYWxsKGFyZ3VtZW50cywgZnVuY3Rpb24gKHN0cikge1xuXHRcdHJldHVybiBzdHIudHJpbSgpO1xuXHR9KS5maWx0ZXIoZnVuY3Rpb24gKHN0cikge1xuXHRcdHJldHVybiBzdHIubGVuZ3RoO1xuXHR9KS5qb2luKCctJyk7XG5cblx0aWYgKCFzdHIubGVuZ3RoKSB7XG5cdFx0cmV0dXJuICcnO1xuXHR9XG5cblx0aWYgKHN0ci5sZW5ndGggPT09IDEpIHtcblx0XHRyZXR1cm4gc3RyO1xuXHR9XG5cblx0aWYgKCEoL1tfLlxcLSBdKy8pLnRlc3Qoc3RyKSkge1xuXHRcdGlmIChzdHIgPT09IHN0ci50b1VwcGVyQ2FzZSgpKSB7XG5cdFx0XHRyZXR1cm4gc3RyLnRvTG93ZXJDYXNlKCk7XG5cdFx0fVxuXG5cdFx0aWYgKHN0clswXSAhPT0gc3RyWzBdLnRvTG93ZXJDYXNlKCkpIHtcblx0XHRcdHJldHVybiBzdHJbMF0udG9Mb3dlckNhc2UoKSArIHN0ci5zbGljZSgxKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gc3RyO1xuXHR9XG5cblx0c3RyID0gcHJlc2VydmVDYW1lbENhc2Uoc3RyKTtcblxuXHRyZXR1cm4gc3RyXG5cdC5yZXBsYWNlKC9eW18uXFwtIF0rLywgJycpXG5cdC50b0xvd2VyQ2FzZSgpXG5cdC5yZXBsYWNlKC9bXy5cXC0gXSsoXFx3fCQpL2csIGZ1bmN0aW9uIChtLCBwMSkge1xuXHRcdHJldHVybiBwMS50b1VwcGVyQ2FzZSgpO1xuXHR9KTtcbn07XG4iLCJ2YXIgVHJhdmVyc2UgPSByZXF1aXJlKCd0cmF2ZXJzZScpO1xudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcblxubW9kdWxlLmV4cG9ydHMgPSBDaGFpbnNhdztcbmZ1bmN0aW9uIENoYWluc2F3IChidWlsZGVyKSB7XG4gICAgdmFyIHNhdyA9IENoYWluc2F3LnNhdyhidWlsZGVyLCB7fSk7XG4gICAgdmFyIHIgPSBidWlsZGVyLmNhbGwoc2F3LmhhbmRsZXJzLCBzYXcpO1xuICAgIGlmIChyICE9PSB1bmRlZmluZWQpIHNhdy5oYW5kbGVycyA9IHI7XG4gICAgc2F3LnJlY29yZCgpO1xuICAgIHJldHVybiBzYXcuY2hhaW4oKTtcbn07XG5cbkNoYWluc2F3LmxpZ2h0ID0gZnVuY3Rpb24gQ2hhaW5zYXdMaWdodCAoYnVpbGRlcikge1xuICAgIHZhciBzYXcgPSBDaGFpbnNhdy5zYXcoYnVpbGRlciwge30pO1xuICAgIHZhciByID0gYnVpbGRlci5jYWxsKHNhdy5oYW5kbGVycywgc2F3KTtcbiAgICBpZiAociAhPT0gdW5kZWZpbmVkKSBzYXcuaGFuZGxlcnMgPSByO1xuICAgIHJldHVybiBzYXcuY2hhaW4oKTtcbn07XG5cbkNoYWluc2F3LnNhdyA9IGZ1bmN0aW9uIChidWlsZGVyLCBoYW5kbGVycykge1xuICAgIHZhciBzYXcgPSBuZXcgRXZlbnRFbWl0dGVyO1xuICAgIHNhdy5oYW5kbGVycyA9IGhhbmRsZXJzO1xuICAgIHNhdy5hY3Rpb25zID0gW107XG5cbiAgICBzYXcuY2hhaW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjaCA9IFRyYXZlcnNlKHNhdy5oYW5kbGVycykubWFwKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1Jvb3QpIHJldHVybiBub2RlO1xuICAgICAgICAgICAgdmFyIHBzID0gdGhpcy5wYXRoO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIG5vZGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHNhdy5hY3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aCA6IHBzLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJncyA6IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNhdy5lbWl0KCdiZWdpbicpO1xuICAgICAgICAgICAgc2F3Lm5leHQoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGNoO1xuICAgIH07XG5cbiAgICBzYXcucG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gc2F3LmFjdGlvbnMuc2hpZnQoKTtcbiAgICB9O1xuXG4gICAgc2F3Lm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhY3Rpb24gPSBzYXcucG9wKCk7XG5cbiAgICAgICAgaWYgKCFhY3Rpb24pIHtcbiAgICAgICAgICAgIHNhdy5lbWl0KCdlbmQnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghYWN0aW9uLnRyYXApIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gc2F3LmhhbmRsZXJzO1xuICAgICAgICAgICAgYWN0aW9uLnBhdGguZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IG5vZGUgPSBub2RlW2tleV0gfSk7XG4gICAgICAgICAgICBub2RlLmFwcGx5KHNhdy5oYW5kbGVycywgYWN0aW9uLmFyZ3MpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHNhdy5uZXN0ID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICB2YXIgYXV0b25leHQgPSB0cnVlO1xuXG4gICAgICAgIGlmICh0eXBlb2YgY2IgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgdmFyIGF1dG9uZXh0ID0gY2I7XG4gICAgICAgICAgICBjYiA9IGFyZ3Muc2hpZnQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzID0gQ2hhaW5zYXcuc2F3KGJ1aWxkZXIsIHt9KTtcbiAgICAgICAgdmFyIHIgPSBidWlsZGVyLmNhbGwocy5oYW5kbGVycywgcyk7XG5cbiAgICAgICAgaWYgKHIgIT09IHVuZGVmaW5lZCkgcy5oYW5kbGVycyA9IHI7XG5cbiAgICAgICAgLy8gSWYgd2UgYXJlIHJlY29yZGluZy4uLlxuICAgICAgICBpZiAoXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIHNhdy5zdGVwKSB7XG4gICAgICAgICAgICAvLyAuLi4gb3VyIGNoaWxkcmVuIHNob3VsZCwgdG9vXG4gICAgICAgICAgICBzLnJlY29yZCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2IuYXBwbHkocy5jaGFpbigpLCBhcmdzKTtcbiAgICAgICAgaWYgKGF1dG9uZXh0ICE9PSBmYWxzZSkgcy5vbignZW5kJywgc2F3Lm5leHQpO1xuICAgIH07XG5cbiAgICBzYXcucmVjb3JkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB1cGdyYWRlQ2hhaW5zYXcoc2F3KTtcbiAgICB9O1xuXG4gICAgWyd0cmFwJywgJ2Rvd24nLCAnanVtcCddLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgICBzYXdbbWV0aG9kXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRvIHVzZSB0aGUgdHJhcCwgZG93biBhbmQganVtcCBmZWF0dXJlcywgcGxlYXNlIFwiK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiY2FsbCByZWNvcmQoKSBmaXJzdCB0byBzdGFydCByZWNvcmRpbmcgYWN0aW9ucy5cIik7XG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICByZXR1cm4gc2F3O1xufTtcblxuZnVuY3Rpb24gdXBncmFkZUNoYWluc2F3KHNhdykge1xuICAgIHNhdy5zdGVwID0gMDtcblxuICAgIC8vIG92ZXJyaWRlIHBvcFxuICAgIHNhdy5wb3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBzYXcuYWN0aW9uc1tzYXcuc3RlcCsrXTtcbiAgICB9O1xuXG4gICAgc2F3LnRyYXAgPSBmdW5jdGlvbiAobmFtZSwgY2IpIHtcbiAgICAgICAgdmFyIHBzID0gQXJyYXkuaXNBcnJheShuYW1lKSA/IG5hbWUgOiBbbmFtZV07XG4gICAgICAgIHNhdy5hY3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgcGF0aCA6IHBzLFxuICAgICAgICAgICAgc3RlcCA6IHNhdy5zdGVwLFxuICAgICAgICAgICAgY2IgOiBjYixcbiAgICAgICAgICAgIHRyYXAgOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBzYXcuZG93biA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHZhciBwcyA9IChBcnJheS5pc0FycmF5KG5hbWUpID8gbmFtZSA6IFtuYW1lXSkuam9pbignLycpO1xuICAgICAgICB2YXIgaSA9IHNhdy5hY3Rpb25zLnNsaWNlKHNhdy5zdGVwKS5tYXAoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgIGlmICh4LnRyYXAgJiYgeC5zdGVwIDw9IHNhdy5zdGVwKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4geC5wYXRoLmpvaW4oJy8nKSA9PSBwcztcbiAgICAgICAgfSkuaW5kZXhPZih0cnVlKTtcblxuICAgICAgICBpZiAoaSA+PSAwKSBzYXcuc3RlcCArPSBpO1xuICAgICAgICBlbHNlIHNhdy5zdGVwID0gc2F3LmFjdGlvbnMubGVuZ3RoO1xuXG4gICAgICAgIHZhciBhY3QgPSBzYXcuYWN0aW9uc1tzYXcuc3RlcCAtIDFdO1xuICAgICAgICBpZiAoYWN0ICYmIGFjdC50cmFwKSB7XG4gICAgICAgICAgICAvLyBJdCdzIGEgdHJhcCFcbiAgICAgICAgICAgIHNhdy5zdGVwID0gYWN0LnN0ZXA7XG4gICAgICAgICAgICBhY3QuY2IoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHNhdy5uZXh0KCk7XG4gICAgfTtcblxuICAgIHNhdy5qdW1wID0gZnVuY3Rpb24gKHN0ZXApIHtcbiAgICAgICAgc2F3LnN0ZXAgPSBzdGVwO1xuICAgICAgICBzYXcubmV4dCgpO1xuICAgIH07XG59O1xuIiwidmFyIHN0cmluZ1dpZHRoID0gcmVxdWlyZSgnc3RyaW5nLXdpZHRoJylcbnZhciBzdHJpcEFuc2kgPSByZXF1aXJlKCdzdHJpcC1hbnNpJylcbnZhciB3cmFwID0gcmVxdWlyZSgnd3JhcC1hbnNpJylcbnZhciBhbGlnbiA9IHtcbiAgcmlnaHQ6IGFsaWduUmlnaHQsXG4gIGNlbnRlcjogYWxpZ25DZW50ZXJcbn1cbnZhciB0b3AgPSAwXG52YXIgcmlnaHQgPSAxXG52YXIgYm90dG9tID0gMlxudmFyIGxlZnQgPSAzXG5cbmZ1bmN0aW9uIFVJIChvcHRzKSB7XG4gIHRoaXMud2lkdGggPSBvcHRzLndpZHRoXG4gIHRoaXMud3JhcCA9IG9wdHMud3JhcFxuICB0aGlzLnJvd3MgPSBbXVxufVxuXG5VSS5wcm90b3R5cGUuc3BhbiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGNvbHMgPSB0aGlzLmRpdi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gIGNvbHMuc3BhbiA9IHRydWVcbn1cblxuVUkucHJvdG90eXBlLmRpdiA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHRoaXMuZGl2KCcnKVxuICBpZiAodGhpcy53cmFwICYmIHRoaXMuX3Nob3VsZEFwcGx5TGF5b3V0RFNMLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpIHtcbiAgICByZXR1cm4gdGhpcy5fYXBwbHlMYXlvdXREU0woYXJndW1lbnRzWzBdKVxuICB9XG5cbiAgdmFyIGNvbHMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwLCBhcmc7IChhcmcgPSBhcmd1bWVudHNbaV0pICE9PSB1bmRlZmluZWQ7IGkrKykge1xuICAgIGlmICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJykgY29scy5wdXNoKHRoaXMuX2NvbEZyb21TdHJpbmcoYXJnKSlcbiAgICBlbHNlIGNvbHMucHVzaChhcmcpXG4gIH1cblxuICB0aGlzLnJvd3MucHVzaChjb2xzKVxuICByZXR1cm4gY29sc1xufVxuXG5VSS5wcm90b3R5cGUuX3Nob3VsZEFwcGx5TGF5b3V0RFNMID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnc3RyaW5nJyAmJlxuICAgIC9bXFx0XFxuXS8udGVzdChhcmd1bWVudHNbMF0pXG59XG5cblVJLnByb3RvdHlwZS5fYXBwbHlMYXlvdXREU0wgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIHZhciBfdGhpcyA9IHRoaXNcbiAgdmFyIHJvd3MgPSBzdHIuc3BsaXQoJ1xcbicpXG4gIHZhciBsZWZ0Q29sdW1uV2lkdGggPSAwXG5cbiAgLy8gc2ltcGxlIGhldXJpc3RpYyBmb3IgbGF5b3V0LCBtYWtlIHN1cmUgdGhlXG4gIC8vIHNlY29uZCBjb2x1bW4gbGluZXMgdXAgYWxvbmcgdGhlIGxlZnQtaGFuZC5cbiAgLy8gZG9uJ3QgYWxsb3cgdGhlIGZpcnN0IGNvbHVtbiB0byB0YWtlIHVwIG1vcmVcbiAgLy8gdGhhbiA1MCUgb2YgdGhlIHNjcmVlbi5cbiAgcm93cy5mb3JFYWNoKGZ1bmN0aW9uIChyb3cpIHtcbiAgICB2YXIgY29sdW1ucyA9IHJvdy5zcGxpdCgnXFx0JylcbiAgICBpZiAoY29sdW1ucy5sZW5ndGggPiAxICYmIHN0cmluZ1dpZHRoKGNvbHVtbnNbMF0pID4gbGVmdENvbHVtbldpZHRoKSB7XG4gICAgICBsZWZ0Q29sdW1uV2lkdGggPSBNYXRoLm1pbihcbiAgICAgICAgTWF0aC5mbG9vcihfdGhpcy53aWR0aCAqIDAuNSksXG4gICAgICAgIHN0cmluZ1dpZHRoKGNvbHVtbnNbMF0pXG4gICAgICApXG4gICAgfVxuICB9KVxuXG4gIC8vIGdlbmVyYXRlIGEgdGFibGU6XG4gIC8vICByZXBsYWNpbmcgJyAnIHdpdGggcGFkZGluZyBjYWxjdWxhdGlvbnMuXG4gIC8vICB1c2luZyB0aGUgYWxnb3JpdGhtaWNhbGx5IGdlbmVyYXRlZCB3aWR0aC5cbiAgcm93cy5mb3JFYWNoKGZ1bmN0aW9uIChyb3cpIHtcbiAgICB2YXIgY29sdW1ucyA9IHJvdy5zcGxpdCgnXFx0JylcbiAgICBfdGhpcy5kaXYuYXBwbHkoX3RoaXMsIGNvbHVtbnMubWFwKGZ1bmN0aW9uIChyLCBpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0ZXh0OiByLnRyaW0oKSxcbiAgICAgICAgcGFkZGluZzogX3RoaXMuX21lYXN1cmVQYWRkaW5nKHIpLFxuICAgICAgICB3aWR0aDogKGkgPT09IDAgJiYgY29sdW1ucy5sZW5ndGggPiAxKSA/IGxlZnRDb2x1bW5XaWR0aCA6IHVuZGVmaW5lZFxuICAgICAgfVxuICAgIH0pKVxuICB9KVxuXG4gIHJldHVybiB0aGlzLnJvd3NbdGhpcy5yb3dzLmxlbmd0aCAtIDFdXG59XG5cblVJLnByb3RvdHlwZS5fY29sRnJvbVN0cmluZyA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHtcbiAgICB0ZXh0OiBzdHIsXG4gICAgcGFkZGluZzogdGhpcy5fbWVhc3VyZVBhZGRpbmcoc3RyKVxuICB9XG59XG5cblVJLnByb3RvdHlwZS5fbWVhc3VyZVBhZGRpbmcgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIC8vIG1lYXN1cmUgcGFkZGluZyB3aXRob3V0IGFuc2kgZXNjYXBlIGNvZGVzXG4gIHZhciBub0Fuc2kgPSBzdHJpcEFuc2koc3RyKVxuICByZXR1cm4gWzAsIG5vQW5zaS5tYXRjaCgvXFxzKiQvKVswXS5sZW5ndGgsIDAsIG5vQW5zaS5tYXRjaCgvXlxccyovKVswXS5sZW5ndGhdXG59XG5cblVJLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIF90aGlzID0gdGhpc1xuICB2YXIgbGluZXMgPSBbXVxuXG4gIF90aGlzLnJvd3MuZm9yRWFjaChmdW5jdGlvbiAocm93LCBpKSB7XG4gICAgX3RoaXMucm93VG9TdHJpbmcocm93LCBsaW5lcylcbiAgfSlcblxuICAvLyBkb24ndCBkaXNwbGF5IGFueSBsaW5lcyB3aXRoIHRoZVxuICAvLyBoaWRkZW4gZmxhZyBzZXQuXG4gIGxpbmVzID0gbGluZXMuZmlsdGVyKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgcmV0dXJuICFsaW5lLmhpZGRlblxuICB9KVxuXG4gIHJldHVybiBsaW5lcy5tYXAoZnVuY3Rpb24gKGxpbmUpIHtcbiAgICByZXR1cm4gbGluZS50ZXh0XG4gIH0pLmpvaW4oJ1xcbicpXG59XG5cblVJLnByb3RvdHlwZS5yb3dUb1N0cmluZyA9IGZ1bmN0aW9uIChyb3csIGxpbmVzKSB7XG4gIHZhciBfdGhpcyA9IHRoaXNcbiAgdmFyIHBhZGRpbmdcbiAgdmFyIHJyb3dzID0gdGhpcy5fcmFzdGVyaXplKHJvdylcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciB0c1xuICB2YXIgd2lkdGhcbiAgdmFyIHdyYXBXaWR0aFxuXG4gIHJyb3dzLmZvckVhY2goZnVuY3Rpb24gKHJyb3csIHIpIHtcbiAgICBzdHIgPSAnJ1xuICAgIHJyb3cuZm9yRWFjaChmdW5jdGlvbiAoY29sLCBjKSB7XG4gICAgICB0cyA9ICcnIC8vIHRlbXBvcmFyeSBzdHJpbmcgdXNlZCBkdXJpbmcgYWxpZ25tZW50L3BhZGRpbmcuXG4gICAgICB3aWR0aCA9IHJvd1tjXS53aWR0aCAvLyB0aGUgd2lkdGggd2l0aCBwYWRkaW5nLlxuICAgICAgd3JhcFdpZHRoID0gX3RoaXMuX25lZ2F0ZVBhZGRpbmcocm93W2NdKSAvLyB0aGUgd2lkdGggd2l0aG91dCBwYWRkaW5nLlxuXG4gICAgICB0cyArPSBjb2xcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB3cmFwV2lkdGggLSBzdHJpbmdXaWR0aChjb2wpOyBpKyspIHtcbiAgICAgICAgdHMgKz0gJyAnXG4gICAgICB9XG5cbiAgICAgIC8vIGFsaWduIHRoZSBzdHJpbmcgd2l0aGluIGl0cyBjb2x1bW4uXG4gICAgICBpZiAocm93W2NdLmFsaWduICYmIHJvd1tjXS5hbGlnbiAhPT0gJ2xlZnQnICYmIF90aGlzLndyYXApIHtcbiAgICAgICAgdHMgPSBhbGlnbltyb3dbY10uYWxpZ25dKHRzLCB3cmFwV2lkdGgpXG4gICAgICAgIGlmIChzdHJpbmdXaWR0aCh0cykgPCB3cmFwV2lkdGgpIHRzICs9IG5ldyBBcnJheSh3aWR0aCAtIHN0cmluZ1dpZHRoKHRzKSkuam9pbignICcpXG4gICAgICB9XG5cbiAgICAgIC8vIGFwcGx5IGJvcmRlciBhbmQgcGFkZGluZyB0byBzdHJpbmcuXG4gICAgICBwYWRkaW5nID0gcm93W2NdLnBhZGRpbmcgfHwgWzAsIDAsIDAsIDBdXG4gICAgICBpZiAocGFkZGluZ1tsZWZ0XSkgc3RyICs9IG5ldyBBcnJheShwYWRkaW5nW2xlZnRdICsgMSkuam9pbignICcpXG4gICAgICBzdHIgKz0gYWRkQm9yZGVyKHJvd1tjXSwgdHMsICd8ICcpXG4gICAgICBzdHIgKz0gdHNcbiAgICAgIHN0ciArPSBhZGRCb3JkZXIocm93W2NdLCB0cywgJyB8JylcbiAgICAgIGlmIChwYWRkaW5nW3JpZ2h0XSkgc3RyICs9IG5ldyBBcnJheShwYWRkaW5nW3JpZ2h0XSArIDEpLmpvaW4oJyAnKVxuXG4gICAgICAvLyBpZiBwcmlvciByb3cgaXMgc3BhbiwgdHJ5IHRvIHJlbmRlciB0aGVcbiAgICAgIC8vIGN1cnJlbnQgcm93IG9uIHRoZSBwcmlvciBsaW5lLlxuICAgICAgaWYgKHIgPT09IDAgJiYgbGluZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBzdHIgPSBfdGhpcy5fcmVuZGVySW5saW5lKHN0ciwgbGluZXNbbGluZXMubGVuZ3RoIC0gMV0pXG4gICAgICB9XG4gICAgfSlcblxuICAgIC8vIHJlbW92ZSB0cmFpbGluZyB3aGl0ZXNwYWNlLlxuICAgIGxpbmVzLnB1c2goe1xuICAgICAgdGV4dDogc3RyLnJlcGxhY2UoLyArJC8sICcnKSxcbiAgICAgIHNwYW46IHJvdy5zcGFuXG4gICAgfSlcbiAgfSlcblxuICByZXR1cm4gbGluZXNcbn1cblxuZnVuY3Rpb24gYWRkQm9yZGVyIChjb2wsIHRzLCBzdHlsZSkge1xuICBpZiAoY29sLmJvcmRlcikge1xuICAgIGlmICgvWy4nXS0rWy4nXS8udGVzdCh0cykpIHJldHVybiAnJ1xuICAgIGVsc2UgaWYgKHRzLnRyaW0oKS5sZW5ndGgpIHJldHVybiBzdHlsZVxuICAgIGVsc2UgcmV0dXJuICcgICdcbiAgfVxuICByZXR1cm4gJydcbn1cblxuLy8gaWYgdGhlIGZ1bGwgJ3NvdXJjZScgY2FuIHJlbmRlciBpblxuLy8gdGhlIHRhcmdldCBsaW5lLCBkbyBzby5cblVJLnByb3RvdHlwZS5fcmVuZGVySW5saW5lID0gZnVuY3Rpb24gKHNvdXJjZSwgcHJldmlvdXNMaW5lKSB7XG4gIHZhciBsZWFkaW5nV2hpdGVzcGFjZSA9IHNvdXJjZS5tYXRjaCgvXiAqLylbMF0ubGVuZ3RoXG4gIHZhciB0YXJnZXQgPSBwcmV2aW91c0xpbmUudGV4dFxuICB2YXIgdGFyZ2V0VGV4dFdpZHRoID0gc3RyaW5nV2lkdGgodGFyZ2V0LnRyaW1SaWdodCgpKVxuXG4gIGlmICghcHJldmlvdXNMaW5lLnNwYW4pIHJldHVybiBzb3VyY2VcblxuICAvLyBpZiB3ZSdyZSBub3QgYXBwbHlpbmcgd3JhcHBpbmcgbG9naWMsXG4gIC8vIGp1c3QgYWx3YXlzIGFwcGVuZCB0byB0aGUgc3Bhbi5cbiAgaWYgKCF0aGlzLndyYXApIHtcbiAgICBwcmV2aW91c0xpbmUuaGlkZGVuID0gdHJ1ZVxuICAgIHJldHVybiB0YXJnZXQgKyBzb3VyY2VcbiAgfVxuXG4gIGlmIChsZWFkaW5nV2hpdGVzcGFjZSA8IHRhcmdldFRleHRXaWR0aCkgcmV0dXJuIHNvdXJjZVxuXG4gIHByZXZpb3VzTGluZS5oaWRkZW4gPSB0cnVlXG5cbiAgcmV0dXJuIHRhcmdldC50cmltUmlnaHQoKSArIG5ldyBBcnJheShsZWFkaW5nV2hpdGVzcGFjZSAtIHRhcmdldFRleHRXaWR0aCArIDEpLmpvaW4oJyAnKSArIHNvdXJjZS50cmltTGVmdCgpXG59XG5cblVJLnByb3RvdHlwZS5fcmFzdGVyaXplID0gZnVuY3Rpb24gKHJvdykge1xuICB2YXIgX3RoaXMgPSB0aGlzXG4gIHZhciBpXG4gIHZhciBycm93XG4gIHZhciBycm93cyA9IFtdXG4gIHZhciB3aWR0aHMgPSB0aGlzLl9jb2x1bW5XaWR0aHMocm93KVxuICB2YXIgd3JhcHBlZFxuXG4gIC8vIHdvcmQgd3JhcCBhbGwgY29sdW1ucywgYW5kIGNyZWF0ZVxuICAvLyBhIGRhdGEtc3RydWN0dXJlIHRoYXQgaXMgZWFzeSB0byByYXN0ZXJpemUuXG4gIHJvdy5mb3JFYWNoKGZ1bmN0aW9uIChjb2wsIGMpIHtcbiAgICAvLyBsZWF2ZSByb29tIGZvciBsZWZ0IGFuZCByaWdodCBwYWRkaW5nLlxuICAgIGNvbC53aWR0aCA9IHdpZHRoc1tjXVxuICAgIGlmIChfdGhpcy53cmFwKSB3cmFwcGVkID0gd3JhcChjb2wudGV4dCwgX3RoaXMuX25lZ2F0ZVBhZGRpbmcoY29sKSwge2hhcmQ6IHRydWV9KS5zcGxpdCgnXFxuJylcbiAgICBlbHNlIHdyYXBwZWQgPSBjb2wudGV4dC5zcGxpdCgnXFxuJylcblxuICAgIGlmIChjb2wuYm9yZGVyKSB7XG4gICAgICB3cmFwcGVkLnVuc2hpZnQoJy4nICsgbmV3IEFycmF5KF90aGlzLl9uZWdhdGVQYWRkaW5nKGNvbCkgKyAzKS5qb2luKCctJykgKyAnLicpXG4gICAgICB3cmFwcGVkLnB1c2goXCInXCIgKyBuZXcgQXJyYXkoX3RoaXMuX25lZ2F0ZVBhZGRpbmcoY29sKSArIDMpLmpvaW4oJy0nKSArIFwiJ1wiKVxuICAgIH1cblxuICAgIC8vIGFkZCB0b3AgYW5kIGJvdHRvbSBwYWRkaW5nLlxuICAgIGlmIChjb2wucGFkZGluZykge1xuICAgICAgZm9yIChpID0gMDsgaSA8IChjb2wucGFkZGluZ1t0b3BdIHx8IDApOyBpKyspIHdyYXBwZWQudW5zaGlmdCgnJylcbiAgICAgIGZvciAoaSA9IDA7IGkgPCAoY29sLnBhZGRpbmdbYm90dG9tXSB8fCAwKTsgaSsrKSB3cmFwcGVkLnB1c2goJycpXG4gICAgfVxuXG4gICAgd3JhcHBlZC5mb3JFYWNoKGZ1bmN0aW9uIChzdHIsIHIpIHtcbiAgICAgIGlmICghcnJvd3Nbcl0pIHJyb3dzLnB1c2goW10pXG5cbiAgICAgIHJyb3cgPSBycm93c1tyXVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGM7IGkrKykge1xuICAgICAgICBpZiAocnJvd1tpXSA9PT0gdW5kZWZpbmVkKSBycm93LnB1c2goJycpXG4gICAgICB9XG4gICAgICBycm93LnB1c2goc3RyKVxuICAgIH0pXG4gIH0pXG5cbiAgcmV0dXJuIHJyb3dzXG59XG5cblVJLnByb3RvdHlwZS5fbmVnYXRlUGFkZGluZyA9IGZ1bmN0aW9uIChjb2wpIHtcbiAgdmFyIHdyYXBXaWR0aCA9IGNvbC53aWR0aFxuICBpZiAoY29sLnBhZGRpbmcpIHdyYXBXaWR0aCAtPSAoY29sLnBhZGRpbmdbbGVmdF0gfHwgMCkgKyAoY29sLnBhZGRpbmdbcmlnaHRdIHx8IDApXG4gIGlmIChjb2wuYm9yZGVyKSB3cmFwV2lkdGggLT0gNFxuICByZXR1cm4gd3JhcFdpZHRoXG59XG5cblVJLnByb3RvdHlwZS5fY29sdW1uV2lkdGhzID0gZnVuY3Rpb24gKHJvdykge1xuICB2YXIgX3RoaXMgPSB0aGlzXG4gIHZhciB3aWR0aHMgPSBbXVxuICB2YXIgdW5zZXQgPSByb3cubGVuZ3RoXG4gIHZhciB1bnNldFdpZHRoXG4gIHZhciByZW1haW5pbmdXaWR0aCA9IHRoaXMud2lkdGhcblxuICAvLyBjb2x1bW4gd2lkdGhzIGNhbiBiZSBzZXQgaW4gY29uZmlnLlxuICByb3cuZm9yRWFjaChmdW5jdGlvbiAoY29sLCBpKSB7XG4gICAgaWYgKGNvbC53aWR0aCkge1xuICAgICAgdW5zZXQtLVxuICAgICAgd2lkdGhzW2ldID0gY29sLndpZHRoXG4gICAgICByZW1haW5pbmdXaWR0aCAtPSBjb2wud2lkdGhcbiAgICB9IGVsc2Uge1xuICAgICAgd2lkdGhzW2ldID0gdW5kZWZpbmVkXG4gICAgfVxuICB9KVxuXG4gIC8vIGFueSB1bnNldCB3aWR0aHMgc2hvdWxkIGJlIGNhbGN1bGF0ZWQuXG4gIGlmICh1bnNldCkgdW5zZXRXaWR0aCA9IE1hdGguZmxvb3IocmVtYWluaW5nV2lkdGggLyB1bnNldClcbiAgd2lkdGhzLmZvckVhY2goZnVuY3Rpb24gKHcsIGkpIHtcbiAgICBpZiAoIV90aGlzLndyYXApIHdpZHRoc1tpXSA9IHJvd1tpXS53aWR0aCB8fCBzdHJpbmdXaWR0aChyb3dbaV0udGV4dClcbiAgICBlbHNlIGlmICh3ID09PSB1bmRlZmluZWQpIHdpZHRoc1tpXSA9IE1hdGgubWF4KHVuc2V0V2lkdGgsIF9taW5XaWR0aChyb3dbaV0pKVxuICB9KVxuXG4gIHJldHVybiB3aWR0aHNcbn1cblxuLy8gY2FsY3VsYXRlcyB0aGUgbWluaW11bSB3aWR0aCBvZlxuLy8gYSBjb2x1bW4sIGJhc2VkIG9uIHBhZGRpbmcgcHJlZmVyZW5jZXMuXG5mdW5jdGlvbiBfbWluV2lkdGggKGNvbCkge1xuICB2YXIgcGFkZGluZyA9IGNvbC5wYWRkaW5nIHx8IFtdXG4gIHZhciBtaW5XaWR0aCA9IDEgKyAocGFkZGluZ1tsZWZ0XSB8fCAwKSArIChwYWRkaW5nW3JpZ2h0XSB8fCAwKVxuICBpZiAoY29sLmJvcmRlcikgbWluV2lkdGggKz0gNFxuICByZXR1cm4gbWluV2lkdGhcbn1cblxuZnVuY3Rpb24gYWxpZ25SaWdodCAoc3RyLCB3aWR0aCkge1xuICBzdHIgPSBzdHIudHJpbSgpXG4gIHZhciBwYWRkaW5nID0gJydcbiAgdmFyIHN0cldpZHRoID0gc3RyaW5nV2lkdGgoc3RyKVxuXG4gIGlmIChzdHJXaWR0aCA8IHdpZHRoKSB7XG4gICAgcGFkZGluZyA9IG5ldyBBcnJheSh3aWR0aCAtIHN0cldpZHRoICsgMSkuam9pbignICcpXG4gIH1cblxuICByZXR1cm4gcGFkZGluZyArIHN0clxufVxuXG5mdW5jdGlvbiBhbGlnbkNlbnRlciAoc3RyLCB3aWR0aCkge1xuICBzdHIgPSBzdHIudHJpbSgpXG4gIHZhciBwYWRkaW5nID0gJydcbiAgdmFyIHN0cldpZHRoID0gc3RyaW5nV2lkdGgoc3RyLnRyaW0oKSlcblxuICBpZiAoc3RyV2lkdGggPCB3aWR0aCkge1xuICAgIHBhZGRpbmcgPSBuZXcgQXJyYXkocGFyc2VJbnQoKHdpZHRoIC0gc3RyV2lkdGgpIC8gMiwgMTApICsgMSkuam9pbignICcpXG4gIH1cblxuICByZXR1cm4gcGFkZGluZyArIHN0clxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gIG9wdHMgPSBvcHRzIHx8IHt9XG5cbiAgcmV0dXJuIG5ldyBVSSh7XG4gICAgd2lkdGg6IChvcHRzIHx8IHt9KS53aWR0aCB8fCA4MCxcbiAgICB3cmFwOiB0eXBlb2Ygb3B0cy53cmFwID09PSAnYm9vbGVhbicgPyBvcHRzLndyYXAgOiB0cnVlXG4gIH0pXG59XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBiYWJlbC9uZXctY2FwLCB4by90aHJvdy1uZXctZXJyb3IgKi9cbid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHN0ciwgcG9zKSB7XG5cdGlmIChzdHIgPT09IG51bGwgfHwgc3RyID09PSB1bmRlZmluZWQpIHtcblx0XHR0aHJvdyBUeXBlRXJyb3IoKTtcblx0fVxuXG5cdHN0ciA9IFN0cmluZyhzdHIpO1xuXG5cdHZhciBzaXplID0gc3RyLmxlbmd0aDtcblx0dmFyIGkgPSBwb3MgPyBOdW1iZXIocG9zKSA6IDA7XG5cblx0aWYgKE51bWJlci5pc05hTihpKSkge1xuXHRcdGkgPSAwO1xuXHR9XG5cblx0aWYgKGkgPCAwIHx8IGkgPj0gc2l6ZSkge1xuXHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdH1cblxuXHR2YXIgZmlyc3QgPSBzdHIuY2hhckNvZGVBdChpKTtcblxuXHRpZiAoZmlyc3QgPj0gMHhEODAwICYmIGZpcnN0IDw9IDB4REJGRiAmJiBzaXplID4gaSArIDEpIHtcblx0XHR2YXIgc2Vjb25kID0gc3RyLmNoYXJDb2RlQXQoaSArIDEpO1xuXG5cdFx0aWYgKHNlY29uZCA+PSAweERDMDAgJiYgc2Vjb25kIDw9IDB4REZGRikge1xuXHRcdFx0cmV0dXJuICgoZmlyc3QgLSAweEQ4MDApICogMHg0MDApICsgc2Vjb25kIC0gMHhEQzAwICsgMHgxMDAwMDtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZmlyc3Q7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoeHMsIGZuKSB7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHggPSBmbih4c1tpXSwgaSk7XG4gICAgICAgIGlmIChpc0FycmF5KHgpKSByZXMucHVzaC5hcHBseShyZXMsIHgpO1xuICAgICAgICBlbHNlIHJlcy5wdXNoKHgpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsIid1c2Ugc3RyaWN0J1xudmFyIHNwYXduID0gcmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpLnNwYXduXG52YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2VcblxudmFyIHVuemlwID0gcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJyA/IGZvcldpbjMyIDogZm9yVW5peFxudW56aXAudW56aXAgPSB1bnppcFxubW9kdWxlLmV4cG9ydHMgPSB1bnppcFxuXG4vLyB0b2RvOiBwcm9ncmVzcyBmZWVkYmFja1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZnJpdHgvd2luLTd6aXBcbmZ1bmN0aW9uIGZvcldpbjMyIChpblBhdGgsIG91dFBhdGgsIGNhbGxiYWNrKSB7XG4gIHZhciBfN3ogPSByZXF1aXJlKCc3emlwJylbJzd6J11cblxuICAvLyB2ZXJ5IOWlh+iRqVxuICAvLyBlZy4gN3ogeCBhcmNoaXZlLnppcCAtb2M6XFxEb2NcbiAgcnVuKF83eiwgWyd4JywgaW5QYXRoLCAnLXknLCAnLW8nICsgb3V0UGF0aF0sIGNhbGxiYWNrKVxufVxuXG5mdW5jdGlvbiBmb3JVbml4IChpblBhdGgsIG91dFBhdGgsIGNhbGxiYWNrKSB7XG4gIHJ1bigndW56aXAnLCBbJy1vJywgaW5QYXRoLCAnLWQnLCBvdXRQYXRoXSwgY2FsbGJhY2spXG59XG5cbi8vIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvY2hpbGRfcHJvY2Vzcy5odG1sI2NoaWxkX3Byb2Nlc3NfZXZlbnRfZXJyb3Jcbi8vIE5vdGUgdGhhdCB0aGUgJ2V4aXQnIGV2ZW50IG1heSBvciBtYXkgbm90IGZpcmUgYWZ0ZXIgYW4gZXJyb3IgaGFzIG9jY3VycmVkLlxuLy8gSWYgeW91IGFyZSBsaXN0ZW5pbmcgdG8gYm90aCB0aGUgJ2V4aXQnIGFuZCAnZXJyb3InIGV2ZW50cyxcbi8vIGl0IGlzIGltcG9ydGFudCB0byBndWFyZCBhZ2FpbnN0IGFjY2lkZW50YWxseSBpbnZva2luZyBoYW5kbGVyIGZ1bmN0aW9ucyBtdWx0aXBsZSB0aW1lcy5cbmZ1bmN0aW9uIHJ1biAoYmluLCBhcmdzLCBjYWxsYmFjaykge1xuICBjYWxsYmFjayA9IG9uY2VpZnkoY2FsbGJhY2spXG5cbiAgdmFyIHByYyA9IHNwYXduKGJpbiwgYXJncywge1xuICAgIHN0ZGlvOiAnaWdub3JlJ1xuICB9KVxuICBwcmMub24oJ2Vycm9yJywgZnVuY3Rpb24gKGVycikge1xuICAgIGNhbGxiYWNrKGVycilcbiAgfSlcbiAgcHJjLm9uKCdleGl0JywgZnVuY3Rpb24gKGNvZGUpIHtcbiAgICBjYWxsYmFjayhjb2RlID8gbmV3IEVycm9yKCdFeGl0ZWQgd2l0aCBjb2RlICcgKyBjb2RlKSA6IG51bGwpXG4gIH0pXG59XG5cbi8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzAyMzQ5MDgvamF2YXNjcmlwdC12OC1vcHRpbWlzYXRpb24tYW5kLWxlYWtpbmctYXJndW1lbnRzXG4vLyBqYXZhc2NyaXB0IFY4IG9wdGltaXNhdGlvbiBhbmQg4oCcbGVha2luZyBhcmd1bWVudHPigJ1cbi8vIG1ha2luZyBjYWxsYmFjayB0byBiZSBpbnZva2VkIG9ubHkgb25jZVxuZnVuY3Rpb24gb25jZWlmeSAoZm4pIHtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNhbGxlZCkgcmV0dXJuXG4gICAgY2FsbGVkID0gdHJ1ZVxuICAgIGZuLmFwcGx5KHRoaXMsIHNsaWNlLmNhbGwoYXJndW1lbnRzKSkgLy8gc2xpY2UgYXJndW1lbnRzXG4gIH1cbn1cbiIsImZ1bmN0aW9uIERhbWVyYXVMZXZlbnNodGVpbiAocHJpY2VzLCBkYW1lcmF1KSB7XG4gICAgLy8gJ3ByaWNlcycgY3VzdG9taXNhdGlvbiBvZiB0aGUgZWRpdCBjb3N0cyBieSBwYXNzaW5nIGFuXG4gICAgLy8gb2JqZWN0IHdpdGggb3B0aW9uYWwgJ2luc2VydCcsICdyZW1vdmUnLCAnc3Vic3RpdHV0ZScsIGFuZFxuICAgIC8vICd0cmFuc3Bvc2UnIGtleXMsIGNvcnJlc3BvbmRpbmcgdG8gZWl0aGVyIGEgY29uc3RhbnRcbiAgICAvLyBudW1iZXIsIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBjb3N0LiBUaGUgZGVmYXVsdFxuICAgIC8vIGNvc3QgZm9yIGVhY2ggb3BlcmF0aW9uIGlzIDEuIFRoZSBwcmljZSBmdW5jdGlvbnMgdGFrZVxuICAgIC8vIHJlbGV2YW50IGNoYXJhY3RlcihzKSBhcyBhcmd1bWVudHMsIHNob3VsZCByZXR1cm4gbnVtYmVycyxcbiAgICAvLyBhbmQgaGF2ZSB0aGUgZm9sbG93aW5nIGZvcm06XG4gICAgLy9cbiAgICAvLyBpbnNlcnQ6IGZ1bmN0aW9uIChpbnNlcnRlZCkgeyByZXR1cm4gTlVNQkVSOyB9XG4gICAgLy9cbiAgICAvLyByZW1vdmU6IGZ1bmN0aW9uIChyZW1vdmVkKSB7IHJldHVybiBOVU1CRVI7IH1cbiAgICAvL1xuICAgIC8vIHN1YnN0aXR1dGU6IGZ1bmN0aW9uIChmcm9tLCB0bykgeyByZXR1cm4gTlVNQkVSOyB9XG4gICAgLy9cbiAgICAvLyB0cmFuc3Bvc2U6IGZ1bmN0aW9uIChiYWNrd2FyZCwgZm9yd2FyZCkgeyByZXR1cm4gTlVNQkVSOyB9XG4gICAgLy9cbiAgICAvLyBUaGUgZGFtZXJhdSBmbGFnIGFsbG93cyB1cyB0byB0dXJuIG9mZiB0cmFuc3Bvc2l0aW9uIGFuZFxuICAgIC8vIG9ubHkgZG8gcGxhaW4gTGV2ZW5zaHRlaW4gZGlzdGFuY2UuXG5cbiAgICBpZiAoZGFtZXJhdSAhPT0gZmFsc2UpIGRhbWVyYXUgPSB0cnVlO1xuICAgIGlmICghcHJpY2VzKSBwcmljZXMgPSB7fTtcbiAgICB2YXIgaW5zZXJ0LCByZW1vdmUsIHN1YnN0aXR1dGUsIHRyYW5zcG9zZTtcblxuICAgIHN3aXRjaCAodHlwZW9mIHByaWNlcy5pbnNlcnQpIHtcbiAgICBjYXNlICdmdW5jdGlvbic6IGluc2VydCA9IHByaWNlcy5pbnNlcnQ7IGJyZWFrO1xuICAgIGNhc2UgJ251bWJlcic6IGluc2VydCA9IGZ1bmN0aW9uIChjKSB7IHJldHVybiBwcmljZXMuaW5zZXJ0OyB9OyBicmVhaztcbiAgICBkZWZhdWx0OiBpbnNlcnQgPSBmdW5jdGlvbiAoYykgeyByZXR1cm4gMTsgfTsgYnJlYWs7IH1cblxuICAgIHN3aXRjaCAodHlwZW9mIHByaWNlcy5yZW1vdmUpIHtcbiAgICBjYXNlICdmdW5jdGlvbic6IHJlbW92ZSA9IHByaWNlcy5yZW1vdmU7IGJyZWFrO1xuICAgIGNhc2UgJ251bWJlcic6IHJlbW92ZSA9IGZ1bmN0aW9uIChjKSB7IHJldHVybiBwcmljZXMucmVtb3ZlOyB9OyBicmVhaztcbiAgICBkZWZhdWx0OiByZW1vdmUgPSBmdW5jdGlvbiAoYykgeyByZXR1cm4gMTsgfTsgYnJlYWs7IH1cblxuICAgIHN3aXRjaCAodHlwZW9mIHByaWNlcy5zdWJzdGl0dXRlKSB7XG4gICAgY2FzZSAnZnVuY3Rpb24nOiBzdWJzdGl0dXRlID0gcHJpY2VzLnN1YnN0aXR1dGU7IGJyZWFrO1xuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgIHN1YnN0aXR1dGUgPSBmdW5jdGlvbiAoZnJvbSwgdG8pIHsgcmV0dXJuIHByaWNlcy5zdWJzdGl0dXRlOyB9O1xuICAgICAgICBicmVhaztcbiAgICBkZWZhdWx0OiBzdWJzdGl0dXRlID0gZnVuY3Rpb24gKGZyb20sIHRvKSB7IHJldHVybiAxOyB9OyBicmVhazsgfVxuXG4gICAgc3dpdGNoICh0eXBlb2YgcHJpY2VzLnRyYW5zcG9zZSkge1xuICAgIGNhc2UgJ2Z1bmN0aW9uJzogdHJhbnNwb3NlID0gcHJpY2VzLnRyYW5zcG9zZTsgYnJlYWs7XG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgdHJhbnNwb3NlID0gZnVuY3Rpb24gKGJhY2t3YXJkLCBmb3J3YXJkKSB7IHJldHVybiBwcmljZXMudHJhbnNwb3NlOyB9O1xuICAgICAgICBicmVhaztcbiAgICBkZWZhdWx0OiB0cmFuc3Bvc2UgPSBmdW5jdGlvbiAoYmFja3dhcmQsIGZvcndhcmQpIHsgcmV0dXJuIDE7IH07IGJyZWFrOyB9XG5cbiAgICBmdW5jdGlvbiBkaXN0YW5jZShkb3duLCBhY3Jvc3MpIHtcbiAgICAgICAgLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9EYW1lcmF1JUUyJTgwJTkzTGV2ZW5zaHRlaW5fZGlzdGFuY2VcbiAgICAgICAgdmFyIGRzID0gW107XG4gICAgICAgIGlmICggZG93biA9PT0gYWNyb3NzICkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkb3duID0gZG93bi5zcGxpdCgnJyk7IGRvd24udW5zaGlmdChudWxsKTtcbiAgICAgICAgICAgIGFjcm9zcyA9IGFjcm9zcy5zcGxpdCgnJyk7IGFjcm9zcy51bnNoaWZ0KG51bGwpO1xuICAgICAgICAgICAgZG93bi5mb3JFYWNoKGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFkc1tpXSkgZHNbaV0gPSBbXTtcbiAgICAgICAgICAgICAgICBhY3Jvc3MuZm9yRWFjaChmdW5jdGlvbiAoYSwgaikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMCAmJiBqID09PSAwKSBkc1tpXVtqXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIC8vIEVtcHR5IGRvd24gKGkgPT0gMCkgLT4gYWNyb3NzWzEuLmpdIGJ5IGluc2VydGluZ1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpID09PSAwKSBkc1tpXVtqXSA9IGRzW2ldW2otMV0gKyBpbnNlcnQoYSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIERvd24gLT4gZW1wdHkgYWNyb3NzIChqID09IDApIGJ5IGRlbGV0aW5nXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGogPT09IDApIGRzW2ldW2pdID0gZHNbaS0xXVtqXSArIHJlbW92ZShkKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGaW5kIHRoZSBsZWFzdCBjb3N0bHkgb3BlcmF0aW9uIHRoYXQgdHVybnNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBwcmVmaXggZG93blsxLi5pXSBpbnRvIHRoZSBwcmVmaXhcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFjcm9zc1sxLi5qXSB1c2luZyBhbHJlYWR5IGNhbGN1bGF0ZWQgY29zdHNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvciBnZXR0aW5nIHRvIHNob3J0ZXIgbWF0Y2hlcy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGRzW2ldW2pdID0gTWF0aC5taW4oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29zdCBvZiBlZGl0aW5nIGRvd25bMS4uaS0xXSB0b1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFjcm9zc1sxLi5qXSBwbHVzIGNvc3Qgb2YgZGVsZXRpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkb3duW2ldIHRvIGdldCB0byBkb3duWzEuLmktMV0uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHNbaS0xXVtqXSArIHJlbW92ZShkKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDb3N0IG9mIGVkaXRpbmcgZG93blsxLi5pXSB0b1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFjcm9zc1sxLi5qLTFdIHBsdXMgY29zdCBvZiBpbnNlcnRpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhY3Jvc3Nbal0gdG8gZ2V0IHRvIGFjcm9zc1sxLi5qXS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkc1tpXVtqLTFdICsgaW5zZXJ0KGEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvc3Qgb2YgZWRpdGluZyBkb3duWzEuLmktMV0gdG9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhY3Jvc3NbMS4uai0xXSBwbHVzIGNvc3Qgb2ZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzdWJzdGl0dXRpbmcgZG93bltpXSAoZCkgd2l0aCBhY3Jvc3Nbal1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAoYSkgdG8gZ2V0IHRvIGFjcm9zc1sxLi5qXS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkc1tpLTFdW2otMV0gKyAoZCA9PT0gYSA/IDAgOiBzdWJzdGl0dXRlKGQsIGEpKVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhbiB3ZSBtYXRjaCB0aGUgbGFzdCB0d28gbGV0dGVycyBvZiBkb3duXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3aXRoIGFjcm9zcyBieSB0cmFuc3Bvc2luZyB0aGVtPyBDb3N0IG9mXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBnZXR0aW5nIGZyb20gZG93bltpLTJdIHRvIGFjcm9zc1tqLTJdIHBsdXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvc3Qgb2YgbW92aW5nIGRvd25baS0xXSBmb3J3YXJkIGFuZFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG93bltpXSBiYWNrd2FyZCB0byBtYXRjaCBhY3Jvc3Nbai0xLi5qXS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYW1lcmF1XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgaSA+IDEgJiYgaiA+IDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiBkb3duW2ktMV0gPT09IGEgJiYgZCA9PT0gYWNyb3NzW2otMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkc1tpXVtqXSA9IE1hdGgubWluKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkc1tpXVtqXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHNbaS0yXVtqLTJdICsgKGQgPT09IGEgPyAwIDogdHJhbnNwb3NlKGQsIGRvd25baS0xXSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBkc1tkb3duLmxlbmd0aC0xXVthY3Jvc3MubGVuZ3RoLTFdO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIGRpc3RhbmNlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBEYW1lcmF1TGV2ZW5zaHRlaW47XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdHIsIHNlcCkge1xuXHRpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBhIHN0cmluZycpO1xuXHR9XG5cblx0c2VwID0gdHlwZW9mIHNlcCA9PT0gJ3VuZGVmaW5lZCcgPyAnXycgOiBzZXA7XG5cblx0cmV0dXJuIHN0clxuXHRcdC5yZXBsYWNlKC8oW2EtelxcZF0pKFtBLVpdKS9nLCAnJDEnICsgc2VwICsgJyQyJylcblx0XHQucmVwbGFjZSgvKFtBLVpdKykoW0EtWl1bYS16XFxkXSspL2csICckMScgKyBzZXAgKyAnJDInKVxuXHRcdC50b0xvd2VyQ2FzZSgpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9mcyA9IHJlcXVpcmUoJ2ZzJyk7XG5cbnZhciBfZnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZnMpO1xuXG52YXIgX3BhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5cbnZhciBfcGF0aDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wYXRoKTtcblxudmFyIF9yaW1yYWYgPSByZXF1aXJlKCdyaW1yYWYnKTtcblxudmFyIF9yaW1yYWYyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmltcmFmKTtcblxudmFyIF9jcm9zc1VuemlwID0gcmVxdWlyZSgnY3Jvc3MtdW56aXAnKTtcblxudmFyIF9jcm9zc1VuemlwMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Nyb3NzVW56aXApO1xuXG52YXIgX3V0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgZG93bmxvYWRDaHJvbWVFeHRlbnNpb24gPSBmdW5jdGlvbiBkb3dubG9hZENocm9tZUV4dGVuc2lvbihjaHJvbWVTdG9yZUlELCBmb3JjZURvd25sb2FkKSB7XG4gIHZhciBhdHRlbXB0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogNTtcblxuICB2YXIgZXh0ZW5zaW9uc1N0b3JlID0gKDAsIF91dGlscy5nZXRQYXRoKSgpO1xuICBpZiAoIV9mczIuZGVmYXVsdC5leGlzdHNTeW5jKGV4dGVuc2lvbnNTdG9yZSkpIHtcbiAgICBfZnMyLmRlZmF1bHQubWtkaXJTeW5jKGV4dGVuc2lvbnNTdG9yZSk7XG4gIH1cbiAgdmFyIGV4dGVuc2lvbkZvbGRlciA9IF9wYXRoMi5kZWZhdWx0LnJlc29sdmUoZXh0ZW5zaW9uc1N0b3JlICsgJy8nICsgY2hyb21lU3RvcmVJRCk7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgaWYgKCFfZnMyLmRlZmF1bHQuZXhpc3RzU3luYyhleHRlbnNpb25Gb2xkZXIpIHx8IGZvcmNlRG93bmxvYWQpIHtcbiAgICAgIGlmIChfZnMyLmRlZmF1bHQuZXhpc3RzU3luYyhleHRlbnNpb25Gb2xkZXIpKSB7XG4gICAgICAgIF9yaW1yYWYyLmRlZmF1bHQuc3luYyhleHRlbnNpb25Gb2xkZXIpO1xuICAgICAgfVxuICAgICAgdmFyIGZpbGVVUkwgPSAnaHR0cHM6Ly9jbGllbnRzMi5nb29nbGUuY29tL3NlcnZpY2UvdXBkYXRlMi9jcng/cmVzcG9uc2U9cmVkaXJlY3QmeD1pZCUzRCcgKyBjaHJvbWVTdG9yZUlEICsgJyUyNnVjJnByb2R2ZXJzaW9uPTMyJzsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgdmFyIGZpbGVQYXRoID0gX3BhdGgyLmRlZmF1bHQucmVzb2x2ZShleHRlbnNpb25Gb2xkZXIgKyAnLmNyeCcpO1xuICAgICAgKDAsIF91dGlscy5kb3dubG9hZEZpbGUpKGZpbGVVUkwsIGZpbGVQYXRoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgKDAsIF9jcm9zc1VuemlwMi5kZWZhdWx0KShmaWxlUGF0aCwgZXh0ZW5zaW9uRm9sZGVyLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgaWYgKGVyciAmJiAhX2ZzMi5kZWZhdWx0LmV4aXN0c1N5bmMoX3BhdGgyLmRlZmF1bHQucmVzb2x2ZShleHRlbnNpb25Gb2xkZXIsICdtYW5pZmVzdC5qc29uJykpKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICAgICAgfVxuICAgICAgICAgICgwLCBfdXRpbHMuY2hhbmdlUGVybWlzc2lvbnMpKGV4dGVuc2lvbkZvbGRlciwgNzU1KTtcbiAgICAgICAgICByZXNvbHZlKGV4dGVuc2lvbkZvbGRlcik7XG4gICAgICAgIH0pO1xuICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICBjb25zb2xlLmxvZygnRmFpbGVkIHRvIGZldGNoIGV4dGVuc2lvbiwgdHJ5aW5nICcgKyAoYXR0ZW1wdHMgLSAxKSArICcgbW9yZSB0aW1lcycpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgIGlmIChhdHRlbXB0cyA8PSAxKSB7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgICB9XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGRvd25sb2FkQ2hyb21lRXh0ZW5zaW9uKGNocm9tZVN0b3JlSUQsIGZvcmNlRG93bmxvYWQsIGF0dGVtcHRzIC0gMSkudGhlbihyZXNvbHZlKS5jYXRjaChyZWplY3QpO1xuICAgICAgICB9LCAyMDApO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc29sdmUoZXh0ZW5zaW9uRm9sZGVyKTtcbiAgICB9XG4gIH0pO1xufTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gZG93bmxvYWRDaHJvbWVFeHRlbnNpb247IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5NT0JYX0RFVlRPT0xTID0gZXhwb3J0cy5BUE9MTE9fREVWRUxPUEVSX1RPT0xTID0gZXhwb3J0cy5DWUNMRUpTX0RFVlRPT0wgPSBleHBvcnRzLlJFQUNUX1BFUkYgPSBleHBvcnRzLlJFRFVYX0RFVlRPT0xTID0gZXhwb3J0cy5WVUVKU19ERVZUT09MUyA9IGV4cG9ydHMuQU5HVUxBUkpTX0JBVEFSQU5HID0gZXhwb3J0cy5KUVVFUllfREVCVUdHRVIgPSBleHBvcnRzLkJBQ0tCT05FX0RFQlVHR0VSID0gZXhwb3J0cy5SRUFDVF9ERVZFTE9QRVJfVE9PTFMgPSBleHBvcnRzLkVNQkVSX0lOU1BFQ1RPUiA9IHVuZGVmaW5lZDtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgX2VsZWN0cm9uID0gcmVxdWlyZSgnZWxlY3Ryb24nKTtcblxudmFyIF9lbGVjdHJvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9lbGVjdHJvbik7XG5cbnZhciBfZnMgPSByZXF1aXJlKCdmcycpO1xuXG52YXIgX2ZzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ZzKTtcblxudmFyIF9wYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuXG52YXIgX3BhdGgyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGF0aCk7XG5cbnZhciBfc2VtdmVyID0gcmVxdWlyZSgnc2VtdmVyJyk7XG5cbnZhciBfc2VtdmVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NlbXZlcik7XG5cbnZhciBfZG93bmxvYWRDaHJvbWVFeHRlbnNpb24gPSByZXF1aXJlKCcuL2Rvd25sb2FkQ2hyb21lRXh0ZW5zaW9uJyk7XG5cbnZhciBfZG93bmxvYWRDaHJvbWVFeHRlbnNpb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZG93bmxvYWRDaHJvbWVFeHRlbnNpb24pO1xuXG52YXIgX3V0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG52YXIgX3JlZiA9IF9lbGVjdHJvbi5yZW1vdGUgfHwgX2VsZWN0cm9uMi5kZWZhdWx0LFxuICAgIEJyb3dzZXJXaW5kb3cgPSBfcmVmLkJyb3dzZXJXaW5kb3c7XG5cbnZhciBJRE1hcCA9IHt9O1xudmFyIElETWFwUGF0aCA9IF9wYXRoMi5kZWZhdWx0LnJlc29sdmUoKDAsIF91dGlscy5nZXRQYXRoKSgpLCAnSURNYXAuanNvbicpO1xuaWYgKF9mczIuZGVmYXVsdC5leGlzdHNTeW5jKElETWFwUGF0aCkpIHtcbiAgdHJ5IHtcbiAgICBJRE1hcCA9IEpTT04ucGFyc2UoX2ZzMi5kZWZhdWx0LnJlYWRGaWxlU3luYyhJRE1hcFBhdGgsICd1dGY4JykpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjb25zb2xlLmVycm9yKCdlbGVjdHJvbi1kZXZ0b29scy1pbnN0YWxsZXI6IEludmFsaWQgSlNPTiBwcmVzZW50IGluIHRoZSBJRE1hcCBmaWxlJyk7XG4gIH1cbn1cblxudmFyIGluc3RhbGwgPSBmdW5jdGlvbiBpbnN0YWxsKGV4dGVuc2lvblJlZmVyZW5jZSkge1xuICB2YXIgZm9yY2VEb3dubG9hZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoZXh0ZW5zaW9uUmVmZXJlbmNlKSkge1xuICAgIHJldHVybiBQcm9taXNlLmFsbChleHRlbnNpb25SZWZlcmVuY2UubWFwKGZ1bmN0aW9uIChleHRlbnNpb24pIHtcbiAgICAgIHJldHVybiBpbnN0YWxsKGV4dGVuc2lvbiwgZm9yY2VEb3dubG9hZCk7XG4gICAgfSkpO1xuICB9XG4gIHZhciBjaHJvbWVTdG9yZUlEID0gdm9pZCAwO1xuICBpZiAoKHR5cGVvZiBleHRlbnNpb25SZWZlcmVuY2UgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGV4dGVuc2lvblJlZmVyZW5jZSkpID09PSAnb2JqZWN0JyAmJiBleHRlbnNpb25SZWZlcmVuY2UuaWQpIHtcbiAgICBjaHJvbWVTdG9yZUlEID0gZXh0ZW5zaW9uUmVmZXJlbmNlLmlkO1xuICAgIHZhciBlbGVjdHJvblZlcnNpb24gPSBwcm9jZXNzLnZlcnNpb25zLmVsZWN0cm9uLnNwbGl0KCctJylbMF07XG4gICAgaWYgKCFfc2VtdmVyMi5kZWZhdWx0LnNhdGlzZmllcyhlbGVjdHJvblZlcnNpb24sIGV4dGVuc2lvblJlZmVyZW5jZS5lbGVjdHJvbikpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ1ZlcnNpb24gb2YgRWxlY3Ryb246ICcgKyBlbGVjdHJvblZlcnNpb24gKyAnIGRvZXMgbm90IG1hdGNoIHJlcXVpcmVkIHJhbmdlICcgKyBleHRlbnNpb25SZWZlcmVuY2UuZWxlY3Ryb24gKyAnIGZvciBleHRlbnNpb24gJyArIGNocm9tZVN0b3JlSUQpIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiBleHRlbnNpb25SZWZlcmVuY2UgPT09ICdzdHJpbmcnKSB7XG4gICAgY2hyb21lU3RvcmVJRCA9IGV4dGVuc2lvblJlZmVyZW5jZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdJbnZhbGlkIGV4dGVuc2lvblJlZmVyZW5jZSBwYXNzZWQgaW46IFwiJyArIGV4dGVuc2lvblJlZmVyZW5jZSArICdcIicpKTtcbiAgfVxuICB2YXIgZXh0ZW5zaW9uTmFtZSA9IElETWFwW2Nocm9tZVN0b3JlSURdO1xuICB2YXIgZXh0ZW5zaW9uSW5zdGFsbGVkID0gZXh0ZW5zaW9uTmFtZSAmJiBCcm93c2VyV2luZG93LmdldERldlRvb2xzRXh0ZW5zaW9ucyAmJiBCcm93c2VyV2luZG93LmdldERldlRvb2xzRXh0ZW5zaW9ucygpW2V4dGVuc2lvbk5hbWVdO1xuICBpZiAoIWZvcmNlRG93bmxvYWQgJiYgZXh0ZW5zaW9uSW5zdGFsbGVkKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShJRE1hcFtjaHJvbWVTdG9yZUlEXSk7XG4gIH1cbiAgcmV0dXJuICgwLCBfZG93bmxvYWRDaHJvbWVFeHRlbnNpb24yLmRlZmF1bHQpKGNocm9tZVN0b3JlSUQsIGZvcmNlRG93bmxvYWQpLnRoZW4oZnVuY3Rpb24gKGV4dGVuc2lvbkZvbGRlcikge1xuICAgIC8vIFVzZSBmb3JjZURvd25sb2FkLCBidXQgYWxyZWFkeSBpbnN0YWxsZWRcbiAgICBpZiAoZXh0ZW5zaW9uSW5zdGFsbGVkKSB7XG4gICAgICBCcm93c2VyV2luZG93LnJlbW92ZURldlRvb2xzRXh0ZW5zaW9uKGV4dGVuc2lvbk5hbWUpO1xuICAgIH1cbiAgICB2YXIgbmFtZSA9IEJyb3dzZXJXaW5kb3cuYWRkRGV2VG9vbHNFeHRlbnNpb24oZXh0ZW5zaW9uRm9sZGVyKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIF9mczIuZGVmYXVsdC53cml0ZUZpbGVTeW5jKElETWFwUGF0aCwgSlNPTi5zdHJpbmdpZnkoT2JqZWN0LmFzc2lnbihJRE1hcCwgX2RlZmluZVByb3BlcnR5KHt9LCBjaHJvbWVTdG9yZUlELCBuYW1lKSkpKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5hbWUpO1xuICB9KTtcbn07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGluc3RhbGw7XG52YXIgRU1CRVJfSU5TUEVDVE9SID0gZXhwb3J0cy5FTUJFUl9JTlNQRUNUT1IgPSB7XG4gIGlkOiAnYm1kYmxuY2Vna2Vua2FjaWVpaGZocGpmcHBvY29uaGknLFxuICBlbGVjdHJvbjogJz49MS4yLjEnXG59O1xudmFyIFJFQUNUX0RFVkVMT1BFUl9UT09MUyA9IGV4cG9ydHMuUkVBQ1RfREVWRUxPUEVSX1RPT0xTID0ge1xuICBpZDogJ2Zta2FkbWFwZ29mYWRvcGxqYmpma2FwZGtvaWVuaWhpJyxcbiAgZWxlY3Ryb246ICc+PTEuMi4xJ1xufTtcbnZhciBCQUNLQk9ORV9ERUJVR0dFUiA9IGV4cG9ydHMuQkFDS0JPTkVfREVCVUdHRVIgPSB7XG4gIGlkOiAnYmhsamhuZGxpbWlhZm9wbW1oamxnZnBubmNoampiaGQnLFxuICBlbGVjdHJvbjogJz49MS4yLjEnXG59O1xudmFyIEpRVUVSWV9ERUJVR0dFUiA9IGV4cG9ydHMuSlFVRVJZX0RFQlVHR0VSID0ge1xuICBpZDogJ2RiaGhubm5wYWVvYmZkZG1sYWxobmVoZ2NsY21qaW1pJyxcbiAgZWxlY3Ryb246ICc+PTEuMi4xJ1xufTtcbnZhciBBTkdVTEFSSlNfQkFUQVJBTkcgPSBleHBvcnRzLkFOR1VMQVJKU19CQVRBUkFORyA9IHtcbiAgaWQ6ICdpZ2hkbWVoaWRoaXBjbWNvampnaWxvYWNvYWZqbXBmaycsXG4gIGVsZWN0cm9uOiAnPj0xLjIuMSdcbn07XG52YXIgVlVFSlNfREVWVE9PTFMgPSBleHBvcnRzLlZVRUpTX0RFVlRPT0xTID0ge1xuICBpZDogJ25oZG9nam1lamlnbGlwY2Nwbm5uYW5oYmxlZGFqYnBkJyxcbiAgZWxlY3Ryb246ICc+PTEuMi4xJ1xufTtcbnZhciBSRURVWF9ERVZUT09MUyA9IGV4cG9ydHMuUkVEVVhfREVWVE9PTFMgPSB7XG4gIGlkOiAnbG1oa3BtYmVrY3Bta25rbGlvZWliZmtwbW1maWJsamQnLFxuICBlbGVjdHJvbjogJz49MS4yLjEnXG59O1xudmFyIFJFQUNUX1BFUkYgPSBleHBvcnRzLlJFQUNUX1BFUkYgPSB7XG4gIGlkOiAnaGFjbWNvZGZsbGhibmVrbWdoZ2RscGxiZG5haG1obW0nLFxuICBlbGVjdHJvbjogJz49MS4yLjYnXG59O1xudmFyIENZQ0xFSlNfREVWVE9PTCA9IGV4cG9ydHMuQ1lDTEVKU19ERVZUT09MID0ge1xuICBpZDogJ2RmZ3BsZm1oaG1kZWthbGJwZWpla2dmZWdrb25qcGZwJyxcbiAgZWxlY3Ryb246ICc+PTEuMi4xJ1xufTtcbnZhciBBUE9MTE9fREVWRUxPUEVSX1RPT0xTID0gZXhwb3J0cy5BUE9MTE9fREVWRUxPUEVSX1RPT0xTID0ge1xuICBpZDogJ2pka2tua2tiZWJiYXBpbGdvZWNjY2lnbGtmYm1ibmZtJyxcbiAgZWxlY3Ryb246ICc+PTEuMi4xJ1xufTtcbnZhciBNT0JYX0RFVlRPT0xTID0gZXhwb3J0cy5NT0JYX0RFVlRPT0xTID0ge1xuICBpZDogJ3BmZ25mZGFnaWRrZmdjY2xqaWdkYW1pZ2Jjbm5ka29kJyxcbiAgZWxlY3Ryb246ICc+PTEuMi4xJ1xufTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmNoYW5nZVBlcm1pc3Npb25zID0gZXhwb3J0cy5kb3dubG9hZEZpbGUgPSBleHBvcnRzLmdldFBhdGggPSB1bmRlZmluZWQ7XG5cbnZhciBfZWxlY3Ryb24gPSByZXF1aXJlKCdlbGVjdHJvbicpO1xuXG52YXIgX2VsZWN0cm9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2VsZWN0cm9uKTtcblxudmFyIF9mcyA9IHJlcXVpcmUoJ2ZzJyk7XG5cbnZhciBfZnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZnMpO1xuXG52YXIgX3BhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5cbnZhciBfcGF0aDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wYXRoKTtcblxudmFyIF9odHRwcyA9IHJlcXVpcmUoJ2h0dHBzJyk7XG5cbnZhciBfaHR0cHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaHR0cHMpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgZ2V0UGF0aCA9IGV4cG9ydHMuZ2V0UGF0aCA9IGZ1bmN0aW9uIGdldFBhdGgoKSB7XG4gIHZhciBzYXZlUGF0aCA9IChfZWxlY3Ryb24ucmVtb3RlIHx8IF9lbGVjdHJvbjIuZGVmYXVsdCkuYXBwLmdldFBhdGgoJ3VzZXJEYXRhJyk7XG4gIHJldHVybiBfcGF0aDIuZGVmYXVsdC5yZXNvbHZlKHNhdmVQYXRoICsgJy9leHRlbnNpb25zJyk7XG59O1xuXG4vLyBVc2UgaHR0cHMuZ2V0IGZhbGxiYWNrIGZvciBFbGVjdHJvbiA8IDEuNC41XG5cbnZhciBfcmVmID0gX2VsZWN0cm9uLnJlbW90ZSB8fCBfZWxlY3Ryb24yLmRlZmF1bHQsXG4gICAgbmV0ID0gX3JlZi5uZXQ7XG5cbnZhciByZXF1ZXN0ID0gbmV0ID8gbmV0LnJlcXVlc3QgOiBfaHR0cHMyLmRlZmF1bHQuZ2V0O1xuXG52YXIgZG93bmxvYWRGaWxlID0gZXhwb3J0cy5kb3dubG9hZEZpbGUgPSBmdW5jdGlvbiBkb3dubG9hZEZpbGUoZnJvbSwgdG8pIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgcmVxID0gcmVxdWVzdChmcm9tKTtcbiAgICByZXEub24oJ3Jlc3BvbnNlJywgZnVuY3Rpb24gKHJlcykge1xuICAgICAgLy8gU2hvdWxkbid0IGhhbmRsZSByZWRpcmVjdCB3aXRoIGBlbGVjdHJvbi5uZXRgLCB0aGlzIGlzIGZvciBodHRwcy5nZXQgZmFsbGJhY2tcbiAgICAgIGlmIChyZXMuc3RhdHVzQ29kZSA+PSAzMDAgJiYgcmVzLnN0YXR1c0NvZGUgPCA0MDAgJiYgcmVzLmhlYWRlcnMubG9jYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGRvd25sb2FkRmlsZShyZXMuaGVhZGVycy5sb2NhdGlvbiwgdG8pLnRoZW4ocmVzb2x2ZSkuY2F0Y2gocmVqZWN0KTtcbiAgICAgIH1cbiAgICAgIHJlcy5waXBlKF9mczIuZGVmYXVsdC5jcmVhdGVXcml0ZVN0cmVhbSh0bykpLm9uKCdjbG9zZScsIHJlc29sdmUpO1xuICAgIH0pO1xuICAgIHJlcS5vbignZXJyb3InLCByZWplY3QpO1xuICAgIHJlcS5lbmQoKTtcbiAgfSk7XG59O1xuXG52YXIgY2hhbmdlUGVybWlzc2lvbnMgPSBleHBvcnRzLmNoYW5nZVBlcm1pc3Npb25zID0gZnVuY3Rpb24gY2hhbmdlUGVybWlzc2lvbnMoZGlyLCBtb2RlKSB7XG4gIHZhciBmaWxlcyA9IF9mczIuZGVmYXVsdC5yZWFkZGlyU3luYyhkaXIpO1xuICBmaWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWxlKSB7XG4gICAgdmFyIGZpbGVQYXRoID0gX3BhdGgyLmRlZmF1bHQuam9pbihkaXIsIGZpbGUpO1xuICAgIF9mczIuZGVmYXVsdC5jaG1vZFN5bmMoZmlsZVBhdGgsIHBhcnNlSW50KG1vZGUsIDgpKTtcbiAgICBpZiAoX2ZzMi5kZWZhdWx0LnN0YXRTeW5jKGZpbGVQYXRoKS5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICBjaGFuZ2VQZXJtaXNzaW9ucyhmaWxlUGF0aCwgbW9kZSk7XG4gICAgfVxuICB9KTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xuY29uc3QgZWxlY3Ryb24gPSByZXF1aXJlKCdlbGVjdHJvbicpO1xuXG5jb25zdCBhcHAgPSBlbGVjdHJvbi5hcHAgfHwgZWxlY3Ryb24ucmVtb3RlLmFwcDtcblxuY29uc3QgaXNFbnZTZXQgPSAnRUxFQ1RST05fSVNfREVWJyBpbiBwcm9jZXNzLmVudjtcbmNvbnN0IGdldEZyb21FbnYgPSBwYXJzZUludChwcm9jZXNzLmVudi5FTEVDVFJPTl9JU19ERVYsIDEwKSA9PT0gMTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0VudlNldCA/IGdldEZyb21FbnYgOiAhYXBwLmlzUGFja2FnZWQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3JlbmRlcmVyJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbWFpbicpO1xufSIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgRU9MICA9IHJlcXVpcmUoJ29zJykuRU9MO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZm9ybWF0OiBmb3JtYXQsXG4gIGZvcm1hdFRpbWVab25lOiBmb3JtYXRUaW1lWm9uZSxcbiAgcGFkOiBwYWQsXG4gIHN0cmluZ2lmeUFycmF5OiBzdHJpbmdpZnlBcnJheVxufTtcblxuZnVuY3Rpb24gZm9ybWF0KG1zZywgZm9ybWF0dGVyKSB7XG4gIGlmICh0eXBlb2YgZm9ybWF0dGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZvcm1hdHRlcihtc2cpO1xuICB9XG5cbiAgdmFyIGRhdGUgPSBtc2cuZGF0ZTtcblxuICByZXR1cm4gZm9ybWF0dGVyXG4gICAgLnJlcGxhY2UoJ3tsZXZlbH0nLCBtc2cubGV2ZWwpXG4gICAgLnJlcGxhY2UoJ3t0ZXh0fScsIHN0cmluZ2lmeUFycmF5KG1zZy5kYXRhKSlcbiAgICAucmVwbGFjZSgne3l9JywgZGF0ZS5nZXRGdWxsWWVhcigpKVxuICAgIC5yZXBsYWNlKCd7bX0nLCBwYWQoZGF0ZS5nZXRNb250aCgpICsgMSkpXG4gICAgLnJlcGxhY2UoJ3tkfScsIHBhZChkYXRlLmdldERhdGUoKSkpXG4gICAgLnJlcGxhY2UoJ3tofScsIHBhZChkYXRlLmdldEhvdXJzKCkpKVxuICAgIC5yZXBsYWNlKCd7aX0nLCBwYWQoZGF0ZS5nZXRNaW51dGVzKCkpKVxuICAgIC5yZXBsYWNlKCd7c30nLCBwYWQoZGF0ZS5nZXRTZWNvbmRzKCkpKVxuICAgIC5yZXBsYWNlKCd7bXN9JywgcGFkKGRhdGUuZ2V0TWlsbGlzZWNvbmRzKCksIDMpKVxuICAgIC5yZXBsYWNlKCd7en0nLCBmb3JtYXRUaW1lWm9uZShkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCkpKTtcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5QXJyYXkoZGF0YSkge1xuICBkYXRhID0gZGF0YS5tYXAoZnVuY3Rpb24gZm9ybWF0RXJyb3JzKGFyZykge1xuICAgIHJldHVybiBhcmcgaW5zdGFuY2VvZiBFcnJvciA/IGFyZy5zdGFjayArIEVPTCA6IGFyZztcbiAgfSk7XG4gIHJldHVybiB1dGlsLmZvcm1hdC5hcHBseSh1dGlsLCBkYXRhKTtcbn1cblxuZnVuY3Rpb24gcGFkKG51bWJlciwgemVyb3MpIHtcbiAgemVyb3MgPSB6ZXJvcyB8fCAyO1xuICByZXR1cm4gKG5ldyBBcnJheSh6ZXJvcyArIDEpLmpvaW4oJzAnKSArIG51bWJlcikuc3Vic3RyKC16ZXJvcywgemVyb3MpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRUaW1lWm9uZShtaW51dGVzT2Zmc2V0KSB7XG4gIHZhciBtID0gTWF0aC5hYnMobWludXRlc09mZnNldCk7XG4gIHJldHVybiAobWludXRlc09mZnNldCA+PSAwID8gJy0nIDogJysnKSArXG4gICAgcGFkKE1hdGguZmxvb3IobSAvIDYwKSkgKyAnOicgK1xuICAgIHBhZChtICUgNjApO1xufVxuIiwiLy8ganNoaW50IC1XMDQwXG4ndXNlIHN0cmljdCc7XG5cbnZhciBMRVZFTFMgPSBbJ2Vycm9yJywgJ3dhcm4nLCAnaW5mbycsICd2ZXJib3NlJywgJ2RlYnVnJywgJ3NpbGx5J107XG5cbm1vZHVsZS5leHBvcnRzID0gbG9nO1xuXG5mdW5jdGlvbiBsb2codHJhbnNwb3J0cywgbGV2ZWwsIHRleHQpIHtcbiAgdmFyIGRhdGEgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuXG4gIHZhciBtc2cgPSB7XG4gICAgZGF0YTogZGF0YSxcbiAgICBkYXRlOiBuZXcgRGF0ZSgpLFxuICAgIGxldmVsOiBsZXZlbFxuICB9O1xuXG4gIGZvciAodmFyIGkgaW4gdHJhbnNwb3J0cykge1xuICAgIC8vIGpzaGludCAtVzA4OVxuICAgIGlmICghdHJhbnNwb3J0cy5oYXNPd25Qcm9wZXJ0eShpKSB8fCB0eXBlb2YgdHJhbnNwb3J0c1tpXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIHRyYW5zcG9ydCA9IHRyYW5zcG9ydHNbaV07XG5cbiAgICBpZiAodHJhbnNwb3J0ID09PSBmYWxzZSB8fCAhY29tcGFyZUxldmVscyh0cmFuc3BvcnQubGV2ZWwsIGxldmVsKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHRyYW5zcG9ydC5sZXZlbCA9PT0gZmFsc2UpIGNvbnRpbnVlO1xuXG4gICAgdHJhbnNwb3J0LmNhbGwobnVsbCwgbXNnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21wYXJlTGV2ZWxzKHBhc3NMZXZlbCwgY2hlY2tMZXZlbCkge1xuICB2YXIgcGFzcyA9IExFVkVMUy5pbmRleE9mKHBhc3NMZXZlbCk7XG4gIHZhciBjaGVjayA9IExFVkVMUy5pbmRleE9mKGNoZWNrTGV2ZWwpO1xuICBpZiAoY2hlY2sgPT09IC0xIHx8IHBhc3MgPT09IC0xKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGNoZWNrIDw9IHBhc3M7XG59IiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFNhdmUgY29uc29sZSBtZXRob2RzIGZvciB1c2luZyB3aGVuIG9yaWdpbmFscyBhcmUgb3ZlcnJpZGRlblxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY29udGV4dDogY29uc29sZSxcbiAgZXJyb3I6ICAgY29uc29sZS5lcnJvcixcbiAgd2FybjogICAgY29uc29sZS53YXJuLFxuICBpbmZvOiAgICBjb25zb2xlLmluZm8sXG4gIHZlcmJvc2U6IGNvbnNvbGUudmVyYm9zZSxcbiAgZGVidWc6ICAgY29uc29sZS5kZWJ1ZyxcbiAgc2lsbHk6ICAgY29uc29sZS5zaWxseSxcbiAgbG9nOiAgICAgY29uc29sZS5sb2dcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBmb3JtYXQgICAgICAgICAgPSByZXF1aXJlKCcuLi9mb3JtYXQnKTtcbnZhciBvcmlnaW5hbENvbnNvbGUgPSByZXF1aXJlKCcuLi9vcmlnaW5hbC1jb25zb2xlJyk7XG5cbnRyYW5zcG9ydC5sZXZlbCAgPSAnc2lsbHknO1xudHJhbnNwb3J0LmZvcm1hdCA9ICdbe2h9OntpfTp7c30ue21zfV0gW3tsZXZlbH1dIHt0ZXh0fSc7XG5cbm1vZHVsZS5leHBvcnRzID0gdHJhbnNwb3J0O1xuXG5mdW5jdGlvbiB0cmFuc3BvcnQobXNnKSB7XG4gIHZhciB0ZXh0ID0gZm9ybWF0LmZvcm1hdChtc2csIHRyYW5zcG9ydC5mb3JtYXQpO1xuICBpZiAob3JpZ2luYWxDb25zb2xlW21zZy5sZXZlbF0pIHtcbiAgICBvcmlnaW5hbENvbnNvbGVbbXNnLmxldmVsXSh0ZXh0KTtcbiAgfSBlbHNlIHtcbiAgICBvcmlnaW5hbENvbnNvbGUubG9nKHRleHQpO1xuICB9XG59XG5cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGZzICAgPSByZXF1aXJlKCdmcycpO1xudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG52YXIgb3MgICA9IHJlcXVpcmUoJ29zJyk7XG52YXIgZ2V0QXBwTmFtZSA9IHJlcXVpcmUoJy4vZ2V0LWFwcC1uYW1lJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZmluZExvZ1BhdGg7XG5cbi8qKlxuICogVHJ5IHRvIGRldGVybWluZSBhIHBsYXRmb3JtLXNwZWNpZmljIHBhdGggd2hlcmUgY2FuIHdyaXRlIGxvZ3NcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXBwTmFtZV0gVXNlZCB0byBkZXRlcm1pbmUgdGhlIGxhc3QgcGFydCBvZiBhIGxvZyBwYXRoXG4gKiBAcmV0dXJuIHtzdHJpbmd8Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gZmluZExvZ1BhdGgoYXBwTmFtZSkge1xuICBhcHBOYW1lID0gYXBwTmFtZSB8fCBnZXRBcHBOYW1lKCk7XG4gIGlmICghYXBwTmFtZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBob21lRGlyID0gb3MuaG9tZWRpciA/IG9zLmhvbWVkaXIoKSA6IHByb2Nlc3MuZW52WydIT01FJ107XG4gIFxuICB2YXIgZGlyO1xuICBzd2l0Y2ggKHByb2Nlc3MucGxhdGZvcm0pIHtcbiAgICBjYXNlICdsaW51eCc6IHtcbiAgICAgIGRpciA9IHByZXBhcmVEaXIocHJvY2Vzcy5lbnZbJ1hER19DT05GSUdfSE9NRSddLCBhcHBOYW1lKVxuICAgICAgICAub3IoaG9tZURpciwgJy5jb25maWcnLCBhcHBOYW1lKVxuICAgICAgICAub3IocHJvY2Vzcy5lbnZbJ1hER19EQVRBX0hPTUUnXSwgYXBwTmFtZSlcbiAgICAgICAgLm9yKGhvbWVEaXIsICcubG9jYWwnLCAnc2hhcmUnLCBhcHBOYW1lKVxuICAgICAgICAucmVzdWx0O1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY2FzZSAnZGFyd2luJzoge1xuICAgICAgZGlyID0gcHJlcGFyZURpcihob21lRGlyLCAnTGlicmFyeScsICdMb2dzJywgYXBwTmFtZSlcbiAgICAgICAgLm9yKGhvbWVEaXIsICdMaWJyYXJ5JywgJ0FwcGxpY2F0aW9uIFN1cHBvcnQnLCBhcHBOYW1lKVxuICAgICAgICAucmVzdWx0O1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY2FzZSAnd2luMzInOiB7XG4gICAgICBkaXIgPSBwcmVwYXJlRGlyKHByb2Nlc3MuZW52WydBUFBEQVRBJ10sIGFwcE5hbWUpXG4gICAgICAgIC5vcihob21lRGlyLCAnQXBwRGF0YScsICdSb2FtaW5nJywgYXBwTmFtZSlcbiAgICAgICAgLnJlc3VsdDtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChkaXIpIHtcbiAgICByZXR1cm4gcGF0aC5qb2luKGRpciwgJ2xvZy5sb2cnKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuXG5cbmZ1bmN0aW9uIHByZXBhcmVEaXIoZGlyUGF0aCkge1xuICAvLyBqc2hpbnQgLVcwNDBcbiAgaWYgKCF0aGlzIHx8IHRoaXMub3IgIT09IHByZXBhcmVEaXIgfHwgIXRoaXMucmVzdWx0KSB7XG4gICAgaWYgKCFkaXJQYXRoKSB7XG4gICAgICByZXR1cm4geyBvcjogcHJlcGFyZURpciB9O1xuICAgIH1cblxuICAgIC8vbm9pbnNwZWN0aW9uIEpTQ2hlY2tGdW5jdGlvblNpZ25hdHVyZXNcbiAgICBkaXJQYXRoID0gcGF0aC5qb2luLmFwcGx5KHBhdGgsIGFyZ3VtZW50cyk7XG4gICAgbWtEaXIoZGlyUGF0aCk7XG5cbiAgICB0cnkge1xuICAgICAgZnMuYWNjZXNzU3luYyhkaXJQYXRoLCBmcy5XX09LKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4geyBvcjogcHJlcGFyZURpciB9O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgb3I6IHByZXBhcmVEaXIsXG4gICAgcmVzdWx0OiAodGhpcyA/IHRoaXMucmVzdWx0IDogZmFsc2UpIHx8IGRpclBhdGhcbiAgfTtcbn1cblxuZnVuY3Rpb24gbWtEaXIoZGlyUGF0aCwgcm9vdCkge1xuICB2YXIgZGlycyA9IGRpclBhdGguc3BsaXQocGF0aC5zZXApO1xuICB2YXIgZGlyID0gZGlycy5zaGlmdCgpO1xuICByb290ID0gKHJvb3QgfHwgJycpICsgZGlyICsgcGF0aC5zZXA7XG5cbiAgdHJ5IHtcbiAgICBmcy5ta2RpclN5bmMocm9vdCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoIWZzLnN0YXRTeW5jKHJvb3QpLmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gIWRpcnMubGVuZ3RoIHx8IG1rRGlyKGRpcnMuam9pbihwYXRoLnNlcCksIHJvb3QpO1xufVxuIiwiLy8ganNoaW50IC1XMDc0XG4ndXNlIHN0cmljdCc7XG5cbi8qKiBAbmFtZSBwcm9jZXNzLnJlc291cmNlc1BhdGggKi9cblxudmFyIGZzICAgPSByZXF1aXJlKCdmcycpO1xudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG52YXIgY29uc29sZVRyYW5zcG9ydCA9IHJlcXVpcmUoJy4uL2NvbnNvbGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRBcHBOYW1lO1xuXG5mdW5jdGlvbiBnZXRBcHBOYW1lKCkge1xuICB0cnkge1xuICAgIHZhciBuYW1lID0gbG9hZFBhY2thZ2VOYW1lKCk7XG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHJldHVybiBuYW1lO1xuICAgIH1cbiAgICByZXR1cm4gd2FybignZWxlY3Ryb24tbG9nOiB1bmFibGUgdG8gbG9hZCB0aGUgYXBwIG5hbWUgZnJvbSBwYWNrYWdlLmpzb24nKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB3YXJuKCdlbGVjdHJvbi1sb2c6ICcgKyBlLm1lc3NhZ2UpO1xuICB9XG59XG5cbi8qKlxuICogVHJ5IHRvIGxvYWQgbWFpbiBhcHAgcGFja2FnZVxuICogQHRocm93cyB7RXJyb3J9XG4gKiBAcmV0dXJuIHtPYmplY3R8bnVsbH1cbiAqL1xuZnVuY3Rpb24gbG9hZFBhY2thZ2VOYW1lKCkge1xuICB2YXIgcGFja2FnZUZpbGU7XG5cbiAgdHJ5IHtcbiAgICBpZiAocmVxdWlyZS5tYWluLmZpbGVuYW1lKSB7XG4gICAgICBwYWNrYWdlRmlsZSA9IGZpbmQocGF0aC5kaXJuYW1lKHJlcXVpcmUubWFpbi5maWxlbmFtZSkpO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge31cblxuICBpZiAoIXBhY2thZ2VGaWxlICYmIHByb2Nlc3MucmVzb3VyY2VzUGF0aCkge1xuICAgIHBhY2thZ2VGaWxlID0gZmluZChwYXRoLmpvaW4ocHJvY2Vzcy5yZXNvdXJjZXNQYXRoLCAnYXBwLmFzYXInKSk7XG4gICAgdmFyIGVsZWN0cm9uTW9kdWxlID0gcGF0aC5qb2luKCdub2RlX21vZHVsZXMnLCAnZWxlY3Ryb24nLCAncGFja2FnZS5qc29uJyk7XG4gICAgaWYgKHBhY2thZ2VGaWxlICYmIHBhY2thZ2VGaWxlLmluZGV4T2YoZWxlY3Ryb25Nb2R1bGUpICE9PSAtMSkge1xuICAgICAgcGFja2FnZUZpbGUgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGlmICghcGFja2FnZUZpbGUpIHtcbiAgICBwYWNrYWdlRmlsZSA9IGZpbmQocHJvY2Vzcy5jd2QoKSk7XG4gIH1cblxuICBpZiAoIXBhY2thZ2VGaWxlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgY29udGVudCA9IGZzLnJlYWRGaWxlU3luYyhwYWNrYWdlRmlsZSwgJ3V0Zi04Jyk7XG4gIHZhciBwYWNrYWdlRGF0YSA9IEpTT04ucGFyc2UoY29udGVudCk7XG5cbiAgLy9ub2luc3BlY3Rpb24gSlNVbnJlc29sdmVkVmFyaWFibGVcbiAgcmV0dXJuIHBhY2thZ2VEYXRhID8gcGFja2FnZURhdGEucHJvZHVjdE5hbWUgfHwgcGFja2FnZURhdGEubmFtZSA6IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBmaW5kKHJvb3QpIHtcbiAgdmFyIGZpbGU7XG5cbiAgd2hpbGUgKCFmaWxlKSB7XG4gICAgdmFyIHBhcmVudDtcbiAgICBmaWxlID0gcGF0aC5qb2luKHJvb3QsICdwYWNrYWdlLmpzb24nKTtcblxuICAgIHRyeSB7XG4gICAgICBmcy5zdGF0U3luYyhmaWxlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBwYXJlbnQgPSBwYXRoLnJlc29sdmUocm9vdCwgJy4uJyk7XG4gICAgICBmaWxlID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAocm9vdCA9PT0gcGFyZW50KSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICByb290ID0gcGFyZW50O1xuICB9XG5cbiAgcmV0dXJuIGZpbGU7XG59XG5cbmZ1bmN0aW9uIHdhcm4obWVzc2FnZSkge1xuICBjb25zb2xlVHJhbnNwb3J0KHtcbiAgICBkYXRhOiBbbWVzc2FnZV0sXG4gICAgZGF0ZTogbmV3IERhdGUoKSxcbiAgICBsZXZlbDogJ3dhcm4nXG4gIH0pO1xufSIsIid1c2Ugc3RyaWN0JztcblxudmFyIGZzICAgICAgICAgICAgICAgPSByZXF1aXJlKCdmcycpO1xudmFyIEVPTCAgICAgICAgICAgICAgPSByZXF1aXJlKCdvcycpLkVPTDtcbnZhciBmb3JtYXQgICAgICAgICAgID0gcmVxdWlyZSgnLi4vLi4vZm9ybWF0Jyk7XG52YXIgY29uc29sZVRyYW5zcG9ydCA9IHJlcXVpcmUoJy4uL2NvbnNvbGUnKTtcbnZhciBmaW5kTG9nUGF0aCAgICAgID0gcmVxdWlyZSgnLi9maW5kLWxvZy1wYXRoJyk7XG5cbnRyYW5zcG9ydC5maW5kTG9nUGF0aCAgPSBmaW5kTG9nUGF0aDtcbnRyYW5zcG9ydC5mb3JtYXQgICAgICAgPSAnW3t5fS17bX0te2R9IHtofTp7aX06e3N9Lnttc31dIFt7bGV2ZWx9XSB7dGV4dH0nO1xudHJhbnNwb3J0LmxldmVsICAgICAgICA9ICd3YXJuJztcbnRyYW5zcG9ydC5tYXhTaXplICAgICAgPSAxMDI0ICogMTAyNDtcbnRyYW5zcG9ydC5zdHJlYW1Db25maWcgPSB1bmRlZmluZWQ7XG5cbm1vZHVsZS5leHBvcnRzID0gdHJhbnNwb3J0O1xuXG5mdW5jdGlvbiB0cmFuc3BvcnQobXNnKSB7XG4gIHZhciB0ZXh0ID0gZm9ybWF0LmZvcm1hdChtc2csIHRyYW5zcG9ydC5mb3JtYXQpICsgRU9MO1xuXG4gIGlmICh0cmFuc3BvcnQuc3RyZWFtID09PSB1bmRlZmluZWQpIHtcbiAgICBpbml0U3RlYW1Db25maWcoKTtcbiAgICBvcGVuU3RyZWFtKCk7XG4gIH1cblxuICBpZiAodHJhbnNwb3J0LmxldmVsID09PSBmYWxzZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBuZWVkTG9nUm90YXRpb24gPSB0cmFuc3BvcnQubWF4U2l6ZSA+IDAgJiZcbiAgICBnZXRTdHJlYW1TaXplKHRyYW5zcG9ydC5zdHJlYW0pID4gdHJhbnNwb3J0Lm1heFNpemU7XG5cbiAgaWYgKG5lZWRMb2dSb3RhdGlvbikge1xuICAgIGFyY2hpdmVMb2codHJhbnNwb3J0LnN0cmVhbSk7XG4gICAgb3BlblN0cmVhbSgpO1xuICB9XG5cbiAgdHJhbnNwb3J0LnN0cmVhbS53cml0ZSh0ZXh0KTtcbn1cblxuZnVuY3Rpb24gaW5pdFN0ZWFtQ29uZmlnKCkge1xuICB0cmFuc3BvcnQuZmlsZSA9IHRyYW5zcG9ydC5maWxlIHx8IGZpbmRMb2dQYXRoKHRyYW5zcG9ydC5hcHBOYW1lKTtcblxuICBpZiAoIXRyYW5zcG9ydC5maWxlKSB7XG4gICAgdHJhbnNwb3J0LmxldmVsID0gZmFsc2U7XG4gICAgbG9nQ29uc29sZSgnQ291bGQgbm90IHNldCBhIGxvZyBmaWxlJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gb3BlblN0cmVhbSgpIHtcbiAgaWYgKHRyYW5zcG9ydC5sZXZlbCA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0cmFuc3BvcnQuc3RyZWFtID0gZnMuY3JlYXRlV3JpdGVTdHJlYW0oXG4gICAgdHJhbnNwb3J0LmZpbGUsXG4gICAgdHJhbnNwb3J0LnN0cmVhbUNvbmZpZyB8fCB7IGZsYWdzOiAnYScgfVxuICApO1xufVxuXG5mdW5jdGlvbiBnZXRTdHJlYW1TaXplKHN0cmVhbSkge1xuICBpZiAoIXN0cmVhbSkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgaWYgKHN0cmVhbS5sb2dTaXplQXRTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdHJ5IHtcbiAgICAgIHN0cmVhbS5sb2dTaXplQXRTdGFydCA9IGZzLnN0YXRTeW5jKHN0cmVhbS5wYXRoKS5zaXplO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHN0cmVhbS5sb2dTaXplQXRTdGFydCA9IDA7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN0cmVhbS5sb2dTaXplQXRTdGFydCArIHN0cmVhbS5ieXRlc1dyaXR0ZW47XG59XG5cbmZ1bmN0aW9uIGFyY2hpdmVMb2coc3RyZWFtKSB7XG4gIGlmIChzdHJlYW0uZW5kKSB7XG4gICAgc3RyZWFtLmVuZCgpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBmcy5yZW5hbWVTeW5jKHN0cmVhbS5wYXRoLCBzdHJlYW0ucGF0aC5yZXBsYWNlKC9sb2ckLywgJ29sZC5sb2cnKSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBsb2dDb25zb2xlKCdDb3VsZCBub3Qgcm90YXRlIGxvZycsIGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGxvZ0NvbnNvbGUobWVzc2FnZSwgZXJyb3IpIHtcbiAgdmFyIGRhdGEgPSBbJ2VsZWN0cm9uLWxvZy50cmFuc3BvcnRzLmZpbGU6ICcgKyBtZXNzYWdlXTtcblxuICBpZiAoZXJyb3IpIHtcbiAgICBkYXRhLnB1c2goZXJyb3IpO1xuICB9XG5cbiAgY29uc29sZVRyYW5zcG9ydCh7IGRhdGE6IGRhdGEsIGRhdGU6IG5ldyBEYXRlKCksIGxldmVsOiAnd2FybicgfSk7XG59XG4iLCIvLyBqc2hpbnQgLVcwNzQsIC1XMDg5XG4ndXNlIHN0cmljdCc7XG5cbnZhciBodHRwICA9IHJlcXVpcmUoJ2h0dHAnKTtcbnZhciBodHRwcyA9IHJlcXVpcmUoJ2h0dHBzJyk7XG52YXIgdXJsICAgPSByZXF1aXJlKCd1cmwnKTtcblxudHJhbnNwb3J0LmNsaWVudCA9IHsgbmFtZTogJ2VsZWN0cm9uLWFwcGxpY2F0aW9uJyB9O1xudHJhbnNwb3J0LmRlcHRoICA9IDY7XG50cmFuc3BvcnQubGV2ZWwgID0gZmFsc2U7XG50cmFuc3BvcnQudXJsICAgID0gbnVsbDtcblxubW9kdWxlLmV4cG9ydHMgPSB0cmFuc3BvcnQ7XG5cbmZ1bmN0aW9uIHRyYW5zcG9ydChtc2cpIHtcbiAgaWYgKCF0cmFuc3BvcnQudXJsKSByZXR1cm47XG5cbiAgdmFyIGRhdGEgPSBqc29uRGVwdGgoe1xuICAgIGNsaWVudDogdHJhbnNwb3J0LmNsaWVudCxcbiAgICBkYXRhOiBtc2cuZGF0YSxcbiAgICBkYXRlOiBtc2cuZGF0ZS5nZXRUaW1lKCksXG4gICAgbGV2ZWw6IG1zZy5sZXZlbFxuICB9LCB0cmFuc3BvcnQuZGVwdGggKyAxKTtcblxuICBwb3N0KHRyYW5zcG9ydC51cmwsIGRhdGEpO1xufVxuXG5mdW5jdGlvbiBwb3N0KHNlcnZlclVybCwgZGF0YSkge1xuICB2YXIgdXJsT2JqZWN0ID0gdXJsLnBhcnNlKHNlcnZlclVybCk7XG4gIHZhciB0cmFuc3BvcnQgPSB1cmxPYmplY3QucHJvdG9jb2wgPT09ICdodHRwczonID8gaHR0cHMgOiBodHRwO1xuXG4gIHZhciBib2R5ID0gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG5cbiAgdmFyIG9wdGlvbnMgPSB7XG4gICAgaG9zdG5hbWU6IHVybE9iamVjdC5ob3N0bmFtZSxcbiAgICBwb3J0OiAgICAgdXJsT2JqZWN0LnBvcnQsXG4gICAgcGF0aDogICAgIHVybE9iamVjdC5wYXRoLFxuICAgIG1ldGhvZDogICAnUE9TVCcsXG4gICAgaGVhZGVyczogIHtcbiAgICAgICdDb250ZW50LVR5cGUnOiAgJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgJ0NvbnRlbnQtTGVuZ3RoJzogYm9keS5sZW5ndGhcbiAgICB9XG4gIH07XG5cbiAgdmFyIHJlcXVlc3QgPSB0cmFuc3BvcnQucmVxdWVzdChvcHRpb25zKTtcbiAgcmVxdWVzdC53cml0ZShib2R5KTtcbiAgcmVxdWVzdC5lbmQoKTtcbn1cblxuZnVuY3Rpb24ganNvbkRlcHRoKGpzb24sIGRlcHRoKSB7XG4gIGlmIChkZXB0aCA8IDEpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShqc29uKSkgIHJldHVybiAnW2FycmF5XSc7XG4gICAgaWYgKHR5cGVvZiBqc29uID09PSAnb2JqZWN0JykgIHJldHVybiAnW29iamVjdF0nO1xuICAgIHJldHVybiBqc29uO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoanNvbikpIHtcbiAgICByZXR1cm4ganNvbi5tYXAoZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgIHJldHVybiBqc29uRGVwdGgoY2hpbGQsIGRlcHRoIC0gMSk7XG4gICAgfSk7XG4gIH1cblxuICBpZiAoanNvbiAmJiB0eXBlb2YganNvbi5nZXRNb250aCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBqc29uO1xuICB9XG5cbiAgaWYgKGpzb24gPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmICh0eXBlb2YganNvbiA9PT0gJ29iamVjdCcpIHtcbiAgICBpZiAodHlwZW9mIGpzb24udG9KU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBqc29uID0ganNvbi50b0pTT04oKTtcbiAgICB9XG5cbiAgICB2YXIgbmV3SnNvbiA9IHt9O1xuICAgIGZvciAodmFyIGkgaW4ganNvbikge1xuICAgICAgLy9ub2luc3BlY3Rpb24gSlNVbmZpbHRlcmVkRm9ySW5Mb29wXG4gICAgICBuZXdKc29uW2ldID0ganNvbkRlcHRoKGpzb25baV0sIGRlcHRoIC0gMSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld0pzb247XG4gIH1cblxuICByZXR1cm4ganNvbjtcbn0iLCIndXNlIHN0cmljdCc7XG5cbnZhciBCcm93c2VyV2luZG93O1xudHJ5IHtcbiAgQnJvd3NlcldpbmRvdyA9IHJlcXVpcmUoJ2VsZWN0cm9uJykuQnJvd3NlcldpbmRvdztcbn0gY2F0Y2ggKGUpIHtcbiAgQnJvd3NlcldpbmRvdyA9IG51bGw7XG59XG5cbnZhciBmb3JtYXQgPSByZXF1aXJlKCcuLi9mb3JtYXQnKTtcblxudHJhbnNwb3J0LmxldmVsICA9IEJyb3dzZXJXaW5kb3cgPyAnc2lsbHknIDogZmFsc2U7XG50cmFuc3BvcnQuZm9ybWF0ID0gJ1t7aH06e2l9OntzfS57bXN9XSB7dGV4dH0nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHRyYW5zcG9ydDtcblxuZnVuY3Rpb24gdHJhbnNwb3J0KG1zZykge1xuICBpZiAoIUJyb3dzZXJXaW5kb3cpIHJldHVybjtcblxuICB2YXIgdGV4dCA9IGZvcm1hdC5mb3JtYXQobXNnLCB0cmFuc3BvcnQuZm9ybWF0KTtcbiAgQnJvd3NlcldpbmRvdy5nZXRBbGxXaW5kb3dzKCkuZm9yRWFjaChmdW5jdGlvbih3bmQpIHtcbiAgICB3bmQud2ViQ29udGVudHMuc2VuZCgnX19FTEVDVFJPTl9MT0dfUkVOREVSRVJfXycsIG1zZy5sZXZlbCwgdGV4dCk7XG4gIH0pO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZWxlY3Ryb247XG50cnkge1xuICBlbGVjdHJvbiA9IHJlcXVpcmUoJ2VsZWN0cm9uJyk7XG59IGNhdGNoIChlKSB7XG4gIGVsZWN0cm9uID0gbnVsbDtcbn1cblxudmFyIGxvZyAgICAgICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vbGliL2xvZycpO1xudmFyIHRyYW5zcG9ydENvbnNvbGUgICAgICAgICA9IHJlcXVpcmUoJy4vbGliL3RyYW5zcG9ydHMvY29uc29sZScpO1xudmFyIHRyYW5zcG9ydEZpbGUgICAgICAgICAgICA9IHJlcXVpcmUoJy4vbGliL3RyYW5zcG9ydHMvZmlsZScpO1xudmFyIHRyYW5zcG9ydExvZ1MgICAgICAgICAgICA9IHJlcXVpcmUoJy4vbGliL3RyYW5zcG9ydHMvbG9nLXMnKTtcbnZhciB0cmFuc3BvcnRSZW5kZXJlckNvbnNvbGUgPSByZXF1aXJlKCcuL2xpYi90cmFuc3BvcnRzL3JlbmRlcmVyLWNvbnNvbGUnKTtcblxudmFyIHRyYW5zcG9ydHMgPSB7XG4gIGNvbnNvbGU6IHRyYW5zcG9ydENvbnNvbGUsXG4gIGZpbGU6IHRyYW5zcG9ydEZpbGUsXG4gIGxvZ1M6IHRyYW5zcG9ydExvZ1MsXG4gIHJlbmRlcmVyQ29uc29sZTogdHJhbnNwb3J0UmVuZGVyZXJDb25zb2xlXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgdHJhbnNwb3J0czogdHJhbnNwb3J0cyxcblxuICBlcnJvcjogICBsb2cuYmluZChudWxsLCB0cmFuc3BvcnRzLCAnZXJyb3InKSxcbiAgd2FybjogICAgbG9nLmJpbmQobnVsbCwgdHJhbnNwb3J0cywgJ3dhcm4nKSxcbiAgaW5mbzogICAgbG9nLmJpbmQobnVsbCwgdHJhbnNwb3J0cywgJ2luZm8nKSxcbiAgdmVyYm9zZTogbG9nLmJpbmQobnVsbCwgdHJhbnNwb3J0cywgJ3ZlcmJvc2UnKSxcbiAgZGVidWc6ICAgbG9nLmJpbmQobnVsbCwgdHJhbnNwb3J0cywgJ2RlYnVnJyksXG4gIHNpbGx5OiAgIGxvZy5iaW5kKG51bGwsIHRyYW5zcG9ydHMsICdzaWxseScpLFxuICBsb2c6ICAgICBsb2cuYmluZChudWxsLCB0cmFuc3BvcnRzLCAnaW5mbycpXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gbW9kdWxlLmV4cG9ydHM7XG5cbmlmIChlbGVjdHJvbiAmJiBlbGVjdHJvbi5pcGNNYWluKSB7XG4gIGVsZWN0cm9uLmlwY01haW4ub24oJ19fRUxFQ1RST05fTE9HX18nLCBvblJlbmRlcmVyTG9nKTtcbiAgdmFyIGFwcE5hbWUgPSBlbGVjdHJvbi5hcHAuZ2V0TmFtZSgpO1xuICBpZiAoYXBwTmFtZSAhPT0gJ0VsZWN0cm9uJykge1xuICAgIHRyYW5zcG9ydEZpbGUuYXBwTmFtZSA9IGFwcE5hbWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gb25SZW5kZXJlckxvZyhldmVudCwgZGF0YSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgIGRhdGEudW5zaGlmdCh0cmFuc3BvcnRzKTtcbiAgICBsb2cuYXBwbHkobnVsbCwgZGF0YSk7XG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBudWxsO1xuXG52YXIgaXBjUmVuZGVyZXI7XG50cnkge1xuICBpcGNSZW5kZXJlciA9IHJlcXVpcmUoJ2VsZWN0cm9uJykuaXBjUmVuZGVyZXI7XG59IGNhdGNoIChlKSB7XG4gIGlwY1JlbmRlcmVyID0gbnVsbDtcbn1cblxudmFyIG9yaWdpbmFsQ29uc29sZSA9IHJlcXVpcmUoJy4vbGliL29yaWdpbmFsLWNvbnNvbGUnKTtcblxuaWYgKGlwY1JlbmRlcmVyKSB7XG4gIG1vZHVsZS5leHBvcnRzID0ge1xuICAgIGVycm9yOiAgIGxvZy5iaW5kKG51bGwsICdlcnJvcicpLFxuICAgIHdhcm46ICAgIGxvZy5iaW5kKG51bGwsICd3YXJuJyksXG4gICAgaW5mbzogICAgbG9nLmJpbmQobnVsbCwgJ2luZm8nKSxcbiAgICB2ZXJib3NlOiBsb2cuYmluZChudWxsLCAndmVyYm9zZScpLFxuICAgIGRlYnVnOiAgIGxvZy5iaW5kKG51bGwsICdkZWJ1ZycpLFxuICAgIHNpbGx5OiAgIGxvZy5iaW5kKG51bGwsICdzaWxseScpLFxuICAgIGxvZzogICAgIGxvZy5iaW5kKG51bGwsICdpbmZvJylcbiAgfTtcblxuICBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gbW9kdWxlLmV4cG9ydHM7XG5cbiAgaXBjUmVuZGVyZXIub24oJ19fRUxFQ1RST05fTE9HX1JFTkRFUkVSX18nLCBmdW5jdGlvbihldmVudCwgbGV2ZWwsIGRhdGEpIHtcbiAgICBpZiAobGV2ZWwgPT09ICd2ZXJib3NlJykge1xuICAgICAgbGV2ZWwgPSAnbG9nJztcbiAgICB9IGVsc2UgaWYgKGxldmVsID09PSAnc2lsbHknKSB7XG4gICAgICBsZXZlbCA9ICdkZWJ1Zyc7XG4gICAgfVxuXG4gICAgb3JpZ2luYWxDb25zb2xlW2xldmVsXS5hcHBseShcbiAgICAgIG9yaWdpbmFsQ29uc29sZS5jb250ZXh0LFxuICAgICAgdHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnID8gW2RhdGFdIDogZGF0YVxuICAgICk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBsb2coKSB7XG4gIHZhciBkYXRhID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblxuICBkYXRhID0gZGF0YS5tYXAoZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICBvYmogPSBvYmouc3RhY2sgfHwgb2JqO1xuICAgIH1cblxuICAgIHJldHVybiBvYmo7XG4gIH0pO1xuXG4gIGlwY1JlbmRlcmVyLnNlbmQoJ19fRUxFQ1RST05fTE9HX18nLCBkYXRhKTtcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gcmVhbHBhdGhcbnJlYWxwYXRoLnJlYWxwYXRoID0gcmVhbHBhdGhcbnJlYWxwYXRoLnN5bmMgPSByZWFscGF0aFN5bmNcbnJlYWxwYXRoLnJlYWxwYXRoU3luYyA9IHJlYWxwYXRoU3luY1xucmVhbHBhdGgubW9ua2V5cGF0Y2ggPSBtb25rZXlwYXRjaFxucmVhbHBhdGgudW5tb25rZXlwYXRjaCA9IHVubW9ua2V5cGF0Y2hcblxudmFyIGZzID0gcmVxdWlyZSgnZnMnKVxudmFyIG9yaWdSZWFscGF0aCA9IGZzLnJlYWxwYXRoXG52YXIgb3JpZ1JlYWxwYXRoU3luYyA9IGZzLnJlYWxwYXRoU3luY1xuXG52YXIgdmVyc2lvbiA9IHByb2Nlc3MudmVyc2lvblxudmFyIG9rID0gL152WzAtNV1cXC4vLnRlc3QodmVyc2lvbilcbnZhciBvbGQgPSByZXF1aXJlKCcuL29sZC5qcycpXG5cbmZ1bmN0aW9uIG5ld0Vycm9yIChlcikge1xuICByZXR1cm4gZXIgJiYgZXIuc3lzY2FsbCA9PT0gJ3JlYWxwYXRoJyAmJiAoXG4gICAgZXIuY29kZSA9PT0gJ0VMT09QJyB8fFxuICAgIGVyLmNvZGUgPT09ICdFTk9NRU0nIHx8XG4gICAgZXIuY29kZSA9PT0gJ0VOQU1FVE9PTE9ORydcbiAgKVxufVxuXG5mdW5jdGlvbiByZWFscGF0aCAocCwgY2FjaGUsIGNiKSB7XG4gIGlmIChvaykge1xuICAgIHJldHVybiBvcmlnUmVhbHBhdGgocCwgY2FjaGUsIGNiKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBjYWNoZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gY2FjaGVcbiAgICBjYWNoZSA9IG51bGxcbiAgfVxuICBvcmlnUmVhbHBhdGgocCwgY2FjaGUsIGZ1bmN0aW9uIChlciwgcmVzdWx0KSB7XG4gICAgaWYgKG5ld0Vycm9yKGVyKSkge1xuICAgICAgb2xkLnJlYWxwYXRoKHAsIGNhY2hlLCBjYilcbiAgICB9IGVsc2Uge1xuICAgICAgY2IoZXIsIHJlc3VsdClcbiAgICB9XG4gIH0pXG59XG5cbmZ1bmN0aW9uIHJlYWxwYXRoU3luYyAocCwgY2FjaGUpIHtcbiAgaWYgKG9rKSB7XG4gICAgcmV0dXJuIG9yaWdSZWFscGF0aFN5bmMocCwgY2FjaGUpXG4gIH1cblxuICB0cnkge1xuICAgIHJldHVybiBvcmlnUmVhbHBhdGhTeW5jKHAsIGNhY2hlKVxuICB9IGNhdGNoIChlcikge1xuICAgIGlmIChuZXdFcnJvcihlcikpIHtcbiAgICAgIHJldHVybiBvbGQucmVhbHBhdGhTeW5jKHAsIGNhY2hlKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBlclxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtb25rZXlwYXRjaCAoKSB7XG4gIGZzLnJlYWxwYXRoID0gcmVhbHBhdGhcbiAgZnMucmVhbHBhdGhTeW5jID0gcmVhbHBhdGhTeW5jXG59XG5cbmZ1bmN0aW9uIHVubW9ua2V5cGF0Y2ggKCkge1xuICBmcy5yZWFscGF0aCA9IG9yaWdSZWFscGF0aFxuICBmcy5yZWFscGF0aFN5bmMgPSBvcmlnUmVhbHBhdGhTeW5jXG59XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIHBhdGhNb2R1bGUgPSByZXF1aXJlKCdwYXRoJyk7XG52YXIgaXNXaW5kb3dzID0gcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJztcbnZhciBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG5cbi8vIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgcmVhbHBhdGgsIHBvcnRlZCBmcm9tIG5vZGUgcHJlLXY2XG5cbnZhciBERUJVRyA9IHByb2Nlc3MuZW52Lk5PREVfREVCVUcgJiYgL2ZzLy50ZXN0KHByb2Nlc3MuZW52Lk5PREVfREVCVUcpO1xuXG5mdW5jdGlvbiByZXRocm93KCkge1xuICAvLyBPbmx5IGVuYWJsZSBpbiBkZWJ1ZyBtb2RlLiBBIGJhY2t0cmFjZSB1c2VzIH4xMDAwIGJ5dGVzIG9mIGhlYXAgc3BhY2UgYW5kXG4gIC8vIGlzIGZhaXJseSBzbG93IHRvIGdlbmVyYXRlLlxuICB2YXIgY2FsbGJhY2s7XG4gIGlmIChERUJVRykge1xuICAgIHZhciBiYWNrdHJhY2UgPSBuZXcgRXJyb3I7XG4gICAgY2FsbGJhY2sgPSBkZWJ1Z0NhbGxiYWNrO1xuICB9IGVsc2VcbiAgICBjYWxsYmFjayA9IG1pc3NpbmdDYWxsYmFjaztcblxuICByZXR1cm4gY2FsbGJhY2s7XG5cbiAgZnVuY3Rpb24gZGVidWdDYWxsYmFjayhlcnIpIHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBiYWNrdHJhY2UubWVzc2FnZSA9IGVyci5tZXNzYWdlO1xuICAgICAgZXJyID0gYmFja3RyYWNlO1xuICAgICAgbWlzc2luZ0NhbGxiYWNrKGVycik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWlzc2luZ0NhbGxiYWNrKGVycikge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIGlmIChwcm9jZXNzLnRocm93RGVwcmVjYXRpb24pXG4gICAgICAgIHRocm93IGVycjsgIC8vIEZvcmdvdCBhIGNhbGxiYWNrIGJ1dCBkb24ndCBrbm93IHdoZXJlPyBVc2UgTk9ERV9ERUJVRz1mc1xuICAgICAgZWxzZSBpZiAoIXByb2Nlc3Mubm9EZXByZWNhdGlvbikge1xuICAgICAgICB2YXIgbXNnID0gJ2ZzOiBtaXNzaW5nIGNhbGxiYWNrICcgKyAoZXJyLnN0YWNrIHx8IGVyci5tZXNzYWdlKTtcbiAgICAgICAgaWYgKHByb2Nlc3MudHJhY2VEZXByZWNhdGlvbilcbiAgICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBjb25zb2xlLmVycm9yKG1zZyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1heWJlQ2FsbGJhY2soY2IpIHtcbiAgcmV0dXJuIHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJyA/IGNiIDogcmV0aHJvdygpO1xufVxuXG52YXIgbm9ybWFsaXplID0gcGF0aE1vZHVsZS5ub3JtYWxpemU7XG5cbi8vIFJlZ2V4cCB0aGF0IGZpbmRzIHRoZSBuZXh0IHBhcnRpb24gb2YgYSAocGFydGlhbCkgcGF0aFxuLy8gcmVzdWx0IGlzIFtiYXNlX3dpdGhfc2xhc2gsIGJhc2VdLCBlLmcuIFsnc29tZWRpci8nLCAnc29tZWRpciddXG5pZiAoaXNXaW5kb3dzKSB7XG4gIHZhciBuZXh0UGFydFJlID0gLyguKj8pKD86W1xcL1xcXFxdK3wkKS9nO1xufSBlbHNlIHtcbiAgdmFyIG5leHRQYXJ0UmUgPSAvKC4qPykoPzpbXFwvXSt8JCkvZztcbn1cblxuLy8gUmVnZXggdG8gZmluZCB0aGUgZGV2aWNlIHJvb3QsIGluY2x1ZGluZyB0cmFpbGluZyBzbGFzaC4gRS5nLiAnYzpcXFxcJy5cbmlmIChpc1dpbmRvd3MpIHtcbiAgdmFyIHNwbGl0Um9vdFJlID0gL14oPzpbYS16QS1aXTp8W1xcXFxcXC9dezJ9W15cXFxcXFwvXStbXFxcXFxcL11bXlxcXFxcXC9dKyk/W1xcXFxcXC9dKi87XG59IGVsc2Uge1xuICB2YXIgc3BsaXRSb290UmUgPSAvXltcXC9dKi87XG59XG5cbmV4cG9ydHMucmVhbHBhdGhTeW5jID0gZnVuY3Rpb24gcmVhbHBhdGhTeW5jKHAsIGNhY2hlKSB7XG4gIC8vIG1ha2UgcCBpcyBhYnNvbHV0ZVxuICBwID0gcGF0aE1vZHVsZS5yZXNvbHZlKHApO1xuXG4gIGlmIChjYWNoZSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY2FjaGUsIHApKSB7XG4gICAgcmV0dXJuIGNhY2hlW3BdO1xuICB9XG5cbiAgdmFyIG9yaWdpbmFsID0gcCxcbiAgICAgIHNlZW5MaW5rcyA9IHt9LFxuICAgICAga25vd25IYXJkID0ge307XG5cbiAgLy8gY3VycmVudCBjaGFyYWN0ZXIgcG9zaXRpb24gaW4gcFxuICB2YXIgcG9zO1xuICAvLyB0aGUgcGFydGlhbCBwYXRoIHNvIGZhciwgaW5jbHVkaW5nIGEgdHJhaWxpbmcgc2xhc2ggaWYgYW55XG4gIHZhciBjdXJyZW50O1xuICAvLyB0aGUgcGFydGlhbCBwYXRoIHdpdGhvdXQgYSB0cmFpbGluZyBzbGFzaCAoZXhjZXB0IHdoZW4gcG9pbnRpbmcgYXQgYSByb290KVxuICB2YXIgYmFzZTtcbiAgLy8gdGhlIHBhcnRpYWwgcGF0aCBzY2FubmVkIGluIHRoZSBwcmV2aW91cyByb3VuZCwgd2l0aCBzbGFzaFxuICB2YXIgcHJldmlvdXM7XG5cbiAgc3RhcnQoKTtcblxuICBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICAvLyBTa2lwIG92ZXIgcm9vdHNcbiAgICB2YXIgbSA9IHNwbGl0Um9vdFJlLmV4ZWMocCk7XG4gICAgcG9zID0gbVswXS5sZW5ndGg7XG4gICAgY3VycmVudCA9IG1bMF07XG4gICAgYmFzZSA9IG1bMF07XG4gICAgcHJldmlvdXMgPSAnJztcblxuICAgIC8vIE9uIHdpbmRvd3MsIGNoZWNrIHRoYXQgdGhlIHJvb3QgZXhpc3RzLiBPbiB1bml4IHRoZXJlIGlzIG5vIG5lZWQuXG4gICAgaWYgKGlzV2luZG93cyAmJiAha25vd25IYXJkW2Jhc2VdKSB7XG4gICAgICBmcy5sc3RhdFN5bmMoYmFzZSk7XG4gICAgICBrbm93bkhhcmRbYmFzZV0gPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8vIHdhbGsgZG93biB0aGUgcGF0aCwgc3dhcHBpbmcgb3V0IGxpbmtlZCBwYXRocGFydHMgZm9yIHRoZWlyIHJlYWxcbiAgLy8gdmFsdWVzXG4gIC8vIE5COiBwLmxlbmd0aCBjaGFuZ2VzLlxuICB3aGlsZSAocG9zIDwgcC5sZW5ndGgpIHtcbiAgICAvLyBmaW5kIHRoZSBuZXh0IHBhcnRcbiAgICBuZXh0UGFydFJlLmxhc3RJbmRleCA9IHBvcztcbiAgICB2YXIgcmVzdWx0ID0gbmV4dFBhcnRSZS5leGVjKHApO1xuICAgIHByZXZpb3VzID0gY3VycmVudDtcbiAgICBjdXJyZW50ICs9IHJlc3VsdFswXTtcbiAgICBiYXNlID0gcHJldmlvdXMgKyByZXN1bHRbMV07XG4gICAgcG9zID0gbmV4dFBhcnRSZS5sYXN0SW5kZXg7XG5cbiAgICAvLyBjb250aW51ZSBpZiBub3QgYSBzeW1saW5rXG4gICAgaWYgKGtub3duSGFyZFtiYXNlXSB8fCAoY2FjaGUgJiYgY2FjaGVbYmFzZV0gPT09IGJhc2UpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgcmVzb2x2ZWRMaW5rO1xuICAgIGlmIChjYWNoZSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY2FjaGUsIGJhc2UpKSB7XG4gICAgICAvLyBzb21lIGtub3duIHN5bWJvbGljIGxpbmsuICBubyBuZWVkIHRvIHN0YXQgYWdhaW4uXG4gICAgICByZXNvbHZlZExpbmsgPSBjYWNoZVtiYXNlXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHN0YXQgPSBmcy5sc3RhdFN5bmMoYmFzZSk7XG4gICAgICBpZiAoIXN0YXQuaXNTeW1ib2xpY0xpbmsoKSkge1xuICAgICAgICBrbm93bkhhcmRbYmFzZV0gPSB0cnVlO1xuICAgICAgICBpZiAoY2FjaGUpIGNhY2hlW2Jhc2VdID0gYmFzZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIHJlYWQgdGhlIGxpbmsgaWYgaXQgd2Fzbid0IHJlYWQgYmVmb3JlXG4gICAgICAvLyBkZXYvaW5vIGFsd2F5cyByZXR1cm4gMCBvbiB3aW5kb3dzLCBzbyBza2lwIHRoZSBjaGVjay5cbiAgICAgIHZhciBsaW5rVGFyZ2V0ID0gbnVsbDtcbiAgICAgIGlmICghaXNXaW5kb3dzKSB7XG4gICAgICAgIHZhciBpZCA9IHN0YXQuZGV2LnRvU3RyaW5nKDMyKSArICc6JyArIHN0YXQuaW5vLnRvU3RyaW5nKDMyKTtcbiAgICAgICAgaWYgKHNlZW5MaW5rcy5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgICBsaW5rVGFyZ2V0ID0gc2VlbkxpbmtzW2lkXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGxpbmtUYXJnZXQgPT09IG51bGwpIHtcbiAgICAgICAgZnMuc3RhdFN5bmMoYmFzZSk7XG4gICAgICAgIGxpbmtUYXJnZXQgPSBmcy5yZWFkbGlua1N5bmMoYmFzZSk7XG4gICAgICB9XG4gICAgICByZXNvbHZlZExpbmsgPSBwYXRoTW9kdWxlLnJlc29sdmUocHJldmlvdXMsIGxpbmtUYXJnZXQpO1xuICAgICAgLy8gdHJhY2sgdGhpcywgaWYgZ2l2ZW4gYSBjYWNoZS5cbiAgICAgIGlmIChjYWNoZSkgY2FjaGVbYmFzZV0gPSByZXNvbHZlZExpbms7XG4gICAgICBpZiAoIWlzV2luZG93cykgc2VlbkxpbmtzW2lkXSA9IGxpbmtUYXJnZXQ7XG4gICAgfVxuXG4gICAgLy8gcmVzb2x2ZSB0aGUgbGluaywgdGhlbiBzdGFydCBvdmVyXG4gICAgcCA9IHBhdGhNb2R1bGUucmVzb2x2ZShyZXNvbHZlZExpbmssIHAuc2xpY2UocG9zKSk7XG4gICAgc3RhcnQoKTtcbiAgfVxuXG4gIGlmIChjYWNoZSkgY2FjaGVbb3JpZ2luYWxdID0gcDtcblxuICByZXR1cm4gcDtcbn07XG5cblxuZXhwb3J0cy5yZWFscGF0aCA9IGZ1bmN0aW9uIHJlYWxwYXRoKHAsIGNhY2hlLCBjYikge1xuICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBtYXliZUNhbGxiYWNrKGNhY2hlKTtcbiAgICBjYWNoZSA9IG51bGw7XG4gIH1cblxuICAvLyBtYWtlIHAgaXMgYWJzb2x1dGVcbiAgcCA9IHBhdGhNb2R1bGUucmVzb2x2ZShwKTtcblxuICBpZiAoY2FjaGUgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNhY2hlLCBwKSkge1xuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGNiLmJpbmQobnVsbCwgbnVsbCwgY2FjaGVbcF0pKTtcbiAgfVxuXG4gIHZhciBvcmlnaW5hbCA9IHAsXG4gICAgICBzZWVuTGlua3MgPSB7fSxcbiAgICAgIGtub3duSGFyZCA9IHt9O1xuXG4gIC8vIGN1cnJlbnQgY2hhcmFjdGVyIHBvc2l0aW9uIGluIHBcbiAgdmFyIHBvcztcbiAgLy8gdGhlIHBhcnRpYWwgcGF0aCBzbyBmYXIsIGluY2x1ZGluZyBhIHRyYWlsaW5nIHNsYXNoIGlmIGFueVxuICB2YXIgY3VycmVudDtcbiAgLy8gdGhlIHBhcnRpYWwgcGF0aCB3aXRob3V0IGEgdHJhaWxpbmcgc2xhc2ggKGV4Y2VwdCB3aGVuIHBvaW50aW5nIGF0IGEgcm9vdClcbiAgdmFyIGJhc2U7XG4gIC8vIHRoZSBwYXJ0aWFsIHBhdGggc2Nhbm5lZCBpbiB0aGUgcHJldmlvdXMgcm91bmQsIHdpdGggc2xhc2hcbiAgdmFyIHByZXZpb3VzO1xuXG4gIHN0YXJ0KCk7XG5cbiAgZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgLy8gU2tpcCBvdmVyIHJvb3RzXG4gICAgdmFyIG0gPSBzcGxpdFJvb3RSZS5leGVjKHApO1xuICAgIHBvcyA9IG1bMF0ubGVuZ3RoO1xuICAgIGN1cnJlbnQgPSBtWzBdO1xuICAgIGJhc2UgPSBtWzBdO1xuICAgIHByZXZpb3VzID0gJyc7XG5cbiAgICAvLyBPbiB3aW5kb3dzLCBjaGVjayB0aGF0IHRoZSByb290IGV4aXN0cy4gT24gdW5peCB0aGVyZSBpcyBubyBuZWVkLlxuICAgIGlmIChpc1dpbmRvd3MgJiYgIWtub3duSGFyZFtiYXNlXSkge1xuICAgICAgZnMubHN0YXQoYmFzZSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpO1xuICAgICAgICBrbm93bkhhcmRbYmFzZV0gPSB0cnVlO1xuICAgICAgICBMT09QKCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhMT09QKTtcbiAgICB9XG4gIH1cblxuICAvLyB3YWxrIGRvd24gdGhlIHBhdGgsIHN3YXBwaW5nIG91dCBsaW5rZWQgcGF0aHBhcnRzIGZvciB0aGVpciByZWFsXG4gIC8vIHZhbHVlc1xuICBmdW5jdGlvbiBMT09QKCkge1xuICAgIC8vIHN0b3AgaWYgc2Nhbm5lZCBwYXN0IGVuZCBvZiBwYXRoXG4gICAgaWYgKHBvcyA+PSBwLmxlbmd0aCkge1xuICAgICAgaWYgKGNhY2hlKSBjYWNoZVtvcmlnaW5hbF0gPSBwO1xuICAgICAgcmV0dXJuIGNiKG51bGwsIHApO1xuICAgIH1cblxuICAgIC8vIGZpbmQgdGhlIG5leHQgcGFydFxuICAgIG5leHRQYXJ0UmUubGFzdEluZGV4ID0gcG9zO1xuICAgIHZhciByZXN1bHQgPSBuZXh0UGFydFJlLmV4ZWMocCk7XG4gICAgcHJldmlvdXMgPSBjdXJyZW50O1xuICAgIGN1cnJlbnQgKz0gcmVzdWx0WzBdO1xuICAgIGJhc2UgPSBwcmV2aW91cyArIHJlc3VsdFsxXTtcbiAgICBwb3MgPSBuZXh0UGFydFJlLmxhc3RJbmRleDtcblxuICAgIC8vIGNvbnRpbnVlIGlmIG5vdCBhIHN5bWxpbmtcbiAgICBpZiAoa25vd25IYXJkW2Jhc2VdIHx8IChjYWNoZSAmJiBjYWNoZVtiYXNlXSA9PT0gYmFzZSkpIHtcbiAgICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKExPT1ApO1xuICAgIH1cblxuICAgIGlmIChjYWNoZSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY2FjaGUsIGJhc2UpKSB7XG4gICAgICAvLyBrbm93biBzeW1ib2xpYyBsaW5rLiAgbm8gbmVlZCB0byBzdGF0IGFnYWluLlxuICAgICAgcmV0dXJuIGdvdFJlc29sdmVkTGluayhjYWNoZVtiYXNlXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZzLmxzdGF0KGJhc2UsIGdvdFN0YXQpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ290U3RhdChlcnIsIHN0YXQpIHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKTtcblxuICAgIC8vIGlmIG5vdCBhIHN5bWxpbmssIHNraXAgdG8gdGhlIG5leHQgcGF0aCBwYXJ0XG4gICAgaWYgKCFzdGF0LmlzU3ltYm9saWNMaW5rKCkpIHtcbiAgICAgIGtub3duSGFyZFtiYXNlXSA9IHRydWU7XG4gICAgICBpZiAoY2FjaGUpIGNhY2hlW2Jhc2VdID0gYmFzZTtcbiAgICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKExPT1ApO1xuICAgIH1cblxuICAgIC8vIHN0YXQgJiByZWFkIHRoZSBsaW5rIGlmIG5vdCByZWFkIGJlZm9yZVxuICAgIC8vIGNhbGwgZ290VGFyZ2V0IGFzIHNvb24gYXMgdGhlIGxpbmsgdGFyZ2V0IGlzIGtub3duXG4gICAgLy8gZGV2L2lubyBhbHdheXMgcmV0dXJuIDAgb24gd2luZG93cywgc28gc2tpcCB0aGUgY2hlY2suXG4gICAgaWYgKCFpc1dpbmRvd3MpIHtcbiAgICAgIHZhciBpZCA9IHN0YXQuZGV2LnRvU3RyaW5nKDMyKSArICc6JyArIHN0YXQuaW5vLnRvU3RyaW5nKDMyKTtcbiAgICAgIGlmIChzZWVuTGlua3MuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAgIHJldHVybiBnb3RUYXJnZXQobnVsbCwgc2VlbkxpbmtzW2lkXSwgYmFzZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZzLnN0YXQoYmFzZSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKTtcblxuICAgICAgZnMucmVhZGxpbmsoYmFzZSwgZnVuY3Rpb24oZXJyLCB0YXJnZXQpIHtcbiAgICAgICAgaWYgKCFpc1dpbmRvd3MpIHNlZW5MaW5rc1tpZF0gPSB0YXJnZXQ7XG4gICAgICAgIGdvdFRhcmdldChlcnIsIHRhcmdldCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdvdFRhcmdldChlcnIsIHRhcmdldCwgYmFzZSkge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpO1xuXG4gICAgdmFyIHJlc29sdmVkTGluayA9IHBhdGhNb2R1bGUucmVzb2x2ZShwcmV2aW91cywgdGFyZ2V0KTtcbiAgICBpZiAoY2FjaGUpIGNhY2hlW2Jhc2VdID0gcmVzb2x2ZWRMaW5rO1xuICAgIGdvdFJlc29sdmVkTGluayhyZXNvbHZlZExpbmspO1xuICB9XG5cbiAgZnVuY3Rpb24gZ290UmVzb2x2ZWRMaW5rKHJlc29sdmVkTGluaykge1xuICAgIC8vIHJlc29sdmUgdGhlIGxpbmssIHRoZW4gc3RhcnQgb3ZlclxuICAgIHAgPSBwYXRoTW9kdWxlLnJlc29sdmUocmVzb2x2ZWRMaW5rLCBwLnNsaWNlKHBvcykpO1xuICAgIHN0YXJ0KCk7XG4gIH1cbn07XG4iLCJleHBvcnRzLmFscGhhc29ydCA9IGFscGhhc29ydFxuZXhwb3J0cy5hbHBoYXNvcnRpID0gYWxwaGFzb3J0aVxuZXhwb3J0cy5zZXRvcHRzID0gc2V0b3B0c1xuZXhwb3J0cy5vd25Qcm9wID0gb3duUHJvcFxuZXhwb3J0cy5tYWtlQWJzID0gbWFrZUFic1xuZXhwb3J0cy5maW5pc2ggPSBmaW5pc2hcbmV4cG9ydHMubWFyayA9IG1hcmtcbmV4cG9ydHMuaXNJZ25vcmVkID0gaXNJZ25vcmVkXG5leHBvcnRzLmNoaWxkcmVuSWdub3JlZCA9IGNoaWxkcmVuSWdub3JlZFxuXG5mdW5jdGlvbiBvd25Qcm9wIChvYmosIGZpZWxkKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBmaWVsZClcbn1cblxudmFyIHBhdGggPSByZXF1aXJlKFwicGF0aFwiKVxudmFyIG1pbmltYXRjaCA9IHJlcXVpcmUoXCJtaW5pbWF0Y2hcIilcbnZhciBpc0Fic29sdXRlID0gcmVxdWlyZShcInBhdGgtaXMtYWJzb2x1dGVcIilcbnZhciBNaW5pbWF0Y2ggPSBtaW5pbWF0Y2guTWluaW1hdGNoXG5cbmZ1bmN0aW9uIGFscGhhc29ydGkgKGEsIGIpIHtcbiAgcmV0dXJuIGEudG9Mb3dlckNhc2UoKS5sb2NhbGVDb21wYXJlKGIudG9Mb3dlckNhc2UoKSlcbn1cblxuZnVuY3Rpb24gYWxwaGFzb3J0IChhLCBiKSB7XG4gIHJldHVybiBhLmxvY2FsZUNvbXBhcmUoYilcbn1cblxuZnVuY3Rpb24gc2V0dXBJZ25vcmVzIChzZWxmLCBvcHRpb25zKSB7XG4gIHNlbGYuaWdub3JlID0gb3B0aW9ucy5pZ25vcmUgfHwgW11cblxuICBpZiAoIUFycmF5LmlzQXJyYXkoc2VsZi5pZ25vcmUpKVxuICAgIHNlbGYuaWdub3JlID0gW3NlbGYuaWdub3JlXVxuXG4gIGlmIChzZWxmLmlnbm9yZS5sZW5ndGgpIHtcbiAgICBzZWxmLmlnbm9yZSA9IHNlbGYuaWdub3JlLm1hcChpZ25vcmVNYXApXG4gIH1cbn1cblxuLy8gaWdub3JlIHBhdHRlcm5zIGFyZSBhbHdheXMgaW4gZG90OnRydWUgbW9kZS5cbmZ1bmN0aW9uIGlnbm9yZU1hcCAocGF0dGVybikge1xuICB2YXIgZ21hdGNoZXIgPSBudWxsXG4gIGlmIChwYXR0ZXJuLnNsaWNlKC0zKSA9PT0gJy8qKicpIHtcbiAgICB2YXIgZ3BhdHRlcm4gPSBwYXR0ZXJuLnJlcGxhY2UoLyhcXC9cXCpcXCopKyQvLCAnJylcbiAgICBnbWF0Y2hlciA9IG5ldyBNaW5pbWF0Y2goZ3BhdHRlcm4sIHsgZG90OiB0cnVlIH0pXG4gIH1cblxuICByZXR1cm4ge1xuICAgIG1hdGNoZXI6IG5ldyBNaW5pbWF0Y2gocGF0dGVybiwgeyBkb3Q6IHRydWUgfSksXG4gICAgZ21hdGNoZXI6IGdtYXRjaGVyXG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0b3B0cyAoc2VsZiwgcGF0dGVybiwgb3B0aW9ucykge1xuICBpZiAoIW9wdGlvbnMpXG4gICAgb3B0aW9ucyA9IHt9XG5cbiAgLy8gYmFzZS1tYXRjaGluZzoganVzdCB1c2UgZ2xvYnN0YXIgZm9yIHRoYXQuXG4gIGlmIChvcHRpb25zLm1hdGNoQmFzZSAmJiAtMSA9PT0gcGF0dGVybi5pbmRleE9mKFwiL1wiKSkge1xuICAgIGlmIChvcHRpb25zLm5vZ2xvYnN0YXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImJhc2UgbWF0Y2hpbmcgcmVxdWlyZXMgZ2xvYnN0YXJcIilcbiAgICB9XG4gICAgcGF0dGVybiA9IFwiKiovXCIgKyBwYXR0ZXJuXG4gIH1cblxuICBzZWxmLnNpbGVudCA9ICEhb3B0aW9ucy5zaWxlbnRcbiAgc2VsZi5wYXR0ZXJuID0gcGF0dGVyblxuICBzZWxmLnN0cmljdCA9IG9wdGlvbnMuc3RyaWN0ICE9PSBmYWxzZVxuICBzZWxmLnJlYWxwYXRoID0gISFvcHRpb25zLnJlYWxwYXRoXG4gIHNlbGYucmVhbHBhdGhDYWNoZSA9IG9wdGlvbnMucmVhbHBhdGhDYWNoZSB8fCBPYmplY3QuY3JlYXRlKG51bGwpXG4gIHNlbGYuZm9sbG93ID0gISFvcHRpb25zLmZvbGxvd1xuICBzZWxmLmRvdCA9ICEhb3B0aW9ucy5kb3RcbiAgc2VsZi5tYXJrID0gISFvcHRpb25zLm1hcmtcbiAgc2VsZi5ub2RpciA9ICEhb3B0aW9ucy5ub2RpclxuICBpZiAoc2VsZi5ub2RpcilcbiAgICBzZWxmLm1hcmsgPSB0cnVlXG4gIHNlbGYuc3luYyA9ICEhb3B0aW9ucy5zeW5jXG4gIHNlbGYubm91bmlxdWUgPSAhIW9wdGlvbnMubm91bmlxdWVcbiAgc2VsZi5ub251bGwgPSAhIW9wdGlvbnMubm9udWxsXG4gIHNlbGYubm9zb3J0ID0gISFvcHRpb25zLm5vc29ydFxuICBzZWxmLm5vY2FzZSA9ICEhb3B0aW9ucy5ub2Nhc2VcbiAgc2VsZi5zdGF0ID0gISFvcHRpb25zLnN0YXRcbiAgc2VsZi5ub3Byb2Nlc3MgPSAhIW9wdGlvbnMubm9wcm9jZXNzXG4gIHNlbGYuYWJzb2x1dGUgPSAhIW9wdGlvbnMuYWJzb2x1dGVcblxuICBzZWxmLm1heExlbmd0aCA9IG9wdGlvbnMubWF4TGVuZ3RoIHx8IEluZmluaXR5XG4gIHNlbGYuY2FjaGUgPSBvcHRpb25zLmNhY2hlIHx8IE9iamVjdC5jcmVhdGUobnVsbClcbiAgc2VsZi5zdGF0Q2FjaGUgPSBvcHRpb25zLnN0YXRDYWNoZSB8fCBPYmplY3QuY3JlYXRlKG51bGwpXG4gIHNlbGYuc3ltbGlua3MgPSBvcHRpb25zLnN5bWxpbmtzIHx8IE9iamVjdC5jcmVhdGUobnVsbClcblxuICBzZXR1cElnbm9yZXMoc2VsZiwgb3B0aW9ucylcblxuICBzZWxmLmNoYW5nZWRDd2QgPSBmYWxzZVxuICB2YXIgY3dkID0gcHJvY2Vzcy5jd2QoKVxuICBpZiAoIW93blByb3Aob3B0aW9ucywgXCJjd2RcIikpXG4gICAgc2VsZi5jd2QgPSBjd2RcbiAgZWxzZSB7XG4gICAgc2VsZi5jd2QgPSBwYXRoLnJlc29sdmUob3B0aW9ucy5jd2QpXG4gICAgc2VsZi5jaGFuZ2VkQ3dkID0gc2VsZi5jd2QgIT09IGN3ZFxuICB9XG5cbiAgc2VsZi5yb290ID0gb3B0aW9ucy5yb290IHx8IHBhdGgucmVzb2x2ZShzZWxmLmN3ZCwgXCIvXCIpXG4gIHNlbGYucm9vdCA9IHBhdGgucmVzb2x2ZShzZWxmLnJvb3QpXG4gIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSBcIndpbjMyXCIpXG4gICAgc2VsZi5yb290ID0gc2VsZi5yb290LnJlcGxhY2UoL1xcXFwvZywgXCIvXCIpXG5cbiAgLy8gVE9ETzogaXMgYW4gYWJzb2x1dGUgYGN3ZGAgc3VwcG9zZWQgdG8gYmUgcmVzb2x2ZWQgYWdhaW5zdCBgcm9vdGA/XG4gIC8vIGUuZy4geyBjd2Q6ICcvdGVzdCcsIHJvb3Q6IF9fZGlybmFtZSB9ID09PSBwYXRoLmpvaW4oX19kaXJuYW1lLCAnL3Rlc3QnKVxuICBzZWxmLmN3ZEFicyA9IGlzQWJzb2x1dGUoc2VsZi5jd2QpID8gc2VsZi5jd2QgOiBtYWtlQWJzKHNlbGYsIHNlbGYuY3dkKVxuICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gXCJ3aW4zMlwiKVxuICAgIHNlbGYuY3dkQWJzID0gc2VsZi5jd2RBYnMucmVwbGFjZSgvXFxcXC9nLCBcIi9cIilcbiAgc2VsZi5ub21vdW50ID0gISFvcHRpb25zLm5vbW91bnRcblxuICAvLyBkaXNhYmxlIGNvbW1lbnRzIGFuZCBuZWdhdGlvbiBpbiBNaW5pbWF0Y2guXG4gIC8vIE5vdGUgdGhhdCB0aGV5IGFyZSBub3Qgc3VwcG9ydGVkIGluIEdsb2IgaXRzZWxmIGFueXdheS5cbiAgb3B0aW9ucy5ub25lZ2F0ZSA9IHRydWVcbiAgb3B0aW9ucy5ub2NvbW1lbnQgPSB0cnVlXG5cbiAgc2VsZi5taW5pbWF0Y2ggPSBuZXcgTWluaW1hdGNoKHBhdHRlcm4sIG9wdGlvbnMpXG4gIHNlbGYub3B0aW9ucyA9IHNlbGYubWluaW1hdGNoLm9wdGlvbnNcbn1cblxuZnVuY3Rpb24gZmluaXNoIChzZWxmKSB7XG4gIHZhciBub3UgPSBzZWxmLm5vdW5pcXVlXG4gIHZhciBhbGwgPSBub3UgPyBbXSA6IE9iamVjdC5jcmVhdGUobnVsbClcblxuICBmb3IgKHZhciBpID0gMCwgbCA9IHNlbGYubWF0Y2hlcy5sZW5ndGg7IGkgPCBsOyBpICsrKSB7XG4gICAgdmFyIG1hdGNoZXMgPSBzZWxmLm1hdGNoZXNbaV1cbiAgICBpZiAoIW1hdGNoZXMgfHwgT2JqZWN0LmtleXMobWF0Y2hlcykubGVuZ3RoID09PSAwKSB7XG4gICAgICBpZiAoc2VsZi5ub251bGwpIHtcbiAgICAgICAgLy8gZG8gbGlrZSB0aGUgc2hlbGwsIGFuZCBzcGl0IG91dCB0aGUgbGl0ZXJhbCBnbG9iXG4gICAgICAgIHZhciBsaXRlcmFsID0gc2VsZi5taW5pbWF0Y2guZ2xvYlNldFtpXVxuICAgICAgICBpZiAobm91KVxuICAgICAgICAgIGFsbC5wdXNoKGxpdGVyYWwpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBhbGxbbGl0ZXJhbF0gPSB0cnVlXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGhhZCBtYXRjaGVzXG4gICAgICB2YXIgbSA9IE9iamVjdC5rZXlzKG1hdGNoZXMpXG4gICAgICBpZiAobm91KVxuICAgICAgICBhbGwucHVzaC5hcHBseShhbGwsIG0pXG4gICAgICBlbHNlXG4gICAgICAgIG0uZm9yRWFjaChmdW5jdGlvbiAobSkge1xuICAgICAgICAgIGFsbFttXSA9IHRydWVcbiAgICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBpZiAoIW5vdSlcbiAgICBhbGwgPSBPYmplY3Qua2V5cyhhbGwpXG5cbiAgaWYgKCFzZWxmLm5vc29ydClcbiAgICBhbGwgPSBhbGwuc29ydChzZWxmLm5vY2FzZSA/IGFscGhhc29ydGkgOiBhbHBoYXNvcnQpXG5cbiAgLy8gYXQgKnNvbWUqIHBvaW50IHdlIHN0YXR0ZWQgYWxsIG9mIHRoZXNlXG4gIGlmIChzZWxmLm1hcmspIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbC5sZW5ndGg7IGkrKykge1xuICAgICAgYWxsW2ldID0gc2VsZi5fbWFyayhhbGxbaV0pXG4gICAgfVxuICAgIGlmIChzZWxmLm5vZGlyKSB7XG4gICAgICBhbGwgPSBhbGwuZmlsdGVyKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBub3REaXIgPSAhKC9cXC8kLy50ZXN0KGUpKVxuICAgICAgICB2YXIgYyA9IHNlbGYuY2FjaGVbZV0gfHwgc2VsZi5jYWNoZVttYWtlQWJzKHNlbGYsIGUpXVxuICAgICAgICBpZiAobm90RGlyICYmIGMpXG4gICAgICAgICAgbm90RGlyID0gYyAhPT0gJ0RJUicgJiYgIUFycmF5LmlzQXJyYXkoYylcbiAgICAgICAgcmV0dXJuIG5vdERpclxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBpZiAoc2VsZi5pZ25vcmUubGVuZ3RoKVxuICAgIGFsbCA9IGFsbC5maWx0ZXIoZnVuY3Rpb24obSkge1xuICAgICAgcmV0dXJuICFpc0lnbm9yZWQoc2VsZiwgbSlcbiAgICB9KVxuXG4gIHNlbGYuZm91bmQgPSBhbGxcbn1cblxuZnVuY3Rpb24gbWFyayAoc2VsZiwgcCkge1xuICB2YXIgYWJzID0gbWFrZUFicyhzZWxmLCBwKVxuICB2YXIgYyA9IHNlbGYuY2FjaGVbYWJzXVxuICB2YXIgbSA9IHBcbiAgaWYgKGMpIHtcbiAgICB2YXIgaXNEaXIgPSBjID09PSAnRElSJyB8fCBBcnJheS5pc0FycmF5KGMpXG4gICAgdmFyIHNsYXNoID0gcC5zbGljZSgtMSkgPT09ICcvJ1xuXG4gICAgaWYgKGlzRGlyICYmICFzbGFzaClcbiAgICAgIG0gKz0gJy8nXG4gICAgZWxzZSBpZiAoIWlzRGlyICYmIHNsYXNoKVxuICAgICAgbSA9IG0uc2xpY2UoMCwgLTEpXG5cbiAgICBpZiAobSAhPT0gcCkge1xuICAgICAgdmFyIG1hYnMgPSBtYWtlQWJzKHNlbGYsIG0pXG4gICAgICBzZWxmLnN0YXRDYWNoZVttYWJzXSA9IHNlbGYuc3RhdENhY2hlW2Fic11cbiAgICAgIHNlbGYuY2FjaGVbbWFic10gPSBzZWxmLmNhY2hlW2Fic11cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbVxufVxuXG4vLyBsb3R0YSBzaXR1cHMuLi5cbmZ1bmN0aW9uIG1ha2VBYnMgKHNlbGYsIGYpIHtcbiAgdmFyIGFicyA9IGZcbiAgaWYgKGYuY2hhckF0KDApID09PSAnLycpIHtcbiAgICBhYnMgPSBwYXRoLmpvaW4oc2VsZi5yb290LCBmKVxuICB9IGVsc2UgaWYgKGlzQWJzb2x1dGUoZikgfHwgZiA9PT0gJycpIHtcbiAgICBhYnMgPSBmXG4gIH0gZWxzZSBpZiAoc2VsZi5jaGFuZ2VkQ3dkKSB7XG4gICAgYWJzID0gcGF0aC5yZXNvbHZlKHNlbGYuY3dkLCBmKVxuICB9IGVsc2Uge1xuICAgIGFicyA9IHBhdGgucmVzb2x2ZShmKVxuICB9XG5cbiAgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicpXG4gICAgYWJzID0gYWJzLnJlcGxhY2UoL1xcXFwvZywgJy8nKVxuXG4gIHJldHVybiBhYnNcbn1cblxuXG4vLyBSZXR1cm4gdHJ1ZSwgaWYgcGF0dGVybiBlbmRzIHdpdGggZ2xvYnN0YXIgJyoqJywgZm9yIHRoZSBhY2NvbXBhbnlpbmcgcGFyZW50IGRpcmVjdG9yeS5cbi8vIEV4Oi0gSWYgbm9kZV9tb2R1bGVzLyoqIGlzIHRoZSBwYXR0ZXJuLCBhZGQgJ25vZGVfbW9kdWxlcycgdG8gaWdub3JlIGxpc3QgYWxvbmcgd2l0aCBpdCdzIGNvbnRlbnRzXG5mdW5jdGlvbiBpc0lnbm9yZWQgKHNlbGYsIHBhdGgpIHtcbiAgaWYgKCFzZWxmLmlnbm9yZS5sZW5ndGgpXG4gICAgcmV0dXJuIGZhbHNlXG5cbiAgcmV0dXJuIHNlbGYuaWdub3JlLnNvbWUoZnVuY3Rpb24oaXRlbSkge1xuICAgIHJldHVybiBpdGVtLm1hdGNoZXIubWF0Y2gocGF0aCkgfHwgISEoaXRlbS5nbWF0Y2hlciAmJiBpdGVtLmdtYXRjaGVyLm1hdGNoKHBhdGgpKVxuICB9KVxufVxuXG5mdW5jdGlvbiBjaGlsZHJlbklnbm9yZWQgKHNlbGYsIHBhdGgpIHtcbiAgaWYgKCFzZWxmLmlnbm9yZS5sZW5ndGgpXG4gICAgcmV0dXJuIGZhbHNlXG5cbiAgcmV0dXJuIHNlbGYuaWdub3JlLnNvbWUoZnVuY3Rpb24oaXRlbSkge1xuICAgIHJldHVybiAhIShpdGVtLmdtYXRjaGVyICYmIGl0ZW0uZ21hdGNoZXIubWF0Y2gocGF0aCkpXG4gIH0pXG59XG4iLCIvLyBBcHByb2FjaDpcbi8vXG4vLyAxLiBHZXQgdGhlIG1pbmltYXRjaCBzZXRcbi8vIDIuIEZvciBlYWNoIHBhdHRlcm4gaW4gdGhlIHNldCwgUFJPQ0VTUyhwYXR0ZXJuLCBmYWxzZSlcbi8vIDMuIFN0b3JlIG1hdGNoZXMgcGVyLXNldCwgdGhlbiB1bmlxIHRoZW1cbi8vXG4vLyBQUk9DRVNTKHBhdHRlcm4sIGluR2xvYlN0YXIpXG4vLyBHZXQgdGhlIGZpcnN0IFtuXSBpdGVtcyBmcm9tIHBhdHRlcm4gdGhhdCBhcmUgYWxsIHN0cmluZ3Ncbi8vIEpvaW4gdGhlc2UgdG9nZXRoZXIuICBUaGlzIGlzIFBSRUZJWC5cbi8vICAgSWYgdGhlcmUgaXMgbm8gbW9yZSByZW1haW5pbmcsIHRoZW4gc3RhdChQUkVGSVgpIGFuZFxuLy8gICBhZGQgdG8gbWF0Y2hlcyBpZiBpdCBzdWNjZWVkcy4gIEVORC5cbi8vXG4vLyBJZiBpbkdsb2JTdGFyIGFuZCBQUkVGSVggaXMgc3ltbGluayBhbmQgcG9pbnRzIHRvIGRpclxuLy8gICBzZXQgRU5UUklFUyA9IFtdXG4vLyBlbHNlIHJlYWRkaXIoUFJFRklYKSBhcyBFTlRSSUVTXG4vLyAgIElmIGZhaWwsIEVORFxuLy9cbi8vIHdpdGggRU5UUklFU1xuLy8gICBJZiBwYXR0ZXJuW25dIGlzIEdMT0JTVEFSXG4vLyAgICAgLy8gaGFuZGxlIHRoZSBjYXNlIHdoZXJlIHRoZSBnbG9ic3RhciBtYXRjaCBpcyBlbXB0eVxuLy8gICAgIC8vIGJ5IHBydW5pbmcgaXQgb3V0LCBhbmQgdGVzdGluZyB0aGUgcmVzdWx0aW5nIHBhdHRlcm5cbi8vICAgICBQUk9DRVNTKHBhdHRlcm5bMC4ubl0gKyBwYXR0ZXJuW24rMSAuLiAkXSwgZmFsc2UpXG4vLyAgICAgLy8gaGFuZGxlIG90aGVyIGNhc2VzLlxuLy8gICAgIGZvciBFTlRSWSBpbiBFTlRSSUVTIChub3QgZG90ZmlsZXMpXG4vLyAgICAgICAvLyBhdHRhY2ggZ2xvYnN0YXIgKyB0YWlsIG9udG8gdGhlIGVudHJ5XG4vLyAgICAgICAvLyBNYXJrIHRoYXQgdGhpcyBlbnRyeSBpcyBhIGdsb2JzdGFyIG1hdGNoXG4vLyAgICAgICBQUk9DRVNTKHBhdHRlcm5bMC4ubl0gKyBFTlRSWSArIHBhdHRlcm5bbiAuLiAkXSwgdHJ1ZSlcbi8vXG4vLyAgIGVsc2UgLy8gbm90IGdsb2JzdGFyXG4vLyAgICAgZm9yIEVOVFJZIGluIEVOVFJJRVMgKG5vdCBkb3RmaWxlcywgdW5sZXNzIHBhdHRlcm5bbl0gaXMgZG90KVxuLy8gICAgICAgVGVzdCBFTlRSWSBhZ2FpbnN0IHBhdHRlcm5bbl1cbi8vICAgICAgIElmIGZhaWxzLCBjb250aW51ZVxuLy8gICAgICAgSWYgcGFzc2VzLCBQUk9DRVNTKHBhdHRlcm5bMC4ubl0gKyBpdGVtICsgcGF0dGVybltuKzEgLi4gJF0pXG4vL1xuLy8gQ2F2ZWF0OlxuLy8gICBDYWNoZSBhbGwgc3RhdHMgYW5kIHJlYWRkaXJzIHJlc3VsdHMgdG8gbWluaW1pemUgc3lzY2FsbC4gIFNpbmNlIGFsbFxuLy8gICB3ZSBldmVyIGNhcmUgYWJvdXQgaXMgZXhpc3RlbmNlIGFuZCBkaXJlY3RvcnktbmVzcywgd2UgY2FuIGp1c3Qga2VlcFxuLy8gICBgdHJ1ZWAgZm9yIGZpbGVzLCBhbmQgW2NoaWxkcmVuLC4uLl0gZm9yIGRpcmVjdG9yaWVzLCBvciBgZmFsc2VgIGZvclxuLy8gICB0aGluZ3MgdGhhdCBkb24ndCBleGlzdC5cblxubW9kdWxlLmV4cG9ydHMgPSBnbG9iXG5cbnZhciBmcyA9IHJlcXVpcmUoJ2ZzJylcbnZhciBycCA9IHJlcXVpcmUoJ2ZzLnJlYWxwYXRoJylcbnZhciBtaW5pbWF0Y2ggPSByZXF1aXJlKCdtaW5pbWF0Y2gnKVxudmFyIE1pbmltYXRjaCA9IG1pbmltYXRjaC5NaW5pbWF0Y2hcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJylcbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKVxudmFyIGlzQWJzb2x1dGUgPSByZXF1aXJlKCdwYXRoLWlzLWFic29sdXRlJylcbnZhciBnbG9iU3luYyA9IHJlcXVpcmUoJy4vc3luYy5qcycpXG52YXIgY29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24uanMnKVxudmFyIGFscGhhc29ydCA9IGNvbW1vbi5hbHBoYXNvcnRcbnZhciBhbHBoYXNvcnRpID0gY29tbW9uLmFscGhhc29ydGlcbnZhciBzZXRvcHRzID0gY29tbW9uLnNldG9wdHNcbnZhciBvd25Qcm9wID0gY29tbW9uLm93blByb3BcbnZhciBpbmZsaWdodCA9IHJlcXVpcmUoJ2luZmxpZ2h0JylcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpXG52YXIgY2hpbGRyZW5JZ25vcmVkID0gY29tbW9uLmNoaWxkcmVuSWdub3JlZFxudmFyIGlzSWdub3JlZCA9IGNvbW1vbi5pc0lnbm9yZWRcblxudmFyIG9uY2UgPSByZXF1aXJlKCdvbmNlJylcblxuZnVuY3Rpb24gZ2xvYiAocGF0dGVybiwgb3B0aW9ucywgY2IpIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSBjYiA9IG9wdGlvbnMsIG9wdGlvbnMgPSB7fVxuICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fVxuXG4gIGlmIChvcHRpb25zLnN5bmMpIHtcbiAgICBpZiAoY2IpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjYWxsYmFjayBwcm92aWRlZCB0byBzeW5jIGdsb2InKVxuICAgIHJldHVybiBnbG9iU3luYyhwYXR0ZXJuLCBvcHRpb25zKVxuICB9XG5cbiAgcmV0dXJuIG5ldyBHbG9iKHBhdHRlcm4sIG9wdGlvbnMsIGNiKVxufVxuXG5nbG9iLnN5bmMgPSBnbG9iU3luY1xudmFyIEdsb2JTeW5jID0gZ2xvYi5HbG9iU3luYyA9IGdsb2JTeW5jLkdsb2JTeW5jXG5cbi8vIG9sZCBhcGkgc3VyZmFjZVxuZ2xvYi5nbG9iID0gZ2xvYlxuXG5mdW5jdGlvbiBleHRlbmQgKG9yaWdpbiwgYWRkKSB7XG4gIGlmIChhZGQgPT09IG51bGwgfHwgdHlwZW9mIGFkZCAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gb3JpZ2luXG4gIH1cblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFkZClcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aFxuICB3aGlsZSAoaS0tKSB7XG4gICAgb3JpZ2luW2tleXNbaV1dID0gYWRkW2tleXNbaV1dXG4gIH1cbiAgcmV0dXJuIG9yaWdpblxufVxuXG5nbG9iLmhhc01hZ2ljID0gZnVuY3Rpb24gKHBhdHRlcm4sIG9wdGlvbnNfKSB7XG4gIHZhciBvcHRpb25zID0gZXh0ZW5kKHt9LCBvcHRpb25zXylcbiAgb3B0aW9ucy5ub3Byb2Nlc3MgPSB0cnVlXG5cbiAgdmFyIGcgPSBuZXcgR2xvYihwYXR0ZXJuLCBvcHRpb25zKVxuICB2YXIgc2V0ID0gZy5taW5pbWF0Y2guc2V0XG5cbiAgaWYgKCFwYXR0ZXJuKVxuICAgIHJldHVybiBmYWxzZVxuXG4gIGlmIChzZXQubGVuZ3RoID4gMSlcbiAgICByZXR1cm4gdHJ1ZVxuXG4gIGZvciAodmFyIGogPSAwOyBqIDwgc2V0WzBdLmxlbmd0aDsgaisrKSB7XG4gICAgaWYgKHR5cGVvZiBzZXRbMF1bal0gIT09ICdzdHJpbmcnKVxuICAgICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHJldHVybiBmYWxzZVxufVxuXG5nbG9iLkdsb2IgPSBHbG9iXG5pbmhlcml0cyhHbG9iLCBFRSlcbmZ1bmN0aW9uIEdsb2IgKHBhdHRlcm4sIG9wdGlvbnMsIGNiKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gb3B0aW9uc1xuICAgIG9wdGlvbnMgPSBudWxsXG4gIH1cblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnN5bmMpIHtcbiAgICBpZiAoY2IpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjYWxsYmFjayBwcm92aWRlZCB0byBzeW5jIGdsb2InKVxuICAgIHJldHVybiBuZXcgR2xvYlN5bmMocGF0dGVybiwgb3B0aW9ucylcbiAgfVxuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBHbG9iKSlcbiAgICByZXR1cm4gbmV3IEdsb2IocGF0dGVybiwgb3B0aW9ucywgY2IpXG5cbiAgc2V0b3B0cyh0aGlzLCBwYXR0ZXJuLCBvcHRpb25zKVxuICB0aGlzLl9kaWRSZWFsUGF0aCA9IGZhbHNlXG5cbiAgLy8gcHJvY2VzcyBlYWNoIHBhdHRlcm4gaW4gdGhlIG1pbmltYXRjaCBzZXRcbiAgdmFyIG4gPSB0aGlzLm1pbmltYXRjaC5zZXQubGVuZ3RoXG5cbiAgLy8gVGhlIG1hdGNoZXMgYXJlIHN0b3JlZCBhcyB7PGZpbGVuYW1lPjogdHJ1ZSwuLi59IHNvIHRoYXRcbiAgLy8gZHVwbGljYXRlcyBhcmUgYXV0b21hZ2ljYWxseSBwcnVuZWQuXG4gIC8vIExhdGVyLCB3ZSBkbyBhbiBPYmplY3Qua2V5cygpIG9uIHRoZXNlLlxuICAvLyBLZWVwIHRoZW0gYXMgYSBsaXN0IHNvIHdlIGNhbiBmaWxsIGluIHdoZW4gbm9udWxsIGlzIHNldC5cbiAgdGhpcy5tYXRjaGVzID0gbmV3IEFycmF5KG4pXG5cbiAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gb25jZShjYilcbiAgICB0aGlzLm9uKCdlcnJvcicsIGNiKVxuICAgIHRoaXMub24oJ2VuZCcsIGZ1bmN0aW9uIChtYXRjaGVzKSB7XG4gICAgICBjYihudWxsLCBtYXRjaGVzKVxuICAgIH0pXG4gIH1cblxuICB2YXIgc2VsZiA9IHRoaXNcbiAgdGhpcy5fcHJvY2Vzc2luZyA9IDBcblxuICB0aGlzLl9lbWl0UXVldWUgPSBbXVxuICB0aGlzLl9wcm9jZXNzUXVldWUgPSBbXVxuICB0aGlzLnBhdXNlZCA9IGZhbHNlXG5cbiAgaWYgKHRoaXMubm9wcm9jZXNzKVxuICAgIHJldHVybiB0aGlzXG5cbiAgaWYgKG4gPT09IDApXG4gICAgcmV0dXJuIGRvbmUoKVxuXG4gIHZhciBzeW5jID0gdHJ1ZVxuICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkgKyspIHtcbiAgICB0aGlzLl9wcm9jZXNzKHRoaXMubWluaW1hdGNoLnNldFtpXSwgaSwgZmFsc2UsIGRvbmUpXG4gIH1cbiAgc3luYyA9IGZhbHNlXG5cbiAgZnVuY3Rpb24gZG9uZSAoKSB7XG4gICAgLS1zZWxmLl9wcm9jZXNzaW5nXG4gICAgaWYgKHNlbGYuX3Byb2Nlc3NpbmcgPD0gMCkge1xuICAgICAgaWYgKHN5bmMpIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgc2VsZi5fZmluaXNoKClcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYuX2ZpbmlzaCgpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbkdsb2IucHJvdG90eXBlLl9maW5pc2ggPSBmdW5jdGlvbiAoKSB7XG4gIGFzc2VydCh0aGlzIGluc3RhbmNlb2YgR2xvYilcbiAgaWYgKHRoaXMuYWJvcnRlZClcbiAgICByZXR1cm5cblxuICBpZiAodGhpcy5yZWFscGF0aCAmJiAhdGhpcy5fZGlkUmVhbHBhdGgpXG4gICAgcmV0dXJuIHRoaXMuX3JlYWxwYXRoKClcblxuICBjb21tb24uZmluaXNoKHRoaXMpXG4gIHRoaXMuZW1pdCgnZW5kJywgdGhpcy5mb3VuZClcbn1cblxuR2xvYi5wcm90b3R5cGUuX3JlYWxwYXRoID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5fZGlkUmVhbHBhdGgpXG4gICAgcmV0dXJuXG5cbiAgdGhpcy5fZGlkUmVhbHBhdGggPSB0cnVlXG5cbiAgdmFyIG4gPSB0aGlzLm1hdGNoZXMubGVuZ3RoXG4gIGlmIChuID09PSAwKVxuICAgIHJldHVybiB0aGlzLl9maW5pc2goKVxuXG4gIHZhciBzZWxmID0gdGhpc1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubWF0Y2hlcy5sZW5ndGg7IGkrKylcbiAgICB0aGlzLl9yZWFscGF0aFNldChpLCBuZXh0KVxuXG4gIGZ1bmN0aW9uIG5leHQgKCkge1xuICAgIGlmICgtLW4gPT09IDApXG4gICAgICBzZWxmLl9maW5pc2goKVxuICB9XG59XG5cbkdsb2IucHJvdG90eXBlLl9yZWFscGF0aFNldCA9IGZ1bmN0aW9uIChpbmRleCwgY2IpIHtcbiAgdmFyIG1hdGNoc2V0ID0gdGhpcy5tYXRjaGVzW2luZGV4XVxuICBpZiAoIW1hdGNoc2V0KVxuICAgIHJldHVybiBjYigpXG5cbiAgdmFyIGZvdW5kID0gT2JqZWN0LmtleXMobWF0Y2hzZXQpXG4gIHZhciBzZWxmID0gdGhpc1xuICB2YXIgbiA9IGZvdW5kLmxlbmd0aFxuXG4gIGlmIChuID09PSAwKVxuICAgIHJldHVybiBjYigpXG5cbiAgdmFyIHNldCA9IHRoaXMubWF0Y2hlc1tpbmRleF0gPSBPYmplY3QuY3JlYXRlKG51bGwpXG4gIGZvdW5kLmZvckVhY2goZnVuY3Rpb24gKHAsIGkpIHtcbiAgICAvLyBJZiB0aGVyZSdzIGEgcHJvYmxlbSB3aXRoIHRoZSBzdGF0LCB0aGVuIGl0IG1lYW5zIHRoYXRcbiAgICAvLyBvbmUgb3IgbW9yZSBvZiB0aGUgbGlua3MgaW4gdGhlIHJlYWxwYXRoIGNvdWxkbid0IGJlXG4gICAgLy8gcmVzb2x2ZWQuICBqdXN0IHJldHVybiB0aGUgYWJzIHZhbHVlIGluIHRoYXQgY2FzZS5cbiAgICBwID0gc2VsZi5fbWFrZUFicyhwKVxuICAgIHJwLnJlYWxwYXRoKHAsIHNlbGYucmVhbHBhdGhDYWNoZSwgZnVuY3Rpb24gKGVyLCByZWFsKSB7XG4gICAgICBpZiAoIWVyKVxuICAgICAgICBzZXRbcmVhbF0gPSB0cnVlXG4gICAgICBlbHNlIGlmIChlci5zeXNjYWxsID09PSAnc3RhdCcpXG4gICAgICAgIHNldFtwXSA9IHRydWVcbiAgICAgIGVsc2VcbiAgICAgICAgc2VsZi5lbWl0KCdlcnJvcicsIGVyKSAvLyBzcnNseSB3dGYgcmlnaHQgaGVyZVxuXG4gICAgICBpZiAoLS1uID09PSAwKSB7XG4gICAgICAgIHNlbGYubWF0Y2hlc1tpbmRleF0gPSBzZXRcbiAgICAgICAgY2IoKVxuICAgICAgfVxuICAgIH0pXG4gIH0pXG59XG5cbkdsb2IucHJvdG90eXBlLl9tYXJrID0gZnVuY3Rpb24gKHApIHtcbiAgcmV0dXJuIGNvbW1vbi5tYXJrKHRoaXMsIHApXG59XG5cbkdsb2IucHJvdG90eXBlLl9tYWtlQWJzID0gZnVuY3Rpb24gKGYpIHtcbiAgcmV0dXJuIGNvbW1vbi5tYWtlQWJzKHRoaXMsIGYpXG59XG5cbkdsb2IucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmFib3J0ZWQgPSB0cnVlXG4gIHRoaXMuZW1pdCgnYWJvcnQnKVxufVxuXG5HbG9iLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLnBhdXNlZCkge1xuICAgIHRoaXMucGF1c2VkID0gdHJ1ZVxuICAgIHRoaXMuZW1pdCgncGF1c2UnKVxuICB9XG59XG5cbkdsb2IucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMucGF1c2VkKSB7XG4gICAgdGhpcy5lbWl0KCdyZXN1bWUnKVxuICAgIHRoaXMucGF1c2VkID0gZmFsc2VcbiAgICBpZiAodGhpcy5fZW1pdFF1ZXVlLmxlbmd0aCkge1xuICAgICAgdmFyIGVxID0gdGhpcy5fZW1pdFF1ZXVlLnNsaWNlKDApXG4gICAgICB0aGlzLl9lbWl0UXVldWUubGVuZ3RoID0gMFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlcS5sZW5ndGg7IGkgKyspIHtcbiAgICAgICAgdmFyIGUgPSBlcVtpXVxuICAgICAgICB0aGlzLl9lbWl0TWF0Y2goZVswXSwgZVsxXSlcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuX3Byb2Nlc3NRdWV1ZS5sZW5ndGgpIHtcbiAgICAgIHZhciBwcSA9IHRoaXMuX3Byb2Nlc3NRdWV1ZS5zbGljZSgwKVxuICAgICAgdGhpcy5fcHJvY2Vzc1F1ZXVlLmxlbmd0aCA9IDBcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHEubGVuZ3RoOyBpICsrKSB7XG4gICAgICAgIHZhciBwID0gcHFbaV1cbiAgICAgICAgdGhpcy5fcHJvY2Vzc2luZy0tXG4gICAgICAgIHRoaXMuX3Byb2Nlc3MocFswXSwgcFsxXSwgcFsyXSwgcFszXSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuR2xvYi5wcm90b3R5cGUuX3Byb2Nlc3MgPSBmdW5jdGlvbiAocGF0dGVybiwgaW5kZXgsIGluR2xvYlN0YXIsIGNiKSB7XG4gIGFzc2VydCh0aGlzIGluc3RhbmNlb2YgR2xvYilcbiAgYXNzZXJ0KHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJylcblxuICBpZiAodGhpcy5hYm9ydGVkKVxuICAgIHJldHVyblxuXG4gIHRoaXMuX3Byb2Nlc3NpbmcrK1xuICBpZiAodGhpcy5wYXVzZWQpIHtcbiAgICB0aGlzLl9wcm9jZXNzUXVldWUucHVzaChbcGF0dGVybiwgaW5kZXgsIGluR2xvYlN0YXIsIGNiXSlcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vY29uc29sZS5lcnJvcignUFJPQ0VTUyAlZCcsIHRoaXMuX3Byb2Nlc3NpbmcsIHBhdHRlcm4pXG5cbiAgLy8gR2V0IHRoZSBmaXJzdCBbbl0gcGFydHMgb2YgcGF0dGVybiB0aGF0IGFyZSBhbGwgc3RyaW5ncy5cbiAgdmFyIG4gPSAwXG4gIHdoaWxlICh0eXBlb2YgcGF0dGVybltuXSA9PT0gJ3N0cmluZycpIHtcbiAgICBuICsrXG4gIH1cbiAgLy8gbm93IG4gaXMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBvbmUgdGhhdCBpcyAqbm90KiBhIHN0cmluZy5cblxuICAvLyBzZWUgaWYgdGhlcmUncyBhbnl0aGluZyBlbHNlXG4gIHZhciBwcmVmaXhcbiAgc3dpdGNoIChuKSB7XG4gICAgLy8gaWYgbm90LCB0aGVuIHRoaXMgaXMgcmF0aGVyIHNpbXBsZVxuICAgIGNhc2UgcGF0dGVybi5sZW5ndGg6XG4gICAgICB0aGlzLl9wcm9jZXNzU2ltcGxlKHBhdHRlcm4uam9pbignLycpLCBpbmRleCwgY2IpXG4gICAgICByZXR1cm5cblxuICAgIGNhc2UgMDpcbiAgICAgIC8vIHBhdHRlcm4gKnN0YXJ0cyogd2l0aCBzb21lIG5vbi10cml2aWFsIGl0ZW0uXG4gICAgICAvLyBnb2luZyB0byByZWFkZGlyKGN3ZCksIGJ1dCBub3QgaW5jbHVkZSB0aGUgcHJlZml4IGluIG1hdGNoZXMuXG4gICAgICBwcmVmaXggPSBudWxsXG4gICAgICBicmVha1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIHBhdHRlcm4gaGFzIHNvbWUgc3RyaW5nIGJpdHMgaW4gdGhlIGZyb250LlxuICAgICAgLy8gd2hhdGV2ZXIgaXQgc3RhcnRzIHdpdGgsIHdoZXRoZXIgdGhhdCdzICdhYnNvbHV0ZScgbGlrZSAvZm9vL2JhcixcbiAgICAgIC8vIG9yICdyZWxhdGl2ZScgbGlrZSAnLi4vYmF6J1xuICAgICAgcHJlZml4ID0gcGF0dGVybi5zbGljZSgwLCBuKS5qb2luKCcvJylcbiAgICAgIGJyZWFrXG4gIH1cblxuICB2YXIgcmVtYWluID0gcGF0dGVybi5zbGljZShuKVxuXG4gIC8vIGdldCB0aGUgbGlzdCBvZiBlbnRyaWVzLlxuICB2YXIgcmVhZFxuICBpZiAocHJlZml4ID09PSBudWxsKVxuICAgIHJlYWQgPSAnLidcbiAgZWxzZSBpZiAoaXNBYnNvbHV0ZShwcmVmaXgpIHx8IGlzQWJzb2x1dGUocGF0dGVybi5qb2luKCcvJykpKSB7XG4gICAgaWYgKCFwcmVmaXggfHwgIWlzQWJzb2x1dGUocHJlZml4KSlcbiAgICAgIHByZWZpeCA9ICcvJyArIHByZWZpeFxuICAgIHJlYWQgPSBwcmVmaXhcbiAgfSBlbHNlXG4gICAgcmVhZCA9IHByZWZpeFxuXG4gIHZhciBhYnMgPSB0aGlzLl9tYWtlQWJzKHJlYWQpXG5cbiAgLy9pZiBpZ25vcmVkLCBza2lwIF9wcm9jZXNzaW5nXG4gIGlmIChjaGlsZHJlbklnbm9yZWQodGhpcywgcmVhZCkpXG4gICAgcmV0dXJuIGNiKClcblxuICB2YXIgaXNHbG9iU3RhciA9IHJlbWFpblswXSA9PT0gbWluaW1hdGNoLkdMT0JTVEFSXG4gIGlmIChpc0dsb2JTdGFyKVxuICAgIHRoaXMuX3Byb2Nlc3NHbG9iU3RhcihwcmVmaXgsIHJlYWQsIGFicywgcmVtYWluLCBpbmRleCwgaW5HbG9iU3RhciwgY2IpXG4gIGVsc2VcbiAgICB0aGlzLl9wcm9jZXNzUmVhZGRpcihwcmVmaXgsIHJlYWQsIGFicywgcmVtYWluLCBpbmRleCwgaW5HbG9iU3RhciwgY2IpXG59XG5cbkdsb2IucHJvdG90eXBlLl9wcm9jZXNzUmVhZGRpciA9IGZ1bmN0aW9uIChwcmVmaXgsIHJlYWQsIGFicywgcmVtYWluLCBpbmRleCwgaW5HbG9iU3RhciwgY2IpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHRoaXMuX3JlYWRkaXIoYWJzLCBpbkdsb2JTdGFyLCBmdW5jdGlvbiAoZXIsIGVudHJpZXMpIHtcbiAgICByZXR1cm4gc2VsZi5fcHJvY2Vzc1JlYWRkaXIyKHByZWZpeCwgcmVhZCwgYWJzLCByZW1haW4sIGluZGV4LCBpbkdsb2JTdGFyLCBlbnRyaWVzLCBjYilcbiAgfSlcbn1cblxuR2xvYi5wcm90b3R5cGUuX3Byb2Nlc3NSZWFkZGlyMiA9IGZ1bmN0aW9uIChwcmVmaXgsIHJlYWQsIGFicywgcmVtYWluLCBpbmRleCwgaW5HbG9iU3RhciwgZW50cmllcywgY2IpIHtcblxuICAvLyBpZiB0aGUgYWJzIGlzbid0IGEgZGlyLCB0aGVuIG5vdGhpbmcgY2FuIG1hdGNoIVxuICBpZiAoIWVudHJpZXMpXG4gICAgcmV0dXJuIGNiKClcblxuICAvLyBJdCB3aWxsIG9ubHkgbWF0Y2ggZG90IGVudHJpZXMgaWYgaXQgc3RhcnRzIHdpdGggYSBkb3QsIG9yIGlmXG4gIC8vIGRvdCBpcyBzZXQuICBTdHVmZiBsaWtlIEAoLmZvb3wuYmFyKSBpc24ndCBhbGxvd2VkLlxuICB2YXIgcG4gPSByZW1haW5bMF1cbiAgdmFyIG5lZ2F0ZSA9ICEhdGhpcy5taW5pbWF0Y2gubmVnYXRlXG4gIHZhciByYXdHbG9iID0gcG4uX2dsb2JcbiAgdmFyIGRvdE9rID0gdGhpcy5kb3QgfHwgcmF3R2xvYi5jaGFyQXQoMCkgPT09ICcuJ1xuXG4gIHZhciBtYXRjaGVkRW50cmllcyA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZW50cmllcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlID0gZW50cmllc1tpXVxuICAgIGlmIChlLmNoYXJBdCgwKSAhPT0gJy4nIHx8IGRvdE9rKSB7XG4gICAgICB2YXIgbVxuICAgICAgaWYgKG5lZ2F0ZSAmJiAhcHJlZml4KSB7XG4gICAgICAgIG0gPSAhZS5tYXRjaChwbilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG0gPSBlLm1hdGNoKHBuKVxuICAgICAgfVxuICAgICAgaWYgKG0pXG4gICAgICAgIG1hdGNoZWRFbnRyaWVzLnB1c2goZSlcbiAgICB9XG4gIH1cblxuICAvL2NvbnNvbGUuZXJyb3IoJ3ByZDInLCBwcmVmaXgsIGVudHJpZXMsIHJlbWFpblswXS5fZ2xvYiwgbWF0Y2hlZEVudHJpZXMpXG5cbiAgdmFyIGxlbiA9IG1hdGNoZWRFbnRyaWVzLmxlbmd0aFxuICAvLyBJZiB0aGVyZSBhcmUgbm8gbWF0Y2hlZCBlbnRyaWVzLCB0aGVuIG5vdGhpbmcgbWF0Y2hlcy5cbiAgaWYgKGxlbiA9PT0gMClcbiAgICByZXR1cm4gY2IoKVxuXG4gIC8vIGlmIHRoaXMgaXMgdGhlIGxhc3QgcmVtYWluaW5nIHBhdHRlcm4gYml0LCB0aGVuIG5vIG5lZWQgZm9yXG4gIC8vIGFuIGFkZGl0aW9uYWwgc3RhdCAqdW5sZXNzKiB0aGUgdXNlciBoYXMgc3BlY2lmaWVkIG1hcmsgb3JcbiAgLy8gc3RhdCBleHBsaWNpdGx5LiAgV2Uga25vdyB0aGV5IGV4aXN0LCBzaW5jZSByZWFkZGlyIHJldHVybmVkXG4gIC8vIHRoZW0uXG5cbiAgaWYgKHJlbWFpbi5sZW5ndGggPT09IDEgJiYgIXRoaXMubWFyayAmJiAhdGhpcy5zdGF0KSB7XG4gICAgaWYgKCF0aGlzLm1hdGNoZXNbaW5kZXhdKVxuICAgICAgdGhpcy5tYXRjaGVzW2luZGV4XSA9IE9iamVjdC5jcmVhdGUobnVsbClcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICsrKSB7XG4gICAgICB2YXIgZSA9IG1hdGNoZWRFbnRyaWVzW2ldXG4gICAgICBpZiAocHJlZml4KSB7XG4gICAgICAgIGlmIChwcmVmaXggIT09ICcvJylcbiAgICAgICAgICBlID0gcHJlZml4ICsgJy8nICsgZVxuICAgICAgICBlbHNlXG4gICAgICAgICAgZSA9IHByZWZpeCArIGVcbiAgICAgIH1cblxuICAgICAgaWYgKGUuY2hhckF0KDApID09PSAnLycgJiYgIXRoaXMubm9tb3VudCkge1xuICAgICAgICBlID0gcGF0aC5qb2luKHRoaXMucm9vdCwgZSlcbiAgICAgIH1cbiAgICAgIHRoaXMuX2VtaXRNYXRjaChpbmRleCwgZSlcbiAgICB9XG4gICAgLy8gVGhpcyB3YXMgdGhlIGxhc3Qgb25lLCBhbmQgbm8gc3RhdHMgd2VyZSBuZWVkZWRcbiAgICByZXR1cm4gY2IoKVxuICB9XG5cbiAgLy8gbm93IHRlc3QgYWxsIG1hdGNoZWQgZW50cmllcyBhcyBzdGFuZC1pbnMgZm9yIHRoYXQgcGFydFxuICAvLyBvZiB0aGUgcGF0dGVybi5cbiAgcmVtYWluLnNoaWZ0KClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKyspIHtcbiAgICB2YXIgZSA9IG1hdGNoZWRFbnRyaWVzW2ldXG4gICAgdmFyIG5ld1BhdHRlcm5cbiAgICBpZiAocHJlZml4KSB7XG4gICAgICBpZiAocHJlZml4ICE9PSAnLycpXG4gICAgICAgIGUgPSBwcmVmaXggKyAnLycgKyBlXG4gICAgICBlbHNlXG4gICAgICAgIGUgPSBwcmVmaXggKyBlXG4gICAgfVxuICAgIHRoaXMuX3Byb2Nlc3MoW2VdLmNvbmNhdChyZW1haW4pLCBpbmRleCwgaW5HbG9iU3RhciwgY2IpXG4gIH1cbiAgY2IoKVxufVxuXG5HbG9iLnByb3RvdHlwZS5fZW1pdE1hdGNoID0gZnVuY3Rpb24gKGluZGV4LCBlKSB7XG4gIGlmICh0aGlzLmFib3J0ZWQpXG4gICAgcmV0dXJuXG5cbiAgaWYgKGlzSWdub3JlZCh0aGlzLCBlKSlcbiAgICByZXR1cm5cblxuICBpZiAodGhpcy5wYXVzZWQpIHtcbiAgICB0aGlzLl9lbWl0UXVldWUucHVzaChbaW5kZXgsIGVdKVxuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGFicyA9IGlzQWJzb2x1dGUoZSkgPyBlIDogdGhpcy5fbWFrZUFicyhlKVxuXG4gIGlmICh0aGlzLm1hcmspXG4gICAgZSA9IHRoaXMuX21hcmsoZSlcblxuICBpZiAodGhpcy5hYnNvbHV0ZSlcbiAgICBlID0gYWJzXG5cbiAgaWYgKHRoaXMubWF0Y2hlc1tpbmRleF1bZV0pXG4gICAgcmV0dXJuXG5cbiAgaWYgKHRoaXMubm9kaXIpIHtcbiAgICB2YXIgYyA9IHRoaXMuY2FjaGVbYWJzXVxuICAgIGlmIChjID09PSAnRElSJyB8fCBBcnJheS5pc0FycmF5KGMpKVxuICAgICAgcmV0dXJuXG4gIH1cblxuICB0aGlzLm1hdGNoZXNbaW5kZXhdW2VdID0gdHJ1ZVxuXG4gIHZhciBzdCA9IHRoaXMuc3RhdENhY2hlW2Fic11cbiAgaWYgKHN0KVxuICAgIHRoaXMuZW1pdCgnc3RhdCcsIGUsIHN0KVxuXG4gIHRoaXMuZW1pdCgnbWF0Y2gnLCBlKVxufVxuXG5HbG9iLnByb3RvdHlwZS5fcmVhZGRpckluR2xvYlN0YXIgPSBmdW5jdGlvbiAoYWJzLCBjYikge1xuICBpZiAodGhpcy5hYm9ydGVkKVxuICAgIHJldHVyblxuXG4gIC8vIGZvbGxvdyBhbGwgc3ltbGlua2VkIGRpcmVjdG9yaWVzIGZvcmV2ZXJcbiAgLy8ganVzdCBwcm9jZWVkIGFzIGlmIHRoaXMgaXMgYSBub24tZ2xvYnN0YXIgc2l0dWF0aW9uXG4gIGlmICh0aGlzLmZvbGxvdylcbiAgICByZXR1cm4gdGhpcy5fcmVhZGRpcihhYnMsIGZhbHNlLCBjYilcblxuICB2YXIgbHN0YXRrZXkgPSAnbHN0YXRcXDAnICsgYWJzXG4gIHZhciBzZWxmID0gdGhpc1xuICB2YXIgbHN0YXRjYiA9IGluZmxpZ2h0KGxzdGF0a2V5LCBsc3RhdGNiXylcblxuICBpZiAobHN0YXRjYilcbiAgICBmcy5sc3RhdChhYnMsIGxzdGF0Y2IpXG5cbiAgZnVuY3Rpb24gbHN0YXRjYl8gKGVyLCBsc3RhdCkge1xuICAgIGlmIChlciAmJiBlci5jb2RlID09PSAnRU5PRU5UJylcbiAgICAgIHJldHVybiBjYigpXG5cbiAgICB2YXIgaXNTeW0gPSBsc3RhdCAmJiBsc3RhdC5pc1N5bWJvbGljTGluaygpXG4gICAgc2VsZi5zeW1saW5rc1thYnNdID0gaXNTeW1cblxuICAgIC8vIElmIGl0J3Mgbm90IGEgc3ltbGluayBvciBhIGRpciwgdGhlbiBpdCdzIGRlZmluaXRlbHkgYSByZWd1bGFyIGZpbGUuXG4gICAgLy8gZG9uJ3QgYm90aGVyIGRvaW5nIGEgcmVhZGRpciBpbiB0aGF0IGNhc2UuXG4gICAgaWYgKCFpc1N5bSAmJiBsc3RhdCAmJiAhbHN0YXQuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgc2VsZi5jYWNoZVthYnNdID0gJ0ZJTEUnXG4gICAgICBjYigpXG4gICAgfSBlbHNlXG4gICAgICBzZWxmLl9yZWFkZGlyKGFicywgZmFsc2UsIGNiKVxuICB9XG59XG5cbkdsb2IucHJvdG90eXBlLl9yZWFkZGlyID0gZnVuY3Rpb24gKGFicywgaW5HbG9iU3RhciwgY2IpIHtcbiAgaWYgKHRoaXMuYWJvcnRlZClcbiAgICByZXR1cm5cblxuICBjYiA9IGluZmxpZ2h0KCdyZWFkZGlyXFwwJythYnMrJ1xcMCcraW5HbG9iU3RhciwgY2IpXG4gIGlmICghY2IpXG4gICAgcmV0dXJuXG5cbiAgLy9jb25zb2xlLmVycm9yKCdSRCAlaiAlaicsICtpbkdsb2JTdGFyLCBhYnMpXG4gIGlmIChpbkdsb2JTdGFyICYmICFvd25Qcm9wKHRoaXMuc3ltbGlua3MsIGFicykpXG4gICAgcmV0dXJuIHRoaXMuX3JlYWRkaXJJbkdsb2JTdGFyKGFicywgY2IpXG5cbiAgaWYgKG93blByb3AodGhpcy5jYWNoZSwgYWJzKSkge1xuICAgIHZhciBjID0gdGhpcy5jYWNoZVthYnNdXG4gICAgaWYgKCFjIHx8IGMgPT09ICdGSUxFJylcbiAgICAgIHJldHVybiBjYigpXG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShjKSlcbiAgICAgIHJldHVybiBjYihudWxsLCBjKVxuICB9XG5cbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGZzLnJlYWRkaXIoYWJzLCByZWFkZGlyQ2IodGhpcywgYWJzLCBjYikpXG59XG5cbmZ1bmN0aW9uIHJlYWRkaXJDYiAoc2VsZiwgYWJzLCBjYikge1xuICByZXR1cm4gZnVuY3Rpb24gKGVyLCBlbnRyaWVzKSB7XG4gICAgaWYgKGVyKVxuICAgICAgc2VsZi5fcmVhZGRpckVycm9yKGFicywgZXIsIGNiKVxuICAgIGVsc2VcbiAgICAgIHNlbGYuX3JlYWRkaXJFbnRyaWVzKGFicywgZW50cmllcywgY2IpXG4gIH1cbn1cblxuR2xvYi5wcm90b3R5cGUuX3JlYWRkaXJFbnRyaWVzID0gZnVuY3Rpb24gKGFicywgZW50cmllcywgY2IpIHtcbiAgaWYgKHRoaXMuYWJvcnRlZClcbiAgICByZXR1cm5cblxuICAvLyBpZiB3ZSBoYXZlbid0IGFza2VkIHRvIHN0YXQgZXZlcnl0aGluZywgdGhlbiBqdXN0XG4gIC8vIGFzc3VtZSB0aGF0IGV2ZXJ5dGhpbmcgaW4gdGhlcmUgZXhpc3RzLCBzbyB3ZSBjYW4gYXZvaWRcbiAgLy8gaGF2aW5nIHRvIHN0YXQgaXQgYSBzZWNvbmQgdGltZS5cbiAgaWYgKCF0aGlzLm1hcmsgJiYgIXRoaXMuc3RhdCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW50cmllcy5sZW5ndGg7IGkgKyspIHtcbiAgICAgIHZhciBlID0gZW50cmllc1tpXVxuICAgICAgaWYgKGFicyA9PT0gJy8nKVxuICAgICAgICBlID0gYWJzICsgZVxuICAgICAgZWxzZVxuICAgICAgICBlID0gYWJzICsgJy8nICsgZVxuICAgICAgdGhpcy5jYWNoZVtlXSA9IHRydWVcbiAgICB9XG4gIH1cblxuICB0aGlzLmNhY2hlW2Fic10gPSBlbnRyaWVzXG4gIHJldHVybiBjYihudWxsLCBlbnRyaWVzKVxufVxuXG5HbG9iLnByb3RvdHlwZS5fcmVhZGRpckVycm9yID0gZnVuY3Rpb24gKGYsIGVyLCBjYikge1xuICBpZiAodGhpcy5hYm9ydGVkKVxuICAgIHJldHVyblxuXG4gIC8vIGhhbmRsZSBlcnJvcnMsIGFuZCBjYWNoZSB0aGUgaW5mb3JtYXRpb25cbiAgc3dpdGNoIChlci5jb2RlKSB7XG4gICAgY2FzZSAnRU5PVFNVUCc6IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9pc2FhY3Mvbm9kZS1nbG9iL2lzc3Vlcy8yMDVcbiAgICBjYXNlICdFTk9URElSJzogLy8gdG90YWxseSBub3JtYWwuIG1lYW5zIGl0ICpkb2VzKiBleGlzdC5cbiAgICAgIHZhciBhYnMgPSB0aGlzLl9tYWtlQWJzKGYpXG4gICAgICB0aGlzLmNhY2hlW2Fic10gPSAnRklMRSdcbiAgICAgIGlmIChhYnMgPT09IHRoaXMuY3dkQWJzKSB7XG4gICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihlci5jb2RlICsgJyBpbnZhbGlkIGN3ZCAnICsgdGhpcy5jd2QpXG4gICAgICAgIGVycm9yLnBhdGggPSB0aGlzLmN3ZFxuICAgICAgICBlcnJvci5jb2RlID0gZXIuY29kZVxuICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyb3IpXG4gICAgICAgIHRoaXMuYWJvcnQoKVxuICAgICAgfVxuICAgICAgYnJlYWtcblxuICAgIGNhc2UgJ0VOT0VOVCc6IC8vIG5vdCB0ZXJyaWJseSB1bnVzdWFsXG4gICAgY2FzZSAnRUxPT1AnOlxuICAgIGNhc2UgJ0VOQU1FVE9PTE9ORyc6XG4gICAgY2FzZSAnVU5LTk9XTic6XG4gICAgICB0aGlzLmNhY2hlW3RoaXMuX21ha2VBYnMoZildID0gZmFsc2VcbiAgICAgIGJyZWFrXG5cbiAgICBkZWZhdWx0OiAvLyBzb21lIHVudXN1YWwgZXJyb3IuICBUcmVhdCBhcyBmYWlsdXJlLlxuICAgICAgdGhpcy5jYWNoZVt0aGlzLl9tYWtlQWJzKGYpXSA9IGZhbHNlXG4gICAgICBpZiAodGhpcy5zdHJpY3QpIHtcbiAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVyKVxuICAgICAgICAvLyBJZiB0aGUgZXJyb3IgaXMgaGFuZGxlZCwgdGhlbiB3ZSBhYm9ydFxuICAgICAgICAvLyBpZiBub3QsIHdlIHRocmV3IG91dCBvZiBoZXJlXG4gICAgICAgIHRoaXMuYWJvcnQoKVxuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLnNpbGVudClcbiAgICAgICAgY29uc29sZS5lcnJvcignZ2xvYiBlcnJvcicsIGVyKVxuICAgICAgYnJlYWtcbiAgfVxuXG4gIHJldHVybiBjYigpXG59XG5cbkdsb2IucHJvdG90eXBlLl9wcm9jZXNzR2xvYlN0YXIgPSBmdW5jdGlvbiAocHJlZml4LCByZWFkLCBhYnMsIHJlbWFpbiwgaW5kZXgsIGluR2xvYlN0YXIsIGNiKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICB0aGlzLl9yZWFkZGlyKGFicywgaW5HbG9iU3RhciwgZnVuY3Rpb24gKGVyLCBlbnRyaWVzKSB7XG4gICAgc2VsZi5fcHJvY2Vzc0dsb2JTdGFyMihwcmVmaXgsIHJlYWQsIGFicywgcmVtYWluLCBpbmRleCwgaW5HbG9iU3RhciwgZW50cmllcywgY2IpXG4gIH0pXG59XG5cblxuR2xvYi5wcm90b3R5cGUuX3Byb2Nlc3NHbG9iU3RhcjIgPSBmdW5jdGlvbiAocHJlZml4LCByZWFkLCBhYnMsIHJlbWFpbiwgaW5kZXgsIGluR2xvYlN0YXIsIGVudHJpZXMsIGNiKSB7XG4gIC8vY29uc29sZS5lcnJvcigncGdzMicsIHByZWZpeCwgcmVtYWluWzBdLCBlbnRyaWVzKVxuXG4gIC8vIG5vIGVudHJpZXMgbWVhbnMgbm90IGEgZGlyLCBzbyBpdCBjYW4gbmV2ZXIgaGF2ZSBtYXRjaGVzXG4gIC8vIGZvby50eHQvKiogZG9lc24ndCBtYXRjaCBmb28udHh0XG4gIGlmICghZW50cmllcylcbiAgICByZXR1cm4gY2IoKVxuXG4gIC8vIHRlc3Qgd2l0aG91dCB0aGUgZ2xvYnN0YXIsIGFuZCB3aXRoIGV2ZXJ5IGNoaWxkIGJvdGggYmVsb3dcbiAgLy8gYW5kIHJlcGxhY2luZyB0aGUgZ2xvYnN0YXIuXG4gIHZhciByZW1haW5XaXRob3V0R2xvYlN0YXIgPSByZW1haW4uc2xpY2UoMSlcbiAgdmFyIGdzcHJlZiA9IHByZWZpeCA/IFsgcHJlZml4IF0gOiBbXVxuICB2YXIgbm9HbG9iU3RhciA9IGdzcHJlZi5jb25jYXQocmVtYWluV2l0aG91dEdsb2JTdGFyKVxuXG4gIC8vIHRoZSBub0dsb2JTdGFyIHBhdHRlcm4gZXhpdHMgdGhlIGluR2xvYlN0YXIgc3RhdGVcbiAgdGhpcy5fcHJvY2Vzcyhub0dsb2JTdGFyLCBpbmRleCwgZmFsc2UsIGNiKVxuXG4gIHZhciBpc1N5bSA9IHRoaXMuc3ltbGlua3NbYWJzXVxuICB2YXIgbGVuID0gZW50cmllcy5sZW5ndGhcblxuICAvLyBJZiBpdCdzIGEgc3ltbGluaywgYW5kIHdlJ3JlIGluIGEgZ2xvYnN0YXIsIHRoZW4gc3RvcFxuICBpZiAoaXNTeW0gJiYgaW5HbG9iU3RhcilcbiAgICByZXR1cm4gY2IoKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgZSA9IGVudHJpZXNbaV1cbiAgICBpZiAoZS5jaGFyQXQoMCkgPT09ICcuJyAmJiAhdGhpcy5kb3QpXG4gICAgICBjb250aW51ZVxuXG4gICAgLy8gdGhlc2UgdHdvIGNhc2VzIGVudGVyIHRoZSBpbkdsb2JTdGFyIHN0YXRlXG4gICAgdmFyIGluc3RlYWQgPSBnc3ByZWYuY29uY2F0KGVudHJpZXNbaV0sIHJlbWFpbldpdGhvdXRHbG9iU3RhcilcbiAgICB0aGlzLl9wcm9jZXNzKGluc3RlYWQsIGluZGV4LCB0cnVlLCBjYilcblxuICAgIHZhciBiZWxvdyA9IGdzcHJlZi5jb25jYXQoZW50cmllc1tpXSwgcmVtYWluKVxuICAgIHRoaXMuX3Byb2Nlc3MoYmVsb3csIGluZGV4LCB0cnVlLCBjYilcbiAgfVxuXG4gIGNiKClcbn1cblxuR2xvYi5wcm90b3R5cGUuX3Byb2Nlc3NTaW1wbGUgPSBmdW5jdGlvbiAocHJlZml4LCBpbmRleCwgY2IpIHtcbiAgLy8gWFhYIHJldmlldyB0aGlzLiAgU2hvdWxkbid0IGl0IGJlIGRvaW5nIHRoZSBtb3VudGluZyBldGNcbiAgLy8gYmVmb3JlIGRvaW5nIHN0YXQ/ICBraW5kYSB3ZWlyZD9cbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHRoaXMuX3N0YXQocHJlZml4LCBmdW5jdGlvbiAoZXIsIGV4aXN0cykge1xuICAgIHNlbGYuX3Byb2Nlc3NTaW1wbGUyKHByZWZpeCwgaW5kZXgsIGVyLCBleGlzdHMsIGNiKVxuICB9KVxufVxuR2xvYi5wcm90b3R5cGUuX3Byb2Nlc3NTaW1wbGUyID0gZnVuY3Rpb24gKHByZWZpeCwgaW5kZXgsIGVyLCBleGlzdHMsIGNiKSB7XG5cbiAgLy9jb25zb2xlLmVycm9yKCdwczInLCBwcmVmaXgsIGV4aXN0cylcblxuICBpZiAoIXRoaXMubWF0Y2hlc1tpbmRleF0pXG4gICAgdGhpcy5tYXRjaGVzW2luZGV4XSA9IE9iamVjdC5jcmVhdGUobnVsbClcblxuICAvLyBJZiBpdCBkb2Vzbid0IGV4aXN0LCB0aGVuIGp1c3QgbWFyayB0aGUgbGFjayBvZiByZXN1bHRzXG4gIGlmICghZXhpc3RzKVxuICAgIHJldHVybiBjYigpXG5cbiAgaWYgKHByZWZpeCAmJiBpc0Fic29sdXRlKHByZWZpeCkgJiYgIXRoaXMubm9tb3VudCkge1xuICAgIHZhciB0cmFpbCA9IC9bXFwvXFxcXF0kLy50ZXN0KHByZWZpeClcbiAgICBpZiAocHJlZml4LmNoYXJBdCgwKSA9PT0gJy8nKSB7XG4gICAgICBwcmVmaXggPSBwYXRoLmpvaW4odGhpcy5yb290LCBwcmVmaXgpXG4gICAgfSBlbHNlIHtcbiAgICAgIHByZWZpeCA9IHBhdGgucmVzb2x2ZSh0aGlzLnJvb3QsIHByZWZpeClcbiAgICAgIGlmICh0cmFpbClcbiAgICAgICAgcHJlZml4ICs9ICcvJ1xuICAgIH1cbiAgfVxuXG4gIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInKVxuICAgIHByZWZpeCA9IHByZWZpeC5yZXBsYWNlKC9cXFxcL2csICcvJylcblxuICAvLyBNYXJrIHRoaXMgYXMgYSBtYXRjaFxuICB0aGlzLl9lbWl0TWF0Y2goaW5kZXgsIHByZWZpeClcbiAgY2IoKVxufVxuXG4vLyBSZXR1cm5zIGVpdGhlciAnRElSJywgJ0ZJTEUnLCBvciBmYWxzZVxuR2xvYi5wcm90b3R5cGUuX3N0YXQgPSBmdW5jdGlvbiAoZiwgY2IpIHtcbiAgdmFyIGFicyA9IHRoaXMuX21ha2VBYnMoZilcbiAgdmFyIG5lZWREaXIgPSBmLnNsaWNlKC0xKSA9PT0gJy8nXG5cbiAgaWYgKGYubGVuZ3RoID4gdGhpcy5tYXhMZW5ndGgpXG4gICAgcmV0dXJuIGNiKClcblxuICBpZiAoIXRoaXMuc3RhdCAmJiBvd25Qcm9wKHRoaXMuY2FjaGUsIGFicykpIHtcbiAgICB2YXIgYyA9IHRoaXMuY2FjaGVbYWJzXVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYykpXG4gICAgICBjID0gJ0RJUidcblxuICAgIC8vIEl0IGV4aXN0cywgYnV0IG1heWJlIG5vdCBob3cgd2UgbmVlZCBpdFxuICAgIGlmICghbmVlZERpciB8fCBjID09PSAnRElSJylcbiAgICAgIHJldHVybiBjYihudWxsLCBjKVxuXG4gICAgaWYgKG5lZWREaXIgJiYgYyA9PT0gJ0ZJTEUnKVxuICAgICAgcmV0dXJuIGNiKClcblxuICAgIC8vIG90aGVyd2lzZSB3ZSBoYXZlIHRvIHN0YXQsIGJlY2F1c2UgbWF5YmUgYz10cnVlXG4gICAgLy8gaWYgd2Uga25vdyBpdCBleGlzdHMsIGJ1dCBub3Qgd2hhdCBpdCBpcy5cbiAgfVxuXG4gIHZhciBleGlzdHNcbiAgdmFyIHN0YXQgPSB0aGlzLnN0YXRDYWNoZVthYnNdXG4gIGlmIChzdGF0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoc3RhdCA9PT0gZmFsc2UpXG4gICAgICByZXR1cm4gY2IobnVsbCwgc3RhdClcbiAgICBlbHNlIHtcbiAgICAgIHZhciB0eXBlID0gc3RhdC5pc0RpcmVjdG9yeSgpID8gJ0RJUicgOiAnRklMRSdcbiAgICAgIGlmIChuZWVkRGlyICYmIHR5cGUgPT09ICdGSUxFJylcbiAgICAgICAgcmV0dXJuIGNiKClcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIGNiKG51bGwsIHR5cGUsIHN0YXQpXG4gICAgfVxuICB9XG5cbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHZhciBzdGF0Y2IgPSBpbmZsaWdodCgnc3RhdFxcMCcgKyBhYnMsIGxzdGF0Y2JfKVxuICBpZiAoc3RhdGNiKVxuICAgIGZzLmxzdGF0KGFicywgc3RhdGNiKVxuXG4gIGZ1bmN0aW9uIGxzdGF0Y2JfIChlciwgbHN0YXQpIHtcbiAgICBpZiAobHN0YXQgJiYgbHN0YXQuaXNTeW1ib2xpY0xpbmsoKSkge1xuICAgICAgLy8gSWYgaXQncyBhIHN5bWxpbmssIHRoZW4gdHJlYXQgaXQgYXMgdGhlIHRhcmdldCwgdW5sZXNzXG4gICAgICAvLyB0aGUgdGFyZ2V0IGRvZXMgbm90IGV4aXN0LCB0aGVuIHRyZWF0IGl0IGFzIGEgZmlsZS5cbiAgICAgIHJldHVybiBmcy5zdGF0KGFicywgZnVuY3Rpb24gKGVyLCBzdGF0KSB7XG4gICAgICAgIGlmIChlcilcbiAgICAgICAgICBzZWxmLl9zdGF0MihmLCBhYnMsIG51bGwsIGxzdGF0LCBjYilcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHNlbGYuX3N0YXQyKGYsIGFicywgZXIsIHN0YXQsIGNiKVxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5fc3RhdDIoZiwgYWJzLCBlciwgbHN0YXQsIGNiKVxuICAgIH1cbiAgfVxufVxuXG5HbG9iLnByb3RvdHlwZS5fc3RhdDIgPSBmdW5jdGlvbiAoZiwgYWJzLCBlciwgc3RhdCwgY2IpIHtcbiAgaWYgKGVyICYmIChlci5jb2RlID09PSAnRU5PRU5UJyB8fCBlci5jb2RlID09PSAnRU5PVERJUicpKSB7XG4gICAgdGhpcy5zdGF0Q2FjaGVbYWJzXSA9IGZhbHNlXG4gICAgcmV0dXJuIGNiKClcbiAgfVxuXG4gIHZhciBuZWVkRGlyID0gZi5zbGljZSgtMSkgPT09ICcvJ1xuICB0aGlzLnN0YXRDYWNoZVthYnNdID0gc3RhdFxuXG4gIGlmIChhYnMuc2xpY2UoLTEpID09PSAnLycgJiYgc3RhdCAmJiAhc3RhdC5pc0RpcmVjdG9yeSgpKVxuICAgIHJldHVybiBjYihudWxsLCBmYWxzZSwgc3RhdClcblxuICB2YXIgYyA9IHRydWVcbiAgaWYgKHN0YXQpXG4gICAgYyA9IHN0YXQuaXNEaXJlY3RvcnkoKSA/ICdESVInIDogJ0ZJTEUnXG4gIHRoaXMuY2FjaGVbYWJzXSA9IHRoaXMuY2FjaGVbYWJzXSB8fCBjXG5cbiAgaWYgKG5lZWREaXIgJiYgYyA9PT0gJ0ZJTEUnKVxuICAgIHJldHVybiBjYigpXG5cbiAgcmV0dXJuIGNiKG51bGwsIGMsIHN0YXQpXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGdsb2JTeW5jXG5nbG9iU3luYy5HbG9iU3luYyA9IEdsb2JTeW5jXG5cbnZhciBmcyA9IHJlcXVpcmUoJ2ZzJylcbnZhciBycCA9IHJlcXVpcmUoJ2ZzLnJlYWxwYXRoJylcbnZhciBtaW5pbWF0Y2ggPSByZXF1aXJlKCdtaW5pbWF0Y2gnKVxudmFyIE1pbmltYXRjaCA9IG1pbmltYXRjaC5NaW5pbWF0Y2hcbnZhciBHbG9iID0gcmVxdWlyZSgnLi9nbG9iLmpzJykuR2xvYlxudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJylcbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0JylcbnZhciBpc0Fic29sdXRlID0gcmVxdWlyZSgncGF0aC1pcy1hYnNvbHV0ZScpXG52YXIgY29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24uanMnKVxudmFyIGFscGhhc29ydCA9IGNvbW1vbi5hbHBoYXNvcnRcbnZhciBhbHBoYXNvcnRpID0gY29tbW9uLmFscGhhc29ydGlcbnZhciBzZXRvcHRzID0gY29tbW9uLnNldG9wdHNcbnZhciBvd25Qcm9wID0gY29tbW9uLm93blByb3BcbnZhciBjaGlsZHJlbklnbm9yZWQgPSBjb21tb24uY2hpbGRyZW5JZ25vcmVkXG52YXIgaXNJZ25vcmVkID0gY29tbW9uLmlzSWdub3JlZFxuXG5mdW5jdGlvbiBnbG9iU3luYyAocGF0dGVybiwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjYWxsYmFjayBwcm92aWRlZCB0byBzeW5jIGdsb2JcXG4nK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1NlZTogaHR0cHM6Ly9naXRodWIuY29tL2lzYWFjcy9ub2RlLWdsb2IvaXNzdWVzLzE2NycpXG5cbiAgcmV0dXJuIG5ldyBHbG9iU3luYyhwYXR0ZXJuLCBvcHRpb25zKS5mb3VuZFxufVxuXG5mdW5jdGlvbiBHbG9iU3luYyAocGF0dGVybiwgb3B0aW9ucykge1xuICBpZiAoIXBhdHRlcm4pXG4gICAgdGhyb3cgbmV3IEVycm9yKCdtdXN0IHByb3ZpZGUgcGF0dGVybicpXG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDMpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2FsbGJhY2sgcHJvdmlkZWQgdG8gc3luYyBnbG9iXFxuJytcbiAgICAgICAgICAgICAgICAgICAgICAgICdTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9pc2FhY3Mvbm9kZS1nbG9iL2lzc3Vlcy8xNjcnKVxuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBHbG9iU3luYykpXG4gICAgcmV0dXJuIG5ldyBHbG9iU3luYyhwYXR0ZXJuLCBvcHRpb25zKVxuXG4gIHNldG9wdHModGhpcywgcGF0dGVybiwgb3B0aW9ucylcblxuICBpZiAodGhpcy5ub3Byb2Nlc3MpXG4gICAgcmV0dXJuIHRoaXNcblxuICB2YXIgbiA9IHRoaXMubWluaW1hdGNoLnNldC5sZW5ndGhcbiAgdGhpcy5tYXRjaGVzID0gbmV3IEFycmF5KG4pXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSArKykge1xuICAgIHRoaXMuX3Byb2Nlc3ModGhpcy5taW5pbWF0Y2guc2V0W2ldLCBpLCBmYWxzZSlcbiAgfVxuICB0aGlzLl9maW5pc2goKVxufVxuXG5HbG9iU3luYy5wcm90b3R5cGUuX2ZpbmlzaCA9IGZ1bmN0aW9uICgpIHtcbiAgYXNzZXJ0KHRoaXMgaW5zdGFuY2VvZiBHbG9iU3luYylcbiAgaWYgKHRoaXMucmVhbHBhdGgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXNcbiAgICB0aGlzLm1hdGNoZXMuZm9yRWFjaChmdW5jdGlvbiAobWF0Y2hzZXQsIGluZGV4KSB7XG4gICAgICB2YXIgc2V0ID0gc2VsZi5tYXRjaGVzW2luZGV4XSA9IE9iamVjdC5jcmVhdGUobnVsbClcbiAgICAgIGZvciAodmFyIHAgaW4gbWF0Y2hzZXQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBwID0gc2VsZi5fbWFrZUFicyhwKVxuICAgICAgICAgIHZhciByZWFsID0gcnAucmVhbHBhdGhTeW5jKHAsIHNlbGYucmVhbHBhdGhDYWNoZSlcbiAgICAgICAgICBzZXRbcmVhbF0gPSB0cnVlXG4gICAgICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICAgICAgaWYgKGVyLnN5c2NhbGwgPT09ICdzdGF0JylcbiAgICAgICAgICAgIHNldFtzZWxmLl9tYWtlQWJzKHApXSA9IHRydWVcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aHJvdyBlclxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgfVxuICBjb21tb24uZmluaXNoKHRoaXMpXG59XG5cblxuR2xvYlN5bmMucHJvdG90eXBlLl9wcm9jZXNzID0gZnVuY3Rpb24gKHBhdHRlcm4sIGluZGV4LCBpbkdsb2JTdGFyKSB7XG4gIGFzc2VydCh0aGlzIGluc3RhbmNlb2YgR2xvYlN5bmMpXG5cbiAgLy8gR2V0IHRoZSBmaXJzdCBbbl0gcGFydHMgb2YgcGF0dGVybiB0aGF0IGFyZSBhbGwgc3RyaW5ncy5cbiAgdmFyIG4gPSAwXG4gIHdoaWxlICh0eXBlb2YgcGF0dGVybltuXSA9PT0gJ3N0cmluZycpIHtcbiAgICBuICsrXG4gIH1cbiAgLy8gbm93IG4gaXMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBvbmUgdGhhdCBpcyAqbm90KiBhIHN0cmluZy5cblxuICAvLyBTZWUgaWYgdGhlcmUncyBhbnl0aGluZyBlbHNlXG4gIHZhciBwcmVmaXhcbiAgc3dpdGNoIChuKSB7XG4gICAgLy8gaWYgbm90LCB0aGVuIHRoaXMgaXMgcmF0aGVyIHNpbXBsZVxuICAgIGNhc2UgcGF0dGVybi5sZW5ndGg6XG4gICAgICB0aGlzLl9wcm9jZXNzU2ltcGxlKHBhdHRlcm4uam9pbignLycpLCBpbmRleClcbiAgICAgIHJldHVyblxuXG4gICAgY2FzZSAwOlxuICAgICAgLy8gcGF0dGVybiAqc3RhcnRzKiB3aXRoIHNvbWUgbm9uLXRyaXZpYWwgaXRlbS5cbiAgICAgIC8vIGdvaW5nIHRvIHJlYWRkaXIoY3dkKSwgYnV0IG5vdCBpbmNsdWRlIHRoZSBwcmVmaXggaW4gbWF0Y2hlcy5cbiAgICAgIHByZWZpeCA9IG51bGxcbiAgICAgIGJyZWFrXG5cbiAgICBkZWZhdWx0OlxuICAgICAgLy8gcGF0dGVybiBoYXMgc29tZSBzdHJpbmcgYml0cyBpbiB0aGUgZnJvbnQuXG4gICAgICAvLyB3aGF0ZXZlciBpdCBzdGFydHMgd2l0aCwgd2hldGhlciB0aGF0J3MgJ2Fic29sdXRlJyBsaWtlIC9mb28vYmFyLFxuICAgICAgLy8gb3IgJ3JlbGF0aXZlJyBsaWtlICcuLi9iYXonXG4gICAgICBwcmVmaXggPSBwYXR0ZXJuLnNsaWNlKDAsIG4pLmpvaW4oJy8nKVxuICAgICAgYnJlYWtcbiAgfVxuXG4gIHZhciByZW1haW4gPSBwYXR0ZXJuLnNsaWNlKG4pXG5cbiAgLy8gZ2V0IHRoZSBsaXN0IG9mIGVudHJpZXMuXG4gIHZhciByZWFkXG4gIGlmIChwcmVmaXggPT09IG51bGwpXG4gICAgcmVhZCA9ICcuJ1xuICBlbHNlIGlmIChpc0Fic29sdXRlKHByZWZpeCkgfHwgaXNBYnNvbHV0ZShwYXR0ZXJuLmpvaW4oJy8nKSkpIHtcbiAgICBpZiAoIXByZWZpeCB8fCAhaXNBYnNvbHV0ZShwcmVmaXgpKVxuICAgICAgcHJlZml4ID0gJy8nICsgcHJlZml4XG4gICAgcmVhZCA9IHByZWZpeFxuICB9IGVsc2VcbiAgICByZWFkID0gcHJlZml4XG5cbiAgdmFyIGFicyA9IHRoaXMuX21ha2VBYnMocmVhZClcblxuICAvL2lmIGlnbm9yZWQsIHNraXAgcHJvY2Vzc2luZ1xuICBpZiAoY2hpbGRyZW5JZ25vcmVkKHRoaXMsIHJlYWQpKVxuICAgIHJldHVyblxuXG4gIHZhciBpc0dsb2JTdGFyID0gcmVtYWluWzBdID09PSBtaW5pbWF0Y2guR0xPQlNUQVJcbiAgaWYgKGlzR2xvYlN0YXIpXG4gICAgdGhpcy5fcHJvY2Vzc0dsb2JTdGFyKHByZWZpeCwgcmVhZCwgYWJzLCByZW1haW4sIGluZGV4LCBpbkdsb2JTdGFyKVxuICBlbHNlXG4gICAgdGhpcy5fcHJvY2Vzc1JlYWRkaXIocHJlZml4LCByZWFkLCBhYnMsIHJlbWFpbiwgaW5kZXgsIGluR2xvYlN0YXIpXG59XG5cblxuR2xvYlN5bmMucHJvdG90eXBlLl9wcm9jZXNzUmVhZGRpciA9IGZ1bmN0aW9uIChwcmVmaXgsIHJlYWQsIGFicywgcmVtYWluLCBpbmRleCwgaW5HbG9iU3Rhcikge1xuICB2YXIgZW50cmllcyA9IHRoaXMuX3JlYWRkaXIoYWJzLCBpbkdsb2JTdGFyKVxuXG4gIC8vIGlmIHRoZSBhYnMgaXNuJ3QgYSBkaXIsIHRoZW4gbm90aGluZyBjYW4gbWF0Y2ghXG4gIGlmICghZW50cmllcylcbiAgICByZXR1cm5cblxuICAvLyBJdCB3aWxsIG9ubHkgbWF0Y2ggZG90IGVudHJpZXMgaWYgaXQgc3RhcnRzIHdpdGggYSBkb3QsIG9yIGlmXG4gIC8vIGRvdCBpcyBzZXQuICBTdHVmZiBsaWtlIEAoLmZvb3wuYmFyKSBpc24ndCBhbGxvd2VkLlxuICB2YXIgcG4gPSByZW1haW5bMF1cbiAgdmFyIG5lZ2F0ZSA9ICEhdGhpcy5taW5pbWF0Y2gubmVnYXRlXG4gIHZhciByYXdHbG9iID0gcG4uX2dsb2JcbiAgdmFyIGRvdE9rID0gdGhpcy5kb3QgfHwgcmF3R2xvYi5jaGFyQXQoMCkgPT09ICcuJ1xuXG4gIHZhciBtYXRjaGVkRW50cmllcyA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZW50cmllcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlID0gZW50cmllc1tpXVxuICAgIGlmIChlLmNoYXJBdCgwKSAhPT0gJy4nIHx8IGRvdE9rKSB7XG4gICAgICB2YXIgbVxuICAgICAgaWYgKG5lZ2F0ZSAmJiAhcHJlZml4KSB7XG4gICAgICAgIG0gPSAhZS5tYXRjaChwbilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG0gPSBlLm1hdGNoKHBuKVxuICAgICAgfVxuICAgICAgaWYgKG0pXG4gICAgICAgIG1hdGNoZWRFbnRyaWVzLnB1c2goZSlcbiAgICB9XG4gIH1cblxuICB2YXIgbGVuID0gbWF0Y2hlZEVudHJpZXMubGVuZ3RoXG4gIC8vIElmIHRoZXJlIGFyZSBubyBtYXRjaGVkIGVudHJpZXMsIHRoZW4gbm90aGluZyBtYXRjaGVzLlxuICBpZiAobGVuID09PSAwKVxuICAgIHJldHVyblxuXG4gIC8vIGlmIHRoaXMgaXMgdGhlIGxhc3QgcmVtYWluaW5nIHBhdHRlcm4gYml0LCB0aGVuIG5vIG5lZWQgZm9yXG4gIC8vIGFuIGFkZGl0aW9uYWwgc3RhdCAqdW5sZXNzKiB0aGUgdXNlciBoYXMgc3BlY2lmaWVkIG1hcmsgb3JcbiAgLy8gc3RhdCBleHBsaWNpdGx5LiAgV2Uga25vdyB0aGV5IGV4aXN0LCBzaW5jZSByZWFkZGlyIHJldHVybmVkXG4gIC8vIHRoZW0uXG5cbiAgaWYgKHJlbWFpbi5sZW5ndGggPT09IDEgJiYgIXRoaXMubWFyayAmJiAhdGhpcy5zdGF0KSB7XG4gICAgaWYgKCF0aGlzLm1hdGNoZXNbaW5kZXhdKVxuICAgICAgdGhpcy5tYXRjaGVzW2luZGV4XSA9IE9iamVjdC5jcmVhdGUobnVsbClcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICsrKSB7XG4gICAgICB2YXIgZSA9IG1hdGNoZWRFbnRyaWVzW2ldXG4gICAgICBpZiAocHJlZml4KSB7XG4gICAgICAgIGlmIChwcmVmaXguc2xpY2UoLTEpICE9PSAnLycpXG4gICAgICAgICAgZSA9IHByZWZpeCArICcvJyArIGVcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGUgPSBwcmVmaXggKyBlXG4gICAgICB9XG5cbiAgICAgIGlmIChlLmNoYXJBdCgwKSA9PT0gJy8nICYmICF0aGlzLm5vbW91bnQpIHtcbiAgICAgICAgZSA9IHBhdGguam9pbih0aGlzLnJvb3QsIGUpXG4gICAgICB9XG4gICAgICB0aGlzLl9lbWl0TWF0Y2goaW5kZXgsIGUpXG4gICAgfVxuICAgIC8vIFRoaXMgd2FzIHRoZSBsYXN0IG9uZSwgYW5kIG5vIHN0YXRzIHdlcmUgbmVlZGVkXG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBub3cgdGVzdCBhbGwgbWF0Y2hlZCBlbnRyaWVzIGFzIHN0YW5kLWlucyBmb3IgdGhhdCBwYXJ0XG4gIC8vIG9mIHRoZSBwYXR0ZXJuLlxuICByZW1haW4uc2hpZnQoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArKykge1xuICAgIHZhciBlID0gbWF0Y2hlZEVudHJpZXNbaV1cbiAgICB2YXIgbmV3UGF0dGVyblxuICAgIGlmIChwcmVmaXgpXG4gICAgICBuZXdQYXR0ZXJuID0gW3ByZWZpeCwgZV1cbiAgICBlbHNlXG4gICAgICBuZXdQYXR0ZXJuID0gW2VdXG4gICAgdGhpcy5fcHJvY2VzcyhuZXdQYXR0ZXJuLmNvbmNhdChyZW1haW4pLCBpbmRleCwgaW5HbG9iU3RhcilcbiAgfVxufVxuXG5cbkdsb2JTeW5jLnByb3RvdHlwZS5fZW1pdE1hdGNoID0gZnVuY3Rpb24gKGluZGV4LCBlKSB7XG4gIGlmIChpc0lnbm9yZWQodGhpcywgZSkpXG4gICAgcmV0dXJuXG5cbiAgdmFyIGFicyA9IHRoaXMuX21ha2VBYnMoZSlcblxuICBpZiAodGhpcy5tYXJrKVxuICAgIGUgPSB0aGlzLl9tYXJrKGUpXG5cbiAgaWYgKHRoaXMuYWJzb2x1dGUpIHtcbiAgICBlID0gYWJzXG4gIH1cblxuICBpZiAodGhpcy5tYXRjaGVzW2luZGV4XVtlXSlcbiAgICByZXR1cm5cblxuICBpZiAodGhpcy5ub2Rpcikge1xuICAgIHZhciBjID0gdGhpcy5jYWNoZVthYnNdXG4gICAgaWYgKGMgPT09ICdESVInIHx8IEFycmF5LmlzQXJyYXkoYykpXG4gICAgICByZXR1cm5cbiAgfVxuXG4gIHRoaXMubWF0Y2hlc1tpbmRleF1bZV0gPSB0cnVlXG5cbiAgaWYgKHRoaXMuc3RhdClcbiAgICB0aGlzLl9zdGF0KGUpXG59XG5cblxuR2xvYlN5bmMucHJvdG90eXBlLl9yZWFkZGlySW5HbG9iU3RhciA9IGZ1bmN0aW9uIChhYnMpIHtcbiAgLy8gZm9sbG93IGFsbCBzeW1saW5rZWQgZGlyZWN0b3JpZXMgZm9yZXZlclxuICAvLyBqdXN0IHByb2NlZWQgYXMgaWYgdGhpcyBpcyBhIG5vbi1nbG9ic3RhciBzaXR1YXRpb25cbiAgaWYgKHRoaXMuZm9sbG93KVxuICAgIHJldHVybiB0aGlzLl9yZWFkZGlyKGFicywgZmFsc2UpXG5cbiAgdmFyIGVudHJpZXNcbiAgdmFyIGxzdGF0XG4gIHZhciBzdGF0XG4gIHRyeSB7XG4gICAgbHN0YXQgPSBmcy5sc3RhdFN5bmMoYWJzKVxuICB9IGNhdGNoIChlcikge1xuICAgIGlmIChlci5jb2RlID09PSAnRU5PRU5UJykge1xuICAgICAgLy8gbHN0YXQgZmFpbGVkLCBkb2Vzbid0IGV4aXN0XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgfVxuXG4gIHZhciBpc1N5bSA9IGxzdGF0ICYmIGxzdGF0LmlzU3ltYm9saWNMaW5rKClcbiAgdGhpcy5zeW1saW5rc1thYnNdID0gaXNTeW1cblxuICAvLyBJZiBpdCdzIG5vdCBhIHN5bWxpbmsgb3IgYSBkaXIsIHRoZW4gaXQncyBkZWZpbml0ZWx5IGEgcmVndWxhciBmaWxlLlxuICAvLyBkb24ndCBib3RoZXIgZG9pbmcgYSByZWFkZGlyIGluIHRoYXQgY2FzZS5cbiAgaWYgKCFpc1N5bSAmJiBsc3RhdCAmJiAhbHN0YXQuaXNEaXJlY3RvcnkoKSlcbiAgICB0aGlzLmNhY2hlW2Fic10gPSAnRklMRSdcbiAgZWxzZVxuICAgIGVudHJpZXMgPSB0aGlzLl9yZWFkZGlyKGFicywgZmFsc2UpXG5cbiAgcmV0dXJuIGVudHJpZXNcbn1cblxuR2xvYlN5bmMucHJvdG90eXBlLl9yZWFkZGlyID0gZnVuY3Rpb24gKGFicywgaW5HbG9iU3Rhcikge1xuICB2YXIgZW50cmllc1xuXG4gIGlmIChpbkdsb2JTdGFyICYmICFvd25Qcm9wKHRoaXMuc3ltbGlua3MsIGFicykpXG4gICAgcmV0dXJuIHRoaXMuX3JlYWRkaXJJbkdsb2JTdGFyKGFicylcblxuICBpZiAob3duUHJvcCh0aGlzLmNhY2hlLCBhYnMpKSB7XG4gICAgdmFyIGMgPSB0aGlzLmNhY2hlW2Fic11cbiAgICBpZiAoIWMgfHwgYyA9PT0gJ0ZJTEUnKVxuICAgICAgcmV0dXJuIG51bGxcblxuICAgIGlmIChBcnJheS5pc0FycmF5KGMpKVxuICAgICAgcmV0dXJuIGNcbiAgfVxuXG4gIHRyeSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRkaXJFbnRyaWVzKGFicywgZnMucmVhZGRpclN5bmMoYWJzKSlcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICB0aGlzLl9yZWFkZGlyRXJyb3IoYWJzLCBlcilcbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG5cbkdsb2JTeW5jLnByb3RvdHlwZS5fcmVhZGRpckVudHJpZXMgPSBmdW5jdGlvbiAoYWJzLCBlbnRyaWVzKSB7XG4gIC8vIGlmIHdlIGhhdmVuJ3QgYXNrZWQgdG8gc3RhdCBldmVyeXRoaW5nLCB0aGVuIGp1c3RcbiAgLy8gYXNzdW1lIHRoYXQgZXZlcnl0aGluZyBpbiB0aGVyZSBleGlzdHMsIHNvIHdlIGNhbiBhdm9pZFxuICAvLyBoYXZpbmcgdG8gc3RhdCBpdCBhIHNlY29uZCB0aW1lLlxuICBpZiAoIXRoaXMubWFyayAmJiAhdGhpcy5zdGF0KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbnRyaWVzLmxlbmd0aDsgaSArKykge1xuICAgICAgdmFyIGUgPSBlbnRyaWVzW2ldXG4gICAgICBpZiAoYWJzID09PSAnLycpXG4gICAgICAgIGUgPSBhYnMgKyBlXG4gICAgICBlbHNlXG4gICAgICAgIGUgPSBhYnMgKyAnLycgKyBlXG4gICAgICB0aGlzLmNhY2hlW2VdID0gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIHRoaXMuY2FjaGVbYWJzXSA9IGVudHJpZXNcblxuICAvLyBtYXJrIGFuZCBjYWNoZSBkaXItbmVzc1xuICByZXR1cm4gZW50cmllc1xufVxuXG5HbG9iU3luYy5wcm90b3R5cGUuX3JlYWRkaXJFcnJvciA9IGZ1bmN0aW9uIChmLCBlcikge1xuICAvLyBoYW5kbGUgZXJyb3JzLCBhbmQgY2FjaGUgdGhlIGluZm9ybWF0aW9uXG4gIHN3aXRjaCAoZXIuY29kZSkge1xuICAgIGNhc2UgJ0VOT1RTVVAnOiAvLyBodHRwczovL2dpdGh1Yi5jb20vaXNhYWNzL25vZGUtZ2xvYi9pc3N1ZXMvMjA1XG4gICAgY2FzZSAnRU5PVERJUic6IC8vIHRvdGFsbHkgbm9ybWFsLiBtZWFucyBpdCAqZG9lcyogZXhpc3QuXG4gICAgICB2YXIgYWJzID0gdGhpcy5fbWFrZUFicyhmKVxuICAgICAgdGhpcy5jYWNoZVthYnNdID0gJ0ZJTEUnXG4gICAgICBpZiAoYWJzID09PSB0aGlzLmN3ZEFicykge1xuICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoZXIuY29kZSArICcgaW52YWxpZCBjd2QgJyArIHRoaXMuY3dkKVxuICAgICAgICBlcnJvci5wYXRoID0gdGhpcy5jd2RcbiAgICAgICAgZXJyb3IuY29kZSA9IGVyLmNvZGVcbiAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgIH1cbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlICdFTk9FTlQnOiAvLyBub3QgdGVycmlibHkgdW51c3VhbFxuICAgIGNhc2UgJ0VMT09QJzpcbiAgICBjYXNlICdFTkFNRVRPT0xPTkcnOlxuICAgIGNhc2UgJ1VOS05PV04nOlxuICAgICAgdGhpcy5jYWNoZVt0aGlzLl9tYWtlQWJzKGYpXSA9IGZhbHNlXG4gICAgICBicmVha1xuXG4gICAgZGVmYXVsdDogLy8gc29tZSB1bnVzdWFsIGVycm9yLiAgVHJlYXQgYXMgZmFpbHVyZS5cbiAgICAgIHRoaXMuY2FjaGVbdGhpcy5fbWFrZUFicyhmKV0gPSBmYWxzZVxuICAgICAgaWYgKHRoaXMuc3RyaWN0KVxuICAgICAgICB0aHJvdyBlclxuICAgICAgaWYgKCF0aGlzLnNpbGVudClcbiAgICAgICAgY29uc29sZS5lcnJvcignZ2xvYiBlcnJvcicsIGVyKVxuICAgICAgYnJlYWtcbiAgfVxufVxuXG5HbG9iU3luYy5wcm90b3R5cGUuX3Byb2Nlc3NHbG9iU3RhciA9IGZ1bmN0aW9uIChwcmVmaXgsIHJlYWQsIGFicywgcmVtYWluLCBpbmRleCwgaW5HbG9iU3Rhcikge1xuXG4gIHZhciBlbnRyaWVzID0gdGhpcy5fcmVhZGRpcihhYnMsIGluR2xvYlN0YXIpXG5cbiAgLy8gbm8gZW50cmllcyBtZWFucyBub3QgYSBkaXIsIHNvIGl0IGNhbiBuZXZlciBoYXZlIG1hdGNoZXNcbiAgLy8gZm9vLnR4dC8qKiBkb2Vzbid0IG1hdGNoIGZvby50eHRcbiAgaWYgKCFlbnRyaWVzKVxuICAgIHJldHVyblxuXG4gIC8vIHRlc3Qgd2l0aG91dCB0aGUgZ2xvYnN0YXIsIGFuZCB3aXRoIGV2ZXJ5IGNoaWxkIGJvdGggYmVsb3dcbiAgLy8gYW5kIHJlcGxhY2luZyB0aGUgZ2xvYnN0YXIuXG4gIHZhciByZW1haW5XaXRob3V0R2xvYlN0YXIgPSByZW1haW4uc2xpY2UoMSlcbiAgdmFyIGdzcHJlZiA9IHByZWZpeCA/IFsgcHJlZml4IF0gOiBbXVxuICB2YXIgbm9HbG9iU3RhciA9IGdzcHJlZi5jb25jYXQocmVtYWluV2l0aG91dEdsb2JTdGFyKVxuXG4gIC8vIHRoZSBub0dsb2JTdGFyIHBhdHRlcm4gZXhpdHMgdGhlIGluR2xvYlN0YXIgc3RhdGVcbiAgdGhpcy5fcHJvY2Vzcyhub0dsb2JTdGFyLCBpbmRleCwgZmFsc2UpXG5cbiAgdmFyIGxlbiA9IGVudHJpZXMubGVuZ3RoXG4gIHZhciBpc1N5bSA9IHRoaXMuc3ltbGlua3NbYWJzXVxuXG4gIC8vIElmIGl0J3MgYSBzeW1saW5rLCBhbmQgd2UncmUgaW4gYSBnbG9ic3RhciwgdGhlbiBzdG9wXG4gIGlmIChpc1N5bSAmJiBpbkdsb2JTdGFyKVxuICAgIHJldHVyblxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgZSA9IGVudHJpZXNbaV1cbiAgICBpZiAoZS5jaGFyQXQoMCkgPT09ICcuJyAmJiAhdGhpcy5kb3QpXG4gICAgICBjb250aW51ZVxuXG4gICAgLy8gdGhlc2UgdHdvIGNhc2VzIGVudGVyIHRoZSBpbkdsb2JTdGFyIHN0YXRlXG4gICAgdmFyIGluc3RlYWQgPSBnc3ByZWYuY29uY2F0KGVudHJpZXNbaV0sIHJlbWFpbldpdGhvdXRHbG9iU3RhcilcbiAgICB0aGlzLl9wcm9jZXNzKGluc3RlYWQsIGluZGV4LCB0cnVlKVxuXG4gICAgdmFyIGJlbG93ID0gZ3NwcmVmLmNvbmNhdChlbnRyaWVzW2ldLCByZW1haW4pXG4gICAgdGhpcy5fcHJvY2VzcyhiZWxvdywgaW5kZXgsIHRydWUpXG4gIH1cbn1cblxuR2xvYlN5bmMucHJvdG90eXBlLl9wcm9jZXNzU2ltcGxlID0gZnVuY3Rpb24gKHByZWZpeCwgaW5kZXgpIHtcbiAgLy8gWFhYIHJldmlldyB0aGlzLiAgU2hvdWxkbid0IGl0IGJlIGRvaW5nIHRoZSBtb3VudGluZyBldGNcbiAgLy8gYmVmb3JlIGRvaW5nIHN0YXQ/ICBraW5kYSB3ZWlyZD9cbiAgdmFyIGV4aXN0cyA9IHRoaXMuX3N0YXQocHJlZml4KVxuXG4gIGlmICghdGhpcy5tYXRjaGVzW2luZGV4XSlcbiAgICB0aGlzLm1hdGNoZXNbaW5kZXhdID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuXG4gIC8vIElmIGl0IGRvZXNuJ3QgZXhpc3QsIHRoZW4ganVzdCBtYXJrIHRoZSBsYWNrIG9mIHJlc3VsdHNcbiAgaWYgKCFleGlzdHMpXG4gICAgcmV0dXJuXG5cbiAgaWYgKHByZWZpeCAmJiBpc0Fic29sdXRlKHByZWZpeCkgJiYgIXRoaXMubm9tb3VudCkge1xuICAgIHZhciB0cmFpbCA9IC9bXFwvXFxcXF0kLy50ZXN0KHByZWZpeClcbiAgICBpZiAocHJlZml4LmNoYXJBdCgwKSA9PT0gJy8nKSB7XG4gICAgICBwcmVmaXggPSBwYXRoLmpvaW4odGhpcy5yb290LCBwcmVmaXgpXG4gICAgfSBlbHNlIHtcbiAgICAgIHByZWZpeCA9IHBhdGgucmVzb2x2ZSh0aGlzLnJvb3QsIHByZWZpeClcbiAgICAgIGlmICh0cmFpbClcbiAgICAgICAgcHJlZml4ICs9ICcvJ1xuICAgIH1cbiAgfVxuXG4gIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInKVxuICAgIHByZWZpeCA9IHByZWZpeC5yZXBsYWNlKC9cXFxcL2csICcvJylcblxuICAvLyBNYXJrIHRoaXMgYXMgYSBtYXRjaFxuICB0aGlzLl9lbWl0TWF0Y2goaW5kZXgsIHByZWZpeClcbn1cblxuLy8gUmV0dXJucyBlaXRoZXIgJ0RJUicsICdGSUxFJywgb3IgZmFsc2Vcbkdsb2JTeW5jLnByb3RvdHlwZS5fc3RhdCA9IGZ1bmN0aW9uIChmKSB7XG4gIHZhciBhYnMgPSB0aGlzLl9tYWtlQWJzKGYpXG4gIHZhciBuZWVkRGlyID0gZi5zbGljZSgtMSkgPT09ICcvJ1xuXG4gIGlmIChmLmxlbmd0aCA+IHRoaXMubWF4TGVuZ3RoKVxuICAgIHJldHVybiBmYWxzZVxuXG4gIGlmICghdGhpcy5zdGF0ICYmIG93blByb3AodGhpcy5jYWNoZSwgYWJzKSkge1xuICAgIHZhciBjID0gdGhpcy5jYWNoZVthYnNdXG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShjKSlcbiAgICAgIGMgPSAnRElSJ1xuXG4gICAgLy8gSXQgZXhpc3RzLCBidXQgbWF5YmUgbm90IGhvdyB3ZSBuZWVkIGl0XG4gICAgaWYgKCFuZWVkRGlyIHx8IGMgPT09ICdESVInKVxuICAgICAgcmV0dXJuIGNcblxuICAgIGlmIChuZWVkRGlyICYmIGMgPT09ICdGSUxFJylcbiAgICAgIHJldHVybiBmYWxzZVxuXG4gICAgLy8gb3RoZXJ3aXNlIHdlIGhhdmUgdG8gc3RhdCwgYmVjYXVzZSBtYXliZSBjPXRydWVcbiAgICAvLyBpZiB3ZSBrbm93IGl0IGV4aXN0cywgYnV0IG5vdCB3aGF0IGl0IGlzLlxuICB9XG5cbiAgdmFyIGV4aXN0c1xuICB2YXIgc3RhdCA9IHRoaXMuc3RhdENhY2hlW2Fic11cbiAgaWYgKCFzdGF0KSB7XG4gICAgdmFyIGxzdGF0XG4gICAgdHJ5IHtcbiAgICAgIGxzdGF0ID0gZnMubHN0YXRTeW5jKGFicylcbiAgICB9IGNhdGNoIChlcikge1xuICAgICAgaWYgKGVyICYmIChlci5jb2RlID09PSAnRU5PRU5UJyB8fCBlci5jb2RlID09PSAnRU5PVERJUicpKSB7XG4gICAgICAgIHRoaXMuc3RhdENhY2hlW2Fic10gPSBmYWxzZVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobHN0YXQgJiYgbHN0YXQuaXNTeW1ib2xpY0xpbmsoKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RhdCA9IGZzLnN0YXRTeW5jKGFicylcbiAgICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICAgIHN0YXQgPSBsc3RhdFxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ID0gbHN0YXRcbiAgICB9XG4gIH1cblxuICB0aGlzLnN0YXRDYWNoZVthYnNdID0gc3RhdFxuXG4gIHZhciBjID0gdHJ1ZVxuICBpZiAoc3RhdClcbiAgICBjID0gc3RhdC5pc0RpcmVjdG9yeSgpID8gJ0RJUicgOiAnRklMRSdcblxuICB0aGlzLmNhY2hlW2Fic10gPSB0aGlzLmNhY2hlW2Fic10gfHwgY1xuXG4gIGlmIChuZWVkRGlyICYmIGMgPT09ICdGSUxFJylcbiAgICByZXR1cm4gZmFsc2VcblxuICByZXR1cm4gY1xufVxuXG5HbG9iU3luYy5wcm90b3R5cGUuX21hcmsgPSBmdW5jdGlvbiAocCkge1xuICByZXR1cm4gY29tbW9uLm1hcmsodGhpcywgcClcbn1cblxuR2xvYlN5bmMucHJvdG90eXBlLl9tYWtlQWJzID0gZnVuY3Rpb24gKGYpIHtcbiAgcmV0dXJuIGNvbW1vbi5tYWtlQWJzKHRoaXMsIGYpXG59XG4iLCJ2YXIgd3JhcHB5ID0gcmVxdWlyZSgnd3JhcHB5JylcbnZhciByZXFzID0gT2JqZWN0LmNyZWF0ZShudWxsKVxudmFyIG9uY2UgPSByZXF1aXJlKCdvbmNlJylcblxubW9kdWxlLmV4cG9ydHMgPSB3cmFwcHkoaW5mbGlnaHQpXG5cbmZ1bmN0aW9uIGluZmxpZ2h0IChrZXksIGNiKSB7XG4gIGlmIChyZXFzW2tleV0pIHtcbiAgICByZXFzW2tleV0ucHVzaChjYilcbiAgICByZXR1cm4gbnVsbFxuICB9IGVsc2Uge1xuICAgIHJlcXNba2V5XSA9IFtjYl1cbiAgICByZXR1cm4gbWFrZXJlcyhrZXkpXG4gIH1cbn1cblxuZnVuY3Rpb24gbWFrZXJlcyAoa2V5KSB7XG4gIHJldHVybiBvbmNlKGZ1bmN0aW9uIFJFUyAoKSB7XG4gICAgdmFyIGNicyA9IHJlcXNba2V5XVxuICAgIHZhciBsZW4gPSBjYnMubGVuZ3RoXG4gICAgdmFyIGFyZ3MgPSBzbGljZShhcmd1bWVudHMpXG5cbiAgICAvLyBYWFggSXQncyBzb21ld2hhdCBhbWJpZ3VvdXMgd2hldGhlciBhIG5ldyBjYWxsYmFjayBhZGRlZCBpbiB0aGlzXG4gICAgLy8gcGFzcyBzaG91bGQgYmUgcXVldWVkIGZvciBsYXRlciBleGVjdXRpb24gaWYgc29tZXRoaW5nIGluIHRoZVxuICAgIC8vIGxpc3Qgb2YgY2FsbGJhY2tzIHRocm93cywgb3IgaWYgaXQgc2hvdWxkIGp1c3QgYmUgZGlzY2FyZGVkLlxuICAgIC8vIEhvd2V2ZXIsIGl0J3Mgc3VjaCBhbiBlZGdlIGNhc2UgdGhhdCBpdCBoYXJkbHkgbWF0dGVycywgYW5kIGVpdGhlclxuICAgIC8vIGNob2ljZSBpcyBsaWtlbHkgYXMgc3VycHJpc2luZyBhcyB0aGUgb3RoZXIuXG4gICAgLy8gQXMgaXQgaGFwcGVucywgd2UgZG8gZ28gYWhlYWQgYW5kIHNjaGVkdWxlIGl0IGZvciBsYXRlciBleGVjdXRpb24uXG4gICAgdHJ5IHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY2JzW2ldLmFwcGx5KG51bGwsIGFyZ3MpXG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChjYnMubGVuZ3RoID4gbGVuKSB7XG4gICAgICAgIC8vIGFkZGVkIG1vcmUgaW4gdGhlIGludGVyaW0uXG4gICAgICAgIC8vIGRlLXphbGdvLCBqdXN0IGluIGNhc2UsIGJ1dCBkb24ndCBjYWxsIGFnYWluLlxuICAgICAgICBjYnMuc3BsaWNlKDAsIGxlbilcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgUkVTLmFwcGx5KG51bGwsIGFyZ3MpXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGUgcmVxc1trZXldXG4gICAgICB9XG4gICAgfVxuICB9KVxufVxuXG5mdW5jdGlvbiBzbGljZSAoYXJncykge1xuICB2YXIgbGVuZ3RoID0gYXJncy5sZW5ndGhcbiAgdmFyIGFycmF5ID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSBhcnJheVtpXSA9IGFyZ3NbaV1cbiAgcmV0dXJuIGFycmF5XG59XG4iLCJ0cnkge1xuICB2YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbiAgaWYgKHR5cGVvZiB1dGlsLmluaGVyaXRzICE9PSAnZnVuY3Rpb24nKSB0aHJvdyAnJztcbiAgbW9kdWxlLmV4cG9ydHMgPSB1dGlsLmluaGVyaXRzO1xufSBjYXRjaCAoZSkge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vaW5oZXJpdHNfYnJvd3Nlci5qcycpO1xufVxuIiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmopIHtcblx0aWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYW4gb2JqZWN0Jyk7XG5cdH1cblxuXHR2YXIgcmV0ID0ge307XG5cblx0Zm9yICh2YXIga2V5IGluIG9iaikge1xuXHRcdHZhciB2YWwgPSBvYmpba2V5XTtcblx0XHRyZXRbdmFsXSA9IGtleTtcblx0fVxuXG5cdHJldHVybiByZXQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIG51bWJlcklzTmFuID0gcmVxdWlyZSgnbnVtYmVyLWlzLW5hbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh4KSB7XG5cdGlmIChudW1iZXJJc05hbih4KSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvaW8uanMvYmxvYi9jZmY3MzAwYTU3OGJlMWIxMDAwMWYyZDk2N2FhZWRjODhhZWU2NDAyL2xpYi9yZWFkbGluZS5qcyNMMTM2OVxuXG5cdC8vIGNvZGUgcG9pbnRzIGFyZSBkZXJpdmVkIGZyb206XG5cdC8vIGh0dHA6Ly93d3cudW5peC5vcmcvUHVibGljL1VOSURBVEEvRWFzdEFzaWFuV2lkdGgudHh0XG5cdGlmICh4ID49IDB4MTEwMCAmJiAoXG5cdFx0eCA8PSAweDExNWYgfHwgIC8vIEhhbmd1bCBKYW1vXG5cdFx0MHgyMzI5ID09PSB4IHx8IC8vIExFRlQtUE9JTlRJTkcgQU5HTEUgQlJBQ0tFVFxuXHRcdDB4MjMyYSA9PT0geCB8fCAvLyBSSUdIVC1QT0lOVElORyBBTkdMRSBCUkFDS0VUXG5cdFx0Ly8gQ0pLIFJhZGljYWxzIFN1cHBsZW1lbnQgLi4gRW5jbG9zZWQgQ0pLIExldHRlcnMgYW5kIE1vbnRoc1xuXHRcdCgweDJlODAgPD0geCAmJiB4IDw9IDB4MzI0NyAmJiB4ICE9PSAweDMwM2YpIHx8XG5cdFx0Ly8gRW5jbG9zZWQgQ0pLIExldHRlcnMgYW5kIE1vbnRocyAuLiBDSksgVW5pZmllZCBJZGVvZ3JhcGhzIEV4dGVuc2lvbiBBXG5cdFx0MHgzMjUwIDw9IHggJiYgeCA8PSAweDRkYmYgfHxcblx0XHQvLyBDSksgVW5pZmllZCBJZGVvZ3JhcGhzIC4uIFlpIFJhZGljYWxzXG5cdFx0MHg0ZTAwIDw9IHggJiYgeCA8PSAweGE0YzYgfHxcblx0XHQvLyBIYW5ndWwgSmFtbyBFeHRlbmRlZC1BXG5cdFx0MHhhOTYwIDw9IHggJiYgeCA8PSAweGE5N2MgfHxcblx0XHQvLyBIYW5ndWwgU3lsbGFibGVzXG5cdFx0MHhhYzAwIDw9IHggJiYgeCA8PSAweGQ3YTMgfHxcblx0XHQvLyBDSksgQ29tcGF0aWJpbGl0eSBJZGVvZ3JhcGhzXG5cdFx0MHhmOTAwIDw9IHggJiYgeCA8PSAweGZhZmYgfHxcblx0XHQvLyBWZXJ0aWNhbCBGb3Jtc1xuXHRcdDB4ZmUxMCA8PSB4ICYmIHggPD0gMHhmZTE5IHx8XG5cdFx0Ly8gQ0pLIENvbXBhdGliaWxpdHkgRm9ybXMgLi4gU21hbGwgRm9ybSBWYXJpYW50c1xuXHRcdDB4ZmUzMCA8PSB4ICYmIHggPD0gMHhmZTZiIHx8XG5cdFx0Ly8gSGFsZndpZHRoIGFuZCBGdWxsd2lkdGggRm9ybXNcblx0XHQweGZmMDEgPD0geCAmJiB4IDw9IDB4ZmY2MCB8fFxuXHRcdDB4ZmZlMCA8PSB4ICYmIHggPD0gMHhmZmU2IHx8XG5cdFx0Ly8gS2FuYSBTdXBwbGVtZW50XG5cdFx0MHgxYjAwMCA8PSB4ICYmIHggPD0gMHgxYjAwMSB8fFxuXHRcdC8vIEVuY2xvc2VkIElkZW9ncmFwaGljIFN1cHBsZW1lbnRcblx0XHQweDFmMjAwIDw9IHggJiYgeCA8PSAweDFmMjUxIHx8XG5cdFx0Ly8gQ0pLIFVuaWZpZWQgSWRlb2dyYXBocyBFeHRlbnNpb24gQiAuLiBUZXJ0aWFyeSBJZGVvZ3JhcGhpYyBQbGFuZVxuXHRcdDB4MjAwMDAgPD0geCAmJiB4IDw9IDB4M2ZmZmQpKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRyZXR1cm4gZmFsc2U7XG59XG4iLCJcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGJ5dGVzKVxue1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZShpIDwgYnl0ZXMubGVuZ3RoKVxuICAgIHtcbiAgICAgICAgaWYoICAgICAoLy8gQVNDSUlcbiAgICAgICAgICAgICAgICAgICAgYnl0ZXNbaV0gPT0gMHgwOSB8fFxuICAgICAgICAgICAgICAgICAgICBieXRlc1tpXSA9PSAweDBBIHx8XG4gICAgICAgICAgICAgICAgICAgIGJ5dGVzW2ldID09IDB4MEQgfHxcbiAgICAgICAgICAgICAgICAgICAgKDB4MjAgPD0gYnl0ZXNbaV0gJiYgYnl0ZXNbaV0gPD0gMHg3RSlcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGlmKCAgICAgKC8vIG5vbi1vdmVybG9uZyAyLWJ5dGVcbiAgICAgICAgICAgICAgICAgICAgKDB4QzIgPD0gYnl0ZXNbaV0gJiYgYnl0ZXNbaV0gPD0gMHhERikgJiZcbiAgICAgICAgICAgICAgICAgICAgKDB4ODAgPD0gYnl0ZXNbaSsxXSAmJiBieXRlc1tpKzFdIDw9IDB4QkYpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgICBpICs9IDI7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICBpZiggICAgICgvLyBleGNsdWRpbmcgb3ZlcmxvbmdzXG4gICAgICAgICAgICAgICAgICAgIGJ5dGVzW2ldID09IDB4RTAgJiZcbiAgICAgICAgICAgICAgICAgICAgKDB4QTAgPD0gYnl0ZXNbaSArIDFdICYmIGJ5dGVzW2kgKyAxXSA8PSAweEJGKSAmJlxuICAgICAgICAgICAgICAgICAgICAoMHg4MCA8PSBieXRlc1tpICsgMl0gJiYgYnl0ZXNbaSArIDJdIDw9IDB4QkYpXG4gICAgICAgICAgICAgICAgKSB8fFxuICAgICAgICAgICAgICAgICgvLyBzdHJhaWdodCAzLWJ5dGVcbiAgICAgICAgICAgICAgICAgKCgweEUxIDw9IGJ5dGVzW2ldICYmIGJ5dGVzW2ldIDw9IDB4RUMpIHx8XG4gICAgICAgICAgICAgICAgICBieXRlc1tpXSA9PSAweEVFIHx8XG4gICAgICAgICAgICAgICAgICBieXRlc1tpXSA9PSAweEVGKSAmJlxuICAgICAgICAgICAgICAgICAoMHg4MCA8PSBieXRlc1tpICsgMV0gJiYgYnl0ZXNbaSsxXSA8PSAweEJGKSAmJlxuICAgICAgICAgICAgICAgICAoMHg4MCA8PSBieXRlc1tpKzJdICYmIGJ5dGVzW2krMl0gPD0gMHhCRilcbiAgICAgICAgICAgICAgICApIHx8XG4gICAgICAgICAgICAgICAgKC8vIGV4Y2x1ZGluZyBzdXJyb2dhdGVzXG4gICAgICAgICAgICAgICAgIGJ5dGVzW2ldID09IDB4RUQgJiZcbiAgICAgICAgICAgICAgICAgKDB4ODAgPD0gYnl0ZXNbaSsxXSAmJiBieXRlc1tpKzFdIDw9IDB4OUYpICYmXG4gICAgICAgICAgICAgICAgICgweDgwIDw9IGJ5dGVzW2krMl0gJiYgYnl0ZXNbaSsyXSA8PSAweEJGKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgaSArPSAzO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgaWYoICAgICAoLy8gcGxhbmVzIDEtM1xuICAgICAgICAgICAgICAgICAgICBieXRlc1tpXSA9PSAweEYwICYmXG4gICAgICAgICAgICAgICAgICAgICgweDkwIDw9IGJ5dGVzW2kgKyAxXSAmJiBieXRlc1tpICsgMV0gPD0gMHhCRikgJiZcbiAgICAgICAgICAgICAgICAgICAgKDB4ODAgPD0gYnl0ZXNbaSArIDJdICYmIGJ5dGVzW2kgKyAyXSA8PSAweEJGKSAmJlxuICAgICAgICAgICAgICAgICAgICAoMHg4MCA8PSBieXRlc1tpICsgM10gJiYgYnl0ZXNbaSArIDNdIDw9IDB4QkYpXG4gICAgICAgICAgICAgICAgKSB8fFxuICAgICAgICAgICAgICAgICgvLyBwbGFuZXMgNC0xNVxuICAgICAgICAgICAgICAgICAoMHhGMSA8PSBieXRlc1tpXSAmJiBieXRlc1tpXSA8PSAweEYzKSAmJlxuICAgICAgICAgICAgICAgICAoMHg4MCA8PSBieXRlc1tpICsgMV0gJiYgYnl0ZXNbaSArIDFdIDw9IDB4QkYpICYmXG4gICAgICAgICAgICAgICAgICgweDgwIDw9IGJ5dGVzW2kgKyAyXSAmJiBieXRlc1tpICsgMl0gPD0gMHhCRikgJiZcbiAgICAgICAgICAgICAgICAgKDB4ODAgPD0gYnl0ZXNbaSArIDNdICYmIGJ5dGVzW2kgKyAzXSA8PSAweEJGKVxuICAgICAgICAgICAgICAgICkgfHxcbiAgICAgICAgICAgICAgICAoLy8gcGxhbmUgMTZcbiAgICAgICAgICAgICAgICAgYnl0ZXNbaV0gPT0gMHhGNCAmJlxuICAgICAgICAgICAgICAgICAoMHg4MCA8PSBieXRlc1tpICsgMV0gJiYgYnl0ZXNbaSArIDFdIDw9IDB4OEYpICYmXG4gICAgICAgICAgICAgICAgICgweDgwIDw9IGJ5dGVzW2kgKyAyXSAmJiBieXRlc1tpICsgMl0gPD0gMHhCRikgJiZcbiAgICAgICAgICAgICAgICAgKDB4ODAgPD0gYnl0ZXNbaSArIDNdICYmIGJ5dGVzW2kgKyAzXSA8PSAweEJGKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgaSArPSA0O1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGludmVydEt2ID0gcmVxdWlyZSgnaW52ZXJ0LWt2Jyk7XG52YXIgYWxsID0gcmVxdWlyZSgnLi9sY2lkLmpzb24nKTtcbnZhciBpbnZlcnRlZCA9IGludmVydEt2KGFsbCk7XG5cbmV4cG9ydHMuZnJvbSA9IGZ1bmN0aW9uIChsY2lkQ29kZSkge1xuXHRpZiAodHlwZW9mIGxjaWRDb2RlICE9PSAnbnVtYmVyJykge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGEgbnVtYmVyJyk7XG5cdH1cblxuXHRyZXR1cm4gaW52ZXJ0ZWRbbGNpZENvZGVdO1xufTtcblxuZXhwb3J0cy50byA9IGZ1bmN0aW9uIChsb2NhbGVJZCkge1xuXHRpZiAodHlwZW9mIGxvY2FsZUlkICE9PSAnc3RyaW5nJykge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGEgc3RyaW5nJyk7XG5cdH1cblxuXHRyZXR1cm4gYWxsW2xvY2FsZUlkXTtcbn07XG5cbmV4cG9ydHMuYWxsID0gYWxsO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBtaW5pbWF0Y2hcbm1pbmltYXRjaC5NaW5pbWF0Y2ggPSBNaW5pbWF0Y2hcblxudmFyIHBhdGggPSB7IHNlcDogJy8nIH1cbnRyeSB7XG4gIHBhdGggPSByZXF1aXJlKCdwYXRoJylcbn0gY2F0Y2ggKGVyKSB7fVxuXG52YXIgR0xPQlNUQVIgPSBtaW5pbWF0Y2guR0xPQlNUQVIgPSBNaW5pbWF0Y2guR0xPQlNUQVIgPSB7fVxudmFyIGV4cGFuZCA9IHJlcXVpcmUoJ2JyYWNlLWV4cGFuc2lvbicpXG5cbnZhciBwbFR5cGVzID0ge1xuICAnISc6IHsgb3BlbjogJyg/Oig/ISg/OicsIGNsb3NlOiAnKSlbXi9dKj8pJ30sXG4gICc/JzogeyBvcGVuOiAnKD86JywgY2xvc2U6ICcpPycgfSxcbiAgJysnOiB7IG9wZW46ICcoPzonLCBjbG9zZTogJykrJyB9LFxuICAnKic6IHsgb3BlbjogJyg/OicsIGNsb3NlOiAnKSonIH0sXG4gICdAJzogeyBvcGVuOiAnKD86JywgY2xvc2U6ICcpJyB9XG59XG5cbi8vIGFueSBzaW5nbGUgdGhpbmcgb3RoZXIgdGhhbiAvXG4vLyBkb24ndCBuZWVkIHRvIGVzY2FwZSAvIHdoZW4gdXNpbmcgbmV3IFJlZ0V4cCgpXG52YXIgcW1hcmsgPSAnW14vXSdcblxuLy8gKiA9PiBhbnkgbnVtYmVyIG9mIGNoYXJhY3RlcnNcbnZhciBzdGFyID0gcW1hcmsgKyAnKj8nXG5cbi8vICoqIHdoZW4gZG90cyBhcmUgYWxsb3dlZC4gIEFueXRoaW5nIGdvZXMsIGV4Y2VwdCAuLiBhbmQgLlxuLy8gbm90ICheIG9yIC8gZm9sbG93ZWQgYnkgb25lIG9yIHR3byBkb3RzIGZvbGxvd2VkIGJ5ICQgb3IgLyksXG4vLyBmb2xsb3dlZCBieSBhbnl0aGluZywgYW55IG51bWJlciBvZiB0aW1lcy5cbnZhciB0d29TdGFyRG90ID0gJyg/Oig/ISg/OlxcXFxcXC98XikoPzpcXFxcLnsxLDJ9KSgkfFxcXFxcXC8pKS4pKj8nXG5cbi8vIG5vdCBhIF4gb3IgLyBmb2xsb3dlZCBieSBhIGRvdCxcbi8vIGZvbGxvd2VkIGJ5IGFueXRoaW5nLCBhbnkgbnVtYmVyIG9mIHRpbWVzLlxudmFyIHR3b1N0YXJOb0RvdCA9ICcoPzooPyEoPzpcXFxcXFwvfF4pXFxcXC4pLikqPydcblxuLy8gY2hhcmFjdGVycyB0aGF0IG5lZWQgdG8gYmUgZXNjYXBlZCBpbiBSZWdFeHAuXG52YXIgcmVTcGVjaWFscyA9IGNoYXJTZXQoJygpLip7fSs/W11eJFxcXFwhJylcblxuLy8gXCJhYmNcIiAtPiB7IGE6dHJ1ZSwgYjp0cnVlLCBjOnRydWUgfVxuZnVuY3Rpb24gY2hhclNldCAocykge1xuICByZXR1cm4gcy5zcGxpdCgnJykucmVkdWNlKGZ1bmN0aW9uIChzZXQsIGMpIHtcbiAgICBzZXRbY10gPSB0cnVlXG4gICAgcmV0dXJuIHNldFxuICB9LCB7fSlcbn1cblxuLy8gbm9ybWFsaXplcyBzbGFzaGVzLlxudmFyIHNsYXNoU3BsaXQgPSAvXFwvKy9cblxubWluaW1hdGNoLmZpbHRlciA9IGZpbHRlclxuZnVuY3Rpb24gZmlsdGVyIChwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG4gIHJldHVybiBmdW5jdGlvbiAocCwgaSwgbGlzdCkge1xuICAgIHJldHVybiBtaW5pbWF0Y2gocCwgcGF0dGVybiwgb3B0aW9ucylcbiAgfVxufVxuXG5mdW5jdGlvbiBleHQgKGEsIGIpIHtcbiAgYSA9IGEgfHwge31cbiAgYiA9IGIgfHwge31cbiAgdmFyIHQgPSB7fVxuICBPYmplY3Qua2V5cyhiKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgdFtrXSA9IGJba11cbiAgfSlcbiAgT2JqZWN0LmtleXMoYSkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgIHRba10gPSBhW2tdXG4gIH0pXG4gIHJldHVybiB0XG59XG5cbm1pbmltYXRjaC5kZWZhdWx0cyA9IGZ1bmN0aW9uIChkZWYpIHtcbiAgaWYgKCFkZWYgfHwgIU9iamVjdC5rZXlzKGRlZikubGVuZ3RoKSByZXR1cm4gbWluaW1hdGNoXG5cbiAgdmFyIG9yaWcgPSBtaW5pbWF0Y2hcblxuICB2YXIgbSA9IGZ1bmN0aW9uIG1pbmltYXRjaCAocCwgcGF0dGVybiwgb3B0aW9ucykge1xuICAgIHJldHVybiBvcmlnLm1pbmltYXRjaChwLCBwYXR0ZXJuLCBleHQoZGVmLCBvcHRpb25zKSlcbiAgfVxuXG4gIG0uTWluaW1hdGNoID0gZnVuY3Rpb24gTWluaW1hdGNoIChwYXR0ZXJuLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBvcmlnLk1pbmltYXRjaChwYXR0ZXJuLCBleHQoZGVmLCBvcHRpb25zKSlcbiAgfVxuXG4gIHJldHVybiBtXG59XG5cbk1pbmltYXRjaC5kZWZhdWx0cyA9IGZ1bmN0aW9uIChkZWYpIHtcbiAgaWYgKCFkZWYgfHwgIU9iamVjdC5rZXlzKGRlZikubGVuZ3RoKSByZXR1cm4gTWluaW1hdGNoXG4gIHJldHVybiBtaW5pbWF0Y2guZGVmYXVsdHMoZGVmKS5NaW5pbWF0Y2hcbn1cblxuZnVuY3Rpb24gbWluaW1hdGNoIChwLCBwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgcGF0dGVybiAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdnbG9iIHBhdHRlcm4gc3RyaW5nIHJlcXVpcmVkJylcbiAgfVxuXG4gIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9XG5cbiAgLy8gc2hvcnRjdXQ6IGNvbW1lbnRzIG1hdGNoIG5vdGhpbmcuXG4gIGlmICghb3B0aW9ucy5ub2NvbW1lbnQgJiYgcGF0dGVybi5jaGFyQXQoMCkgPT09ICcjJykge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gXCJcIiBvbmx5IG1hdGNoZXMgXCJcIlxuICBpZiAocGF0dGVybi50cmltKCkgPT09ICcnKSByZXR1cm4gcCA9PT0gJydcblxuICByZXR1cm4gbmV3IE1pbmltYXRjaChwYXR0ZXJuLCBvcHRpb25zKS5tYXRjaChwKVxufVxuXG5mdW5jdGlvbiBNaW5pbWF0Y2ggKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE1pbmltYXRjaCkpIHtcbiAgICByZXR1cm4gbmV3IE1pbmltYXRjaChwYXR0ZXJuLCBvcHRpb25zKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBwYXR0ZXJuICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2dsb2IgcGF0dGVybiBzdHJpbmcgcmVxdWlyZWQnKVxuICB9XG5cbiAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge31cbiAgcGF0dGVybiA9IHBhdHRlcm4udHJpbSgpXG5cbiAgLy8gd2luZG93cyBzdXBwb3J0OiBuZWVkIHRvIHVzZSAvLCBub3QgXFxcbiAgaWYgKHBhdGguc2VwICE9PSAnLycpIHtcbiAgICBwYXR0ZXJuID0gcGF0dGVybi5zcGxpdChwYXRoLnNlcCkuam9pbignLycpXG4gIH1cblxuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zXG4gIHRoaXMuc2V0ID0gW11cbiAgdGhpcy5wYXR0ZXJuID0gcGF0dGVyblxuICB0aGlzLnJlZ2V4cCA9IG51bGxcbiAgdGhpcy5uZWdhdGUgPSBmYWxzZVxuICB0aGlzLmNvbW1lbnQgPSBmYWxzZVxuICB0aGlzLmVtcHR5ID0gZmFsc2VcblxuICAvLyBtYWtlIHRoZSBzZXQgb2YgcmVnZXhwcyBldGMuXG4gIHRoaXMubWFrZSgpXG59XG5cbk1pbmltYXRjaC5wcm90b3R5cGUuZGVidWcgPSBmdW5jdGlvbiAoKSB7fVxuXG5NaW5pbWF0Y2gucHJvdG90eXBlLm1ha2UgPSBtYWtlXG5mdW5jdGlvbiBtYWtlICgpIHtcbiAgLy8gZG9uJ3QgZG8gaXQgbW9yZSB0aGFuIG9uY2UuXG4gIGlmICh0aGlzLl9tYWRlKSByZXR1cm5cblxuICB2YXIgcGF0dGVybiA9IHRoaXMucGF0dGVyblxuICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9uc1xuXG4gIC8vIGVtcHR5IHBhdHRlcm5zIGFuZCBjb21tZW50cyBtYXRjaCBub3RoaW5nLlxuICBpZiAoIW9wdGlvbnMubm9jb21tZW50ICYmIHBhdHRlcm4uY2hhckF0KDApID09PSAnIycpIHtcbiAgICB0aGlzLmNvbW1lbnQgPSB0cnVlXG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKCFwYXR0ZXJuKSB7XG4gICAgdGhpcy5lbXB0eSA9IHRydWVcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIHN0ZXAgMTogZmlndXJlIG91dCBuZWdhdGlvbiwgZXRjLlxuICB0aGlzLnBhcnNlTmVnYXRlKClcblxuICAvLyBzdGVwIDI6IGV4cGFuZCBicmFjZXNcbiAgdmFyIHNldCA9IHRoaXMuZ2xvYlNldCA9IHRoaXMuYnJhY2VFeHBhbmQoKVxuXG4gIGlmIChvcHRpb25zLmRlYnVnKSB0aGlzLmRlYnVnID0gY29uc29sZS5lcnJvclxuXG4gIHRoaXMuZGVidWcodGhpcy5wYXR0ZXJuLCBzZXQpXG5cbiAgLy8gc3RlcCAzOiBub3cgd2UgaGF2ZSBhIHNldCwgc28gdHVybiBlYWNoIG9uZSBpbnRvIGEgc2VyaWVzIG9mIHBhdGgtcG9ydGlvblxuICAvLyBtYXRjaGluZyBwYXR0ZXJucy5cbiAgLy8gVGhlc2Ugd2lsbCBiZSByZWdleHBzLCBleGNlcHQgaW4gdGhlIGNhc2Ugb2YgXCIqKlwiLCB3aGljaCBpc1xuICAvLyBzZXQgdG8gdGhlIEdMT0JTVEFSIG9iamVjdCBmb3IgZ2xvYnN0YXIgYmVoYXZpb3IsXG4gIC8vIGFuZCB3aWxsIG5vdCBjb250YWluIGFueSAvIGNoYXJhY3RlcnNcbiAgc2V0ID0gdGhpcy5nbG9iUGFydHMgPSBzZXQubWFwKGZ1bmN0aW9uIChzKSB7XG4gICAgcmV0dXJuIHMuc3BsaXQoc2xhc2hTcGxpdClcbiAgfSlcblxuICB0aGlzLmRlYnVnKHRoaXMucGF0dGVybiwgc2V0KVxuXG4gIC8vIGdsb2IgLS0+IHJlZ2V4cHNcbiAgc2V0ID0gc2V0Lm1hcChmdW5jdGlvbiAocywgc2ksIHNldCkge1xuICAgIHJldHVybiBzLm1hcCh0aGlzLnBhcnNlLCB0aGlzKVxuICB9LCB0aGlzKVxuXG4gIHRoaXMuZGVidWcodGhpcy5wYXR0ZXJuLCBzZXQpXG5cbiAgLy8gZmlsdGVyIG91dCBldmVyeXRoaW5nIHRoYXQgZGlkbid0IGNvbXBpbGUgcHJvcGVybHkuXG4gIHNldCA9IHNldC5maWx0ZXIoZnVuY3Rpb24gKHMpIHtcbiAgICByZXR1cm4gcy5pbmRleE9mKGZhbHNlKSA9PT0gLTFcbiAgfSlcblxuICB0aGlzLmRlYnVnKHRoaXMucGF0dGVybiwgc2V0KVxuXG4gIHRoaXMuc2V0ID0gc2V0XG59XG5cbk1pbmltYXRjaC5wcm90b3R5cGUucGFyc2VOZWdhdGUgPSBwYXJzZU5lZ2F0ZVxuZnVuY3Rpb24gcGFyc2VOZWdhdGUgKCkge1xuICB2YXIgcGF0dGVybiA9IHRoaXMucGF0dGVyblxuICB2YXIgbmVnYXRlID0gZmFsc2VcbiAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnNcbiAgdmFyIG5lZ2F0ZU9mZnNldCA9IDBcblxuICBpZiAob3B0aW9ucy5ub25lZ2F0ZSkgcmV0dXJuXG5cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBwYXR0ZXJuLmxlbmd0aFxuICAgIDsgaSA8IGwgJiYgcGF0dGVybi5jaGFyQXQoaSkgPT09ICchJ1xuICAgIDsgaSsrKSB7XG4gICAgbmVnYXRlID0gIW5lZ2F0ZVxuICAgIG5lZ2F0ZU9mZnNldCsrXG4gIH1cblxuICBpZiAobmVnYXRlT2Zmc2V0KSB0aGlzLnBhdHRlcm4gPSBwYXR0ZXJuLnN1YnN0cihuZWdhdGVPZmZzZXQpXG4gIHRoaXMubmVnYXRlID0gbmVnYXRlXG59XG5cbi8vIEJyYWNlIGV4cGFuc2lvbjpcbi8vIGF7YixjfWQgLT4gYWJkIGFjZFxuLy8gYXtiLH1jIC0+IGFiYyBhY1xuLy8gYXswLi4zfWQgLT4gYTBkIGExZCBhMmQgYTNkXG4vLyBhe2IsY3tkLGV9Zn1nIC0+IGFiZyBhY2RmZyBhY2VmZ1xuLy8gYXtiLGN9ZHtlLGZ9ZyAtPiBhYmRlZyBhY2RlZyBhYmRlZyBhYmRmZ1xuLy9cbi8vIEludmFsaWQgc2V0cyBhcmUgbm90IGV4cGFuZGVkLlxuLy8gYXsyLi59YiAtPiBhezIuLn1iXG4vLyBhe2J9YyAtPiBhe2J9Y1xubWluaW1hdGNoLmJyYWNlRXhwYW5kID0gZnVuY3Rpb24gKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGJyYWNlRXhwYW5kKHBhdHRlcm4sIG9wdGlvbnMpXG59XG5cbk1pbmltYXRjaC5wcm90b3R5cGUuYnJhY2VFeHBhbmQgPSBicmFjZUV4cGFuZFxuXG5mdW5jdGlvbiBicmFjZUV4cGFuZCAocGF0dGVybiwgb3B0aW9ucykge1xuICBpZiAoIW9wdGlvbnMpIHtcbiAgICBpZiAodGhpcyBpbnN0YW5jZW9mIE1pbmltYXRjaCkge1xuICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9uc1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb25zID0ge31cbiAgICB9XG4gIH1cblxuICBwYXR0ZXJuID0gdHlwZW9mIHBhdHRlcm4gPT09ICd1bmRlZmluZWQnXG4gICAgPyB0aGlzLnBhdHRlcm4gOiBwYXR0ZXJuXG5cbiAgaWYgKHR5cGVvZiBwYXR0ZXJuID09PSAndW5kZWZpbmVkJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3VuZGVmaW5lZCBwYXR0ZXJuJylcbiAgfVxuXG4gIGlmIChvcHRpb25zLm5vYnJhY2UgfHxcbiAgICAhcGF0dGVybi5tYXRjaCgvXFx7LipcXH0vKSkge1xuICAgIC8vIHNob3J0Y3V0LiBubyBuZWVkIHRvIGV4cGFuZC5cbiAgICByZXR1cm4gW3BhdHRlcm5dXG4gIH1cblxuICByZXR1cm4gZXhwYW5kKHBhdHRlcm4pXG59XG5cbi8vIHBhcnNlIGEgY29tcG9uZW50IG9mIHRoZSBleHBhbmRlZCBzZXQuXG4vLyBBdCB0aGlzIHBvaW50LCBubyBwYXR0ZXJuIG1heSBjb250YWluIFwiL1wiIGluIGl0XG4vLyBzbyB3ZSdyZSBnb2luZyB0byByZXR1cm4gYSAyZCBhcnJheSwgd2hlcmUgZWFjaCBlbnRyeSBpcyB0aGUgZnVsbFxuLy8gcGF0dGVybiwgc3BsaXQgb24gJy8nLCBhbmQgdGhlbiB0dXJuZWQgaW50byBhIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbi8vIEEgcmVnZXhwIGlzIG1hZGUgYXQgdGhlIGVuZCB3aGljaCBqb2lucyBlYWNoIGFycmF5IHdpdGggYW5cbi8vIGVzY2FwZWQgLywgYW5kIGFub3RoZXIgZnVsbCBvbmUgd2hpY2ggam9pbnMgZWFjaCByZWdleHAgd2l0aCB8LlxuLy9cbi8vIEZvbGxvd2luZyB0aGUgbGVhZCBvZiBCYXNoIDQuMSwgbm90ZSB0aGF0IFwiKipcIiBvbmx5IGhhcyBzcGVjaWFsIG1lYW5pbmdcbi8vIHdoZW4gaXQgaXMgdGhlICpvbmx5KiB0aGluZyBpbiBhIHBhdGggcG9ydGlvbi4gIE90aGVyd2lzZSwgYW55IHNlcmllc1xuLy8gb2YgKiBpcyBlcXVpdmFsZW50IHRvIGEgc2luZ2xlICouICBHbG9ic3RhciBiZWhhdmlvciBpcyBlbmFibGVkIGJ5XG4vLyBkZWZhdWx0LCBhbmQgY2FuIGJlIGRpc2FibGVkIGJ5IHNldHRpbmcgb3B0aW9ucy5ub2dsb2JzdGFyLlxuTWluaW1hdGNoLnByb3RvdHlwZS5wYXJzZSA9IHBhcnNlXG52YXIgU1VCUEFSU0UgPSB7fVxuZnVuY3Rpb24gcGFyc2UgKHBhdHRlcm4sIGlzU3ViKSB7XG4gIGlmIChwYXR0ZXJuLmxlbmd0aCA+IDEwMjQgKiA2NCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3BhdHRlcm4gaXMgdG9vIGxvbmcnKVxuICB9XG5cbiAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnNcblxuICAvLyBzaG9ydGN1dHNcbiAgaWYgKCFvcHRpb25zLm5vZ2xvYnN0YXIgJiYgcGF0dGVybiA9PT0gJyoqJykgcmV0dXJuIEdMT0JTVEFSXG4gIGlmIChwYXR0ZXJuID09PSAnJykgcmV0dXJuICcnXG5cbiAgdmFyIHJlID0gJydcbiAgdmFyIGhhc01hZ2ljID0gISFvcHRpb25zLm5vY2FzZVxuICB2YXIgZXNjYXBpbmcgPSBmYWxzZVxuICAvLyA/ID0+IG9uZSBzaW5nbGUgY2hhcmFjdGVyXG4gIHZhciBwYXR0ZXJuTGlzdFN0YWNrID0gW11cbiAgdmFyIG5lZ2F0aXZlTGlzdHMgPSBbXVxuICB2YXIgc3RhdGVDaGFyXG4gIHZhciBpbkNsYXNzID0gZmFsc2VcbiAgdmFyIHJlQ2xhc3NTdGFydCA9IC0xXG4gIHZhciBjbGFzc1N0YXJ0ID0gLTFcbiAgLy8gLiBhbmQgLi4gbmV2ZXIgbWF0Y2ggYW55dGhpbmcgdGhhdCBkb2Vzbid0IHN0YXJ0IHdpdGggLixcbiAgLy8gZXZlbiB3aGVuIG9wdGlvbnMuZG90IGlzIHNldC5cbiAgdmFyIHBhdHRlcm5TdGFydCA9IHBhdHRlcm4uY2hhckF0KDApID09PSAnLicgPyAnJyAvLyBhbnl0aGluZ1xuICAvLyBub3QgKHN0YXJ0IG9yIC8gZm9sbG93ZWQgYnkgLiBvciAuLiBmb2xsb3dlZCBieSAvIG9yIGVuZClcbiAgOiBvcHRpb25zLmRvdCA/ICcoPyEoPzpefFxcXFxcXC8pXFxcXC57MSwyfSg/OiR8XFxcXFxcLykpJ1xuICA6ICcoPyFcXFxcLiknXG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIGZ1bmN0aW9uIGNsZWFyU3RhdGVDaGFyICgpIHtcbiAgICBpZiAoc3RhdGVDaGFyKSB7XG4gICAgICAvLyB3ZSBoYWQgc29tZSBzdGF0ZS10cmFja2luZyBjaGFyYWN0ZXJcbiAgICAgIC8vIHRoYXQgd2Fzbid0IGNvbnN1bWVkIGJ5IHRoaXMgcGFzcy5cbiAgICAgIHN3aXRjaCAoc3RhdGVDaGFyKSB7XG4gICAgICAgIGNhc2UgJyonOlxuICAgICAgICAgIHJlICs9IHN0YXJcbiAgICAgICAgICBoYXNNYWdpYyA9IHRydWVcbiAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAnPyc6XG4gICAgICAgICAgcmUgKz0gcW1hcmtcbiAgICAgICAgICBoYXNNYWdpYyA9IHRydWVcbiAgICAgICAgYnJlYWtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZSArPSAnXFxcXCcgKyBzdGF0ZUNoYXJcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIHNlbGYuZGVidWcoJ2NsZWFyU3RhdGVDaGFyICVqICVqJywgc3RhdGVDaGFyLCByZSlcbiAgICAgIHN0YXRlQ2hhciA9IGZhbHNlXG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHBhdHRlcm4ubGVuZ3RoLCBjXG4gICAgOyAoaSA8IGxlbikgJiYgKGMgPSBwYXR0ZXJuLmNoYXJBdChpKSlcbiAgICA7IGkrKykge1xuICAgIHRoaXMuZGVidWcoJyVzXFx0JXMgJXMgJWonLCBwYXR0ZXJuLCBpLCByZSwgYylcblxuICAgIC8vIHNraXAgb3ZlciBhbnkgdGhhdCBhcmUgZXNjYXBlZC5cbiAgICBpZiAoZXNjYXBpbmcgJiYgcmVTcGVjaWFsc1tjXSkge1xuICAgICAgcmUgKz0gJ1xcXFwnICsgY1xuICAgICAgZXNjYXBpbmcgPSBmYWxzZVxuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICBzd2l0Y2ggKGMpIHtcbiAgICAgIGNhc2UgJy8nOlxuICAgICAgICAvLyBjb21wbGV0ZWx5IG5vdCBhbGxvd2VkLCBldmVuIGVzY2FwZWQuXG4gICAgICAgIC8vIFNob3VsZCBhbHJlYWR5IGJlIHBhdGgtc3BsaXQgYnkgbm93LlxuICAgICAgICByZXR1cm4gZmFsc2VcblxuICAgICAgY2FzZSAnXFxcXCc6XG4gICAgICAgIGNsZWFyU3RhdGVDaGFyKClcbiAgICAgICAgZXNjYXBpbmcgPSB0cnVlXG4gICAgICBjb250aW51ZVxuXG4gICAgICAvLyB0aGUgdmFyaW91cyBzdGF0ZUNoYXIgdmFsdWVzXG4gICAgICAvLyBmb3IgdGhlIFwiZXh0Z2xvYlwiIHN0dWZmLlxuICAgICAgY2FzZSAnPyc6XG4gICAgICBjYXNlICcqJzpcbiAgICAgIGNhc2UgJysnOlxuICAgICAgY2FzZSAnQCc6XG4gICAgICBjYXNlICchJzpcbiAgICAgICAgdGhpcy5kZWJ1ZygnJXNcXHQlcyAlcyAlaiA8LS0gc3RhdGVDaGFyJywgcGF0dGVybiwgaSwgcmUsIGMpXG5cbiAgICAgICAgLy8gYWxsIG9mIHRob3NlIGFyZSBsaXRlcmFscyBpbnNpZGUgYSBjbGFzcywgZXhjZXB0IHRoYXRcbiAgICAgICAgLy8gdGhlIGdsb2IgWyFhXSBtZWFucyBbXmFdIGluIHJlZ2V4cFxuICAgICAgICBpZiAoaW5DbGFzcykge1xuICAgICAgICAgIHRoaXMuZGVidWcoJyAgaW4gY2xhc3MnKVxuICAgICAgICAgIGlmIChjID09PSAnIScgJiYgaSA9PT0gY2xhc3NTdGFydCArIDEpIGMgPSAnXidcbiAgICAgICAgICByZSArPSBjXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHdlIGFscmVhZHkgaGF2ZSBhIHN0YXRlQ2hhciwgdGhlbiBpdCBtZWFuc1xuICAgICAgICAvLyB0aGF0IHRoZXJlIHdhcyBzb21ldGhpbmcgbGlrZSAqKiBvciArPyBpbiB0aGVyZS5cbiAgICAgICAgLy8gSGFuZGxlIHRoZSBzdGF0ZUNoYXIsIHRoZW4gcHJvY2VlZCB3aXRoIHRoaXMgb25lLlxuICAgICAgICBzZWxmLmRlYnVnKCdjYWxsIGNsZWFyU3RhdGVDaGFyICVqJywgc3RhdGVDaGFyKVxuICAgICAgICBjbGVhclN0YXRlQ2hhcigpXG4gICAgICAgIHN0YXRlQ2hhciA9IGNcbiAgICAgICAgLy8gaWYgZXh0Z2xvYiBpcyBkaXNhYmxlZCwgdGhlbiArKGFzZGZ8Zm9vKSBpc24ndCBhIHRoaW5nLlxuICAgICAgICAvLyBqdXN0IGNsZWFyIHRoZSBzdGF0ZWNoYXIgKm5vdyosIHJhdGhlciB0aGFuIGV2ZW4gZGl2aW5nIGludG9cbiAgICAgICAgLy8gdGhlIHBhdHRlcm5MaXN0IHN0dWZmLlxuICAgICAgICBpZiAob3B0aW9ucy5ub2V4dCkgY2xlYXJTdGF0ZUNoYXIoKVxuICAgICAgY29udGludWVcblxuICAgICAgY2FzZSAnKCc6XG4gICAgICAgIGlmIChpbkNsYXNzKSB7XG4gICAgICAgICAgcmUgKz0gJygnXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghc3RhdGVDaGFyKSB7XG4gICAgICAgICAgcmUgKz0gJ1xcXFwoJ1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICBwYXR0ZXJuTGlzdFN0YWNrLnB1c2goe1xuICAgICAgICAgIHR5cGU6IHN0YXRlQ2hhcixcbiAgICAgICAgICBzdGFydDogaSAtIDEsXG4gICAgICAgICAgcmVTdGFydDogcmUubGVuZ3RoLFxuICAgICAgICAgIG9wZW46IHBsVHlwZXNbc3RhdGVDaGFyXS5vcGVuLFxuICAgICAgICAgIGNsb3NlOiBwbFR5cGVzW3N0YXRlQ2hhcl0uY2xvc2VcbiAgICAgICAgfSlcbiAgICAgICAgLy8gbmVnYXRpb24gaXMgKD86KD8hanMpW14vXSopXG4gICAgICAgIHJlICs9IHN0YXRlQ2hhciA9PT0gJyEnID8gJyg/Oig/ISg/OicgOiAnKD86J1xuICAgICAgICB0aGlzLmRlYnVnKCdwbFR5cGUgJWogJWonLCBzdGF0ZUNoYXIsIHJlKVxuICAgICAgICBzdGF0ZUNoYXIgPSBmYWxzZVxuICAgICAgY29udGludWVcblxuICAgICAgY2FzZSAnKSc6XG4gICAgICAgIGlmIChpbkNsYXNzIHx8ICFwYXR0ZXJuTGlzdFN0YWNrLmxlbmd0aCkge1xuICAgICAgICAgIHJlICs9ICdcXFxcKSdcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgY2xlYXJTdGF0ZUNoYXIoKVxuICAgICAgICBoYXNNYWdpYyA9IHRydWVcbiAgICAgICAgdmFyIHBsID0gcGF0dGVybkxpc3RTdGFjay5wb3AoKVxuICAgICAgICAvLyBuZWdhdGlvbiBpcyAoPzooPyFqcylbXi9dKilcbiAgICAgICAgLy8gVGhlIG90aGVycyBhcmUgKD86PHBhdHRlcm4+KTx0eXBlPlxuICAgICAgICByZSArPSBwbC5jbG9zZVxuICAgICAgICBpZiAocGwudHlwZSA9PT0gJyEnKSB7XG4gICAgICAgICAgbmVnYXRpdmVMaXN0cy5wdXNoKHBsKVxuICAgICAgICB9XG4gICAgICAgIHBsLnJlRW5kID0gcmUubGVuZ3RoXG4gICAgICBjb250aW51ZVxuXG4gICAgICBjYXNlICd8JzpcbiAgICAgICAgaWYgKGluQ2xhc3MgfHwgIXBhdHRlcm5MaXN0U3RhY2subGVuZ3RoIHx8IGVzY2FwaW5nKSB7XG4gICAgICAgICAgcmUgKz0gJ1xcXFx8J1xuICAgICAgICAgIGVzY2FwaW5nID0gZmFsc2VcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgY2xlYXJTdGF0ZUNoYXIoKVxuICAgICAgICByZSArPSAnfCdcbiAgICAgIGNvbnRpbnVlXG5cbiAgICAgIC8vIHRoZXNlIGFyZSBtb3N0bHkgdGhlIHNhbWUgaW4gcmVnZXhwIGFuZCBnbG9iXG4gICAgICBjYXNlICdbJzpcbiAgICAgICAgLy8gc3dhbGxvdyBhbnkgc3RhdGUtdHJhY2tpbmcgY2hhciBiZWZvcmUgdGhlIFtcbiAgICAgICAgY2xlYXJTdGF0ZUNoYXIoKVxuXG4gICAgICAgIGlmIChpbkNsYXNzKSB7XG4gICAgICAgICAgcmUgKz0gJ1xcXFwnICsgY1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICBpbkNsYXNzID0gdHJ1ZVxuICAgICAgICBjbGFzc1N0YXJ0ID0gaVxuICAgICAgICByZUNsYXNzU3RhcnQgPSByZS5sZW5ndGhcbiAgICAgICAgcmUgKz0gY1xuICAgICAgY29udGludWVcblxuICAgICAgY2FzZSAnXSc6XG4gICAgICAgIC8vICBhIHJpZ2h0IGJyYWNrZXQgc2hhbGwgbG9zZSBpdHMgc3BlY2lhbFxuICAgICAgICAvLyAgbWVhbmluZyBhbmQgcmVwcmVzZW50IGl0c2VsZiBpblxuICAgICAgICAvLyAgYSBicmFja2V0IGV4cHJlc3Npb24gaWYgaXQgb2NjdXJzXG4gICAgICAgIC8vICBmaXJzdCBpbiB0aGUgbGlzdC4gIC0tIFBPU0lYLjIgMi44LjMuMlxuICAgICAgICBpZiAoaSA9PT0gY2xhc3NTdGFydCArIDEgfHwgIWluQ2xhc3MpIHtcbiAgICAgICAgICByZSArPSAnXFxcXCcgKyBjXG4gICAgICAgICAgZXNjYXBpbmcgPSBmYWxzZVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyBoYW5kbGUgdGhlIGNhc2Ugd2hlcmUgd2UgbGVmdCBhIGNsYXNzIG9wZW4uXG4gICAgICAgIC8vIFwiW3otYV1cIiBpcyB2YWxpZCwgZXF1aXZhbGVudCB0byBcIlxcW3otYVxcXVwiXG4gICAgICAgIGlmIChpbkNsYXNzKSB7XG4gICAgICAgICAgLy8gc3BsaXQgd2hlcmUgdGhlIGxhc3QgWyB3YXMsIG1ha2Ugc3VyZSB3ZSBkb24ndCBoYXZlXG4gICAgICAgICAgLy8gYW4gaW52YWxpZCByZS4gaWYgc28sIHJlLXdhbGsgdGhlIGNvbnRlbnRzIG9mIHRoZVxuICAgICAgICAgIC8vIHdvdWxkLWJlIGNsYXNzIHRvIHJlLXRyYW5zbGF0ZSBhbnkgY2hhcmFjdGVycyB0aGF0XG4gICAgICAgICAgLy8gd2VyZSBwYXNzZWQgdGhyb3VnaCBhcy1pc1xuICAgICAgICAgIC8vIFRPRE86IEl0IHdvdWxkIHByb2JhYmx5IGJlIGZhc3RlciB0byBkZXRlcm1pbmUgdGhpc1xuICAgICAgICAgIC8vIHdpdGhvdXQgYSB0cnkvY2F0Y2ggYW5kIGEgbmV3IFJlZ0V4cCwgYnV0IGl0J3MgdHJpY2t5XG4gICAgICAgICAgLy8gdG8gZG8gc2FmZWx5LiAgRm9yIG5vdywgdGhpcyBpcyBzYWZlIGFuZCB3b3Jrcy5cbiAgICAgICAgICB2YXIgY3MgPSBwYXR0ZXJuLnN1YnN0cmluZyhjbGFzc1N0YXJ0ICsgMSwgaSlcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgUmVnRXhwKCdbJyArIGNzICsgJ10nKVxuICAgICAgICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICAgICAgICAvLyBub3QgYSB2YWxpZCBjbGFzcyFcbiAgICAgICAgICAgIHZhciBzcCA9IHRoaXMucGFyc2UoY3MsIFNVQlBBUlNFKVxuICAgICAgICAgICAgcmUgPSByZS5zdWJzdHIoMCwgcmVDbGFzc1N0YXJ0KSArICdcXFxcWycgKyBzcFswXSArICdcXFxcXSdcbiAgICAgICAgICAgIGhhc01hZ2ljID0gaGFzTWFnaWMgfHwgc3BbMV1cbiAgICAgICAgICAgIGluQ2xhc3MgPSBmYWxzZVxuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmaW5pc2ggdXAgdGhlIGNsYXNzLlxuICAgICAgICBoYXNNYWdpYyA9IHRydWVcbiAgICAgICAgaW5DbGFzcyA9IGZhbHNlXG4gICAgICAgIHJlICs9IGNcbiAgICAgIGNvbnRpbnVlXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIHN3YWxsb3cgYW55IHN0YXRlIGNoYXIgdGhhdCB3YXNuJ3QgY29uc3VtZWRcbiAgICAgICAgY2xlYXJTdGF0ZUNoYXIoKVxuXG4gICAgICAgIGlmIChlc2NhcGluZykge1xuICAgICAgICAgIC8vIG5vIG5lZWRcbiAgICAgICAgICBlc2NhcGluZyA9IGZhbHNlXG4gICAgICAgIH0gZWxzZSBpZiAocmVTcGVjaWFsc1tjXVxuICAgICAgICAgICYmICEoYyA9PT0gJ14nICYmIGluQ2xhc3MpKSB7XG4gICAgICAgICAgcmUgKz0gJ1xcXFwnXG4gICAgICAgIH1cblxuICAgICAgICByZSArPSBjXG5cbiAgICB9IC8vIHN3aXRjaFxuICB9IC8vIGZvclxuXG4gIC8vIGhhbmRsZSB0aGUgY2FzZSB3aGVyZSB3ZSBsZWZ0IGEgY2xhc3Mgb3Blbi5cbiAgLy8gXCJbYWJjXCIgaXMgdmFsaWQsIGVxdWl2YWxlbnQgdG8gXCJcXFthYmNcIlxuICBpZiAoaW5DbGFzcykge1xuICAgIC8vIHNwbGl0IHdoZXJlIHRoZSBsYXN0IFsgd2FzLCBhbmQgZXNjYXBlIGl0XG4gICAgLy8gdGhpcyBpcyBhIGh1Z2UgcGl0YS4gIFdlIG5vdyBoYXZlIHRvIHJlLXdhbGtcbiAgICAvLyB0aGUgY29udGVudHMgb2YgdGhlIHdvdWxkLWJlIGNsYXNzIHRvIHJlLXRyYW5zbGF0ZVxuICAgIC8vIGFueSBjaGFyYWN0ZXJzIHRoYXQgd2VyZSBwYXNzZWQgdGhyb3VnaCBhcy1pc1xuICAgIGNzID0gcGF0dGVybi5zdWJzdHIoY2xhc3NTdGFydCArIDEpXG4gICAgc3AgPSB0aGlzLnBhcnNlKGNzLCBTVUJQQVJTRSlcbiAgICByZSA9IHJlLnN1YnN0cigwLCByZUNsYXNzU3RhcnQpICsgJ1xcXFxbJyArIHNwWzBdXG4gICAgaGFzTWFnaWMgPSBoYXNNYWdpYyB8fCBzcFsxXVxuICB9XG5cbiAgLy8gaGFuZGxlIHRoZSBjYXNlIHdoZXJlIHdlIGhhZCBhICsoIHRoaW5nIGF0IHRoZSAqZW5kKlxuICAvLyBvZiB0aGUgcGF0dGVybi5cbiAgLy8gZWFjaCBwYXR0ZXJuIGxpc3Qgc3RhY2sgYWRkcyAzIGNoYXJzLCBhbmQgd2UgbmVlZCB0byBnbyB0aHJvdWdoXG4gIC8vIGFuZCBlc2NhcGUgYW55IHwgY2hhcnMgdGhhdCB3ZXJlIHBhc3NlZCB0aHJvdWdoIGFzLWlzIGZvciB0aGUgcmVnZXhwLlxuICAvLyBHbyB0aHJvdWdoIGFuZCBlc2NhcGUgdGhlbSwgdGFraW5nIGNhcmUgbm90IHRvIGRvdWJsZS1lc2NhcGUgYW55XG4gIC8vIHwgY2hhcnMgdGhhdCB3ZXJlIGFscmVhZHkgZXNjYXBlZC5cbiAgZm9yIChwbCA9IHBhdHRlcm5MaXN0U3RhY2sucG9wKCk7IHBsOyBwbCA9IHBhdHRlcm5MaXN0U3RhY2sucG9wKCkpIHtcbiAgICB2YXIgdGFpbCA9IHJlLnNsaWNlKHBsLnJlU3RhcnQgKyBwbC5vcGVuLmxlbmd0aClcbiAgICB0aGlzLmRlYnVnKCdzZXR0aW5nIHRhaWwnLCByZSwgcGwpXG4gICAgLy8gbWF5YmUgc29tZSBldmVuIG51bWJlciBvZiBcXCwgdGhlbiBtYXliZSAxIFxcLCBmb2xsb3dlZCBieSBhIHxcbiAgICB0YWlsID0gdGFpbC5yZXBsYWNlKC8oKD86XFxcXHsyfSl7MCw2NH0pKFxcXFw/KVxcfC9nLCBmdW5jdGlvbiAoXywgJDEsICQyKSB7XG4gICAgICBpZiAoISQyKSB7XG4gICAgICAgIC8vIHRoZSB8IGlzbid0IGFscmVhZHkgZXNjYXBlZCwgc28gZXNjYXBlIGl0LlxuICAgICAgICAkMiA9ICdcXFxcJ1xuICAgICAgfVxuXG4gICAgICAvLyBuZWVkIHRvIGVzY2FwZSBhbGwgdGhvc2Ugc2xhc2hlcyAqYWdhaW4qLCB3aXRob3V0IGVzY2FwaW5nIHRoZVxuICAgICAgLy8gb25lIHRoYXQgd2UgbmVlZCBmb3IgZXNjYXBpbmcgdGhlIHwgY2hhcmFjdGVyLiAgQXMgaXQgd29ya3Mgb3V0LFxuICAgICAgLy8gZXNjYXBpbmcgYW4gZXZlbiBudW1iZXIgb2Ygc2xhc2hlcyBjYW4gYmUgZG9uZSBieSBzaW1wbHkgcmVwZWF0aW5nXG4gICAgICAvLyBpdCBleGFjdGx5IGFmdGVyIGl0c2VsZi4gIFRoYXQncyB3aHkgdGhpcyB0cmljayB3b3Jrcy5cbiAgICAgIC8vXG4gICAgICAvLyBJIGFtIHNvcnJ5IHRoYXQgeW91IGhhdmUgdG8gc2VlIHRoaXMuXG4gICAgICByZXR1cm4gJDEgKyAkMSArICQyICsgJ3wnXG4gICAgfSlcblxuICAgIHRoaXMuZGVidWcoJ3RhaWw9JWpcXG4gICAlcycsIHRhaWwsIHRhaWwsIHBsLCByZSlcbiAgICB2YXIgdCA9IHBsLnR5cGUgPT09ICcqJyA/IHN0YXJcbiAgICAgIDogcGwudHlwZSA9PT0gJz8nID8gcW1hcmtcbiAgICAgIDogJ1xcXFwnICsgcGwudHlwZVxuXG4gICAgaGFzTWFnaWMgPSB0cnVlXG4gICAgcmUgPSByZS5zbGljZSgwLCBwbC5yZVN0YXJ0KSArIHQgKyAnXFxcXCgnICsgdGFpbFxuICB9XG5cbiAgLy8gaGFuZGxlIHRyYWlsaW5nIHRoaW5ncyB0aGF0IG9ubHkgbWF0dGVyIGF0IHRoZSB2ZXJ5IGVuZC5cbiAgY2xlYXJTdGF0ZUNoYXIoKVxuICBpZiAoZXNjYXBpbmcpIHtcbiAgICAvLyB0cmFpbGluZyBcXFxcXG4gICAgcmUgKz0gJ1xcXFxcXFxcJ1xuICB9XG5cbiAgLy8gb25seSBuZWVkIHRvIGFwcGx5IHRoZSBub2RvdCBzdGFydCBpZiB0aGUgcmUgc3RhcnRzIHdpdGhcbiAgLy8gc29tZXRoaW5nIHRoYXQgY291bGQgY29uY2VpdmFibHkgY2FwdHVyZSBhIGRvdFxuICB2YXIgYWRkUGF0dGVyblN0YXJ0ID0gZmFsc2VcbiAgc3dpdGNoIChyZS5jaGFyQXQoMCkpIHtcbiAgICBjYXNlICcuJzpcbiAgICBjYXNlICdbJzpcbiAgICBjYXNlICcoJzogYWRkUGF0dGVyblN0YXJ0ID0gdHJ1ZVxuICB9XG5cbiAgLy8gSGFjayB0byB3b3JrIGFyb3VuZCBsYWNrIG9mIG5lZ2F0aXZlIGxvb2tiZWhpbmQgaW4gSlNcbiAgLy8gQSBwYXR0ZXJuIGxpa2U6ICouISh4KS4hKHl8eikgbmVlZHMgdG8gZW5zdXJlIHRoYXQgYSBuYW1lXG4gIC8vIGxpa2UgJ2EueHl6Lnl6JyBkb2Vzbid0IG1hdGNoLiAgU28sIHRoZSBmaXJzdCBuZWdhdGl2ZVxuICAvLyBsb29rYWhlYWQsIGhhcyB0byBsb29rIEFMTCB0aGUgd2F5IGFoZWFkLCB0byB0aGUgZW5kIG9mXG4gIC8vIHRoZSBwYXR0ZXJuLlxuICBmb3IgKHZhciBuID0gbmVnYXRpdmVMaXN0cy5sZW5ndGggLSAxOyBuID4gLTE7IG4tLSkge1xuICAgIHZhciBubCA9IG5lZ2F0aXZlTGlzdHNbbl1cblxuICAgIHZhciBubEJlZm9yZSA9IHJlLnNsaWNlKDAsIG5sLnJlU3RhcnQpXG4gICAgdmFyIG5sRmlyc3QgPSByZS5zbGljZShubC5yZVN0YXJ0LCBubC5yZUVuZCAtIDgpXG4gICAgdmFyIG5sTGFzdCA9IHJlLnNsaWNlKG5sLnJlRW5kIC0gOCwgbmwucmVFbmQpXG4gICAgdmFyIG5sQWZ0ZXIgPSByZS5zbGljZShubC5yZUVuZClcblxuICAgIG5sTGFzdCArPSBubEFmdGVyXG5cbiAgICAvLyBIYW5kbGUgbmVzdGVkIHN0dWZmIGxpa2UgKigqLmpzfCEoKi5qc29uKSksIHdoZXJlIG9wZW4gcGFyZW5zXG4gICAgLy8gbWVhbiB0aGF0IHdlIHNob3VsZCAqbm90KiBpbmNsdWRlIHRoZSApIGluIHRoZSBiaXQgdGhhdCBpcyBjb25zaWRlcmVkXG4gICAgLy8gXCJhZnRlclwiIHRoZSBuZWdhdGVkIHNlY3Rpb24uXG4gICAgdmFyIG9wZW5QYXJlbnNCZWZvcmUgPSBubEJlZm9yZS5zcGxpdCgnKCcpLmxlbmd0aCAtIDFcbiAgICB2YXIgY2xlYW5BZnRlciA9IG5sQWZ0ZXJcbiAgICBmb3IgKGkgPSAwOyBpIDwgb3BlblBhcmVuc0JlZm9yZTsgaSsrKSB7XG4gICAgICBjbGVhbkFmdGVyID0gY2xlYW5BZnRlci5yZXBsYWNlKC9cXClbKyo/XT8vLCAnJylcbiAgICB9XG4gICAgbmxBZnRlciA9IGNsZWFuQWZ0ZXJcblxuICAgIHZhciBkb2xsYXIgPSAnJ1xuICAgIGlmIChubEFmdGVyID09PSAnJyAmJiBpc1N1YiAhPT0gU1VCUEFSU0UpIHtcbiAgICAgIGRvbGxhciA9ICckJ1xuICAgIH1cbiAgICB2YXIgbmV3UmUgPSBubEJlZm9yZSArIG5sRmlyc3QgKyBubEFmdGVyICsgZG9sbGFyICsgbmxMYXN0XG4gICAgcmUgPSBuZXdSZVxuICB9XG5cbiAgLy8gaWYgdGhlIHJlIGlzIG5vdCBcIlwiIGF0IHRoaXMgcG9pbnQsIHRoZW4gd2UgbmVlZCB0byBtYWtlIHN1cmVcbiAgLy8gaXQgZG9lc24ndCBtYXRjaCBhZ2FpbnN0IGFuIGVtcHR5IHBhdGggcGFydC5cbiAgLy8gT3RoZXJ3aXNlIGEvKiB3aWxsIG1hdGNoIGEvLCB3aGljaCBpdCBzaG91bGQgbm90LlxuICBpZiAocmUgIT09ICcnICYmIGhhc01hZ2ljKSB7XG4gICAgcmUgPSAnKD89LiknICsgcmVcbiAgfVxuXG4gIGlmIChhZGRQYXR0ZXJuU3RhcnQpIHtcbiAgICByZSA9IHBhdHRlcm5TdGFydCArIHJlXG4gIH1cblxuICAvLyBwYXJzaW5nIGp1c3QgYSBwaWVjZSBvZiBhIGxhcmdlciBwYXR0ZXJuLlxuICBpZiAoaXNTdWIgPT09IFNVQlBBUlNFKSB7XG4gICAgcmV0dXJuIFtyZSwgaGFzTWFnaWNdXG4gIH1cblxuICAvLyBza2lwIHRoZSByZWdleHAgZm9yIG5vbi1tYWdpY2FsIHBhdHRlcm5zXG4gIC8vIHVuZXNjYXBlIGFueXRoaW5nIGluIGl0LCB0aG91Z2gsIHNvIHRoYXQgaXQnbGwgYmVcbiAgLy8gYW4gZXhhY3QgbWF0Y2ggYWdhaW5zdCBhIGZpbGUgZXRjLlxuICBpZiAoIWhhc01hZ2ljKSB7XG4gICAgcmV0dXJuIGdsb2JVbmVzY2FwZShwYXR0ZXJuKVxuICB9XG5cbiAgdmFyIGZsYWdzID0gb3B0aW9ucy5ub2Nhc2UgPyAnaScgOiAnJ1xuICB0cnkge1xuICAgIHZhciByZWdFeHAgPSBuZXcgUmVnRXhwKCdeJyArIHJlICsgJyQnLCBmbGFncylcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICAvLyBJZiBpdCB3YXMgYW4gaW52YWxpZCByZWd1bGFyIGV4cHJlc3Npb24sIHRoZW4gaXQgY2FuJ3QgbWF0Y2hcbiAgICAvLyBhbnl0aGluZy4gIFRoaXMgdHJpY2sgbG9va3MgZm9yIGEgY2hhcmFjdGVyIGFmdGVyIHRoZSBlbmQgb2ZcbiAgICAvLyB0aGUgc3RyaW5nLCB3aGljaCBpcyBvZiBjb3Vyc2UgaW1wb3NzaWJsZSwgZXhjZXB0IGluIG11bHRpLWxpbmVcbiAgICAvLyBtb2RlLCBidXQgaXQncyBub3QgYSAvbSByZWdleC5cbiAgICByZXR1cm4gbmV3IFJlZ0V4cCgnJC4nKVxuICB9XG5cbiAgcmVnRXhwLl9nbG9iID0gcGF0dGVyblxuICByZWdFeHAuX3NyYyA9IHJlXG5cbiAgcmV0dXJuIHJlZ0V4cFxufVxuXG5taW5pbWF0Y2gubWFrZVJlID0gZnVuY3Rpb24gKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBNaW5pbWF0Y2gocGF0dGVybiwgb3B0aW9ucyB8fCB7fSkubWFrZVJlKClcbn1cblxuTWluaW1hdGNoLnByb3RvdHlwZS5tYWtlUmUgPSBtYWtlUmVcbmZ1bmN0aW9uIG1ha2VSZSAoKSB7XG4gIGlmICh0aGlzLnJlZ2V4cCB8fCB0aGlzLnJlZ2V4cCA9PT0gZmFsc2UpIHJldHVybiB0aGlzLnJlZ2V4cFxuXG4gIC8vIGF0IHRoaXMgcG9pbnQsIHRoaXMuc2V0IGlzIGEgMmQgYXJyYXkgb2YgcGFydGlhbFxuICAvLyBwYXR0ZXJuIHN0cmluZ3MsIG9yIFwiKipcIi5cbiAgLy9cbiAgLy8gSXQncyBiZXR0ZXIgdG8gdXNlIC5tYXRjaCgpLiAgVGhpcyBmdW5jdGlvbiBzaG91bGRuJ3RcbiAgLy8gYmUgdXNlZCwgcmVhbGx5LCBidXQgaXQncyBwcmV0dHkgY29udmVuaWVudCBzb21ldGltZXMsXG4gIC8vIHdoZW4geW91IGp1c3Qgd2FudCB0byB3b3JrIHdpdGggYSByZWdleC5cbiAgdmFyIHNldCA9IHRoaXMuc2V0XG5cbiAgaWYgKCFzZXQubGVuZ3RoKSB7XG4gICAgdGhpcy5yZWdleHAgPSBmYWxzZVxuICAgIHJldHVybiB0aGlzLnJlZ2V4cFxuICB9XG4gIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zXG5cbiAgdmFyIHR3b1N0YXIgPSBvcHRpb25zLm5vZ2xvYnN0YXIgPyBzdGFyXG4gICAgOiBvcHRpb25zLmRvdCA/IHR3b1N0YXJEb3RcbiAgICA6IHR3b1N0YXJOb0RvdFxuICB2YXIgZmxhZ3MgPSBvcHRpb25zLm5vY2FzZSA/ICdpJyA6ICcnXG5cbiAgdmFyIHJlID0gc2V0Lm1hcChmdW5jdGlvbiAocGF0dGVybikge1xuICAgIHJldHVybiBwYXR0ZXJuLm1hcChmdW5jdGlvbiAocCkge1xuICAgICAgcmV0dXJuIChwID09PSBHTE9CU1RBUikgPyB0d29TdGFyXG4gICAgICA6ICh0eXBlb2YgcCA9PT0gJ3N0cmluZycpID8gcmVnRXhwRXNjYXBlKHApXG4gICAgICA6IHAuX3NyY1xuICAgIH0pLmpvaW4oJ1xcXFxcXC8nKVxuICB9KS5qb2luKCd8JylcblxuICAvLyBtdXN0IG1hdGNoIGVudGlyZSBwYXR0ZXJuXG4gIC8vIGVuZGluZyBpbiBhICogb3IgKiogd2lsbCBtYWtlIGl0IGxlc3Mgc3RyaWN0LlxuICByZSA9ICdeKD86JyArIHJlICsgJykkJ1xuXG4gIC8vIGNhbiBtYXRjaCBhbnl0aGluZywgYXMgbG9uZyBhcyBpdCdzIG5vdCB0aGlzLlxuICBpZiAodGhpcy5uZWdhdGUpIHJlID0gJ14oPyEnICsgcmUgKyAnKS4qJCdcblxuICB0cnkge1xuICAgIHRoaXMucmVnZXhwID0gbmV3IFJlZ0V4cChyZSwgZmxhZ3MpXG4gIH0gY2F0Y2ggKGV4KSB7XG4gICAgdGhpcy5yZWdleHAgPSBmYWxzZVxuICB9XG4gIHJldHVybiB0aGlzLnJlZ2V4cFxufVxuXG5taW5pbWF0Y2gubWF0Y2ggPSBmdW5jdGlvbiAobGlzdCwgcGF0dGVybiwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICB2YXIgbW0gPSBuZXcgTWluaW1hdGNoKHBhdHRlcm4sIG9wdGlvbnMpXG4gIGxpc3QgPSBsaXN0LmZpbHRlcihmdW5jdGlvbiAoZikge1xuICAgIHJldHVybiBtbS5tYXRjaChmKVxuICB9KVxuICBpZiAobW0ub3B0aW9ucy5ub251bGwgJiYgIWxpc3QubGVuZ3RoKSB7XG4gICAgbGlzdC5wdXNoKHBhdHRlcm4pXG4gIH1cbiAgcmV0dXJuIGxpc3Rcbn1cblxuTWluaW1hdGNoLnByb3RvdHlwZS5tYXRjaCA9IG1hdGNoXG5mdW5jdGlvbiBtYXRjaCAoZiwgcGFydGlhbCkge1xuICB0aGlzLmRlYnVnKCdtYXRjaCcsIGYsIHRoaXMucGF0dGVybilcbiAgLy8gc2hvcnQtY2lyY3VpdCBpbiB0aGUgY2FzZSBvZiBidXN0ZWQgdGhpbmdzLlxuICAvLyBjb21tZW50cywgZXRjLlxuICBpZiAodGhpcy5jb21tZW50KSByZXR1cm4gZmFsc2VcbiAgaWYgKHRoaXMuZW1wdHkpIHJldHVybiBmID09PSAnJ1xuXG4gIGlmIChmID09PSAnLycgJiYgcGFydGlhbCkgcmV0dXJuIHRydWVcblxuICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9uc1xuXG4gIC8vIHdpbmRvd3M6IG5lZWQgdG8gdXNlIC8sIG5vdCBcXFxuICBpZiAocGF0aC5zZXAgIT09ICcvJykge1xuICAgIGYgPSBmLnNwbGl0KHBhdGguc2VwKS5qb2luKCcvJylcbiAgfVxuXG4gIC8vIHRyZWF0IHRoZSB0ZXN0IHBhdGggYXMgYSBzZXQgb2YgcGF0aHBhcnRzLlxuICBmID0gZi5zcGxpdChzbGFzaFNwbGl0KVxuICB0aGlzLmRlYnVnKHRoaXMucGF0dGVybiwgJ3NwbGl0JywgZilcblxuICAvLyBqdXN0IE9ORSBvZiB0aGUgcGF0dGVybiBzZXRzIGluIHRoaXMuc2V0IG5lZWRzIHRvIG1hdGNoXG4gIC8vIGluIG9yZGVyIGZvciBpdCB0byBiZSB2YWxpZC4gIElmIG5lZ2F0aW5nLCB0aGVuIGp1c3Qgb25lXG4gIC8vIG1hdGNoIG1lYW5zIHRoYXQgd2UgaGF2ZSBmYWlsZWQuXG4gIC8vIEVpdGhlciB3YXksIHJldHVybiBvbiB0aGUgZmlyc3QgaGl0LlxuXG4gIHZhciBzZXQgPSB0aGlzLnNldFxuICB0aGlzLmRlYnVnKHRoaXMucGF0dGVybiwgJ3NldCcsIHNldClcblxuICAvLyBGaW5kIHRoZSBiYXNlbmFtZSBvZiB0aGUgcGF0aCBieSBsb29raW5nIGZvciB0aGUgbGFzdCBub24tZW1wdHkgc2VnbWVudFxuICB2YXIgZmlsZW5hbWVcbiAgdmFyIGlcbiAgZm9yIChpID0gZi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGZpbGVuYW1lID0gZltpXVxuICAgIGlmIChmaWxlbmFtZSkgYnJlYWtcbiAgfVxuXG4gIGZvciAoaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcGF0dGVybiA9IHNldFtpXVxuICAgIHZhciBmaWxlID0gZlxuICAgIGlmIChvcHRpb25zLm1hdGNoQmFzZSAmJiBwYXR0ZXJuLmxlbmd0aCA9PT0gMSkge1xuICAgICAgZmlsZSA9IFtmaWxlbmFtZV1cbiAgICB9XG4gICAgdmFyIGhpdCA9IHRoaXMubWF0Y2hPbmUoZmlsZSwgcGF0dGVybiwgcGFydGlhbClcbiAgICBpZiAoaGl0KSB7XG4gICAgICBpZiAob3B0aW9ucy5mbGlwTmVnYXRlKSByZXR1cm4gdHJ1ZVxuICAgICAgcmV0dXJuICF0aGlzLm5lZ2F0ZVxuICAgIH1cbiAgfVxuXG4gIC8vIGRpZG4ndCBnZXQgYW55IGhpdHMuICB0aGlzIGlzIHN1Y2Nlc3MgaWYgaXQncyBhIG5lZ2F0aXZlXG4gIC8vIHBhdHRlcm4sIGZhaWx1cmUgb3RoZXJ3aXNlLlxuICBpZiAob3B0aW9ucy5mbGlwTmVnYXRlKSByZXR1cm4gZmFsc2VcbiAgcmV0dXJuIHRoaXMubmVnYXRlXG59XG5cbi8vIHNldCBwYXJ0aWFsIHRvIHRydWUgdG8gdGVzdCBpZiwgZm9yIGV4YW1wbGUsXG4vLyBcIi9hL2JcIiBtYXRjaGVzIHRoZSBzdGFydCBvZiBcIi8qL2IvKi9kXCJcbi8vIFBhcnRpYWwgbWVhbnMsIGlmIHlvdSBydW4gb3V0IG9mIGZpbGUgYmVmb3JlIHlvdSBydW5cbi8vIG91dCBvZiBwYXR0ZXJuLCB0aGVuIHRoYXQncyBmaW5lLCBhcyBsb25nIGFzIGFsbFxuLy8gdGhlIHBhcnRzIG1hdGNoLlxuTWluaW1hdGNoLnByb3RvdHlwZS5tYXRjaE9uZSA9IGZ1bmN0aW9uIChmaWxlLCBwYXR0ZXJuLCBwYXJ0aWFsKSB7XG4gIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zXG5cbiAgdGhpcy5kZWJ1ZygnbWF0Y2hPbmUnLFxuICAgIHsgJ3RoaXMnOiB0aGlzLCBmaWxlOiBmaWxlLCBwYXR0ZXJuOiBwYXR0ZXJuIH0pXG5cbiAgdGhpcy5kZWJ1ZygnbWF0Y2hPbmUnLCBmaWxlLmxlbmd0aCwgcGF0dGVybi5sZW5ndGgpXG5cbiAgZm9yICh2YXIgZmkgPSAwLFxuICAgICAgcGkgPSAwLFxuICAgICAgZmwgPSBmaWxlLmxlbmd0aCxcbiAgICAgIHBsID0gcGF0dGVybi5sZW5ndGhcbiAgICAgIDsgKGZpIDwgZmwpICYmIChwaSA8IHBsKVxuICAgICAgOyBmaSsrLCBwaSsrKSB7XG4gICAgdGhpcy5kZWJ1ZygnbWF0Y2hPbmUgbG9vcCcpXG4gICAgdmFyIHAgPSBwYXR0ZXJuW3BpXVxuICAgIHZhciBmID0gZmlsZVtmaV1cblxuICAgIHRoaXMuZGVidWcocGF0dGVybiwgcCwgZilcblxuICAgIC8vIHNob3VsZCBiZSBpbXBvc3NpYmxlLlxuICAgIC8vIHNvbWUgaW52YWxpZCByZWdleHAgc3R1ZmYgaW4gdGhlIHNldC5cbiAgICBpZiAocCA9PT0gZmFsc2UpIHJldHVybiBmYWxzZVxuXG4gICAgaWYgKHAgPT09IEdMT0JTVEFSKSB7XG4gICAgICB0aGlzLmRlYnVnKCdHTE9CU1RBUicsIFtwYXR0ZXJuLCBwLCBmXSlcblxuICAgICAgLy8gXCIqKlwiXG4gICAgICAvLyBhLyoqL2IvKiovYyB3b3VsZCBtYXRjaCB0aGUgZm9sbG93aW5nOlxuICAgICAgLy8gYS9iL3gveS96L2NcbiAgICAgIC8vIGEveC95L3ovYi9jXG4gICAgICAvLyBhL2IveC9iL3gvY1xuICAgICAgLy8gYS9iL2NcbiAgICAgIC8vIFRvIGRvIHRoaXMsIHRha2UgdGhlIHJlc3Qgb2YgdGhlIHBhdHRlcm4gYWZ0ZXJcbiAgICAgIC8vIHRoZSAqKiwgYW5kIHNlZSBpZiBpdCB3b3VsZCBtYXRjaCB0aGUgZmlsZSByZW1haW5kZXIuXG4gICAgICAvLyBJZiBzbywgcmV0dXJuIHN1Y2Nlc3MuXG4gICAgICAvLyBJZiBub3QsIHRoZSAqKiBcInN3YWxsb3dzXCIgYSBzZWdtZW50LCBhbmQgdHJ5IGFnYWluLlxuICAgICAgLy8gVGhpcyBpcyByZWN1cnNpdmVseSBhd2Z1bC5cbiAgICAgIC8vXG4gICAgICAvLyBhLyoqL2IvKiovYyBtYXRjaGluZyBhL2IveC95L3ovY1xuICAgICAgLy8gLSBhIG1hdGNoZXMgYVxuICAgICAgLy8gLSBkb3VibGVzdGFyXG4gICAgICAvLyAgIC0gbWF0Y2hPbmUoYi94L3kvei9jLCBiLyoqL2MpXG4gICAgICAvLyAgICAgLSBiIG1hdGNoZXMgYlxuICAgICAgLy8gICAgIC0gZG91Ymxlc3RhclxuICAgICAgLy8gICAgICAgLSBtYXRjaE9uZSh4L3kvei9jLCBjKSAtPiBub1xuICAgICAgLy8gICAgICAgLSBtYXRjaE9uZSh5L3ovYywgYykgLT4gbm9cbiAgICAgIC8vICAgICAgIC0gbWF0Y2hPbmUoei9jLCBjKSAtPiBub1xuICAgICAgLy8gICAgICAgLSBtYXRjaE9uZShjLCBjKSB5ZXMsIGhpdFxuICAgICAgdmFyIGZyID0gZmlcbiAgICAgIHZhciBwciA9IHBpICsgMVxuICAgICAgaWYgKHByID09PSBwbCkge1xuICAgICAgICB0aGlzLmRlYnVnKCcqKiBhdCB0aGUgZW5kJylcbiAgICAgICAgLy8gYSAqKiBhdCB0aGUgZW5kIHdpbGwganVzdCBzd2FsbG93IHRoZSByZXN0LlxuICAgICAgICAvLyBXZSBoYXZlIGZvdW5kIGEgbWF0Y2guXG4gICAgICAgIC8vIGhvd2V2ZXIsIGl0IHdpbGwgbm90IHN3YWxsb3cgLy54LCB1bmxlc3NcbiAgICAgICAgLy8gb3B0aW9ucy5kb3QgaXMgc2V0LlxuICAgICAgICAvLyAuIGFuZCAuLiBhcmUgKm5ldmVyKiBtYXRjaGVkIGJ5ICoqLCBmb3IgZXhwbG9zaXZlbHlcbiAgICAgICAgLy8gZXhwb25lbnRpYWwgcmVhc29ucy5cbiAgICAgICAgZm9yICg7IGZpIDwgZmw7IGZpKyspIHtcbiAgICAgICAgICBpZiAoZmlsZVtmaV0gPT09ICcuJyB8fCBmaWxlW2ZpXSA9PT0gJy4uJyB8fFxuICAgICAgICAgICAgKCFvcHRpb25zLmRvdCAmJiBmaWxlW2ZpXS5jaGFyQXQoMCkgPT09ICcuJykpIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG5cbiAgICAgIC8vIG9rLCBsZXQncyBzZWUgaWYgd2UgY2FuIHN3YWxsb3cgd2hhdGV2ZXIgd2UgY2FuLlxuICAgICAgd2hpbGUgKGZyIDwgZmwpIHtcbiAgICAgICAgdmFyIHN3YWxsb3dlZSA9IGZpbGVbZnJdXG5cbiAgICAgICAgdGhpcy5kZWJ1ZygnXFxuZ2xvYnN0YXIgd2hpbGUnLCBmaWxlLCBmciwgcGF0dGVybiwgcHIsIHN3YWxsb3dlZSlcblxuICAgICAgICAvLyBYWFggcmVtb3ZlIHRoaXMgc2xpY2UuICBKdXN0IHBhc3MgdGhlIHN0YXJ0IGluZGV4LlxuICAgICAgICBpZiAodGhpcy5tYXRjaE9uZShmaWxlLnNsaWNlKGZyKSwgcGF0dGVybi5zbGljZShwciksIHBhcnRpYWwpKSB7XG4gICAgICAgICAgdGhpcy5kZWJ1ZygnZ2xvYnN0YXIgZm91bmQgbWF0Y2ghJywgZnIsIGZsLCBzd2FsbG93ZWUpXG4gICAgICAgICAgLy8gZm91bmQgYSBtYXRjaC5cbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGNhbid0IHN3YWxsb3cgXCIuXCIgb3IgXCIuLlwiIGV2ZXIuXG4gICAgICAgICAgLy8gY2FuIG9ubHkgc3dhbGxvdyBcIi5mb29cIiB3aGVuIGV4cGxpY2l0bHkgYXNrZWQuXG4gICAgICAgICAgaWYgKHN3YWxsb3dlZSA9PT0gJy4nIHx8IHN3YWxsb3dlZSA9PT0gJy4uJyB8fFxuICAgICAgICAgICAgKCFvcHRpb25zLmRvdCAmJiBzd2FsbG93ZWUuY2hhckF0KDApID09PSAnLicpKSB7XG4gICAgICAgICAgICB0aGlzLmRlYnVnKCdkb3QgZGV0ZWN0ZWQhJywgZmlsZSwgZnIsIHBhdHRlcm4sIHByKVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyAqKiBzd2FsbG93cyBhIHNlZ21lbnQsIGFuZCBjb250aW51ZS5cbiAgICAgICAgICB0aGlzLmRlYnVnKCdnbG9ic3RhciBzd2FsbG93IGEgc2VnbWVudCwgYW5kIGNvbnRpbnVlJylcbiAgICAgICAgICBmcisrXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gbm8gbWF0Y2ggd2FzIGZvdW5kLlxuICAgICAgLy8gSG93ZXZlciwgaW4gcGFydGlhbCBtb2RlLCB3ZSBjYW4ndCBzYXkgdGhpcyBpcyBuZWNlc3NhcmlseSBvdmVyLlxuICAgICAgLy8gSWYgdGhlcmUncyBtb3JlICpwYXR0ZXJuKiBsZWZ0LCB0aGVuXG4gICAgICBpZiAocGFydGlhbCkge1xuICAgICAgICAvLyByYW4gb3V0IG9mIGZpbGVcbiAgICAgICAgdGhpcy5kZWJ1ZygnXFxuPj4+IG5vIG1hdGNoLCBwYXJ0aWFsPycsIGZpbGUsIGZyLCBwYXR0ZXJuLCBwcilcbiAgICAgICAgaWYgKGZyID09PSBmbCkgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8vIHNvbWV0aGluZyBvdGhlciB0aGFuICoqXG4gICAgLy8gbm9uLW1hZ2ljIHBhdHRlcm5zIGp1c3QgaGF2ZSB0byBtYXRjaCBleGFjdGx5XG4gICAgLy8gcGF0dGVybnMgd2l0aCBtYWdpYyBoYXZlIGJlZW4gdHVybmVkIGludG8gcmVnZXhwcy5cbiAgICB2YXIgaGl0XG4gICAgaWYgKHR5cGVvZiBwID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKG9wdGlvbnMubm9jYXNlKSB7XG4gICAgICAgIGhpdCA9IGYudG9Mb3dlckNhc2UoKSA9PT0gcC50b0xvd2VyQ2FzZSgpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoaXQgPSBmID09PSBwXG4gICAgICB9XG4gICAgICB0aGlzLmRlYnVnKCdzdHJpbmcgbWF0Y2gnLCBwLCBmLCBoaXQpXG4gICAgfSBlbHNlIHtcbiAgICAgIGhpdCA9IGYubWF0Y2gocClcbiAgICAgIHRoaXMuZGVidWcoJ3BhdHRlcm4gbWF0Y2gnLCBwLCBmLCBoaXQpXG4gICAgfVxuXG4gICAgaWYgKCFoaXQpIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gTm90ZTogZW5kaW5nIGluIC8gbWVhbnMgdGhhdCB3ZSdsbCBnZXQgYSBmaW5hbCBcIlwiXG4gIC8vIGF0IHRoZSBlbmQgb2YgdGhlIHBhdHRlcm4uICBUaGlzIGNhbiBvbmx5IG1hdGNoIGFcbiAgLy8gY29ycmVzcG9uZGluZyBcIlwiIGF0IHRoZSBlbmQgb2YgdGhlIGZpbGUuXG4gIC8vIElmIHRoZSBmaWxlIGVuZHMgaW4gLywgdGhlbiBpdCBjYW4gb25seSBtYXRjaCBhXG4gIC8vIGEgcGF0dGVybiB0aGF0IGVuZHMgaW4gLywgdW5sZXNzIHRoZSBwYXR0ZXJuIGp1c3RcbiAgLy8gZG9lc24ndCBoYXZlIGFueSBtb3JlIGZvciBpdC4gQnV0LCBhL2IvIHNob3VsZCAqbm90KlxuICAvLyBtYXRjaCBcImEvYi8qXCIsIGV2ZW4gdGhvdWdoIFwiXCIgbWF0Y2hlcyBhZ2FpbnN0IHRoZVxuICAvLyBbXi9dKj8gcGF0dGVybiwgZXhjZXB0IGluIHBhcnRpYWwgbW9kZSwgd2hlcmUgaXQgbWlnaHRcbiAgLy8gc2ltcGx5IG5vdCBiZSByZWFjaGVkIHlldC5cbiAgLy8gSG93ZXZlciwgYS9iLyBzaG91bGQgc3RpbGwgc2F0aXNmeSBhLypcblxuICAvLyBub3cgZWl0aGVyIHdlIGZlbGwgb2ZmIHRoZSBlbmQgb2YgdGhlIHBhdHRlcm4sIG9yIHdlJ3JlIGRvbmUuXG4gIGlmIChmaSA9PT0gZmwgJiYgcGkgPT09IHBsKSB7XG4gICAgLy8gcmFuIG91dCBvZiBwYXR0ZXJuIGFuZCBmaWxlbmFtZSBhdCB0aGUgc2FtZSB0aW1lLlxuICAgIC8vIGFuIGV4YWN0IGhpdCFcbiAgICByZXR1cm4gdHJ1ZVxuICB9IGVsc2UgaWYgKGZpID09PSBmbCkge1xuICAgIC8vIHJhbiBvdXQgb2YgZmlsZSwgYnV0IHN0aWxsIGhhZCBwYXR0ZXJuIGxlZnQuXG4gICAgLy8gdGhpcyBpcyBvayBpZiB3ZSdyZSBkb2luZyB0aGUgbWF0Y2ggYXMgcGFydCBvZlxuICAgIC8vIGEgZ2xvYiBmcyB0cmF2ZXJzYWwuXG4gICAgcmV0dXJuIHBhcnRpYWxcbiAgfSBlbHNlIGlmIChwaSA9PT0gcGwpIHtcbiAgICAvLyByYW4gb3V0IG9mIHBhdHRlcm4sIHN0aWxsIGhhdmUgZmlsZSBsZWZ0LlxuICAgIC8vIHRoaXMgaXMgb25seSBhY2NlcHRhYmxlIGlmIHdlJ3JlIG9uIHRoZSB2ZXJ5IGxhc3RcbiAgICAvLyBlbXB0eSBzZWdtZW50IG9mIGEgZmlsZSB3aXRoIGEgdHJhaWxpbmcgc2xhc2guXG4gICAgLy8gYS8qIHNob3VsZCBtYXRjaCBhL2IvXG4gICAgdmFyIGVtcHR5RmlsZUVuZCA9IChmaSA9PT0gZmwgLSAxKSAmJiAoZmlsZVtmaV0gPT09ICcnKVxuICAgIHJldHVybiBlbXB0eUZpbGVFbmRcbiAgfVxuXG4gIC8vIHNob3VsZCBiZSB1bnJlYWNoYWJsZS5cbiAgdGhyb3cgbmV3IEVycm9yKCd3dGY/Jylcbn1cblxuLy8gcmVwbGFjZSBzdHVmZiBsaWtlIFxcKiB3aXRoICpcbmZ1bmN0aW9uIGdsb2JVbmVzY2FwZSAocykge1xuICByZXR1cm4gcy5yZXBsYWNlKC9cXFxcKC4pL2csICckMScpXG59XG5cbmZ1bmN0aW9uIHJlZ0V4cEVzY2FwZSAocykge1xuICByZXR1cm4gcy5yZXBsYWNlKC9bLVtcXF17fSgpKis/LixcXFxcXiR8I1xcc10vZywgJ1xcXFwkJicpXG59XG4iLCJ2YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbnZhciBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG52YXIgXzA3NzcgPSBwYXJzZUludCgnMDc3NycsIDgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG1rZGlyUC5ta2RpcnAgPSBta2RpclAubWtkaXJQID0gbWtkaXJQO1xuXG5mdW5jdGlvbiBta2RpclAgKHAsIG9wdHMsIGYsIG1hZGUpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZiA9IG9wdHM7XG4gICAgICAgIG9wdHMgPSB7fTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIW9wdHMgfHwgdHlwZW9mIG9wdHMgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIG9wdHMgPSB7IG1vZGU6IG9wdHMgfTtcbiAgICB9XG4gICAgXG4gICAgdmFyIG1vZGUgPSBvcHRzLm1vZGU7XG4gICAgdmFyIHhmcyA9IG9wdHMuZnMgfHwgZnM7XG4gICAgXG4gICAgaWYgKG1vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBtb2RlID0gXzA3NzcgJiAofnByb2Nlc3MudW1hc2soKSk7XG4gICAgfVxuICAgIGlmICghbWFkZSkgbWFkZSA9IG51bGw7XG4gICAgXG4gICAgdmFyIGNiID0gZiB8fCBmdW5jdGlvbiAoKSB7fTtcbiAgICBwID0gcGF0aC5yZXNvbHZlKHApO1xuICAgIFxuICAgIHhmcy5ta2RpcihwLCBtb2RlLCBmdW5jdGlvbiAoZXIpIHtcbiAgICAgICAgaWYgKCFlcikge1xuICAgICAgICAgICAgbWFkZSA9IG1hZGUgfHwgcDtcbiAgICAgICAgICAgIHJldHVybiBjYihudWxsLCBtYWRlKTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGVyLmNvZGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ0VOT0VOVCc6XG4gICAgICAgICAgICAgICAgbWtkaXJQKHBhdGguZGlybmFtZShwKSwgb3B0cywgZnVuY3Rpb24gKGVyLCBtYWRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcikgY2IoZXIsIG1hZGUpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIG1rZGlyUChwLCBvcHRzLCBjYiwgbWFkZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIC8vIEluIHRoZSBjYXNlIG9mIGFueSBvdGhlciBlcnJvciwganVzdCBzZWUgaWYgdGhlcmUncyBhIGRpclxuICAgICAgICAgICAgLy8gdGhlcmUgYWxyZWFkeS4gIElmIHNvLCB0aGVuIGhvb3JheSEgIElmIG5vdCwgdGhlbiBzb21ldGhpbmdcbiAgICAgICAgICAgIC8vIGlzIGJvcmtlZC5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgeGZzLnN0YXQocCwgZnVuY3Rpb24gKGVyMiwgc3RhdCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgc3RhdCBmYWlscywgdGhlbiB0aGF0J3Mgc3VwZXIgd2VpcmQuXG4gICAgICAgICAgICAgICAgICAgIC8vIGxldCB0aGUgb3JpZ2luYWwgZXJyb3IgYmUgdGhlIGZhaWx1cmUgcmVhc29uLlxuICAgICAgICAgICAgICAgICAgICBpZiAoZXIyIHx8ICFzdGF0LmlzRGlyZWN0b3J5KCkpIGNiKGVyLCBtYWRlKVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGNiKG51bGwsIG1hZGUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbm1rZGlyUC5zeW5jID0gZnVuY3Rpb24gc3luYyAocCwgb3B0cywgbWFkZSkge1xuICAgIGlmICghb3B0cyB8fCB0eXBlb2Ygb3B0cyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgb3B0cyA9IHsgbW9kZTogb3B0cyB9O1xuICAgIH1cbiAgICBcbiAgICB2YXIgbW9kZSA9IG9wdHMubW9kZTtcbiAgICB2YXIgeGZzID0gb3B0cy5mcyB8fCBmcztcbiAgICBcbiAgICBpZiAobW9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG1vZGUgPSBfMDc3NyAmICh+cHJvY2Vzcy51bWFzaygpKTtcbiAgICB9XG4gICAgaWYgKCFtYWRlKSBtYWRlID0gbnVsbDtcblxuICAgIHAgPSBwYXRoLnJlc29sdmUocCk7XG5cbiAgICB0cnkge1xuICAgICAgICB4ZnMubWtkaXJTeW5jKHAsIG1vZGUpO1xuICAgICAgICBtYWRlID0gbWFkZSB8fCBwO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyMCkge1xuICAgICAgICBzd2l0Y2ggKGVycjAuY29kZSkge1xuICAgICAgICAgICAgY2FzZSAnRU5PRU5UJyA6XG4gICAgICAgICAgICAgICAgbWFkZSA9IHN5bmMocGF0aC5kaXJuYW1lKHApLCBvcHRzLCBtYWRlKTtcbiAgICAgICAgICAgICAgICBzeW5jKHAsIG9wdHMsIG1hZGUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAvLyBJbiB0aGUgY2FzZSBvZiBhbnkgb3RoZXIgZXJyb3IsIGp1c3Qgc2VlIGlmIHRoZXJlJ3MgYSBkaXJcbiAgICAgICAgICAgIC8vIHRoZXJlIGFscmVhZHkuICBJZiBzbywgdGhlbiBob29yYXkhICBJZiBub3QsIHRoZW4gc29tZXRoaW5nXG4gICAgICAgICAgICAvLyBpcyBib3JrZWQuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHZhciBzdGF0O1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXQgPSB4ZnMuc3RhdFN5bmMocCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycjA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghc3RhdC5pc0RpcmVjdG9yeSgpKSB0aHJvdyBlcnIwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hZGU7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSBOdW1iZXIuaXNOYU4gfHwgZnVuY3Rpb24gKHgpIHtcblx0cmV0dXJuIHggIT09IHg7XG59O1xuIiwidmFyIHdyYXBweSA9IHJlcXVpcmUoJ3dyYXBweScpXG5tb2R1bGUuZXhwb3J0cyA9IHdyYXBweShvbmNlKVxubW9kdWxlLmV4cG9ydHMuc3RyaWN0ID0gd3JhcHB5KG9uY2VTdHJpY3QpXG5cbm9uY2UucHJvdG8gPSBvbmNlKGZ1bmN0aW9uICgpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZ1bmN0aW9uLnByb3RvdHlwZSwgJ29uY2UnLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBvbmNlKHRoaXMpXG4gICAgfSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSlcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRnVuY3Rpb24ucHJvdG90eXBlLCAnb25jZVN0cmljdCcsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG9uY2VTdHJpY3QodGhpcylcbiAgICB9LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KVxufSlcblxuZnVuY3Rpb24gb25jZSAoZm4pIHtcbiAgdmFyIGYgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGYuY2FsbGVkKSByZXR1cm4gZi52YWx1ZVxuICAgIGYuY2FsbGVkID0gdHJ1ZVxuICAgIHJldHVybiBmLnZhbHVlID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICB9XG4gIGYuY2FsbGVkID0gZmFsc2VcbiAgcmV0dXJuIGZcbn1cblxuZnVuY3Rpb24gb25jZVN0cmljdCAoZm4pIHtcbiAgdmFyIGYgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGYuY2FsbGVkKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGYub25jZUVycm9yKVxuICAgIGYuY2FsbGVkID0gdHJ1ZVxuICAgIHJldHVybiBmLnZhbHVlID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICB9XG4gIHZhciBuYW1lID0gZm4ubmFtZSB8fCAnRnVuY3Rpb24gd3JhcHBlZCB3aXRoIGBvbmNlYCdcbiAgZi5vbmNlRXJyb3IgPSBuYW1lICsgXCIgc2hvdWxkbid0IGJlIGNhbGxlZCBtb3JlIHRoYW4gb25jZVwiXG4gIGYuY2FsbGVkID0gZmFsc2VcbiAgcmV0dXJuIGZcbn1cbiIsIid1c2Ugc3RyaWN0JztcbnZhciBjaGlsZFByb2Nlc3MgPSByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJyk7XG52YXIgZXhlY0ZpbGVTeW5jID0gY2hpbGRQcm9jZXNzLmV4ZWNGaWxlU3luYztcbnZhciBsY2lkID0gcmVxdWlyZSgnbGNpZCcpO1xudmFyIGRlZmF1bHRPcHRzID0ge3NwYXduOiB0cnVlfTtcbnZhciBjYWNoZTtcblxuZnVuY3Rpb24gZmFsbGJhY2soKSB7XG5cdGNhY2hlID0gJ2VuX1VTJztcblx0cmV0dXJuIGNhY2hlO1xufVxuXG5mdW5jdGlvbiBnZXRFbnZMb2NhbGUoZW52KSB7XG5cdGVudiA9IGVudiB8fCBwcm9jZXNzLmVudjtcblx0dmFyIHJldCA9IGVudi5MQ19BTEwgfHwgZW52LkxDX01FU1NBR0VTIHx8IGVudi5MQU5HIHx8IGVudi5MQU5HVUFHRTtcblx0Y2FjaGUgPSBnZXRMb2NhbGUocmV0KTtcblx0cmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gcGFyc2VMb2NhbGUoeCkge1xuXHR2YXIgZW52ID0geC5zcGxpdCgnXFxuJykucmVkdWNlKGZ1bmN0aW9uIChlbnYsIGRlZikge1xuXHRcdGRlZiA9IGRlZi5zcGxpdCgnPScpO1xuXHRcdGVudltkZWZbMF1dID0gZGVmWzFdO1xuXHRcdHJldHVybiBlbnY7XG5cdH0sIHt9KTtcblx0cmV0dXJuIGdldEVudkxvY2FsZShlbnYpO1xufVxuXG5mdW5jdGlvbiBnZXRMb2NhbGUoc3RyKSB7XG5cdHJldHVybiAoc3RyICYmIHN0ci5yZXBsYWNlKC9bLjpdLiovLCAnJykpIHx8IGZhbGxiYWNrKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9wdHMsIGNiKSB7XG5cdGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdGNiID0gb3B0cztcblx0XHRvcHRzID0gZGVmYXVsdE9wdHM7XG5cdH0gZWxzZSB7XG5cdFx0b3B0cyA9IG9wdHMgfHwgZGVmYXVsdE9wdHM7XG5cdH1cblxuXHRpZiAoY2FjaGUgfHwgZ2V0RW52TG9jYWxlKCkgfHwgb3B0cy5zcGF3biA9PT0gZmFsc2UpIHtcblx0XHRzZXRJbW1lZGlhdGUoY2IsIG51bGwsIGNhY2hlKTtcblx0XHRyZXR1cm47XG5cdH1cblxuXHR2YXIgZ2V0QXBwbGVMb2NhbGUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0Y2hpbGRQcm9jZXNzLmV4ZWNGaWxlKCdkZWZhdWx0cycsIFsncmVhZCcsICctZycsICdBcHBsZUxvY2FsZSddLCBmdW5jdGlvbiAoZXJyLCBzdGRvdXQpIHtcblx0XHRcdGlmIChlcnIpIHtcblx0XHRcdFx0ZmFsbGJhY2soKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRjYWNoZSA9IHN0ZG91dC50cmltKCkgfHwgZmFsbGJhY2soKTtcblx0XHRcdGNiKG51bGwsIGNhY2hlKTtcblx0XHR9KTtcblx0fTtcblxuXHRpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJykge1xuXHRcdGNoaWxkUHJvY2Vzcy5leGVjRmlsZSgnd21pYycsIFsnb3MnLCAnZ2V0JywgJ2xvY2FsZSddLCBmdW5jdGlvbiAoZXJyLCBzdGRvdXQpIHtcblx0XHRcdGlmIChlcnIpIHtcblx0XHRcdFx0ZmFsbGJhY2soKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgbGNpZENvZGUgPSBwYXJzZUludChzdGRvdXQucmVwbGFjZSgnTG9jYWxlJywgJycpLCAxNik7XG5cdFx0XHRjYWNoZSA9IGxjaWQuZnJvbShsY2lkQ29kZSkgfHwgZmFsbGJhY2soKTtcblx0XHRcdGNiKG51bGwsIGNhY2hlKTtcblx0XHR9KTtcblx0fSBlbHNlIHtcblx0XHRjaGlsZFByb2Nlc3MuZXhlY0ZpbGUoJ2xvY2FsZScsIGZ1bmN0aW9uIChlcnIsIHN0ZG91dCkge1xuXHRcdFx0aWYgKGVycikge1xuXHRcdFx0XHRmYWxsYmFjaygpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHZhciByZXMgPSBwYXJzZUxvY2FsZShzdGRvdXQpO1xuXG5cdFx0XHRpZiAoIXJlcyAmJiBwcm9jZXNzLnBsYXRmb3JtID09PSAnZGFyd2luJykge1xuXHRcdFx0XHRnZXRBcHBsZUxvY2FsZSgpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGNhY2hlID0gZ2V0TG9jYWxlKHJlcyk7XG5cdFx0XHRjYihudWxsLCBjYWNoZSk7XG5cdFx0fSk7XG5cdH1cbn07XG5cbm1vZHVsZS5leHBvcnRzLnN5bmMgPSBmdW5jdGlvbiAob3B0cykge1xuXHRvcHRzID0gb3B0cyB8fCBkZWZhdWx0T3B0cztcblxuXHRpZiAoY2FjaGUgfHwgZ2V0RW52TG9jYWxlKCkgfHwgIWV4ZWNGaWxlU3luYyB8fCBvcHRzLnNwYXduID09PSBmYWxzZSkge1xuXHRcdHJldHVybiBjYWNoZTtcblx0fVxuXG5cdGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInKSB7XG5cdFx0dmFyIHN0ZG91dDtcblxuXHRcdHRyeSB7XG5cdFx0XHRzdGRvdXQgPSBleGVjRmlsZVN5bmMoJ3dtaWMnLCBbJ29zJywgJ2dldCcsICdsb2NhbGUnXSwge2VuY29kaW5nOiAndXRmOCd9KTtcblx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdHJldHVybiBmYWxsYmFjaygpO1xuXHRcdH1cblxuXHRcdHZhciBsY2lkQ29kZSA9IHBhcnNlSW50KHN0ZG91dC5yZXBsYWNlKCdMb2NhbGUnLCAnJyksIDE2KTtcblx0XHRjYWNoZSA9IGxjaWQuZnJvbShsY2lkQ29kZSkgfHwgZmFsbGJhY2soKTtcblx0XHRyZXR1cm4gY2FjaGU7XG5cdH1cblxuXHR2YXIgcmVzO1xuXG5cdHRyeSB7XG5cdFx0cmVzID0gcGFyc2VMb2NhbGUoZXhlY0ZpbGVTeW5jKCdsb2NhbGUnLCB7ZW5jb2Rpbmc6ICd1dGY4J30pKTtcblx0fSBjYXRjaCAoZXJyKSB7fVxuXG5cdGlmICghcmVzICYmIHByb2Nlc3MucGxhdGZvcm0gPT09ICdkYXJ3aW4nKSB7XG5cdFx0dHJ5IHtcblx0XHRcdGNhY2hlID0gZXhlY0ZpbGVTeW5jKCdkZWZhdWx0cycsIFsncmVhZCcsICctZycsICdBcHBsZUxvY2FsZSddLCB7ZW5jb2Rpbmc6ICd1dGY4J30pLnRyaW0oKSB8fCBmYWxsYmFjaygpO1xuXHRcdFx0cmV0dXJuIGNhY2hlO1xuXHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0cmV0dXJuIGZhbGxiYWNrKCk7XG5cdFx0fVxuXHR9XG5cblx0Y2FjaGUgPSBnZXRMb2NhbGUocmVzKTtcblx0cmV0dXJuIGNhY2hlO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gcG9zaXgocGF0aCkge1xuXHRyZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbn1cblxuZnVuY3Rpb24gd2luMzIocGF0aCkge1xuXHQvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvYmxvYi9iM2ZjYzI0NWZiMjU1Mzk5MDllZjFkNWVhYTAxZGJmOTJlMTY4NjMzL2xpYi9wYXRoLmpzI0w1NlxuXHR2YXIgc3BsaXREZXZpY2VSZSA9IC9eKFthLXpBLVpdOnxbXFxcXFxcL117Mn1bXlxcXFxcXC9dK1tcXFxcXFwvXStbXlxcXFxcXC9dKyk/KFtcXFxcXFwvXSk/KFtcXHNcXFNdKj8pJC87XG5cdHZhciByZXN1bHQgPSBzcGxpdERldmljZVJlLmV4ZWMocGF0aCk7XG5cdHZhciBkZXZpY2UgPSByZXN1bHRbMV0gfHwgJyc7XG5cdHZhciBpc1VuYyA9IEJvb2xlYW4oZGV2aWNlICYmIGRldmljZS5jaGFyQXQoMSkgIT09ICc6Jyk7XG5cblx0Ly8gVU5DIHBhdGhzIGFyZSBhbHdheXMgYWJzb2x1dGVcblx0cmV0dXJuIEJvb2xlYW4ocmVzdWx0WzJdIHx8IGlzVW5jKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInID8gd2luMzIgOiBwb3NpeDtcbm1vZHVsZS5leHBvcnRzLnBvc2l4ID0gcG9zaXg7XG5tb2R1bGUuZXhwb3J0cy53aW4zMiA9IHdpbjMyO1xuIiwibW9kdWxlLmV4cG9ydHMgPSByaW1yYWZcbnJpbXJhZi5zeW5jID0gcmltcmFmU3luY1xuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZShcImFzc2VydFwiKVxudmFyIHBhdGggPSByZXF1aXJlKFwicGF0aFwiKVxudmFyIGZzID0gcmVxdWlyZShcImZzXCIpXG52YXIgZ2xvYiA9IHJlcXVpcmUoXCJnbG9iXCIpXG52YXIgXzA2NjYgPSBwYXJzZUludCgnNjY2JywgOClcblxudmFyIGRlZmF1bHRHbG9iT3B0cyA9IHtcbiAgbm9zb3J0OiB0cnVlLFxuICBzaWxlbnQ6IHRydWVcbn1cblxuLy8gZm9yIEVNRklMRSBoYW5kbGluZ1xudmFyIHRpbWVvdXQgPSAwXG5cbnZhciBpc1dpbmRvd3MgPSAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gXCJ3aW4zMlwiKVxuXG5mdW5jdGlvbiBkZWZhdWx0cyAob3B0aW9ucykge1xuICB2YXIgbWV0aG9kcyA9IFtcbiAgICAndW5saW5rJyxcbiAgICAnY2htb2QnLFxuICAgICdzdGF0JyxcbiAgICAnbHN0YXQnLFxuICAgICdybWRpcicsXG4gICAgJ3JlYWRkaXInXG4gIF1cbiAgbWV0aG9kcy5mb3JFYWNoKGZ1bmN0aW9uKG0pIHtcbiAgICBvcHRpb25zW21dID0gb3B0aW9uc1ttXSB8fCBmc1ttXVxuICAgIG0gPSBtICsgJ1N5bmMnXG4gICAgb3B0aW9uc1ttXSA9IG9wdGlvbnNbbV0gfHwgZnNbbV1cbiAgfSlcblxuICBvcHRpb25zLm1heEJ1c3lUcmllcyA9IG9wdGlvbnMubWF4QnVzeVRyaWVzIHx8IDNcbiAgb3B0aW9ucy5lbWZpbGVXYWl0ID0gb3B0aW9ucy5lbWZpbGVXYWl0IHx8IDEwMDBcbiAgaWYgKG9wdGlvbnMuZ2xvYiA9PT0gZmFsc2UpIHtcbiAgICBvcHRpb25zLmRpc2FibGVHbG9iID0gdHJ1ZVxuICB9XG4gIG9wdGlvbnMuZGlzYWJsZUdsb2IgPSBvcHRpb25zLmRpc2FibGVHbG9iIHx8IGZhbHNlXG4gIG9wdGlvbnMuZ2xvYiA9IG9wdGlvbnMuZ2xvYiB8fCBkZWZhdWx0R2xvYk9wdHNcbn1cblxuZnVuY3Rpb24gcmltcmFmIChwLCBvcHRpb25zLCBjYikge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IG9wdGlvbnNcbiAgICBvcHRpb25zID0ge31cbiAgfVxuXG4gIGFzc2VydChwLCAncmltcmFmOiBtaXNzaW5nIHBhdGgnKVxuICBhc3NlcnQuZXF1YWwodHlwZW9mIHAsICdzdHJpbmcnLCAncmltcmFmOiBwYXRoIHNob3VsZCBiZSBhIHN0cmluZycpXG4gIGFzc2VydC5lcXVhbCh0eXBlb2YgY2IsICdmdW5jdGlvbicsICdyaW1yYWY6IGNhbGxiYWNrIGZ1bmN0aW9uIHJlcXVpcmVkJylcbiAgYXNzZXJ0KG9wdGlvbnMsICdyaW1yYWY6IGludmFsaWQgb3B0aW9ucyBhcmd1bWVudCBwcm92aWRlZCcpXG4gIGFzc2VydC5lcXVhbCh0eXBlb2Ygb3B0aW9ucywgJ29iamVjdCcsICdyaW1yYWY6IG9wdGlvbnMgc2hvdWxkIGJlIG9iamVjdCcpXG5cbiAgZGVmYXVsdHMob3B0aW9ucylcblxuICB2YXIgYnVzeVRyaWVzID0gMFxuICB2YXIgZXJyU3RhdGUgPSBudWxsXG4gIHZhciBuID0gMFxuXG4gIGlmIChvcHRpb25zLmRpc2FibGVHbG9iIHx8ICFnbG9iLmhhc01hZ2ljKHApKVxuICAgIHJldHVybiBhZnRlckdsb2IobnVsbCwgW3BdKVxuXG4gIG9wdGlvbnMubHN0YXQocCwgZnVuY3Rpb24gKGVyLCBzdGF0KSB7XG4gICAgaWYgKCFlcilcbiAgICAgIHJldHVybiBhZnRlckdsb2IobnVsbCwgW3BdKVxuXG4gICAgZ2xvYihwLCBvcHRpb25zLmdsb2IsIGFmdGVyR2xvYilcbiAgfSlcblxuICBmdW5jdGlvbiBuZXh0IChlcikge1xuICAgIGVyclN0YXRlID0gZXJyU3RhdGUgfHwgZXJcbiAgICBpZiAoLS1uID09PSAwKVxuICAgICAgY2IoZXJyU3RhdGUpXG4gIH1cblxuICBmdW5jdGlvbiBhZnRlckdsb2IgKGVyLCByZXN1bHRzKSB7XG4gICAgaWYgKGVyKVxuICAgICAgcmV0dXJuIGNiKGVyKVxuXG4gICAgbiA9IHJlc3VsdHMubGVuZ3RoXG4gICAgaWYgKG4gPT09IDApXG4gICAgICByZXR1cm4gY2IoKVxuXG4gICAgcmVzdWx0cy5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7XG4gICAgICByaW1yYWZfKHAsIG9wdGlvbnMsIGZ1bmN0aW9uIENCIChlcikge1xuICAgICAgICBpZiAoZXIpIHtcbiAgICAgICAgICBpZiAoKGVyLmNvZGUgPT09IFwiRUJVU1lcIiB8fCBlci5jb2RlID09PSBcIkVOT1RFTVBUWVwiIHx8IGVyLmNvZGUgPT09IFwiRVBFUk1cIikgJiZcbiAgICAgICAgICAgICAgYnVzeVRyaWVzIDwgb3B0aW9ucy5tYXhCdXN5VHJpZXMpIHtcbiAgICAgICAgICAgIGJ1c3lUcmllcyArK1xuICAgICAgICAgICAgdmFyIHRpbWUgPSBidXN5VHJpZXMgKiAxMDBcbiAgICAgICAgICAgIC8vIHRyeSBhZ2Fpbiwgd2l0aCB0aGUgc2FtZSBleGFjdCBjYWxsYmFjayBhcyB0aGlzIG9uZS5cbiAgICAgICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmltcmFmXyhwLCBvcHRpb25zLCBDQilcbiAgICAgICAgICAgIH0sIHRpbWUpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gdGhpcyBvbmUgd29uJ3QgaGFwcGVuIGlmIGdyYWNlZnVsLWZzIGlzIHVzZWQuXG4gICAgICAgICAgaWYgKGVyLmNvZGUgPT09IFwiRU1GSUxFXCIgJiYgdGltZW91dCA8IG9wdGlvbnMuZW1maWxlV2FpdCkge1xuICAgICAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByaW1yYWZfKHAsIG9wdGlvbnMsIENCKVxuICAgICAgICAgICAgfSwgdGltZW91dCArKylcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBhbHJlYWR5IGdvbmVcbiAgICAgICAgICBpZiAoZXIuY29kZSA9PT0gXCJFTk9FTlRcIikgZXIgPSBudWxsXG4gICAgICAgIH1cblxuICAgICAgICB0aW1lb3V0ID0gMFxuICAgICAgICBuZXh0KGVyKVxuICAgICAgfSlcbiAgICB9KVxuICB9XG59XG5cbi8vIFR3byBwb3NzaWJsZSBzdHJhdGVnaWVzLlxuLy8gMS4gQXNzdW1lIGl0J3MgYSBmaWxlLiAgdW5saW5rIGl0LCB0aGVuIGRvIHRoZSBkaXIgc3R1ZmYgb24gRVBFUk0gb3IgRUlTRElSXG4vLyAyLiBBc3N1bWUgaXQncyBhIGRpcmVjdG9yeS4gIHJlYWRkaXIsIHRoZW4gZG8gdGhlIGZpbGUgc3R1ZmYgb24gRU5PVERJUlxuLy9cbi8vIEJvdGggcmVzdWx0IGluIGFuIGV4dHJhIHN5c2NhbGwgd2hlbiB5b3UgZ3Vlc3Mgd3JvbmcuICBIb3dldmVyLCB0aGVyZVxuLy8gYXJlIGxpa2VseSBmYXIgbW9yZSBub3JtYWwgZmlsZXMgaW4gdGhlIHdvcmxkIHRoYW4gZGlyZWN0b3JpZXMuICBUaGlzXG4vLyBpcyBiYXNlZCBvbiB0aGUgYXNzdW1wdGlvbiB0aGF0IGEgdGhlIGF2ZXJhZ2UgbnVtYmVyIG9mIGZpbGVzIHBlclxuLy8gZGlyZWN0b3J5IGlzID49IDEuXG4vL1xuLy8gSWYgYW55b25lIGV2ZXIgY29tcGxhaW5zIGFib3V0IHRoaXMsIHRoZW4gSSBndWVzcyB0aGUgc3RyYXRlZ3kgY291bGRcbi8vIGJlIG1hZGUgY29uZmlndXJhYmxlIHNvbWVob3cuICBCdXQgdW50aWwgdGhlbiwgWUFHTkkuXG5mdW5jdGlvbiByaW1yYWZfIChwLCBvcHRpb25zLCBjYikge1xuICBhc3NlcnQocClcbiAgYXNzZXJ0KG9wdGlvbnMpXG4gIGFzc2VydCh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpXG5cbiAgLy8gc3Vub3MgbGV0cyB0aGUgcm9vdCB1c2VyIHVubGluayBkaXJlY3Rvcmllcywgd2hpY2ggaXMuLi4gd2VpcmQuXG4gIC8vIHNvIHdlIGhhdmUgdG8gbHN0YXQgaGVyZSBhbmQgbWFrZSBzdXJlIGl0J3Mgbm90IGEgZGlyLlxuICBvcHRpb25zLmxzdGF0KHAsIGZ1bmN0aW9uIChlciwgc3QpIHtcbiAgICBpZiAoZXIgJiYgZXIuY29kZSA9PT0gXCJFTk9FTlRcIilcbiAgICAgIHJldHVybiBjYihudWxsKVxuXG4gICAgLy8gV2luZG93cyBjYW4gRVBFUk0gb24gc3RhdC4gIExpZmUgaXMgc3VmZmVyaW5nLlxuICAgIGlmIChlciAmJiBlci5jb2RlID09PSBcIkVQRVJNXCIgJiYgaXNXaW5kb3dzKVxuICAgICAgZml4V2luRVBFUk0ocCwgb3B0aW9ucywgZXIsIGNiKVxuXG4gICAgaWYgKHN0ICYmIHN0LmlzRGlyZWN0b3J5KCkpXG4gICAgICByZXR1cm4gcm1kaXIocCwgb3B0aW9ucywgZXIsIGNiKVxuXG4gICAgb3B0aW9ucy51bmxpbmsocCwgZnVuY3Rpb24gKGVyKSB7XG4gICAgICBpZiAoZXIpIHtcbiAgICAgICAgaWYgKGVyLmNvZGUgPT09IFwiRU5PRU5UXCIpXG4gICAgICAgICAgcmV0dXJuIGNiKG51bGwpXG4gICAgICAgIGlmIChlci5jb2RlID09PSBcIkVQRVJNXCIpXG4gICAgICAgICAgcmV0dXJuIChpc1dpbmRvd3MpXG4gICAgICAgICAgICA/IGZpeFdpbkVQRVJNKHAsIG9wdGlvbnMsIGVyLCBjYilcbiAgICAgICAgICAgIDogcm1kaXIocCwgb3B0aW9ucywgZXIsIGNiKVxuICAgICAgICBpZiAoZXIuY29kZSA9PT0gXCJFSVNESVJcIilcbiAgICAgICAgICByZXR1cm4gcm1kaXIocCwgb3B0aW9ucywgZXIsIGNiKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGNiKGVyKVxuICAgIH0pXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGZpeFdpbkVQRVJNIChwLCBvcHRpb25zLCBlciwgY2IpIHtcbiAgYXNzZXJ0KHApXG4gIGFzc2VydChvcHRpb25zKVxuICBhc3NlcnQodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKVxuICBpZiAoZXIpXG4gICAgYXNzZXJ0KGVyIGluc3RhbmNlb2YgRXJyb3IpXG5cbiAgb3B0aW9ucy5jaG1vZChwLCBfMDY2NiwgZnVuY3Rpb24gKGVyMikge1xuICAgIGlmIChlcjIpXG4gICAgICBjYihlcjIuY29kZSA9PT0gXCJFTk9FTlRcIiA/IG51bGwgOiBlcilcbiAgICBlbHNlXG4gICAgICBvcHRpb25zLnN0YXQocCwgZnVuY3Rpb24oZXIzLCBzdGF0cykge1xuICAgICAgICBpZiAoZXIzKVxuICAgICAgICAgIGNiKGVyMy5jb2RlID09PSBcIkVOT0VOVFwiID8gbnVsbCA6IGVyKVxuICAgICAgICBlbHNlIGlmIChzdGF0cy5pc0RpcmVjdG9yeSgpKVxuICAgICAgICAgIHJtZGlyKHAsIG9wdGlvbnMsIGVyLCBjYilcbiAgICAgICAgZWxzZVxuICAgICAgICAgIG9wdGlvbnMudW5saW5rKHAsIGNiKVxuICAgICAgfSlcbiAgfSlcbn1cblxuZnVuY3Rpb24gZml4V2luRVBFUk1TeW5jIChwLCBvcHRpb25zLCBlcikge1xuICBhc3NlcnQocClcbiAgYXNzZXJ0KG9wdGlvbnMpXG4gIGlmIChlcilcbiAgICBhc3NlcnQoZXIgaW5zdGFuY2VvZiBFcnJvcilcblxuICB0cnkge1xuICAgIG9wdGlvbnMuY2htb2RTeW5jKHAsIF8wNjY2KVxuICB9IGNhdGNoIChlcjIpIHtcbiAgICBpZiAoZXIyLmNvZGUgPT09IFwiRU5PRU5UXCIpXG4gICAgICByZXR1cm5cbiAgICBlbHNlXG4gICAgICB0aHJvdyBlclxuICB9XG5cbiAgdHJ5IHtcbiAgICB2YXIgc3RhdHMgPSBvcHRpb25zLnN0YXRTeW5jKHApXG4gIH0gY2F0Y2ggKGVyMykge1xuICAgIGlmIChlcjMuY29kZSA9PT0gXCJFTk9FTlRcIilcbiAgICAgIHJldHVyblxuICAgIGVsc2VcbiAgICAgIHRocm93IGVyXG4gIH1cblxuICBpZiAoc3RhdHMuaXNEaXJlY3RvcnkoKSlcbiAgICBybWRpclN5bmMocCwgb3B0aW9ucywgZXIpXG4gIGVsc2VcbiAgICBvcHRpb25zLnVubGlua1N5bmMocClcbn1cblxuZnVuY3Rpb24gcm1kaXIgKHAsIG9wdGlvbnMsIG9yaWdpbmFsRXIsIGNiKSB7XG4gIGFzc2VydChwKVxuICBhc3NlcnQob3B0aW9ucylcbiAgaWYgKG9yaWdpbmFsRXIpXG4gICAgYXNzZXJ0KG9yaWdpbmFsRXIgaW5zdGFuY2VvZiBFcnJvcilcbiAgYXNzZXJ0KHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJylcblxuICAvLyB0cnkgdG8gcm1kaXIgZmlyc3QsIGFuZCBvbmx5IHJlYWRkaXIgb24gRU5PVEVNUFRZIG9yIEVFWElTVCAoU3VuT1MpXG4gIC8vIGlmIHdlIGd1ZXNzZWQgd3JvbmcsIGFuZCBpdCdzIG5vdCBhIGRpcmVjdG9yeSwgdGhlblxuICAvLyByYWlzZSB0aGUgb3JpZ2luYWwgZXJyb3IuXG4gIG9wdGlvbnMucm1kaXIocCwgZnVuY3Rpb24gKGVyKSB7XG4gICAgaWYgKGVyICYmIChlci5jb2RlID09PSBcIkVOT1RFTVBUWVwiIHx8IGVyLmNvZGUgPT09IFwiRUVYSVNUXCIgfHwgZXIuY29kZSA9PT0gXCJFUEVSTVwiKSlcbiAgICAgIHJta2lkcyhwLCBvcHRpb25zLCBjYilcbiAgICBlbHNlIGlmIChlciAmJiBlci5jb2RlID09PSBcIkVOT1RESVJcIilcbiAgICAgIGNiKG9yaWdpbmFsRXIpXG4gICAgZWxzZVxuICAgICAgY2IoZXIpXG4gIH0pXG59XG5cbmZ1bmN0aW9uIHJta2lkcyhwLCBvcHRpb25zLCBjYikge1xuICBhc3NlcnQocClcbiAgYXNzZXJ0KG9wdGlvbnMpXG4gIGFzc2VydCh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpXG5cbiAgb3B0aW9ucy5yZWFkZGlyKHAsIGZ1bmN0aW9uIChlciwgZmlsZXMpIHtcbiAgICBpZiAoZXIpXG4gICAgICByZXR1cm4gY2IoZXIpXG4gICAgdmFyIG4gPSBmaWxlcy5sZW5ndGhcbiAgICBpZiAobiA9PT0gMClcbiAgICAgIHJldHVybiBvcHRpb25zLnJtZGlyKHAsIGNiKVxuICAgIHZhciBlcnJTdGF0ZVxuICAgIGZpbGVzLmZvckVhY2goZnVuY3Rpb24gKGYpIHtcbiAgICAgIHJpbXJhZihwYXRoLmpvaW4ocCwgZiksIG9wdGlvbnMsIGZ1bmN0aW9uIChlcikge1xuICAgICAgICBpZiAoZXJyU3RhdGUpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIGlmIChlcilcbiAgICAgICAgICByZXR1cm4gY2IoZXJyU3RhdGUgPSBlcilcbiAgICAgICAgaWYgKC0tbiA9PT0gMClcbiAgICAgICAgICBvcHRpb25zLnJtZGlyKHAsIGNiKVxuICAgICAgfSlcbiAgICB9KVxuICB9KVxufVxuXG4vLyB0aGlzIGxvb2tzIHNpbXBsZXIsIGFuZCBpcyBzdHJpY3RseSAqZmFzdGVyKiwgYnV0IHdpbGxcbi8vIHRpZSB1cCB0aGUgSmF2YVNjcmlwdCB0aHJlYWQgYW5kIGZhaWwgb24gZXhjZXNzaXZlbHlcbi8vIGRlZXAgZGlyZWN0b3J5IHRyZWVzLlxuZnVuY3Rpb24gcmltcmFmU3luYyAocCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICBkZWZhdWx0cyhvcHRpb25zKVxuXG4gIGFzc2VydChwLCAncmltcmFmOiBtaXNzaW5nIHBhdGgnKVxuICBhc3NlcnQuZXF1YWwodHlwZW9mIHAsICdzdHJpbmcnLCAncmltcmFmOiBwYXRoIHNob3VsZCBiZSBhIHN0cmluZycpXG4gIGFzc2VydChvcHRpb25zLCAncmltcmFmOiBtaXNzaW5nIG9wdGlvbnMnKVxuICBhc3NlcnQuZXF1YWwodHlwZW9mIG9wdGlvbnMsICdvYmplY3QnLCAncmltcmFmOiBvcHRpb25zIHNob3VsZCBiZSBvYmplY3QnKVxuXG4gIHZhciByZXN1bHRzXG5cbiAgaWYgKG9wdGlvbnMuZGlzYWJsZUdsb2IgfHwgIWdsb2IuaGFzTWFnaWMocCkpIHtcbiAgICByZXN1bHRzID0gW3BdXG4gIH0gZWxzZSB7XG4gICAgdHJ5IHtcbiAgICAgIG9wdGlvbnMubHN0YXRTeW5jKHApXG4gICAgICByZXN1bHRzID0gW3BdXG4gICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgIHJlc3VsdHMgPSBnbG9iLnN5bmMocCwgb3B0aW9ucy5nbG9iKVxuICAgIH1cbiAgfVxuXG4gIGlmICghcmVzdWx0cy5sZW5ndGgpXG4gICAgcmV0dXJuXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXN1bHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHAgPSByZXN1bHRzW2ldXG5cbiAgICB0cnkge1xuICAgICAgdmFyIHN0ID0gb3B0aW9ucy5sc3RhdFN5bmMocClcbiAgICB9IGNhdGNoIChlcikge1xuICAgICAgaWYgKGVyLmNvZGUgPT09IFwiRU5PRU5UXCIpXG4gICAgICAgIHJldHVyblxuXG4gICAgICAvLyBXaW5kb3dzIGNhbiBFUEVSTSBvbiBzdGF0LiAgTGlmZSBpcyBzdWZmZXJpbmcuXG4gICAgICBpZiAoZXIuY29kZSA9PT0gXCJFUEVSTVwiICYmIGlzV2luZG93cylcbiAgICAgICAgZml4V2luRVBFUk1TeW5jKHAsIG9wdGlvbnMsIGVyKVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAvLyBzdW5vcyBsZXRzIHRoZSByb290IHVzZXIgdW5saW5rIGRpcmVjdG9yaWVzLCB3aGljaCBpcy4uLiB3ZWlyZC5cbiAgICAgIGlmIChzdCAmJiBzdC5pc0RpcmVjdG9yeSgpKVxuICAgICAgICBybWRpclN5bmMocCwgb3B0aW9ucywgbnVsbClcbiAgICAgIGVsc2VcbiAgICAgICAgb3B0aW9ucy51bmxpbmtTeW5jKHApXG4gICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgIGlmIChlci5jb2RlID09PSBcIkVOT0VOVFwiKVxuICAgICAgICByZXR1cm5cbiAgICAgIGlmIChlci5jb2RlID09PSBcIkVQRVJNXCIpXG4gICAgICAgIHJldHVybiBpc1dpbmRvd3MgPyBmaXhXaW5FUEVSTVN5bmMocCwgb3B0aW9ucywgZXIpIDogcm1kaXJTeW5jKHAsIG9wdGlvbnMsIGVyKVxuICAgICAgaWYgKGVyLmNvZGUgIT09IFwiRUlTRElSXCIpXG4gICAgICAgIHRocm93IGVyXG5cbiAgICAgIHJtZGlyU3luYyhwLCBvcHRpb25zLCBlcilcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcm1kaXJTeW5jIChwLCBvcHRpb25zLCBvcmlnaW5hbEVyKSB7XG4gIGFzc2VydChwKVxuICBhc3NlcnQob3B0aW9ucylcbiAgaWYgKG9yaWdpbmFsRXIpXG4gICAgYXNzZXJ0KG9yaWdpbmFsRXIgaW5zdGFuY2VvZiBFcnJvcilcblxuICB0cnkge1xuICAgIG9wdGlvbnMucm1kaXJTeW5jKHApXG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgaWYgKGVyLmNvZGUgPT09IFwiRU5PRU5UXCIpXG4gICAgICByZXR1cm5cbiAgICBpZiAoZXIuY29kZSA9PT0gXCJFTk9URElSXCIpXG4gICAgICB0aHJvdyBvcmlnaW5hbEVyXG4gICAgaWYgKGVyLmNvZGUgPT09IFwiRU5PVEVNUFRZXCIgfHwgZXIuY29kZSA9PT0gXCJFRVhJU1RcIiB8fCBlci5jb2RlID09PSBcIkVQRVJNXCIpXG4gICAgICBybWtpZHNTeW5jKHAsIG9wdGlvbnMpXG4gIH1cbn1cblxuZnVuY3Rpb24gcm1raWRzU3luYyAocCwgb3B0aW9ucykge1xuICBhc3NlcnQocClcbiAgYXNzZXJ0KG9wdGlvbnMpXG4gIG9wdGlvbnMucmVhZGRpclN5bmMocCkuZm9yRWFjaChmdW5jdGlvbiAoZikge1xuICAgIHJpbXJhZlN5bmMocGF0aC5qb2luKHAsIGYpLCBvcHRpb25zKVxuICB9KVxuXG4gIC8vIFdlIG9ubHkgZW5kIHVwIGhlcmUgb25jZSB3ZSBnb3QgRU5PVEVNUFRZIGF0IGxlYXN0IG9uY2UsIGFuZFxuICAvLyBhdCB0aGlzIHBvaW50LCB3ZSBhcmUgZ3VhcmFudGVlZCB0byBoYXZlIHJlbW92ZWQgYWxsIHRoZSBraWRzLlxuICAvLyBTbywgd2Uga25vdyB0aGF0IGl0IHdvbid0IGJlIEVOT0VOVCBvciBFTk9URElSIG9yIGFueXRoaW5nIGVsc2UuXG4gIC8vIHRyeSByZWFsbHkgaGFyZCB0byBkZWxldGUgc3R1ZmYgb24gd2luZG93cywgYmVjYXVzZSBpdCBoYXMgYVxuICAvLyBQUk9GT1VORExZIGFubm95aW5nIGhhYml0IG9mIG5vdCBjbG9zaW5nIGhhbmRsZXMgcHJvbXB0bHkgd2hlblxuICAvLyBmaWxlcyBhcmUgZGVsZXRlZCwgcmVzdWx0aW5nIGluIHNwdXJpb3VzIEVOT1RFTVBUWSBlcnJvcnMuXG4gIHZhciByZXRyaWVzID0gaXNXaW5kb3dzID8gMTAwIDogMVxuICB2YXIgaSA9IDBcbiAgZG8ge1xuICAgIHZhciB0aHJldyA9IHRydWVcbiAgICB0cnkge1xuICAgICAgdmFyIHJldCA9IG9wdGlvbnMucm1kaXJTeW5jKHAsIG9wdGlvbnMpXG4gICAgICB0aHJldyA9IGZhbHNlXG4gICAgICByZXR1cm4gcmV0XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmICgrK2kgPCByZXRyaWVzICYmIHRocmV3KVxuICAgICAgICBjb250aW51ZVxuICAgIH1cbiAgfSB3aGlsZSAodHJ1ZSlcbn1cbiIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IFNlbVZlcjtcblxuLy8gVGhlIGRlYnVnIGZ1bmN0aW9uIGlzIGV4Y2x1ZGVkIGVudGlyZWx5IGZyb20gdGhlIG1pbmlmaWVkIHZlcnNpb24uXG4vKiBub21pbiAqLyB2YXIgZGVidWc7XG4vKiBub21pbiAqLyBpZiAodHlwZW9mIHByb2Nlc3MgPT09ICdvYmplY3QnICYmXG4gICAgLyogbm9taW4gKi8gcHJvY2Vzcy5lbnYgJiZcbiAgICAvKiBub21pbiAqLyBwcm9jZXNzLmVudi5OT0RFX0RFQlVHICYmXG4gICAgLyogbm9taW4gKi8gL1xcYnNlbXZlclxcYi9pLnRlc3QocHJvY2Vzcy5lbnYuTk9ERV9ERUJVRykpXG4gIC8qIG5vbWluICovIGRlYnVnID0gZnVuY3Rpb24oKSB7XG4gICAgLyogbm9taW4gKi8gdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICAgIC8qIG5vbWluICovIGFyZ3MudW5zaGlmdCgnU0VNVkVSJyk7XG4gICAgLyogbm9taW4gKi8gY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJncyk7XG4gICAgLyogbm9taW4gKi8gfTtcbi8qIG5vbWluICovIGVsc2VcbiAgLyogbm9taW4gKi8gZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuXG4vLyBOb3RlOiB0aGlzIGlzIHRoZSBzZW12ZXIub3JnIHZlcnNpb24gb2YgdGhlIHNwZWMgdGhhdCBpdCBpbXBsZW1lbnRzXG4vLyBOb3QgbmVjZXNzYXJpbHkgdGhlIHBhY2thZ2UgdmVyc2lvbiBvZiB0aGlzIGNvZGUuXG5leHBvcnRzLlNFTVZFUl9TUEVDX1ZFUlNJT04gPSAnMi4wLjAnO1xuXG52YXIgTUFYX0xFTkdUSCA9IDI1NjtcbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgfHwgOTAwNzE5OTI1NDc0MDk5MTtcblxuLy8gTWF4IHNhZmUgc2VnbWVudCBsZW5ndGggZm9yIGNvZXJjaW9uLlxudmFyIE1BWF9TQUZFX0NPTVBPTkVOVF9MRU5HVEggPSAxNjtcblxuLy8gVGhlIGFjdHVhbCByZWdleHBzIGdvIG9uIGV4cG9ydHMucmVcbnZhciByZSA9IGV4cG9ydHMucmUgPSBbXTtcbnZhciBzcmMgPSBleHBvcnRzLnNyYyA9IFtdO1xudmFyIFIgPSAwO1xuXG4vLyBUaGUgZm9sbG93aW5nIFJlZ3VsYXIgRXhwcmVzc2lvbnMgY2FuIGJlIHVzZWQgZm9yIHRva2VuaXppbmcsXG4vLyB2YWxpZGF0aW5nLCBhbmQgcGFyc2luZyBTZW1WZXIgdmVyc2lvbiBzdHJpbmdzLlxuXG4vLyAjIyBOdW1lcmljIElkZW50aWZpZXJcbi8vIEEgc2luZ2xlIGAwYCwgb3IgYSBub24temVybyBkaWdpdCBmb2xsb3dlZCBieSB6ZXJvIG9yIG1vcmUgZGlnaXRzLlxuXG52YXIgTlVNRVJJQ0lERU5USUZJRVIgPSBSKys7XG5zcmNbTlVNRVJJQ0lERU5USUZJRVJdID0gJzB8WzEtOV1cXFxcZConO1xudmFyIE5VTUVSSUNJREVOVElGSUVSTE9PU0UgPSBSKys7XG5zcmNbTlVNRVJJQ0lERU5USUZJRVJMT09TRV0gPSAnWzAtOV0rJztcblxuXG4vLyAjIyBOb24tbnVtZXJpYyBJZGVudGlmaWVyXG4vLyBaZXJvIG9yIG1vcmUgZGlnaXRzLCBmb2xsb3dlZCBieSBhIGxldHRlciBvciBoeXBoZW4sIGFuZCB0aGVuIHplcm8gb3Jcbi8vIG1vcmUgbGV0dGVycywgZGlnaXRzLCBvciBoeXBoZW5zLlxuXG52YXIgTk9OTlVNRVJJQ0lERU5USUZJRVIgPSBSKys7XG5zcmNbTk9OTlVNRVJJQ0lERU5USUZJRVJdID0gJ1xcXFxkKlthLXpBLVotXVthLXpBLVowLTktXSonO1xuXG5cbi8vICMjIE1haW4gVmVyc2lvblxuLy8gVGhyZWUgZG90LXNlcGFyYXRlZCBudW1lcmljIGlkZW50aWZpZXJzLlxuXG52YXIgTUFJTlZFUlNJT04gPSBSKys7XG5zcmNbTUFJTlZFUlNJT05dID0gJygnICsgc3JjW05VTUVSSUNJREVOVElGSUVSXSArICcpXFxcXC4nICtcbiAgICAgICAgICAgICAgICAgICAnKCcgKyBzcmNbTlVNRVJJQ0lERU5USUZJRVJdICsgJylcXFxcLicgK1xuICAgICAgICAgICAgICAgICAgICcoJyArIHNyY1tOVU1FUklDSURFTlRJRklFUl0gKyAnKSc7XG5cbnZhciBNQUlOVkVSU0lPTkxPT1NFID0gUisrO1xuc3JjW01BSU5WRVJTSU9OTE9PU0VdID0gJygnICsgc3JjW05VTUVSSUNJREVOVElGSUVSTE9PU0VdICsgJylcXFxcLicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJygnICsgc3JjW05VTUVSSUNJREVOVElGSUVSTE9PU0VdICsgJylcXFxcLicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJygnICsgc3JjW05VTUVSSUNJREVOVElGSUVSTE9PU0VdICsgJyknO1xuXG4vLyAjIyBQcmUtcmVsZWFzZSBWZXJzaW9uIElkZW50aWZpZXJcbi8vIEEgbnVtZXJpYyBpZGVudGlmaWVyLCBvciBhIG5vbi1udW1lcmljIGlkZW50aWZpZXIuXG5cbnZhciBQUkVSRUxFQVNFSURFTlRJRklFUiA9IFIrKztcbnNyY1tQUkVSRUxFQVNFSURFTlRJRklFUl0gPSAnKD86JyArIHNyY1tOVU1FUklDSURFTlRJRklFUl0gK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICd8JyArIHNyY1tOT05OVU1FUklDSURFTlRJRklFUl0gKyAnKSc7XG5cbnZhciBQUkVSRUxFQVNFSURFTlRJRklFUkxPT1NFID0gUisrO1xuc3JjW1BSRVJFTEVBU0VJREVOVElGSUVSTE9PU0VdID0gJyg/OicgKyBzcmNbTlVNRVJJQ0lERU5USUZJRVJMT09TRV0gK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3wnICsgc3JjW05PTk5VTUVSSUNJREVOVElGSUVSXSArICcpJztcblxuXG4vLyAjIyBQcmUtcmVsZWFzZSBWZXJzaW9uXG4vLyBIeXBoZW4sIGZvbGxvd2VkIGJ5IG9uZSBvciBtb3JlIGRvdC1zZXBhcmF0ZWQgcHJlLXJlbGVhc2UgdmVyc2lvblxuLy8gaWRlbnRpZmllcnMuXG5cbnZhciBQUkVSRUxFQVNFID0gUisrO1xuc3JjW1BSRVJFTEVBU0VdID0gJyg/Oi0oJyArIHNyY1tQUkVSRUxFQVNFSURFTlRJRklFUl0gK1xuICAgICAgICAgICAgICAgICAgJyg/OlxcXFwuJyArIHNyY1tQUkVSRUxFQVNFSURFTlRJRklFUl0gKyAnKSopKSc7XG5cbnZhciBQUkVSRUxFQVNFTE9PU0UgPSBSKys7XG5zcmNbUFJFUkVMRUFTRUxPT1NFXSA9ICcoPzotPygnICsgc3JjW1BSRVJFTEVBU0VJREVOVElGSUVSTE9PU0VdICtcbiAgICAgICAgICAgICAgICAgICAgICAgJyg/OlxcXFwuJyArIHNyY1tQUkVSRUxFQVNFSURFTlRJRklFUkxPT1NFXSArICcpKikpJztcblxuLy8gIyMgQnVpbGQgTWV0YWRhdGEgSWRlbnRpZmllclxuLy8gQW55IGNvbWJpbmF0aW9uIG9mIGRpZ2l0cywgbGV0dGVycywgb3IgaHlwaGVucy5cblxudmFyIEJVSUxESURFTlRJRklFUiA9IFIrKztcbnNyY1tCVUlMRElERU5USUZJRVJdID0gJ1swLTlBLVphLXotXSsnO1xuXG4vLyAjIyBCdWlsZCBNZXRhZGF0YVxuLy8gUGx1cyBzaWduLCBmb2xsb3dlZCBieSBvbmUgb3IgbW9yZSBwZXJpb2Qtc2VwYXJhdGVkIGJ1aWxkIG1ldGFkYXRhXG4vLyBpZGVudGlmaWVycy5cblxudmFyIEJVSUxEID0gUisrO1xuc3JjW0JVSUxEXSA9ICcoPzpcXFxcKygnICsgc3JjW0JVSUxESURFTlRJRklFUl0gK1xuICAgICAgICAgICAgICcoPzpcXFxcLicgKyBzcmNbQlVJTERJREVOVElGSUVSXSArICcpKikpJztcblxuXG4vLyAjIyBGdWxsIFZlcnNpb24gU3RyaW5nXG4vLyBBIG1haW4gdmVyc2lvbiwgZm9sbG93ZWQgb3B0aW9uYWxseSBieSBhIHByZS1yZWxlYXNlIHZlcnNpb24gYW5kXG4vLyBidWlsZCBtZXRhZGF0YS5cblxuLy8gTm90ZSB0aGF0IHRoZSBvbmx5IG1ham9yLCBtaW5vciwgcGF0Y2gsIGFuZCBwcmUtcmVsZWFzZSBzZWN0aW9ucyBvZlxuLy8gdGhlIHZlcnNpb24gc3RyaW5nIGFyZSBjYXB0dXJpbmcgZ3JvdXBzLiAgVGhlIGJ1aWxkIG1ldGFkYXRhIGlzIG5vdCBhXG4vLyBjYXB0dXJpbmcgZ3JvdXAsIGJlY2F1c2UgaXQgc2hvdWxkIG5vdCBldmVyIGJlIHVzZWQgaW4gdmVyc2lvblxuLy8gY29tcGFyaXNvbi5cblxudmFyIEZVTEwgPSBSKys7XG52YXIgRlVMTFBMQUlOID0gJ3Y/JyArIHNyY1tNQUlOVkVSU0lPTl0gK1xuICAgICAgICAgICAgICAgIHNyY1tQUkVSRUxFQVNFXSArICc/JyArXG4gICAgICAgICAgICAgICAgc3JjW0JVSUxEXSArICc/Jztcblxuc3JjW0ZVTExdID0gJ14nICsgRlVMTFBMQUlOICsgJyQnO1xuXG4vLyBsaWtlIGZ1bGwsIGJ1dCBhbGxvd3MgdjEuMi4zIGFuZCA9MS4yLjMsIHdoaWNoIHBlb3BsZSBkbyBzb21ldGltZXMuXG4vLyBhbHNvLCAxLjAuMGFscGhhMSAocHJlcmVsZWFzZSB3aXRob3V0IHRoZSBoeXBoZW4pIHdoaWNoIGlzIHByZXR0eVxuLy8gY29tbW9uIGluIHRoZSBucG0gcmVnaXN0cnkuXG52YXIgTE9PU0VQTEFJTiA9ICdbdj1cXFxcc10qJyArIHNyY1tNQUlOVkVSU0lPTkxPT1NFXSArXG4gICAgICAgICAgICAgICAgIHNyY1tQUkVSRUxFQVNFTE9PU0VdICsgJz8nICtcbiAgICAgICAgICAgICAgICAgc3JjW0JVSUxEXSArICc/JztcblxudmFyIExPT1NFID0gUisrO1xuc3JjW0xPT1NFXSA9ICdeJyArIExPT1NFUExBSU4gKyAnJCc7XG5cbnZhciBHVExUID0gUisrO1xuc3JjW0dUTFRdID0gJygoPzo8fD4pPz0/KSc7XG5cbi8vIFNvbWV0aGluZyBsaWtlIFwiMi4qXCIgb3IgXCIxLjIueFwiLlxuLy8gTm90ZSB0aGF0IFwieC54XCIgaXMgYSB2YWxpZCB4UmFuZ2UgaWRlbnRpZmVyLCBtZWFuaW5nIFwiYW55IHZlcnNpb25cIlxuLy8gT25seSB0aGUgZmlyc3QgaXRlbSBpcyBzdHJpY3RseSByZXF1aXJlZC5cbnZhciBYUkFOR0VJREVOVElGSUVSTE9PU0UgPSBSKys7XG5zcmNbWFJBTkdFSURFTlRJRklFUkxPT1NFXSA9IHNyY1tOVU1FUklDSURFTlRJRklFUkxPT1NFXSArICd8eHxYfFxcXFwqJztcbnZhciBYUkFOR0VJREVOVElGSUVSID0gUisrO1xuc3JjW1hSQU5HRUlERU5USUZJRVJdID0gc3JjW05VTUVSSUNJREVOVElGSUVSXSArICd8eHxYfFxcXFwqJztcblxudmFyIFhSQU5HRVBMQUlOID0gUisrO1xuc3JjW1hSQU5HRVBMQUlOXSA9ICdbdj1cXFxcc10qKCcgKyBzcmNbWFJBTkdFSURFTlRJRklFUl0gKyAnKScgK1xuICAgICAgICAgICAgICAgICAgICcoPzpcXFxcLignICsgc3JjW1hSQU5HRUlERU5USUZJRVJdICsgJyknICtcbiAgICAgICAgICAgICAgICAgICAnKD86XFxcXC4oJyArIHNyY1tYUkFOR0VJREVOVElGSUVSXSArICcpJyArXG4gICAgICAgICAgICAgICAgICAgJyg/OicgKyBzcmNbUFJFUkVMRUFTRV0gKyAnKT8nICtcbiAgICAgICAgICAgICAgICAgICBzcmNbQlVJTERdICsgJz8nICtcbiAgICAgICAgICAgICAgICAgICAnKT8pPyc7XG5cbnZhciBYUkFOR0VQTEFJTkxPT1NFID0gUisrO1xuc3JjW1hSQU5HRVBMQUlOTE9PU0VdID0gJ1t2PVxcXFxzXSooJyArIHNyY1tYUkFOR0VJREVOVElGSUVSTE9PU0VdICsgJyknICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcoPzpcXFxcLignICsgc3JjW1hSQU5HRUlERU5USUZJRVJMT09TRV0gKyAnKScgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyg/OlxcXFwuKCcgKyBzcmNbWFJBTkdFSURFTlRJRklFUkxPT1NFXSArICcpJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnKD86JyArIHNyY1tQUkVSRUxFQVNFTE9PU0VdICsgJyk/JyArXG4gICAgICAgICAgICAgICAgICAgICAgICBzcmNbQlVJTERdICsgJz8nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcpPyk/JztcblxudmFyIFhSQU5HRSA9IFIrKztcbnNyY1tYUkFOR0VdID0gJ14nICsgc3JjW0dUTFRdICsgJ1xcXFxzKicgKyBzcmNbWFJBTkdFUExBSU5dICsgJyQnO1xudmFyIFhSQU5HRUxPT1NFID0gUisrO1xuc3JjW1hSQU5HRUxPT1NFXSA9ICdeJyArIHNyY1tHVExUXSArICdcXFxccyonICsgc3JjW1hSQU5HRVBMQUlOTE9PU0VdICsgJyQnO1xuXG4vLyBDb2VyY2lvbi5cbi8vIEV4dHJhY3QgYW55dGhpbmcgdGhhdCBjb3VsZCBjb25jZWl2YWJseSBiZSBhIHBhcnQgb2YgYSB2YWxpZCBzZW12ZXJcbnZhciBDT0VSQ0UgPSBSKys7XG5zcmNbQ09FUkNFXSA9ICcoPzpefFteXFxcXGRdKScgK1xuICAgICAgICAgICAgICAnKFxcXFxkezEsJyArIE1BWF9TQUZFX0NPTVBPTkVOVF9MRU5HVEggKyAnfSknICtcbiAgICAgICAgICAgICAgJyg/OlxcXFwuKFxcXFxkezEsJyArIE1BWF9TQUZFX0NPTVBPTkVOVF9MRU5HVEggKyAnfSkpPycgK1xuICAgICAgICAgICAgICAnKD86XFxcXC4oXFxcXGR7MSwnICsgTUFYX1NBRkVfQ09NUE9ORU5UX0xFTkdUSCArICd9KSk/JyArXG4gICAgICAgICAgICAgICcoPzokfFteXFxcXGRdKSc7XG5cbi8vIFRpbGRlIHJhbmdlcy5cbi8vIE1lYW5pbmcgaXMgXCJyZWFzb25hYmx5IGF0IG9yIGdyZWF0ZXIgdGhhblwiXG52YXIgTE9ORVRJTERFID0gUisrO1xuc3JjW0xPTkVUSUxERV0gPSAnKD86fj4/KSc7XG5cbnZhciBUSUxERVRSSU0gPSBSKys7XG5zcmNbVElMREVUUklNXSA9ICcoXFxcXHMqKScgKyBzcmNbTE9ORVRJTERFXSArICdcXFxccysnO1xucmVbVElMREVUUklNXSA9IG5ldyBSZWdFeHAoc3JjW1RJTERFVFJJTV0sICdnJyk7XG52YXIgdGlsZGVUcmltUmVwbGFjZSA9ICckMX4nO1xuXG52YXIgVElMREUgPSBSKys7XG5zcmNbVElMREVdID0gJ14nICsgc3JjW0xPTkVUSUxERV0gKyBzcmNbWFJBTkdFUExBSU5dICsgJyQnO1xudmFyIFRJTERFTE9PU0UgPSBSKys7XG5zcmNbVElMREVMT09TRV0gPSAnXicgKyBzcmNbTE9ORVRJTERFXSArIHNyY1tYUkFOR0VQTEFJTkxPT1NFXSArICckJztcblxuLy8gQ2FyZXQgcmFuZ2VzLlxuLy8gTWVhbmluZyBpcyBcImF0IGxlYXN0IGFuZCBiYWNrd2FyZHMgY29tcGF0aWJsZSB3aXRoXCJcbnZhciBMT05FQ0FSRVQgPSBSKys7XG5zcmNbTE9ORUNBUkVUXSA9ICcoPzpcXFxcXiknO1xuXG52YXIgQ0FSRVRUUklNID0gUisrO1xuc3JjW0NBUkVUVFJJTV0gPSAnKFxcXFxzKiknICsgc3JjW0xPTkVDQVJFVF0gKyAnXFxcXHMrJztcbnJlW0NBUkVUVFJJTV0gPSBuZXcgUmVnRXhwKHNyY1tDQVJFVFRSSU1dLCAnZycpO1xudmFyIGNhcmV0VHJpbVJlcGxhY2UgPSAnJDFeJztcblxudmFyIENBUkVUID0gUisrO1xuc3JjW0NBUkVUXSA9ICdeJyArIHNyY1tMT05FQ0FSRVRdICsgc3JjW1hSQU5HRVBMQUlOXSArICckJztcbnZhciBDQVJFVExPT1NFID0gUisrO1xuc3JjW0NBUkVUTE9PU0VdID0gJ14nICsgc3JjW0xPTkVDQVJFVF0gKyBzcmNbWFJBTkdFUExBSU5MT09TRV0gKyAnJCc7XG5cbi8vIEEgc2ltcGxlIGd0L2x0L2VxIHRoaW5nLCBvciBqdXN0IFwiXCIgdG8gaW5kaWNhdGUgXCJhbnkgdmVyc2lvblwiXG52YXIgQ09NUEFSQVRPUkxPT1NFID0gUisrO1xuc3JjW0NPTVBBUkFUT1JMT09TRV0gPSAnXicgKyBzcmNbR1RMVF0gKyAnXFxcXHMqKCcgKyBMT09TRVBMQUlOICsgJykkfF4kJztcbnZhciBDT01QQVJBVE9SID0gUisrO1xuc3JjW0NPTVBBUkFUT1JdID0gJ14nICsgc3JjW0dUTFRdICsgJ1xcXFxzKignICsgRlVMTFBMQUlOICsgJykkfF4kJztcblxuXG4vLyBBbiBleHByZXNzaW9uIHRvIHN0cmlwIGFueSB3aGl0ZXNwYWNlIGJldHdlZW4gdGhlIGd0bHQgYW5kIHRoZSB0aGluZ1xuLy8gaXQgbW9kaWZpZXMsIHNvIHRoYXQgYD4gMS4yLjNgID09PiBgPjEuMi4zYFxudmFyIENPTVBBUkFUT1JUUklNID0gUisrO1xuc3JjW0NPTVBBUkFUT1JUUklNXSA9ICcoXFxcXHMqKScgKyBzcmNbR1RMVF0gK1xuICAgICAgICAgICAgICAgICAgICAgICdcXFxccyooJyArIExPT1NFUExBSU4gKyAnfCcgKyBzcmNbWFJBTkdFUExBSU5dICsgJyknO1xuXG4vLyB0aGlzIG9uZSBoYXMgdG8gdXNlIHRoZSAvZyBmbGFnXG5yZVtDT01QQVJBVE9SVFJJTV0gPSBuZXcgUmVnRXhwKHNyY1tDT01QQVJBVE9SVFJJTV0sICdnJyk7XG52YXIgY29tcGFyYXRvclRyaW1SZXBsYWNlID0gJyQxJDIkMyc7XG5cblxuLy8gU29tZXRoaW5nIGxpa2UgYDEuMi4zIC0gMS4yLjRgXG4vLyBOb3RlIHRoYXQgdGhlc2UgYWxsIHVzZSB0aGUgbG9vc2UgZm9ybSwgYmVjYXVzZSB0aGV5J2xsIGJlXG4vLyBjaGVja2VkIGFnYWluc3QgZWl0aGVyIHRoZSBzdHJpY3Qgb3IgbG9vc2UgY29tcGFyYXRvciBmb3JtXG4vLyBsYXRlci5cbnZhciBIWVBIRU5SQU5HRSA9IFIrKztcbnNyY1tIWVBIRU5SQU5HRV0gPSAnXlxcXFxzKignICsgc3JjW1hSQU5HRVBMQUlOXSArICcpJyArXG4gICAgICAgICAgICAgICAgICAgJ1xcXFxzKy1cXFxccysnICtcbiAgICAgICAgICAgICAgICAgICAnKCcgKyBzcmNbWFJBTkdFUExBSU5dICsgJyknICtcbiAgICAgICAgICAgICAgICAgICAnXFxcXHMqJCc7XG5cbnZhciBIWVBIRU5SQU5HRUxPT1NFID0gUisrO1xuc3JjW0hZUEhFTlJBTkdFTE9PU0VdID0gJ15cXFxccyooJyArIHNyY1tYUkFOR0VQTEFJTkxPT1NFXSArICcpJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnXFxcXHMrLVxcXFxzKycgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJygnICsgc3JjW1hSQU5HRVBMQUlOTE9PU0VdICsgJyknICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdcXFxccyokJztcblxuLy8gU3RhciByYW5nZXMgYmFzaWNhbGx5IGp1c3QgYWxsb3cgYW55dGhpbmcgYXQgYWxsLlxudmFyIFNUQVIgPSBSKys7XG5zcmNbU1RBUl0gPSAnKDx8Pik/PT9cXFxccypcXFxcKic7XG5cbi8vIENvbXBpbGUgdG8gYWN0dWFsIHJlZ2V4cCBvYmplY3RzLlxuLy8gQWxsIGFyZSBmbGFnLWZyZWUsIHVubGVzcyB0aGV5IHdlcmUgY3JlYXRlZCBhYm92ZSB3aXRoIGEgZmxhZy5cbmZvciAodmFyIGkgPSAwOyBpIDwgUjsgaSsrKSB7XG4gIGRlYnVnKGksIHNyY1tpXSk7XG4gIGlmICghcmVbaV0pXG4gICAgcmVbaV0gPSBuZXcgUmVnRXhwKHNyY1tpXSk7XG59XG5cbmV4cG9ydHMucGFyc2UgPSBwYXJzZTtcbmZ1bmN0aW9uIHBhcnNlKHZlcnNpb24sIGxvb3NlKSB7XG4gIGlmICh2ZXJzaW9uIGluc3RhbmNlb2YgU2VtVmVyKVxuICAgIHJldHVybiB2ZXJzaW9uO1xuXG4gIGlmICh0eXBlb2YgdmVyc2lvbiAhPT0gJ3N0cmluZycpXG4gICAgcmV0dXJuIG51bGw7XG5cbiAgaWYgKHZlcnNpb24ubGVuZ3RoID4gTUFYX0xFTkdUSClcbiAgICByZXR1cm4gbnVsbDtcblxuICB2YXIgciA9IGxvb3NlID8gcmVbTE9PU0VdIDogcmVbRlVMTF07XG4gIGlmICghci50ZXN0KHZlcnNpb24pKVxuICAgIHJldHVybiBudWxsO1xuXG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBTZW1WZXIodmVyc2lvbiwgbG9vc2UpO1xuICB9IGNhdGNoIChlcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmV4cG9ydHMudmFsaWQgPSB2YWxpZDtcbmZ1bmN0aW9uIHZhbGlkKHZlcnNpb24sIGxvb3NlKSB7XG4gIHZhciB2ID0gcGFyc2UodmVyc2lvbiwgbG9vc2UpO1xuICByZXR1cm4gdiA/IHYudmVyc2lvbiA6IG51bGw7XG59XG5cblxuZXhwb3J0cy5jbGVhbiA9IGNsZWFuO1xuZnVuY3Rpb24gY2xlYW4odmVyc2lvbiwgbG9vc2UpIHtcbiAgdmFyIHMgPSBwYXJzZSh2ZXJzaW9uLnRyaW0oKS5yZXBsYWNlKC9eWz12XSsvLCAnJyksIGxvb3NlKTtcbiAgcmV0dXJuIHMgPyBzLnZlcnNpb24gOiBudWxsO1xufVxuXG5leHBvcnRzLlNlbVZlciA9IFNlbVZlcjtcblxuZnVuY3Rpb24gU2VtVmVyKHZlcnNpb24sIGxvb3NlKSB7XG4gIGlmICh2ZXJzaW9uIGluc3RhbmNlb2YgU2VtVmVyKSB7XG4gICAgaWYgKHZlcnNpb24ubG9vc2UgPT09IGxvb3NlKVxuICAgICAgcmV0dXJuIHZlcnNpb247XG4gICAgZWxzZVxuICAgICAgdmVyc2lvbiA9IHZlcnNpb24udmVyc2lvbjtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmVyc2lvbiAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIFZlcnNpb246ICcgKyB2ZXJzaW9uKTtcbiAgfVxuXG4gIGlmICh2ZXJzaW9uLmxlbmd0aCA+IE1BWF9MRU5HVEgpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmVyc2lvbiBpcyBsb25nZXIgdGhhbiAnICsgTUFYX0xFTkdUSCArICcgY2hhcmFjdGVycycpXG5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNlbVZlcikpXG4gICAgcmV0dXJuIG5ldyBTZW1WZXIodmVyc2lvbiwgbG9vc2UpO1xuXG4gIGRlYnVnKCdTZW1WZXInLCB2ZXJzaW9uLCBsb29zZSk7XG4gIHRoaXMubG9vc2UgPSBsb29zZTtcbiAgdmFyIG0gPSB2ZXJzaW9uLnRyaW0oKS5tYXRjaChsb29zZSA/IHJlW0xPT1NFXSA6IHJlW0ZVTExdKTtcblxuICBpZiAoIW0pXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBWZXJzaW9uOiAnICsgdmVyc2lvbik7XG5cbiAgdGhpcy5yYXcgPSB2ZXJzaW9uO1xuXG4gIC8vIHRoZXNlIGFyZSBhY3R1YWxseSBudW1iZXJzXG4gIHRoaXMubWFqb3IgPSArbVsxXTtcbiAgdGhpcy5taW5vciA9ICttWzJdO1xuICB0aGlzLnBhdGNoID0gK21bM107XG5cbiAgaWYgKHRoaXMubWFqb3IgPiBNQVhfU0FGRV9JTlRFR0VSIHx8IHRoaXMubWFqb3IgPCAwKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbWFqb3IgdmVyc2lvbicpXG5cbiAgaWYgKHRoaXMubWlub3IgPiBNQVhfU0FGRV9JTlRFR0VSIHx8IHRoaXMubWlub3IgPCAwKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbWlub3IgdmVyc2lvbicpXG5cbiAgaWYgKHRoaXMucGF0Y2ggPiBNQVhfU0FGRV9JTlRFR0VSIHx8IHRoaXMucGF0Y2ggPCAwKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgcGF0Y2ggdmVyc2lvbicpXG5cbiAgLy8gbnVtYmVyaWZ5IGFueSBwcmVyZWxlYXNlIG51bWVyaWMgaWRzXG4gIGlmICghbVs0XSlcbiAgICB0aGlzLnByZXJlbGVhc2UgPSBbXTtcbiAgZWxzZVxuICAgIHRoaXMucHJlcmVsZWFzZSA9IG1bNF0uc3BsaXQoJy4nKS5tYXAoZnVuY3Rpb24oaWQpIHtcbiAgICAgIGlmICgvXlswLTldKyQvLnRlc3QoaWQpKSB7XG4gICAgICAgIHZhciBudW0gPSAraWQ7XG4gICAgICAgIGlmIChudW0gPj0gMCAmJiBudW0gPCBNQVhfU0FGRV9JTlRFR0VSKVxuICAgICAgICAgIHJldHVybiBudW07XG4gICAgICB9XG4gICAgICByZXR1cm4gaWQ7XG4gICAgfSk7XG5cbiAgdGhpcy5idWlsZCA9IG1bNV0gPyBtWzVdLnNwbGl0KCcuJykgOiBbXTtcbiAgdGhpcy5mb3JtYXQoKTtcbn1cblxuU2VtVmVyLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy52ZXJzaW9uID0gdGhpcy5tYWpvciArICcuJyArIHRoaXMubWlub3IgKyAnLicgKyB0aGlzLnBhdGNoO1xuICBpZiAodGhpcy5wcmVyZWxlYXNlLmxlbmd0aClcbiAgICB0aGlzLnZlcnNpb24gKz0gJy0nICsgdGhpcy5wcmVyZWxlYXNlLmpvaW4oJy4nKTtcbiAgcmV0dXJuIHRoaXMudmVyc2lvbjtcbn07XG5cblNlbVZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudmVyc2lvbjtcbn07XG5cblNlbVZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uKG90aGVyKSB7XG4gIGRlYnVnKCdTZW1WZXIuY29tcGFyZScsIHRoaXMudmVyc2lvbiwgdGhpcy5sb29zZSwgb3RoZXIpO1xuICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFNlbVZlcikpXG4gICAgb3RoZXIgPSBuZXcgU2VtVmVyKG90aGVyLCB0aGlzLmxvb3NlKTtcblxuICByZXR1cm4gdGhpcy5jb21wYXJlTWFpbihvdGhlcikgfHwgdGhpcy5jb21wYXJlUHJlKG90aGVyKTtcbn07XG5cblNlbVZlci5wcm90b3R5cGUuY29tcGFyZU1haW4gPSBmdW5jdGlvbihvdGhlcikge1xuICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFNlbVZlcikpXG4gICAgb3RoZXIgPSBuZXcgU2VtVmVyKG90aGVyLCB0aGlzLmxvb3NlKTtcblxuICByZXR1cm4gY29tcGFyZUlkZW50aWZpZXJzKHRoaXMubWFqb3IsIG90aGVyLm1ham9yKSB8fFxuICAgICAgICAgY29tcGFyZUlkZW50aWZpZXJzKHRoaXMubWlub3IsIG90aGVyLm1pbm9yKSB8fFxuICAgICAgICAgY29tcGFyZUlkZW50aWZpZXJzKHRoaXMucGF0Y2gsIG90aGVyLnBhdGNoKTtcbn07XG5cblNlbVZlci5wcm90b3R5cGUuY29tcGFyZVByZSA9IGZ1bmN0aW9uKG90aGVyKSB7XG4gIGlmICghKG90aGVyIGluc3RhbmNlb2YgU2VtVmVyKSlcbiAgICBvdGhlciA9IG5ldyBTZW1WZXIob3RoZXIsIHRoaXMubG9vc2UpO1xuXG4gIC8vIE5PVCBoYXZpbmcgYSBwcmVyZWxlYXNlIGlzID4gaGF2aW5nIG9uZVxuICBpZiAodGhpcy5wcmVyZWxlYXNlLmxlbmd0aCAmJiAhb3RoZXIucHJlcmVsZWFzZS5sZW5ndGgpXG4gICAgcmV0dXJuIC0xO1xuICBlbHNlIGlmICghdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCAmJiBvdGhlci5wcmVyZWxlYXNlLmxlbmd0aClcbiAgICByZXR1cm4gMTtcbiAgZWxzZSBpZiAoIXRoaXMucHJlcmVsZWFzZS5sZW5ndGggJiYgIW90aGVyLnByZXJlbGVhc2UubGVuZ3RoKVxuICAgIHJldHVybiAwO1xuXG4gIHZhciBpID0gMDtcbiAgZG8ge1xuICAgIHZhciBhID0gdGhpcy5wcmVyZWxlYXNlW2ldO1xuICAgIHZhciBiID0gb3RoZXIucHJlcmVsZWFzZVtpXTtcbiAgICBkZWJ1ZygncHJlcmVsZWFzZSBjb21wYXJlJywgaSwgYSwgYik7XG4gICAgaWYgKGEgPT09IHVuZGVmaW5lZCAmJiBiID09PSB1bmRlZmluZWQpXG4gICAgICByZXR1cm4gMDtcbiAgICBlbHNlIGlmIChiID09PSB1bmRlZmluZWQpXG4gICAgICByZXR1cm4gMTtcbiAgICBlbHNlIGlmIChhID09PSB1bmRlZmluZWQpXG4gICAgICByZXR1cm4gLTE7XG4gICAgZWxzZSBpZiAoYSA9PT0gYilcbiAgICAgIGNvbnRpbnVlO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiBjb21wYXJlSWRlbnRpZmllcnMoYSwgYik7XG4gIH0gd2hpbGUgKCsraSk7XG59O1xuXG4vLyBwcmVtaW5vciB3aWxsIGJ1bXAgdGhlIHZlcnNpb24gdXAgdG8gdGhlIG5leHQgbWlub3IgcmVsZWFzZSwgYW5kIGltbWVkaWF0ZWx5XG4vLyBkb3duIHRvIHByZS1yZWxlYXNlLiBwcmVtYWpvciBhbmQgcHJlcGF0Y2ggd29yayB0aGUgc2FtZSB3YXkuXG5TZW1WZXIucHJvdG90eXBlLmluYyA9IGZ1bmN0aW9uKHJlbGVhc2UsIGlkZW50aWZpZXIpIHtcbiAgc3dpdGNoIChyZWxlYXNlKSB7XG4gICAgY2FzZSAncHJlbWFqb3InOlxuICAgICAgdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9IDA7XG4gICAgICB0aGlzLnBhdGNoID0gMDtcbiAgICAgIHRoaXMubWlub3IgPSAwO1xuICAgICAgdGhpcy5tYWpvcisrO1xuICAgICAgdGhpcy5pbmMoJ3ByZScsIGlkZW50aWZpZXIpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAncHJlbWlub3InOlxuICAgICAgdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9IDA7XG4gICAgICB0aGlzLnBhdGNoID0gMDtcbiAgICAgIHRoaXMubWlub3IrKztcbiAgICAgIHRoaXMuaW5jKCdwcmUnLCBpZGVudGlmaWVyKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3ByZXBhdGNoJzpcbiAgICAgIC8vIElmIHRoaXMgaXMgYWxyZWFkeSBhIHByZXJlbGVhc2UsIGl0IHdpbGwgYnVtcCB0byB0aGUgbmV4dCB2ZXJzaW9uXG4gICAgICAvLyBkcm9wIGFueSBwcmVyZWxlYXNlcyB0aGF0IG1pZ2h0IGFscmVhZHkgZXhpc3QsIHNpbmNlIHRoZXkgYXJlIG5vdFxuICAgICAgLy8gcmVsZXZhbnQgYXQgdGhpcyBwb2ludC5cbiAgICAgIHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPSAwO1xuICAgICAgdGhpcy5pbmMoJ3BhdGNoJywgaWRlbnRpZmllcik7XG4gICAgICB0aGlzLmluYygncHJlJywgaWRlbnRpZmllcik7XG4gICAgICBicmVhaztcbiAgICAvLyBJZiB0aGUgaW5wdXQgaXMgYSBub24tcHJlcmVsZWFzZSB2ZXJzaW9uLCB0aGlzIGFjdHMgdGhlIHNhbWUgYXNcbiAgICAvLyBwcmVwYXRjaC5cbiAgICBjYXNlICdwcmVyZWxlYXNlJzpcbiAgICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKVxuICAgICAgICB0aGlzLmluYygncGF0Y2gnLCBpZGVudGlmaWVyKTtcbiAgICAgIHRoaXMuaW5jKCdwcmUnLCBpZGVudGlmaWVyKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnbWFqb3InOlxuICAgICAgLy8gSWYgdGhpcyBpcyBhIHByZS1tYWpvciB2ZXJzaW9uLCBidW1wIHVwIHRvIHRoZSBzYW1lIG1ham9yIHZlcnNpb24uXG4gICAgICAvLyBPdGhlcndpc2UgaW5jcmVtZW50IG1ham9yLlxuICAgICAgLy8gMS4wLjAtNSBidW1wcyB0byAxLjAuMFxuICAgICAgLy8gMS4xLjAgYnVtcHMgdG8gMi4wLjBcbiAgICAgIGlmICh0aGlzLm1pbm9yICE9PSAwIHx8IHRoaXMucGF0Y2ggIT09IDAgfHwgdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMClcbiAgICAgICAgdGhpcy5tYWpvcisrO1xuICAgICAgdGhpcy5taW5vciA9IDA7XG4gICAgICB0aGlzLnBhdGNoID0gMDtcbiAgICAgIHRoaXMucHJlcmVsZWFzZSA9IFtdO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnbWlub3InOlxuICAgICAgLy8gSWYgdGhpcyBpcyBhIHByZS1taW5vciB2ZXJzaW9uLCBidW1wIHVwIHRvIHRoZSBzYW1lIG1pbm9yIHZlcnNpb24uXG4gICAgICAvLyBPdGhlcndpc2UgaW5jcmVtZW50IG1pbm9yLlxuICAgICAgLy8gMS4yLjAtNSBidW1wcyB0byAxLjIuMFxuICAgICAgLy8gMS4yLjEgYnVtcHMgdG8gMS4zLjBcbiAgICAgIGlmICh0aGlzLnBhdGNoICE9PSAwIHx8IHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPT09IDApXG4gICAgICAgIHRoaXMubWlub3IrKztcbiAgICAgIHRoaXMucGF0Y2ggPSAwO1xuICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW107XG4gICAgICBicmVhaztcbiAgICBjYXNlICdwYXRjaCc6XG4gICAgICAvLyBJZiB0aGlzIGlzIG5vdCBhIHByZS1yZWxlYXNlIHZlcnNpb24sIGl0IHdpbGwgaW5jcmVtZW50IHRoZSBwYXRjaC5cbiAgICAgIC8vIElmIGl0IGlzIGEgcHJlLXJlbGVhc2UgaXQgd2lsbCBidW1wIHVwIHRvIHRoZSBzYW1lIHBhdGNoIHZlcnNpb24uXG4gICAgICAvLyAxLjIuMC01IHBhdGNoZXMgdG8gMS4yLjBcbiAgICAgIC8vIDEuMi4wIHBhdGNoZXMgdG8gMS4yLjFcbiAgICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKVxuICAgICAgICB0aGlzLnBhdGNoKys7XG4gICAgICB0aGlzLnByZXJlbGVhc2UgPSBbXTtcbiAgICAgIGJyZWFrO1xuICAgIC8vIFRoaXMgcHJvYmFibHkgc2hvdWxkbid0IGJlIHVzZWQgcHVibGljbHkuXG4gICAgLy8gMS4wLjAgXCJwcmVcIiB3b3VsZCBiZWNvbWUgMS4wLjAtMCB3aGljaCBpcyB0aGUgd3JvbmcgZGlyZWN0aW9uLlxuICAgIGNhc2UgJ3ByZSc6XG4gICAgICBpZiAodGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMClcbiAgICAgICAgdGhpcy5wcmVyZWxlYXNlID0gWzBdO1xuICAgICAgZWxzZSB7XG4gICAgICAgIHZhciBpID0gdGhpcy5wcmVyZWxlYXNlLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKC0taSA+PSAwKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnByZXJlbGVhc2VbaV0gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aGlzLnByZXJlbGVhc2VbaV0rKztcbiAgICAgICAgICAgIGkgPSAtMjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPT09IC0xKSAvLyBkaWRuJ3QgaW5jcmVtZW50IGFueXRoaW5nXG4gICAgICAgICAgdGhpcy5wcmVyZWxlYXNlLnB1c2goMCk7XG4gICAgICB9XG4gICAgICBpZiAoaWRlbnRpZmllcikge1xuICAgICAgICAvLyAxLjIuMC1iZXRhLjEgYnVtcHMgdG8gMS4yLjAtYmV0YS4yLFxuICAgICAgICAvLyAxLjIuMC1iZXRhLmZvb2JseiBvciAxLjIuMC1iZXRhIGJ1bXBzIHRvIDEuMi4wLWJldGEuMFxuICAgICAgICBpZiAodGhpcy5wcmVyZWxlYXNlWzBdID09PSBpZGVudGlmaWVyKSB7XG4gICAgICAgICAgaWYgKGlzTmFOKHRoaXMucHJlcmVsZWFzZVsxXSkpXG4gICAgICAgICAgICB0aGlzLnByZXJlbGVhc2UgPSBbaWRlbnRpZmllciwgMF07XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIHRoaXMucHJlcmVsZWFzZSA9IFtpZGVudGlmaWVyLCAwXTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpbmNyZW1lbnQgYXJndW1lbnQ6ICcgKyByZWxlYXNlKTtcbiAgfVxuICB0aGlzLmZvcm1hdCgpO1xuICB0aGlzLnJhdyA9IHRoaXMudmVyc2lvbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5leHBvcnRzLmluYyA9IGluYztcbmZ1bmN0aW9uIGluYyh2ZXJzaW9uLCByZWxlYXNlLCBsb29zZSwgaWRlbnRpZmllcikge1xuICBpZiAodHlwZW9mKGxvb3NlKSA9PT0gJ3N0cmluZycpIHtcbiAgICBpZGVudGlmaWVyID0gbG9vc2U7XG4gICAgbG9vc2UgPSB1bmRlZmluZWQ7XG4gIH1cblxuICB0cnkge1xuICAgIHJldHVybiBuZXcgU2VtVmVyKHZlcnNpb24sIGxvb3NlKS5pbmMocmVsZWFzZSwgaWRlbnRpZmllcikudmVyc2lvbjtcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5leHBvcnRzLmRpZmYgPSBkaWZmO1xuZnVuY3Rpb24gZGlmZih2ZXJzaW9uMSwgdmVyc2lvbjIpIHtcbiAgaWYgKGVxKHZlcnNpb24xLCB2ZXJzaW9uMikpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICB2YXIgdjEgPSBwYXJzZSh2ZXJzaW9uMSk7XG4gICAgdmFyIHYyID0gcGFyc2UodmVyc2lvbjIpO1xuICAgIGlmICh2MS5wcmVyZWxlYXNlLmxlbmd0aCB8fCB2Mi5wcmVyZWxlYXNlLmxlbmd0aCkge1xuICAgICAgZm9yICh2YXIga2V5IGluIHYxKSB7XG4gICAgICAgIGlmIChrZXkgPT09ICdtYWpvcicgfHwga2V5ID09PSAnbWlub3InIHx8IGtleSA9PT0gJ3BhdGNoJykge1xuICAgICAgICAgIGlmICh2MVtrZXldICE9PSB2MltrZXldKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3ByZScra2V5O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuICdwcmVyZWxlYXNlJztcbiAgICB9XG4gICAgZm9yICh2YXIga2V5IGluIHYxKSB7XG4gICAgICBpZiAoa2V5ID09PSAnbWFqb3InIHx8IGtleSA9PT0gJ21pbm9yJyB8fCBrZXkgPT09ICdwYXRjaCcpIHtcbiAgICAgICAgaWYgKHYxW2tleV0gIT09IHYyW2tleV0pIHtcbiAgICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydHMuY29tcGFyZUlkZW50aWZpZXJzID0gY29tcGFyZUlkZW50aWZpZXJzO1xuXG52YXIgbnVtZXJpYyA9IC9eWzAtOV0rJC87XG5mdW5jdGlvbiBjb21wYXJlSWRlbnRpZmllcnMoYSwgYikge1xuICB2YXIgYW51bSA9IG51bWVyaWMudGVzdChhKTtcbiAgdmFyIGJudW0gPSBudW1lcmljLnRlc3QoYik7XG5cbiAgaWYgKGFudW0gJiYgYm51bSkge1xuICAgIGEgPSArYTtcbiAgICBiID0gK2I7XG4gIH1cblxuICByZXR1cm4gKGFudW0gJiYgIWJudW0pID8gLTEgOlxuICAgICAgICAgKGJudW0gJiYgIWFudW0pID8gMSA6XG4gICAgICAgICBhIDwgYiA/IC0xIDpcbiAgICAgICAgIGEgPiBiID8gMSA6XG4gICAgICAgICAwO1xufVxuXG5leHBvcnRzLnJjb21wYXJlSWRlbnRpZmllcnMgPSByY29tcGFyZUlkZW50aWZpZXJzO1xuZnVuY3Rpb24gcmNvbXBhcmVJZGVudGlmaWVycyhhLCBiKSB7XG4gIHJldHVybiBjb21wYXJlSWRlbnRpZmllcnMoYiwgYSk7XG59XG5cbmV4cG9ydHMubWFqb3IgPSBtYWpvcjtcbmZ1bmN0aW9uIG1ham9yKGEsIGxvb3NlKSB7XG4gIHJldHVybiBuZXcgU2VtVmVyKGEsIGxvb3NlKS5tYWpvcjtcbn1cblxuZXhwb3J0cy5taW5vciA9IG1pbm9yO1xuZnVuY3Rpb24gbWlub3IoYSwgbG9vc2UpIHtcbiAgcmV0dXJuIG5ldyBTZW1WZXIoYSwgbG9vc2UpLm1pbm9yO1xufVxuXG5leHBvcnRzLnBhdGNoID0gcGF0Y2g7XG5mdW5jdGlvbiBwYXRjaChhLCBsb29zZSkge1xuICByZXR1cm4gbmV3IFNlbVZlcihhLCBsb29zZSkucGF0Y2g7XG59XG5cbmV4cG9ydHMuY29tcGFyZSA9IGNvbXBhcmU7XG5mdW5jdGlvbiBjb21wYXJlKGEsIGIsIGxvb3NlKSB7XG4gIHJldHVybiBuZXcgU2VtVmVyKGEsIGxvb3NlKS5jb21wYXJlKG5ldyBTZW1WZXIoYiwgbG9vc2UpKTtcbn1cblxuZXhwb3J0cy5jb21wYXJlTG9vc2UgPSBjb21wYXJlTG9vc2U7XG5mdW5jdGlvbiBjb21wYXJlTG9vc2UoYSwgYikge1xuICByZXR1cm4gY29tcGFyZShhLCBiLCB0cnVlKTtcbn1cblxuZXhwb3J0cy5yY29tcGFyZSA9IHJjb21wYXJlO1xuZnVuY3Rpb24gcmNvbXBhcmUoYSwgYiwgbG9vc2UpIHtcbiAgcmV0dXJuIGNvbXBhcmUoYiwgYSwgbG9vc2UpO1xufVxuXG5leHBvcnRzLnNvcnQgPSBzb3J0O1xuZnVuY3Rpb24gc29ydChsaXN0LCBsb29zZSkge1xuICByZXR1cm4gbGlzdC5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5jb21wYXJlKGEsIGIsIGxvb3NlKTtcbiAgfSk7XG59XG5cbmV4cG9ydHMucnNvcnQgPSByc29ydDtcbmZ1bmN0aW9uIHJzb3J0KGxpc3QsIGxvb3NlKSB7XG4gIHJldHVybiBsaXN0LnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgIHJldHVybiBleHBvcnRzLnJjb21wYXJlKGEsIGIsIGxvb3NlKTtcbiAgfSk7XG59XG5cbmV4cG9ydHMuZ3QgPSBndDtcbmZ1bmN0aW9uIGd0KGEsIGIsIGxvb3NlKSB7XG4gIHJldHVybiBjb21wYXJlKGEsIGIsIGxvb3NlKSA+IDA7XG59XG5cbmV4cG9ydHMubHQgPSBsdDtcbmZ1bmN0aW9uIGx0KGEsIGIsIGxvb3NlKSB7XG4gIHJldHVybiBjb21wYXJlKGEsIGIsIGxvb3NlKSA8IDA7XG59XG5cbmV4cG9ydHMuZXEgPSBlcTtcbmZ1bmN0aW9uIGVxKGEsIGIsIGxvb3NlKSB7XG4gIHJldHVybiBjb21wYXJlKGEsIGIsIGxvb3NlKSA9PT0gMDtcbn1cblxuZXhwb3J0cy5uZXEgPSBuZXE7XG5mdW5jdGlvbiBuZXEoYSwgYiwgbG9vc2UpIHtcbiAgcmV0dXJuIGNvbXBhcmUoYSwgYiwgbG9vc2UpICE9PSAwO1xufVxuXG5leHBvcnRzLmd0ZSA9IGd0ZTtcbmZ1bmN0aW9uIGd0ZShhLCBiLCBsb29zZSkge1xuICByZXR1cm4gY29tcGFyZShhLCBiLCBsb29zZSkgPj0gMDtcbn1cblxuZXhwb3J0cy5sdGUgPSBsdGU7XG5mdW5jdGlvbiBsdGUoYSwgYiwgbG9vc2UpIHtcbiAgcmV0dXJuIGNvbXBhcmUoYSwgYiwgbG9vc2UpIDw9IDA7XG59XG5cbmV4cG9ydHMuY21wID0gY21wO1xuZnVuY3Rpb24gY21wKGEsIG9wLCBiLCBsb29zZSkge1xuICB2YXIgcmV0O1xuICBzd2l0Y2ggKG9wKSB7XG4gICAgY2FzZSAnPT09JzpcbiAgICAgIGlmICh0eXBlb2YgYSA9PT0gJ29iamVjdCcpIGEgPSBhLnZlcnNpb247XG4gICAgICBpZiAodHlwZW9mIGIgPT09ICdvYmplY3QnKSBiID0gYi52ZXJzaW9uO1xuICAgICAgcmV0ID0gYSA9PT0gYjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJyE9PSc6XG4gICAgICBpZiAodHlwZW9mIGEgPT09ICdvYmplY3QnKSBhID0gYS52ZXJzaW9uO1xuICAgICAgaWYgKHR5cGVvZiBiID09PSAnb2JqZWN0JykgYiA9IGIudmVyc2lvbjtcbiAgICAgIHJldCA9IGEgIT09IGI7XG4gICAgICBicmVhaztcbiAgICBjYXNlICcnOiBjYXNlICc9JzogY2FzZSAnPT0nOiByZXQgPSBlcShhLCBiLCBsb29zZSk7IGJyZWFrO1xuICAgIGNhc2UgJyE9JzogcmV0ID0gbmVxKGEsIGIsIGxvb3NlKTsgYnJlYWs7XG4gICAgY2FzZSAnPic6IHJldCA9IGd0KGEsIGIsIGxvb3NlKTsgYnJlYWs7XG4gICAgY2FzZSAnPj0nOiByZXQgPSBndGUoYSwgYiwgbG9vc2UpOyBicmVhaztcbiAgICBjYXNlICc8JzogcmV0ID0gbHQoYSwgYiwgbG9vc2UpOyBicmVhaztcbiAgICBjYXNlICc8PSc6IHJldCA9IGx0ZShhLCBiLCBsb29zZSk7IGJyZWFrO1xuICAgIGRlZmF1bHQ6IHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgb3BlcmF0b3I6ICcgKyBvcCk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZXhwb3J0cy5Db21wYXJhdG9yID0gQ29tcGFyYXRvcjtcbmZ1bmN0aW9uIENvbXBhcmF0b3IoY29tcCwgbG9vc2UpIHtcbiAgaWYgKGNvbXAgaW5zdGFuY2VvZiBDb21wYXJhdG9yKSB7XG4gICAgaWYgKGNvbXAubG9vc2UgPT09IGxvb3NlKVxuICAgICAgcmV0dXJuIGNvbXA7XG4gICAgZWxzZVxuICAgICAgY29tcCA9IGNvbXAudmFsdWU7XG4gIH1cblxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQ29tcGFyYXRvcikpXG4gICAgcmV0dXJuIG5ldyBDb21wYXJhdG9yKGNvbXAsIGxvb3NlKTtcblxuICBkZWJ1ZygnY29tcGFyYXRvcicsIGNvbXAsIGxvb3NlKTtcbiAgdGhpcy5sb29zZSA9IGxvb3NlO1xuICB0aGlzLnBhcnNlKGNvbXApO1xuXG4gIGlmICh0aGlzLnNlbXZlciA9PT0gQU5ZKVxuICAgIHRoaXMudmFsdWUgPSAnJztcbiAgZWxzZVxuICAgIHRoaXMudmFsdWUgPSB0aGlzLm9wZXJhdG9yICsgdGhpcy5zZW12ZXIudmVyc2lvbjtcblxuICBkZWJ1ZygnY29tcCcsIHRoaXMpO1xufVxuXG52YXIgQU5ZID0ge307XG5Db21wYXJhdG9yLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKGNvbXApIHtcbiAgdmFyIHIgPSB0aGlzLmxvb3NlID8gcmVbQ09NUEFSQVRPUkxPT1NFXSA6IHJlW0NPTVBBUkFUT1JdO1xuICB2YXIgbSA9IGNvbXAubWF0Y2gocik7XG5cbiAgaWYgKCFtKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgY29tcGFyYXRvcjogJyArIGNvbXApO1xuXG4gIHRoaXMub3BlcmF0b3IgPSBtWzFdO1xuICBpZiAodGhpcy5vcGVyYXRvciA9PT0gJz0nKVxuICAgIHRoaXMub3BlcmF0b3IgPSAnJztcblxuICAvLyBpZiBpdCBsaXRlcmFsbHkgaXMganVzdCAnPicgb3IgJycgdGhlbiBhbGxvdyBhbnl0aGluZy5cbiAgaWYgKCFtWzJdKVxuICAgIHRoaXMuc2VtdmVyID0gQU5ZO1xuICBlbHNlXG4gICAgdGhpcy5zZW12ZXIgPSBuZXcgU2VtVmVyKG1bMl0sIHRoaXMubG9vc2UpO1xufTtcblxuQ29tcGFyYXRvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudmFsdWU7XG59O1xuXG5Db21wYXJhdG9yLnByb3RvdHlwZS50ZXN0ID0gZnVuY3Rpb24odmVyc2lvbikge1xuICBkZWJ1ZygnQ29tcGFyYXRvci50ZXN0JywgdmVyc2lvbiwgdGhpcy5sb29zZSk7XG5cbiAgaWYgKHRoaXMuc2VtdmVyID09PSBBTlkpXG4gICAgcmV0dXJuIHRydWU7XG5cbiAgaWYgKHR5cGVvZiB2ZXJzaW9uID09PSAnc3RyaW5nJylcbiAgICB2ZXJzaW9uID0gbmV3IFNlbVZlcih2ZXJzaW9uLCB0aGlzLmxvb3NlKTtcblxuICByZXR1cm4gY21wKHZlcnNpb24sIHRoaXMub3BlcmF0b3IsIHRoaXMuc2VtdmVyLCB0aGlzLmxvb3NlKTtcbn07XG5cbkNvbXBhcmF0b3IucHJvdG90eXBlLmludGVyc2VjdHMgPSBmdW5jdGlvbihjb21wLCBsb29zZSkge1xuICBpZiAoIShjb21wIGluc3RhbmNlb2YgQ29tcGFyYXRvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhIENvbXBhcmF0b3IgaXMgcmVxdWlyZWQnKTtcbiAgfVxuXG4gIHZhciByYW5nZVRtcDtcblxuICBpZiAodGhpcy5vcGVyYXRvciA9PT0gJycpIHtcbiAgICByYW5nZVRtcCA9IG5ldyBSYW5nZShjb21wLnZhbHVlLCBsb29zZSk7XG4gICAgcmV0dXJuIHNhdGlzZmllcyh0aGlzLnZhbHVlLCByYW5nZVRtcCwgbG9vc2UpO1xuICB9IGVsc2UgaWYgKGNvbXAub3BlcmF0b3IgPT09ICcnKSB7XG4gICAgcmFuZ2VUbXAgPSBuZXcgUmFuZ2UodGhpcy52YWx1ZSwgbG9vc2UpO1xuICAgIHJldHVybiBzYXRpc2ZpZXMoY29tcC5zZW12ZXIsIHJhbmdlVG1wLCBsb29zZSk7XG4gIH1cblxuICB2YXIgc2FtZURpcmVjdGlvbkluY3JlYXNpbmcgPVxuICAgICh0aGlzLm9wZXJhdG9yID09PSAnPj0nIHx8IHRoaXMub3BlcmF0b3IgPT09ICc+JykgJiZcbiAgICAoY29tcC5vcGVyYXRvciA9PT0gJz49JyB8fCBjb21wLm9wZXJhdG9yID09PSAnPicpO1xuICB2YXIgc2FtZURpcmVjdGlvbkRlY3JlYXNpbmcgPVxuICAgICh0aGlzLm9wZXJhdG9yID09PSAnPD0nIHx8IHRoaXMub3BlcmF0b3IgPT09ICc8JykgJiZcbiAgICAoY29tcC5vcGVyYXRvciA9PT0gJzw9JyB8fCBjb21wLm9wZXJhdG9yID09PSAnPCcpO1xuICB2YXIgc2FtZVNlbVZlciA9IHRoaXMuc2VtdmVyLnZlcnNpb24gPT09IGNvbXAuc2VtdmVyLnZlcnNpb247XG4gIHZhciBkaWZmZXJlbnREaXJlY3Rpb25zSW5jbHVzaXZlID1cbiAgICAodGhpcy5vcGVyYXRvciA9PT0gJz49JyB8fCB0aGlzLm9wZXJhdG9yID09PSAnPD0nKSAmJlxuICAgIChjb21wLm9wZXJhdG9yID09PSAnPj0nIHx8IGNvbXAub3BlcmF0b3IgPT09ICc8PScpO1xuICB2YXIgb3Bwb3NpdGVEaXJlY3Rpb25zTGVzc1RoYW4gPVxuICAgIGNtcCh0aGlzLnNlbXZlciwgJzwnLCBjb21wLnNlbXZlciwgbG9vc2UpICYmXG4gICAgKCh0aGlzLm9wZXJhdG9yID09PSAnPj0nIHx8IHRoaXMub3BlcmF0b3IgPT09ICc+JykgJiZcbiAgICAoY29tcC5vcGVyYXRvciA9PT0gJzw9JyB8fCBjb21wLm9wZXJhdG9yID09PSAnPCcpKTtcbiAgdmFyIG9wcG9zaXRlRGlyZWN0aW9uc0dyZWF0ZXJUaGFuID1cbiAgICBjbXAodGhpcy5zZW12ZXIsICc+JywgY29tcC5zZW12ZXIsIGxvb3NlKSAmJlxuICAgICgodGhpcy5vcGVyYXRvciA9PT0gJzw9JyB8fCB0aGlzLm9wZXJhdG9yID09PSAnPCcpICYmXG4gICAgKGNvbXAub3BlcmF0b3IgPT09ICc+PScgfHwgY29tcC5vcGVyYXRvciA9PT0gJz4nKSk7XG5cbiAgcmV0dXJuIHNhbWVEaXJlY3Rpb25JbmNyZWFzaW5nIHx8IHNhbWVEaXJlY3Rpb25EZWNyZWFzaW5nIHx8XG4gICAgKHNhbWVTZW1WZXIgJiYgZGlmZmVyZW50RGlyZWN0aW9uc0luY2x1c2l2ZSkgfHxcbiAgICBvcHBvc2l0ZURpcmVjdGlvbnNMZXNzVGhhbiB8fCBvcHBvc2l0ZURpcmVjdGlvbnNHcmVhdGVyVGhhbjtcbn07XG5cblxuZXhwb3J0cy5SYW5nZSA9IFJhbmdlO1xuZnVuY3Rpb24gUmFuZ2UocmFuZ2UsIGxvb3NlKSB7XG4gIGlmIChyYW5nZSBpbnN0YW5jZW9mIFJhbmdlKSB7XG4gICAgaWYgKHJhbmdlLmxvb3NlID09PSBsb29zZSkge1xuICAgICAgcmV0dXJuIHJhbmdlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IFJhbmdlKHJhbmdlLnJhdywgbG9vc2UpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChyYW5nZSBpbnN0YW5jZW9mIENvbXBhcmF0b3IpIHtcbiAgICByZXR1cm4gbmV3IFJhbmdlKHJhbmdlLnZhbHVlLCBsb29zZSk7XG4gIH1cblxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmFuZ2UpKVxuICAgIHJldHVybiBuZXcgUmFuZ2UocmFuZ2UsIGxvb3NlKTtcblxuICB0aGlzLmxvb3NlID0gbG9vc2U7XG5cbiAgLy8gRmlyc3QsIHNwbGl0IGJhc2VkIG9uIGJvb2xlYW4gb3IgfHxcbiAgdGhpcy5yYXcgPSByYW5nZTtcbiAgdGhpcy5zZXQgPSByYW5nZS5zcGxpdCgvXFxzKlxcfFxcfFxccyovKS5tYXAoZnVuY3Rpb24ocmFuZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZVJhbmdlKHJhbmdlLnRyaW0oKSk7XG4gIH0sIHRoaXMpLmZpbHRlcihmdW5jdGlvbihjKSB7XG4gICAgLy8gdGhyb3cgb3V0IGFueSB0aGF0IGFyZSBub3QgcmVsZXZhbnQgZm9yIHdoYXRldmVyIHJlYXNvblxuICAgIHJldHVybiBjLmxlbmd0aDtcbiAgfSk7XG5cbiAgaWYgKCF0aGlzLnNldC5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIFNlbVZlciBSYW5nZTogJyArIHJhbmdlKTtcbiAgfVxuXG4gIHRoaXMuZm9ybWF0KCk7XG59XG5cblJhbmdlLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5yYW5nZSA9IHRoaXMuc2V0Lm1hcChmdW5jdGlvbihjb21wcykge1xuICAgIHJldHVybiBjb21wcy5qb2luKCcgJykudHJpbSgpO1xuICB9KS5qb2luKCd8fCcpLnRyaW0oKTtcbiAgcmV0dXJuIHRoaXMucmFuZ2U7XG59O1xuXG5SYW5nZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMucmFuZ2U7XG59O1xuXG5SYW5nZS5wcm90b3R5cGUucGFyc2VSYW5nZSA9IGZ1bmN0aW9uKHJhbmdlKSB7XG4gIHZhciBsb29zZSA9IHRoaXMubG9vc2U7XG4gIHJhbmdlID0gcmFuZ2UudHJpbSgpO1xuICBkZWJ1ZygncmFuZ2UnLCByYW5nZSwgbG9vc2UpO1xuICAvLyBgMS4yLjMgLSAxLjIuNGAgPT4gYD49MS4yLjMgPD0xLjIuNGBcbiAgdmFyIGhyID0gbG9vc2UgPyByZVtIWVBIRU5SQU5HRUxPT1NFXSA6IHJlW0hZUEhFTlJBTkdFXTtcbiAgcmFuZ2UgPSByYW5nZS5yZXBsYWNlKGhyLCBoeXBoZW5SZXBsYWNlKTtcbiAgZGVidWcoJ2h5cGhlbiByZXBsYWNlJywgcmFuZ2UpO1xuICAvLyBgPiAxLjIuMyA8IDEuMi41YCA9PiBgPjEuMi4zIDwxLjIuNWBcbiAgcmFuZ2UgPSByYW5nZS5yZXBsYWNlKHJlW0NPTVBBUkFUT1JUUklNXSwgY29tcGFyYXRvclRyaW1SZXBsYWNlKTtcbiAgZGVidWcoJ2NvbXBhcmF0b3IgdHJpbScsIHJhbmdlLCByZVtDT01QQVJBVE9SVFJJTV0pO1xuXG4gIC8vIGB+IDEuMi4zYCA9PiBgfjEuMi4zYFxuICByYW5nZSA9IHJhbmdlLnJlcGxhY2UocmVbVElMREVUUklNXSwgdGlsZGVUcmltUmVwbGFjZSk7XG5cbiAgLy8gYF4gMS4yLjNgID0+IGBeMS4yLjNgXG4gIHJhbmdlID0gcmFuZ2UucmVwbGFjZShyZVtDQVJFVFRSSU1dLCBjYXJldFRyaW1SZXBsYWNlKTtcblxuICAvLyBub3JtYWxpemUgc3BhY2VzXG4gIHJhbmdlID0gcmFuZ2Uuc3BsaXQoL1xccysvKS5qb2luKCcgJyk7XG5cbiAgLy8gQXQgdGhpcyBwb2ludCwgdGhlIHJhbmdlIGlzIGNvbXBsZXRlbHkgdHJpbW1lZCBhbmRcbiAgLy8gcmVhZHkgdG8gYmUgc3BsaXQgaW50byBjb21wYXJhdG9ycy5cblxuICB2YXIgY29tcFJlID0gbG9vc2UgPyByZVtDT01QQVJBVE9STE9PU0VdIDogcmVbQ09NUEFSQVRPUl07XG4gIHZhciBzZXQgPSByYW5nZS5zcGxpdCgnICcpLm1hcChmdW5jdGlvbihjb21wKSB7XG4gICAgcmV0dXJuIHBhcnNlQ29tcGFyYXRvcihjb21wLCBsb29zZSk7XG4gIH0pLmpvaW4oJyAnKS5zcGxpdCgvXFxzKy8pO1xuICBpZiAodGhpcy5sb29zZSkge1xuICAgIC8vIGluIGxvb3NlIG1vZGUsIHRocm93IG91dCBhbnkgdGhhdCBhcmUgbm90IHZhbGlkIGNvbXBhcmF0b3JzXG4gICAgc2V0ID0gc2V0LmZpbHRlcihmdW5jdGlvbihjb21wKSB7XG4gICAgICByZXR1cm4gISFjb21wLm1hdGNoKGNvbXBSZSk7XG4gICAgfSk7XG4gIH1cbiAgc2V0ID0gc2V0Lm1hcChmdW5jdGlvbihjb21wKSB7XG4gICAgcmV0dXJuIG5ldyBDb21wYXJhdG9yKGNvbXAsIGxvb3NlKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHNldDtcbn07XG5cblJhbmdlLnByb3RvdHlwZS5pbnRlcnNlY3RzID0gZnVuY3Rpb24ocmFuZ2UsIGxvb3NlKSB7XG4gIGlmICghKHJhbmdlIGluc3RhbmNlb2YgUmFuZ2UpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYSBSYW5nZSBpcyByZXF1aXJlZCcpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuc2V0LnNvbWUoZnVuY3Rpb24odGhpc0NvbXBhcmF0b3JzKSB7XG4gICAgcmV0dXJuIHRoaXNDb21wYXJhdG9ycy5ldmVyeShmdW5jdGlvbih0aGlzQ29tcGFyYXRvcikge1xuICAgICAgcmV0dXJuIHJhbmdlLnNldC5zb21lKGZ1bmN0aW9uKHJhbmdlQ29tcGFyYXRvcnMpIHtcbiAgICAgICAgcmV0dXJuIHJhbmdlQ29tcGFyYXRvcnMuZXZlcnkoZnVuY3Rpb24ocmFuZ2VDb21wYXJhdG9yKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXNDb21wYXJhdG9yLmludGVyc2VjdHMocmFuZ2VDb21wYXJhdG9yLCBsb29zZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xufTtcblxuLy8gTW9zdGx5IGp1c3QgZm9yIHRlc3RpbmcgYW5kIGxlZ2FjeSBBUEkgcmVhc29uc1xuZXhwb3J0cy50b0NvbXBhcmF0b3JzID0gdG9Db21wYXJhdG9ycztcbmZ1bmN0aW9uIHRvQ29tcGFyYXRvcnMocmFuZ2UsIGxvb3NlKSB7XG4gIHJldHVybiBuZXcgUmFuZ2UocmFuZ2UsIGxvb3NlKS5zZXQubWFwKGZ1bmN0aW9uKGNvbXApIHtcbiAgICByZXR1cm4gY29tcC5tYXAoZnVuY3Rpb24oYykge1xuICAgICAgcmV0dXJuIGMudmFsdWU7XG4gICAgfSkuam9pbignICcpLnRyaW0oKS5zcGxpdCgnICcpO1xuICB9KTtcbn1cblxuLy8gY29tcHJpc2VkIG9mIHhyYW5nZXMsIHRpbGRlcywgc3RhcnMsIGFuZCBndGx0J3MgYXQgdGhpcyBwb2ludC5cbi8vIGFscmVhZHkgcmVwbGFjZWQgdGhlIGh5cGhlbiByYW5nZXNcbi8vIHR1cm4gaW50byBhIHNldCBvZiBKVVNUIGNvbXBhcmF0b3JzLlxuZnVuY3Rpb24gcGFyc2VDb21wYXJhdG9yKGNvbXAsIGxvb3NlKSB7XG4gIGRlYnVnKCdjb21wJywgY29tcCk7XG4gIGNvbXAgPSByZXBsYWNlQ2FyZXRzKGNvbXAsIGxvb3NlKTtcbiAgZGVidWcoJ2NhcmV0JywgY29tcCk7XG4gIGNvbXAgPSByZXBsYWNlVGlsZGVzKGNvbXAsIGxvb3NlKTtcbiAgZGVidWcoJ3RpbGRlcycsIGNvbXApO1xuICBjb21wID0gcmVwbGFjZVhSYW5nZXMoY29tcCwgbG9vc2UpO1xuICBkZWJ1ZygneHJhbmdlJywgY29tcCk7XG4gIGNvbXAgPSByZXBsYWNlU3RhcnMoY29tcCwgbG9vc2UpO1xuICBkZWJ1Zygnc3RhcnMnLCBjb21wKTtcbiAgcmV0dXJuIGNvbXA7XG59XG5cbmZ1bmN0aW9uIGlzWChpZCkge1xuICByZXR1cm4gIWlkIHx8IGlkLnRvTG93ZXJDYXNlKCkgPT09ICd4JyB8fCBpZCA9PT0gJyonO1xufVxuXG4vLyB+LCB+PiAtLT4gKiAoYW55LCBraW5kYSBzaWxseSlcbi8vIH4yLCB+Mi54LCB+Mi54LngsIH4+Miwgfj4yLnggfj4yLngueCAtLT4gPj0yLjAuMCA8My4wLjBcbi8vIH4yLjAsIH4yLjAueCwgfj4yLjAsIH4+Mi4wLnggLS0+ID49Mi4wLjAgPDIuMS4wXG4vLyB+MS4yLCB+MS4yLngsIH4+MS4yLCB+PjEuMi54IC0tPiA+PTEuMi4wIDwxLjMuMFxuLy8gfjEuMi4zLCB+PjEuMi4zIC0tPiA+PTEuMi4zIDwxLjMuMFxuLy8gfjEuMi4wLCB+PjEuMi4wIC0tPiA+PTEuMi4wIDwxLjMuMFxuZnVuY3Rpb24gcmVwbGFjZVRpbGRlcyhjb21wLCBsb29zZSkge1xuICByZXR1cm4gY29tcC50cmltKCkuc3BsaXQoL1xccysvKS5tYXAoZnVuY3Rpb24oY29tcCkge1xuICAgIHJldHVybiByZXBsYWNlVGlsZGUoY29tcCwgbG9vc2UpO1xuICB9KS5qb2luKCcgJyk7XG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VUaWxkZShjb21wLCBsb29zZSkge1xuICB2YXIgciA9IGxvb3NlID8gcmVbVElMREVMT09TRV0gOiByZVtUSUxERV07XG4gIHJldHVybiBjb21wLnJlcGxhY2UociwgZnVuY3Rpb24oXywgTSwgbSwgcCwgcHIpIHtcbiAgICBkZWJ1ZygndGlsZGUnLCBjb21wLCBfLCBNLCBtLCBwLCBwcik7XG4gICAgdmFyIHJldDtcblxuICAgIGlmIChpc1goTSkpXG4gICAgICByZXQgPSAnJztcbiAgICBlbHNlIGlmIChpc1gobSkpXG4gICAgICByZXQgPSAnPj0nICsgTSArICcuMC4wIDwnICsgKCtNICsgMSkgKyAnLjAuMCc7XG4gICAgZWxzZSBpZiAoaXNYKHApKVxuICAgICAgLy8gfjEuMiA9PSA+PTEuMi4wIDwxLjMuMFxuICAgICAgcmV0ID0gJz49JyArIE0gKyAnLicgKyBtICsgJy4wIDwnICsgTSArICcuJyArICgrbSArIDEpICsgJy4wJztcbiAgICBlbHNlIGlmIChwcikge1xuICAgICAgZGVidWcoJ3JlcGxhY2VUaWxkZSBwcicsIHByKTtcbiAgICAgIGlmIChwci5jaGFyQXQoMCkgIT09ICctJylcbiAgICAgICAgcHIgPSAnLScgKyBwcjtcbiAgICAgIHJldCA9ICc+PScgKyBNICsgJy4nICsgbSArICcuJyArIHAgKyBwciArXG4gICAgICAgICAgICAnIDwnICsgTSArICcuJyArICgrbSArIDEpICsgJy4wJztcbiAgICB9IGVsc2VcbiAgICAgIC8vIH4xLjIuMyA9PSA+PTEuMi4zIDwxLjMuMFxuICAgICAgcmV0ID0gJz49JyArIE0gKyAnLicgKyBtICsgJy4nICsgcCArXG4gICAgICAgICAgICAnIDwnICsgTSArICcuJyArICgrbSArIDEpICsgJy4wJztcblxuICAgIGRlYnVnKCd0aWxkZSByZXR1cm4nLCByZXQpO1xuICAgIHJldHVybiByZXQ7XG4gIH0pO1xufVxuXG4vLyBeIC0tPiAqIChhbnksIGtpbmRhIHNpbGx5KVxuLy8gXjIsIF4yLngsIF4yLngueCAtLT4gPj0yLjAuMCA8My4wLjBcbi8vIF4yLjAsIF4yLjAueCAtLT4gPj0yLjAuMCA8My4wLjBcbi8vIF4xLjIsIF4xLjIueCAtLT4gPj0xLjIuMCA8Mi4wLjBcbi8vIF4xLjIuMyAtLT4gPj0xLjIuMyA8Mi4wLjBcbi8vIF4xLjIuMCAtLT4gPj0xLjIuMCA8Mi4wLjBcbmZ1bmN0aW9uIHJlcGxhY2VDYXJldHMoY29tcCwgbG9vc2UpIHtcbiAgcmV0dXJuIGNvbXAudHJpbSgpLnNwbGl0KC9cXHMrLykubWFwKGZ1bmN0aW9uKGNvbXApIHtcbiAgICByZXR1cm4gcmVwbGFjZUNhcmV0KGNvbXAsIGxvb3NlKTtcbiAgfSkuam9pbignICcpO1xufVxuXG5mdW5jdGlvbiByZXBsYWNlQ2FyZXQoY29tcCwgbG9vc2UpIHtcbiAgZGVidWcoJ2NhcmV0JywgY29tcCwgbG9vc2UpO1xuICB2YXIgciA9IGxvb3NlID8gcmVbQ0FSRVRMT09TRV0gOiByZVtDQVJFVF07XG4gIHJldHVybiBjb21wLnJlcGxhY2UociwgZnVuY3Rpb24oXywgTSwgbSwgcCwgcHIpIHtcbiAgICBkZWJ1ZygnY2FyZXQnLCBjb21wLCBfLCBNLCBtLCBwLCBwcik7XG4gICAgdmFyIHJldDtcblxuICAgIGlmIChpc1goTSkpXG4gICAgICByZXQgPSAnJztcbiAgICBlbHNlIGlmIChpc1gobSkpXG4gICAgICByZXQgPSAnPj0nICsgTSArICcuMC4wIDwnICsgKCtNICsgMSkgKyAnLjAuMCc7XG4gICAgZWxzZSBpZiAoaXNYKHApKSB7XG4gICAgICBpZiAoTSA9PT0gJzAnKVxuICAgICAgICByZXQgPSAnPj0nICsgTSArICcuJyArIG0gKyAnLjAgPCcgKyBNICsgJy4nICsgKCttICsgMSkgKyAnLjAnO1xuICAgICAgZWxzZVxuICAgICAgICByZXQgPSAnPj0nICsgTSArICcuJyArIG0gKyAnLjAgPCcgKyAoK00gKyAxKSArICcuMC4wJztcbiAgICB9IGVsc2UgaWYgKHByKSB7XG4gICAgICBkZWJ1ZygncmVwbGFjZUNhcmV0IHByJywgcHIpO1xuICAgICAgaWYgKHByLmNoYXJBdCgwKSAhPT0gJy0nKVxuICAgICAgICBwciA9ICctJyArIHByO1xuICAgICAgaWYgKE0gPT09ICcwJykge1xuICAgICAgICBpZiAobSA9PT0gJzAnKVxuICAgICAgICAgIHJldCA9ICc+PScgKyBNICsgJy4nICsgbSArICcuJyArIHAgKyBwciArXG4gICAgICAgICAgICAgICAgJyA8JyArIE0gKyAnLicgKyBtICsgJy4nICsgKCtwICsgMSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICByZXQgPSAnPj0nICsgTSArICcuJyArIG0gKyAnLicgKyBwICsgcHIgK1xuICAgICAgICAgICAgICAgICcgPCcgKyBNICsgJy4nICsgKCttICsgMSkgKyAnLjAnO1xuICAgICAgfSBlbHNlXG4gICAgICAgIHJldCA9ICc+PScgKyBNICsgJy4nICsgbSArICcuJyArIHAgKyBwciArXG4gICAgICAgICAgICAgICcgPCcgKyAoK00gKyAxKSArICcuMC4wJztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWcoJ25vIHByJyk7XG4gICAgICBpZiAoTSA9PT0gJzAnKSB7XG4gICAgICAgIGlmIChtID09PSAnMCcpXG4gICAgICAgICAgcmV0ID0gJz49JyArIE0gKyAnLicgKyBtICsgJy4nICsgcCArXG4gICAgICAgICAgICAgICAgJyA8JyArIE0gKyAnLicgKyBtICsgJy4nICsgKCtwICsgMSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICByZXQgPSAnPj0nICsgTSArICcuJyArIG0gKyAnLicgKyBwICtcbiAgICAgICAgICAgICAgICAnIDwnICsgTSArICcuJyArICgrbSArIDEpICsgJy4wJztcbiAgICAgIH0gZWxzZVxuICAgICAgICByZXQgPSAnPj0nICsgTSArICcuJyArIG0gKyAnLicgKyBwICtcbiAgICAgICAgICAgICAgJyA8JyArICgrTSArIDEpICsgJy4wLjAnO1xuICAgIH1cblxuICAgIGRlYnVnKCdjYXJldCByZXR1cm4nLCByZXQpO1xuICAgIHJldHVybiByZXQ7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZXBsYWNlWFJhbmdlcyhjb21wLCBsb29zZSkge1xuICBkZWJ1ZygncmVwbGFjZVhSYW5nZXMnLCBjb21wLCBsb29zZSk7XG4gIHJldHVybiBjb21wLnNwbGl0KC9cXHMrLykubWFwKGZ1bmN0aW9uKGNvbXApIHtcbiAgICByZXR1cm4gcmVwbGFjZVhSYW5nZShjb21wLCBsb29zZSk7XG4gIH0pLmpvaW4oJyAnKTtcbn1cblxuZnVuY3Rpb24gcmVwbGFjZVhSYW5nZShjb21wLCBsb29zZSkge1xuICBjb21wID0gY29tcC50cmltKCk7XG4gIHZhciByID0gbG9vc2UgPyByZVtYUkFOR0VMT09TRV0gOiByZVtYUkFOR0VdO1xuICByZXR1cm4gY29tcC5yZXBsYWNlKHIsIGZ1bmN0aW9uKHJldCwgZ3RsdCwgTSwgbSwgcCwgcHIpIHtcbiAgICBkZWJ1ZygneFJhbmdlJywgY29tcCwgcmV0LCBndGx0LCBNLCBtLCBwLCBwcik7XG4gICAgdmFyIHhNID0gaXNYKE0pO1xuICAgIHZhciB4bSA9IHhNIHx8IGlzWChtKTtcbiAgICB2YXIgeHAgPSB4bSB8fCBpc1gocCk7XG4gICAgdmFyIGFueVggPSB4cDtcblxuICAgIGlmIChndGx0ID09PSAnPScgJiYgYW55WClcbiAgICAgIGd0bHQgPSAnJztcblxuICAgIGlmICh4TSkge1xuICAgICAgaWYgKGd0bHQgPT09ICc+JyB8fCBndGx0ID09PSAnPCcpIHtcbiAgICAgICAgLy8gbm90aGluZyBpcyBhbGxvd2VkXG4gICAgICAgIHJldCA9ICc8MC4wLjAnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbm90aGluZyBpcyBmb3JiaWRkZW5cbiAgICAgICAgcmV0ID0gJyonO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZ3RsdCAmJiBhbnlYKSB7XG4gICAgICAvLyByZXBsYWNlIFggd2l0aCAwXG4gICAgICBpZiAoeG0pXG4gICAgICAgIG0gPSAwO1xuICAgICAgaWYgKHhwKVxuICAgICAgICBwID0gMDtcblxuICAgICAgaWYgKGd0bHQgPT09ICc+Jykge1xuICAgICAgICAvLyA+MSA9PiA+PTIuMC4wXG4gICAgICAgIC8vID4xLjIgPT4gPj0xLjMuMFxuICAgICAgICAvLyA+MS4yLjMgPT4gPj0gMS4yLjRcbiAgICAgICAgZ3RsdCA9ICc+PSc7XG4gICAgICAgIGlmICh4bSkge1xuICAgICAgICAgIE0gPSArTSArIDE7XG4gICAgICAgICAgbSA9IDA7XG4gICAgICAgICAgcCA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoeHApIHtcbiAgICAgICAgICBtID0gK20gKyAxO1xuICAgICAgICAgIHAgPSAwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGd0bHQgPT09ICc8PScpIHtcbiAgICAgICAgLy8gPD0wLjcueCBpcyBhY3R1YWxseSA8MC44LjAsIHNpbmNlIGFueSAwLjcueCBzaG91bGRcbiAgICAgICAgLy8gcGFzcy4gIFNpbWlsYXJseSwgPD03LnggaXMgYWN0dWFsbHkgPDguMC4wLCBldGMuXG4gICAgICAgIGd0bHQgPSAnPCc7XG4gICAgICAgIGlmICh4bSlcbiAgICAgICAgICBNID0gK00gKyAxO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgbSA9ICttICsgMTtcbiAgICAgIH1cblxuICAgICAgcmV0ID0gZ3RsdCArIE0gKyAnLicgKyBtICsgJy4nICsgcDtcbiAgICB9IGVsc2UgaWYgKHhtKSB7XG4gICAgICByZXQgPSAnPj0nICsgTSArICcuMC4wIDwnICsgKCtNICsgMSkgKyAnLjAuMCc7XG4gICAgfSBlbHNlIGlmICh4cCkge1xuICAgICAgcmV0ID0gJz49JyArIE0gKyAnLicgKyBtICsgJy4wIDwnICsgTSArICcuJyArICgrbSArIDEpICsgJy4wJztcbiAgICB9XG5cbiAgICBkZWJ1ZygneFJhbmdlIHJldHVybicsIHJldCk7XG5cbiAgICByZXR1cm4gcmV0O1xuICB9KTtcbn1cblxuLy8gQmVjYXVzZSAqIGlzIEFORC1lZCB3aXRoIGV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgY29tcGFyYXRvcixcbi8vIGFuZCAnJyBtZWFucyBcImFueSB2ZXJzaW9uXCIsIGp1c3QgcmVtb3ZlIHRoZSAqcyBlbnRpcmVseS5cbmZ1bmN0aW9uIHJlcGxhY2VTdGFycyhjb21wLCBsb29zZSkge1xuICBkZWJ1ZygncmVwbGFjZVN0YXJzJywgY29tcCwgbG9vc2UpO1xuICAvLyBMb29zZW5lc3MgaXMgaWdub3JlZCBoZXJlLiAgc3RhciBpcyBhbHdheXMgYXMgbG9vc2UgYXMgaXQgZ2V0cyFcbiAgcmV0dXJuIGNvbXAudHJpbSgpLnJlcGxhY2UocmVbU1RBUl0sICcnKTtcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBpcyBwYXNzZWQgdG8gc3RyaW5nLnJlcGxhY2UocmVbSFlQSEVOUkFOR0VdKVxuLy8gTSwgbSwgcGF0Y2gsIHByZXJlbGVhc2UsIGJ1aWxkXG4vLyAxLjIgLSAzLjQuNSA9PiA+PTEuMi4wIDw9My40LjVcbi8vIDEuMi4zIC0gMy40ID0+ID49MS4yLjAgPDMuNS4wIEFueSAzLjQueCB3aWxsIGRvXG4vLyAxLjIgLSAzLjQgPT4gPj0xLjIuMCA8My41LjBcbmZ1bmN0aW9uIGh5cGhlblJlcGxhY2UoJDAsXG4gICAgICAgICAgICAgICAgICAgICAgIGZyb20sIGZNLCBmbSwgZnAsIGZwciwgZmIsXG4gICAgICAgICAgICAgICAgICAgICAgIHRvLCB0TSwgdG0sIHRwLCB0cHIsIHRiKSB7XG5cbiAgaWYgKGlzWChmTSkpXG4gICAgZnJvbSA9ICcnO1xuICBlbHNlIGlmIChpc1goZm0pKVxuICAgIGZyb20gPSAnPj0nICsgZk0gKyAnLjAuMCc7XG4gIGVsc2UgaWYgKGlzWChmcCkpXG4gICAgZnJvbSA9ICc+PScgKyBmTSArICcuJyArIGZtICsgJy4wJztcbiAgZWxzZVxuICAgIGZyb20gPSAnPj0nICsgZnJvbTtcblxuICBpZiAoaXNYKHRNKSlcbiAgICB0byA9ICcnO1xuICBlbHNlIGlmIChpc1godG0pKVxuICAgIHRvID0gJzwnICsgKCt0TSArIDEpICsgJy4wLjAnO1xuICBlbHNlIGlmIChpc1godHApKVxuICAgIHRvID0gJzwnICsgdE0gKyAnLicgKyAoK3RtICsgMSkgKyAnLjAnO1xuICBlbHNlIGlmICh0cHIpXG4gICAgdG8gPSAnPD0nICsgdE0gKyAnLicgKyB0bSArICcuJyArIHRwICsgJy0nICsgdHByO1xuICBlbHNlXG4gICAgdG8gPSAnPD0nICsgdG87XG5cbiAgcmV0dXJuIChmcm9tICsgJyAnICsgdG8pLnRyaW0oKTtcbn1cblxuXG4vLyBpZiBBTlkgb2YgdGhlIHNldHMgbWF0Y2ggQUxMIG9mIGl0cyBjb21wYXJhdG9ycywgdGhlbiBwYXNzXG5SYW5nZS5wcm90b3R5cGUudGVzdCA9IGZ1bmN0aW9uKHZlcnNpb24pIHtcbiAgaWYgKCF2ZXJzaW9uKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAodHlwZW9mIHZlcnNpb24gPT09ICdzdHJpbmcnKVxuICAgIHZlcnNpb24gPSBuZXcgU2VtVmVyKHZlcnNpb24sIHRoaXMubG9vc2UpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zZXQubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAodGVzdFNldCh0aGlzLnNldFtpXSwgdmVyc2lvbikpXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5mdW5jdGlvbiB0ZXN0U2V0KHNldCwgdmVyc2lvbikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkrKykge1xuICAgIGlmICghc2V0W2ldLnRlc3QodmVyc2lvbikpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAodmVyc2lvbi5wcmVyZWxlYXNlLmxlbmd0aCkge1xuICAgIC8vIEZpbmQgdGhlIHNldCBvZiB2ZXJzaW9ucyB0aGF0IGFyZSBhbGxvd2VkIHRvIGhhdmUgcHJlcmVsZWFzZXNcbiAgICAvLyBGb3IgZXhhbXBsZSwgXjEuMi4zLXByLjEgZGVzdWdhcnMgdG8gPj0xLjIuMy1wci4xIDwyLjAuMFxuICAgIC8vIFRoYXQgc2hvdWxkIGFsbG93IGAxLjIuMy1wci4yYCB0byBwYXNzLlxuICAgIC8vIEhvd2V2ZXIsIGAxLjIuNC1hbHBoYS5ub3RyZWFkeWAgc2hvdWxkIE5PVCBiZSBhbGxvd2VkLFxuICAgIC8vIGV2ZW4gdGhvdWdoIGl0J3Mgd2l0aGluIHRoZSByYW5nZSBzZXQgYnkgdGhlIGNvbXBhcmF0b3JzLlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZWJ1ZyhzZXRbaV0uc2VtdmVyKTtcbiAgICAgIGlmIChzZXRbaV0uc2VtdmVyID09PSBBTlkpXG4gICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICBpZiAoc2V0W2ldLnNlbXZlci5wcmVyZWxlYXNlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIGFsbG93ZWQgPSBzZXRbaV0uc2VtdmVyO1xuICAgICAgICBpZiAoYWxsb3dlZC5tYWpvciA9PT0gdmVyc2lvbi5tYWpvciAmJlxuICAgICAgICAgICAgYWxsb3dlZC5taW5vciA9PT0gdmVyc2lvbi5taW5vciAmJlxuICAgICAgICAgICAgYWxsb3dlZC5wYXRjaCA9PT0gdmVyc2lvbi5wYXRjaClcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBWZXJzaW9uIGhhcyBhIC1wcmUsIGJ1dCBpdCdzIG5vdCBvbmUgb2YgdGhlIG9uZXMgd2UgbGlrZS5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZXhwb3J0cy5zYXRpc2ZpZXMgPSBzYXRpc2ZpZXM7XG5mdW5jdGlvbiBzYXRpc2ZpZXModmVyc2lvbiwgcmFuZ2UsIGxvb3NlKSB7XG4gIHRyeSB7XG4gICAgcmFuZ2UgPSBuZXcgUmFuZ2UocmFuZ2UsIGxvb3NlKTtcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHJhbmdlLnRlc3QodmVyc2lvbik7XG59XG5cbmV4cG9ydHMubWF4U2F0aXNmeWluZyA9IG1heFNhdGlzZnlpbmc7XG5mdW5jdGlvbiBtYXhTYXRpc2Z5aW5nKHZlcnNpb25zLCByYW5nZSwgbG9vc2UpIHtcbiAgdmFyIG1heCA9IG51bGw7XG4gIHZhciBtYXhTViA9IG51bGw7XG4gIHRyeSB7XG4gICAgdmFyIHJhbmdlT2JqID0gbmV3IFJhbmdlKHJhbmdlLCBsb29zZSk7XG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmVyc2lvbnMuZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgIGlmIChyYW5nZU9iai50ZXN0KHYpKSB7IC8vIHNhdGlzZmllcyh2LCByYW5nZSwgbG9vc2UpXG4gICAgICBpZiAoIW1heCB8fCBtYXhTVi5jb21wYXJlKHYpID09PSAtMSkgeyAvLyBjb21wYXJlKG1heCwgdiwgdHJ1ZSlcbiAgICAgICAgbWF4ID0gdjtcbiAgICAgICAgbWF4U1YgPSBuZXcgU2VtVmVyKG1heCwgbG9vc2UpO1xuICAgICAgfVxuICAgIH1cbiAgfSlcbiAgcmV0dXJuIG1heDtcbn1cblxuZXhwb3J0cy5taW5TYXRpc2Z5aW5nID0gbWluU2F0aXNmeWluZztcbmZ1bmN0aW9uIG1pblNhdGlzZnlpbmcodmVyc2lvbnMsIHJhbmdlLCBsb29zZSkge1xuICB2YXIgbWluID0gbnVsbDtcbiAgdmFyIG1pblNWID0gbnVsbDtcbiAgdHJ5IHtcbiAgICB2YXIgcmFuZ2VPYmogPSBuZXcgUmFuZ2UocmFuZ2UsIGxvb3NlKTtcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2ZXJzaW9ucy5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XG4gICAgaWYgKHJhbmdlT2JqLnRlc3QodikpIHsgLy8gc2F0aXNmaWVzKHYsIHJhbmdlLCBsb29zZSlcbiAgICAgIGlmICghbWluIHx8IG1pblNWLmNvbXBhcmUodikgPT09IDEpIHsgLy8gY29tcGFyZShtaW4sIHYsIHRydWUpXG4gICAgICAgIG1pbiA9IHY7XG4gICAgICAgIG1pblNWID0gbmV3IFNlbVZlcihtaW4sIGxvb3NlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pXG4gIHJldHVybiBtaW47XG59XG5cbmV4cG9ydHMudmFsaWRSYW5nZSA9IHZhbGlkUmFuZ2U7XG5mdW5jdGlvbiB2YWxpZFJhbmdlKHJhbmdlLCBsb29zZSkge1xuICB0cnkge1xuICAgIC8vIFJldHVybiAnKicgaW5zdGVhZCBvZiAnJyBzbyB0aGF0IHRydXRoaW5lc3Mgd29ya3MuXG4gICAgLy8gVGhpcyB3aWxsIHRocm93IGlmIGl0J3MgaW52YWxpZCBhbnl3YXlcbiAgICByZXR1cm4gbmV3IFJhbmdlKHJhbmdlLCBsb29zZSkucmFuZ2UgfHwgJyonO1xuICB9IGNhdGNoIChlcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8vIERldGVybWluZSBpZiB2ZXJzaW9uIGlzIGxlc3MgdGhhbiBhbGwgdGhlIHZlcnNpb25zIHBvc3NpYmxlIGluIHRoZSByYW5nZVxuZXhwb3J0cy5sdHIgPSBsdHI7XG5mdW5jdGlvbiBsdHIodmVyc2lvbiwgcmFuZ2UsIGxvb3NlKSB7XG4gIHJldHVybiBvdXRzaWRlKHZlcnNpb24sIHJhbmdlLCAnPCcsIGxvb3NlKTtcbn1cblxuLy8gRGV0ZXJtaW5lIGlmIHZlcnNpb24gaXMgZ3JlYXRlciB0aGFuIGFsbCB0aGUgdmVyc2lvbnMgcG9zc2libGUgaW4gdGhlIHJhbmdlLlxuZXhwb3J0cy5ndHIgPSBndHI7XG5mdW5jdGlvbiBndHIodmVyc2lvbiwgcmFuZ2UsIGxvb3NlKSB7XG4gIHJldHVybiBvdXRzaWRlKHZlcnNpb24sIHJhbmdlLCAnPicsIGxvb3NlKTtcbn1cblxuZXhwb3J0cy5vdXRzaWRlID0gb3V0c2lkZTtcbmZ1bmN0aW9uIG91dHNpZGUodmVyc2lvbiwgcmFuZ2UsIGhpbG8sIGxvb3NlKSB7XG4gIHZlcnNpb24gPSBuZXcgU2VtVmVyKHZlcnNpb24sIGxvb3NlKTtcbiAgcmFuZ2UgPSBuZXcgUmFuZ2UocmFuZ2UsIGxvb3NlKTtcblxuICB2YXIgZ3RmbiwgbHRlZm4sIGx0Zm4sIGNvbXAsIGVjb21wO1xuICBzd2l0Y2ggKGhpbG8pIHtcbiAgICBjYXNlICc+JzpcbiAgICAgIGd0Zm4gPSBndDtcbiAgICAgIGx0ZWZuID0gbHRlO1xuICAgICAgbHRmbiA9IGx0O1xuICAgICAgY29tcCA9ICc+JztcbiAgICAgIGVjb21wID0gJz49JztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJzwnOlxuICAgICAgZ3RmbiA9IGx0O1xuICAgICAgbHRlZm4gPSBndGU7XG4gICAgICBsdGZuID0gZ3Q7XG4gICAgICBjb21wID0gJzwnO1xuICAgICAgZWNvbXAgPSAnPD0nO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ011c3QgcHJvdmlkZSBhIGhpbG8gdmFsIG9mIFwiPFwiIG9yIFwiPlwiJyk7XG4gIH1cblxuICAvLyBJZiBpdCBzYXRpc2lmZXMgdGhlIHJhbmdlIGl0IGlzIG5vdCBvdXRzaWRlXG4gIGlmIChzYXRpc2ZpZXModmVyc2lvbiwgcmFuZ2UsIGxvb3NlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIEZyb20gbm93IG9uLCB2YXJpYWJsZSB0ZXJtcyBhcmUgYXMgaWYgd2UncmUgaW4gXCJndHJcIiBtb2RlLlxuICAvLyBidXQgbm90ZSB0aGF0IGV2ZXJ5dGhpbmcgaXMgZmxpcHBlZCBmb3IgdGhlIFwibHRyXCIgZnVuY3Rpb24uXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZS5zZXQubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgY29tcGFyYXRvcnMgPSByYW5nZS5zZXRbaV07XG5cbiAgICB2YXIgaGlnaCA9IG51bGw7XG4gICAgdmFyIGxvdyA9IG51bGw7XG5cbiAgICBjb21wYXJhdG9ycy5mb3JFYWNoKGZ1bmN0aW9uKGNvbXBhcmF0b3IpIHtcbiAgICAgIGlmIChjb21wYXJhdG9yLnNlbXZlciA9PT0gQU5ZKSB7XG4gICAgICAgIGNvbXBhcmF0b3IgPSBuZXcgQ29tcGFyYXRvcignPj0wLjAuMCcpXG4gICAgICB9XG4gICAgICBoaWdoID0gaGlnaCB8fCBjb21wYXJhdG9yO1xuICAgICAgbG93ID0gbG93IHx8IGNvbXBhcmF0b3I7XG4gICAgICBpZiAoZ3Rmbihjb21wYXJhdG9yLnNlbXZlciwgaGlnaC5zZW12ZXIsIGxvb3NlKSkge1xuICAgICAgICBoaWdoID0gY29tcGFyYXRvcjtcbiAgICAgIH0gZWxzZSBpZiAobHRmbihjb21wYXJhdG9yLnNlbXZlciwgbG93LnNlbXZlciwgbG9vc2UpKSB7XG4gICAgICAgIGxvdyA9IGNvbXBhcmF0b3I7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBJZiB0aGUgZWRnZSB2ZXJzaW9uIGNvbXBhcmF0b3IgaGFzIGEgb3BlcmF0b3IgdGhlbiBvdXIgdmVyc2lvblxuICAgIC8vIGlzbid0IG91dHNpZGUgaXRcbiAgICBpZiAoaGlnaC5vcGVyYXRvciA9PT0gY29tcCB8fCBoaWdoLm9wZXJhdG9yID09PSBlY29tcCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSBsb3dlc3QgdmVyc2lvbiBjb21wYXJhdG9yIGhhcyBhbiBvcGVyYXRvciBhbmQgb3VyIHZlcnNpb25cbiAgICAvLyBpcyBsZXNzIHRoYW4gaXQgdGhlbiBpdCBpc24ndCBoaWdoZXIgdGhhbiB0aGUgcmFuZ2VcbiAgICBpZiAoKCFsb3cub3BlcmF0b3IgfHwgbG93Lm9wZXJhdG9yID09PSBjb21wKSAmJlxuICAgICAgICBsdGVmbih2ZXJzaW9uLCBsb3cuc2VtdmVyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAobG93Lm9wZXJhdG9yID09PSBlY29tcCAmJiBsdGZuKHZlcnNpb24sIGxvdy5zZW12ZXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5leHBvcnRzLnByZXJlbGVhc2UgPSBwcmVyZWxlYXNlO1xuZnVuY3Rpb24gcHJlcmVsZWFzZSh2ZXJzaW9uLCBsb29zZSkge1xuICB2YXIgcGFyc2VkID0gcGFyc2UodmVyc2lvbiwgbG9vc2UpO1xuICByZXR1cm4gKHBhcnNlZCAmJiBwYXJzZWQucHJlcmVsZWFzZS5sZW5ndGgpID8gcGFyc2VkLnByZXJlbGVhc2UgOiBudWxsO1xufVxuXG5leHBvcnRzLmludGVyc2VjdHMgPSBpbnRlcnNlY3RzO1xuZnVuY3Rpb24gaW50ZXJzZWN0cyhyMSwgcjIsIGxvb3NlKSB7XG4gIHIxID0gbmV3IFJhbmdlKHIxLCBsb29zZSlcbiAgcjIgPSBuZXcgUmFuZ2UocjIsIGxvb3NlKVxuICByZXR1cm4gcjEuaW50ZXJzZWN0cyhyMilcbn1cblxuZXhwb3J0cy5jb2VyY2UgPSBjb2VyY2U7XG5mdW5jdGlvbiBjb2VyY2UodmVyc2lvbikge1xuICBpZiAodmVyc2lvbiBpbnN0YW5jZW9mIFNlbVZlcilcbiAgICByZXR1cm4gdmVyc2lvbjtcblxuICBpZiAodHlwZW9mIHZlcnNpb24gIT09ICdzdHJpbmcnKVxuICAgIHJldHVybiBudWxsO1xuXG4gIHZhciBtYXRjaCA9IHZlcnNpb24ubWF0Y2gocmVbQ09FUkNFXSk7XG5cbiAgaWYgKG1hdGNoID09IG51bGwpXG4gICAgcmV0dXJuIG51bGw7XG5cbiAgcmV0dXJuIHBhcnNlKChtYXRjaFsxXSB8fCAnMCcpICsgJy4nICsgKG1hdGNoWzJdIHx8ICcwJykgKyAnLicgKyAobWF0Y2hbM10gfHwgJzAnKSk7IFxufVxuIiwiLypcclxuICogQ29weXJpZ2h0IChjKSAyMDE2IEpvc8OpIEYuIE1hbGRvbmFkb1xyXG4gKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljIExpY2Vuc2UsIHYuIDIuMC4gXHJcbiAqIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXHJcbiAqL1xyXG5cclxuLy8gTG9hZCBkZXBlbmRlbmNpZXMuXHJcbmNvbnN0IEJpbmFyeVNlYXJjaCA9IHJlcXVpcmUoJ2JpbmFyeXNlYXJjaCcpO1xyXG5jb25zdCBFZGl0RGlzdGFuY2UgPSByZXF1aXJlKCdkYW1lcmF1LWxldmVuc2h0ZWluJykoKTtcclxuXHJcbi8vIFVzZSB0aGlzIG9iamVjdCBmb3IgY29uc2lkZXIgYWNjZW50cyBhbmQgc3BlY2lhbCBjaGFyYWN0ZXJzIHdoZW4gY29tcGFyaW5nIFVURi04IHN0cmluZ3MuXHJcbnZhciBDb2xsYXRvciA9IG5ldyBJbnRsLkNvbGxhdG9yKHVuZGVmaW5lZCwgeydzZW5zaXRpdml0eSc6ICdhY2NlbnQnfSk7XHJcbiBcclxuLy8gVGhlIHNlYXJjaCBmb3Igc3VnZ2VzdGlvbnMgaXMgZ29pbmcgdG8gYmUgbGltaXRlZCB0byB3b3JkcyB0aGF0IGFyZSBuZXh0IHRvIHRoZSBwb3NpdGlvbiwgaW4gdGhlIHdvcmQgbGlzdCwgaW4gd2hpY2ggdGhlIHdvcmQgd291bGQgYmUgaW5zZXJ0ZWQuXHJcbnZhciBTdWdnZXN0UmFkaXVzID0gMTAwMDtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIERpY3Rpb25hcnkuXHJcbiAqXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAdGhpcyB7RGljdGlvbmFyeX1cclxuICogQHBhcmFtIHtzdHJpbmdbXX0gd29yZGxpc3QgQSBzb3J0ZWQgYXJyYXkgb2Ygc3RyaW5ncy5cclxuICovXHJcbmZ1bmN0aW9uIERpY3Rpb25hcnkod29yZGxpc3QpIHtcclxuICAgIHRoaXMud29yZGxpc3QgPSBbXTtcclxuICAgIHRoaXMuc2V0V29yZGxpc3Qod29yZGxpc3QpO1xyXG4gICAgdGhpcy5jbGVhclJlZ2V4cygpO1xyXG59XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIHdvcmRzIGluIHRoZSBkaWN0aW9uYXJ5LlxyXG4gKlxyXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2Ygd29yZHMgaW4gdGhlIGRpY3Rpb25hcnkuXHJcbiAqL1xyXG5EaWN0aW9uYXJ5LnByb3RvdHlwZS5nZXRMZW5ndGggPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLndvcmRsaXN0ICE9IG51bGw/IHRoaXMud29yZGxpc3QubGVuZ3RoIDogMDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTZXQgdGhlIGxpc3Qgb2Ygd29yZHMgb2YgdGhlIGRpY3Rpb25hcnkuIGEgbmV3IENpcmNsZSBmcm9tIGEgZGlhbWV0ZXIuXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nW119IHdvcmRsaXN0IEEgc29ydGVkIGFycmF5IG9mIHN0cmluZ3MuXHJcbiAqL1xyXG5EaWN0aW9uYXJ5LnByb3RvdHlwZS5zZXRXb3JkbGlzdCA9IGZ1bmN0aW9uKHdvcmRsaXN0KSB7XHJcbiAgICBpZih3b3JkbGlzdCAhPSBudWxsICYmIEFycmF5LmlzQXJyYXkod29yZGxpc3QpKSB0aGlzLndvcmRsaXN0ID0gd29yZGxpc3Q7XHJcbn07XHJcblxyXG4vKipcclxuICogVmVyaWZ5IGlmIGEgd29yZCBpcyBpbiB0aGUgZGljdGlvbmFyeS5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IHdvcmQgQSBzdHJpbmcuXHJcbiAqIEByZXR1cm4ge2Jvb2x9ICd0cnVlJyBpZiB0aGUgd29yZCBpcyBpbiB0aGUgZGljdGlvbmFyeSwgJ2ZhbHNlJyBvdGhlcndpc2UuXHJcbiAqL1xyXG5EaWN0aW9uYXJ5LnByb3RvdHlwZS5zcGVsbENoZWNrID0gZnVuY3Rpb24od29yZCkge1xyXG4gICAgLy8gVmVyaWZ5IGlmIHRoZSB3b3JkIHNhdGlmaWVzIG9uZSBvZiB0aGUgcmVndWxhciBleHByZXNzaW9ucy5cclxuICAgIGZvcih2YXIgaT0wOyBpPHRoaXMucmVnZXhzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYodGhpcy5yZWdleHNbaV0udGVzdCh3b3JkKSkgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgXHJcbiAgICAvLyBTaW5jZSB0aGUgbGlzdCBpcyBzb3J0ZWQsIGlzIG1vcmUgZmFzdCB0byBkbyBhIGJpbmFyeSBzZWFyY2ggdGhhbiAndGhpcy53b3JkbGlzdC5pbmRleE9mKHdvcmQpJy5cclxuICAgIHZhciByZXMgPSBCaW5hcnlTZWFyY2goXHJcbiAgICAgICAgdGhpcy53b3JkbGlzdCwgLy8gSGF5c3RhY2tcclxuICAgICAgICB3b3JkLnRvTG93ZXJDYXNlKCksIC8vIE5lZWRsZVxyXG4gICAgICAgIENvbGxhdG9yLmNvbXBhcmUgLy8gQ29tcGFyaXNvbiBtZXRob2RcclxuICAgICk7XHJcbiAgICByZXR1cm4gcmVzID49IDA7XHJcbn07XHJcblxyXG4vKipcclxuICogVmVyaWZ5IGlmIGEgd29yZCBpcyBtaXNzcGVsbGVkLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gd29yZCBBIHN0cmluZy5cclxuICogQHJldHVybiB7Ym9vbH0gJ3RydWUnIGlmIHRoZSB3b3JkIGlzIG1pc3NwZWxsZWQsICdmYWxzZScgb3RoZXJ3aXNlLlxyXG4gKi9cclxuRGljdGlvbmFyeS5wcm90b3R5cGUuaXNNaXNzcGVsbGVkID0gZnVuY3Rpb24od29yZCkge1xyXG4gICAgcmV0dXJuICEgdGhpcy5zcGVsbENoZWNrKHdvcmQpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldCBhIGxpc3Qgb2Ygc3VnZ2VzdGlvbnMgZm9yIGEgbWlzc3BlbGxlZCB3b3JkLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gd29yZCBBIHN0cmluZy5cclxuICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IEFuIGludGVnZXIgaW5kaWNhdGluZyB0aGUgbWF4aW11bSBudW1iZXIgb2Ygc3VnZ2VzdGlvbnMgKGJ5IGRlZmF1bHQgNSkuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhEaXN0YW5jZSBBbiBpbnRlZ2VyIGluZGljYXRpbmcgdGhlIG1heGltdW0gZWRpdCBkaXN0YW5jZSBiZXR3ZWVuIHRoZSB3b3JkIGFuZCB0aGUgc3VnZ2VzdGlvbnMgKGJ5IGRlZmF1bHQgMykuXHJcbiAqIEByZXR1cm4ge3N0cmluZ1tdfSBBbiBhcnJheSBvZiBzdHJpbmdzIHdpdGggdGhlIHN1Z2dlc3Rpb25zLlxyXG4gKi9cclxuRGljdGlvbmFyeS5wcm90b3R5cGUuZ2V0U3VnZ2VzdGlvbnMgPSBmdW5jdGlvbih3b3JkLCBsaW1pdCwgbWF4RGlzdGFuY2UpIHtcclxuICAgIHZhciBzdWdnZXN0aW9ucyA9IFtdO1xyXG4gICAgaWYod29yZCAhPSBudWxsICYmIHdvcmQubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIC8vIFZhbGlkYXRlIHBhcmFtZXRlcnMuXHJcbiAgICAgICAgd29yZCA9IHdvcmQudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICBpZihsaW1pdCA9PSBudWxsIHx8IGlzTmFOKGxpbWl0KSB8fCBsaW1pdCA8PSAwKSBsaW1pdCA9IDU7XHJcbiAgICAgICAgaWYobWF4RGlzdGFuY2UgPT0gbnVsbCB8fCBpc05hTihtYXhEaXN0YW5jZSkgfHwgbWF4RGlzdGFuY2UgPD0gMCkgbWF4RGlzdGFuY2UgPSAyO1xyXG4gICAgICAgIGlmKG1heERpc3RhbmNlID49IHdvcmQubGVuZ3RoKSBtYXhEaXN0YW5jZSA9IHdvcmQubGVuZ3RoIC0gMTtcclxuICAgICAgXHJcbiAgICAgICAgLy8gU2VhcmNoIGluZGV4IG9mIGNsb3Nlc3QgaXRlbS5cclxuICAgICAgICB2YXIgY2xvc2VzdCA9IEJpbmFyeVNlYXJjaC5jbG9zZXN0KHRoaXMud29yZGxpc3QsIHdvcmQsIENvbGxhdG9yLmNvbXBhcmUpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIEluaXRpYWxpemUgdmFyaWFibGVzIGZvciBzdG9yZSByZXN1bHRzLlxyXG4gICAgICAgIHZhciByZXMgPSBbXTtcclxuICAgICAgICBmb3IodmFyIGk9MDsgaTw9bWF4RGlzdGFuY2U7IGkrKykgcmVzLnB1c2goW10pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIFNlYXJjaCBzdWdnZXN0aW9ucyBhcm91bmQgdGhlIHBvc2l0aW9uIGluIHdoaWNoIHRoZSB3b3JkIHdvdWxkIGJlIGluc2VydGVkLlxyXG4gICAgICAgIHZhciBrLCBkaXN0O1xyXG4gICAgICAgIGZvcih2YXIgaT0wOyBpPFN1Z2dlc3RSYWRpdXM7IGkrKykge1xyXG4gICAgICAgICAgICAvLyBUaGUgaW5kZXggJ2snIGlzIGdvaW5nIHRvIGJlIDAsIDEsIC0xLCAyLCAtMi4uLiBcclxuICAgICAgICAgICAgayA9IGNsb3Nlc3QgKyAoaSUyICE9IDA/ICgoaSsxKS8yKSA6ICgtaS8yKSApO1xyXG4gICAgICAgICAgICBpZihrID49MCAmJiBrIDwgdGhpcy53b3JkbGlzdC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGRpc3QgPSBFZGl0RGlzdGFuY2Uod29yZCwgdGhpcy53b3JkbGlzdFtrXS50b0xvd2VyQ2FzZSgpKTsgXHJcbiAgICAgICAgICAgICAgICBpZihkaXN0IDw9IG1heERpc3RhbmNlKSByZXNbZGlzdF0ucHVzaCh0aGlzLndvcmRsaXN0W2tdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvLyBQcmVwYXJlIHJlc3VsdC5cclxuICAgICAgICBmb3IodmFyIGQ9MDsgZDw9bWF4RGlzdGFuY2UgJiYgc3VnZ2VzdGlvbnMubGVuZ3RoIDwgbGltaXQ7IGQrKykge1xyXG4gICAgICAgICAgICB2YXIgcmVtYWluaW5nID0gbGltaXQgLSBzdWdnZXN0aW9ucy5sZW5ndGg7XHJcbiAgICAgICAgICAgIHN1Z2dlc3Rpb25zID0gc3VnZ2VzdGlvbnMuY29uY2F0KCAocmVzW2RdLmxlbmd0aCA+IHJlbWFpbmluZyk/IHJlc1tkXS5zbGljZSgwLCByZW1haW5pbmcpIDogcmVzW2RdICk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHN1Z2dlc3Rpb25zO1xyXG59XHJcblxyXG4vKipcclxuICogVmVyaWZ5IGlmIGEgd29yZCBpcyBtaXNzcGVsbGVkIGFuZCBnZXQgYSBsaXN0IG9mIHN1Z2dlc3Rpb25zLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gd29yZCBBIHN0cmluZy5cclxuICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IEFuIGludGVnZXIgaW5kaWNhdGluZyB0aGUgbWF4aW11bSBudW1iZXIgb2Ygc3VnZ2VzdGlvbnMgKGJ5IGRlZmF1bHQgNSkuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhEaXN0YW5jZSBBbiBpbnRlZ2VyIGluZGljYXRpbmcgdGhlIG1heGltdW0gZWRpdCBkaXN0YW5jZSBiZXR3ZWVuIHRoZSB3b3JkIGFuZCB0aGUgc3VnZ2VzdGlvbnMgKGJ5IGRlZmF1bHQgMykuXHJcbiAqIEByZXR1cm4ge09iamVjdH0gQW4gb2JqZWN0IHdpdGggdGhlIHByb3BlcnRpZXMgJ21pc3NwZWxsZWQnIChhIGJvb2xlYW4pIGFuZCAnc3VnZ2VzdGlvbnMnIChhbiBhcnJheSBvZiBzdHJpbmdzKS5cclxuICovXHJcbkRpY3Rpb25hcnkucHJvdG90eXBlLmNoZWNrQW5kU3VnZ2VzdCA9IGZ1bmN0aW9uKHdvcmQsIGxpbWl0LCBtYXhEaXN0YW5jZSkge1xyXG4gICAgLy8gR2V0IHN1Z2dlc3Rpb25zLlxyXG4gICAgdmFyIHN1Z2dlc3Rpb25zID0gdGhpcy5nZXRTdWdnZXN0aW9ucyh3b3JkLCBsaW1pdCsxLCBtYXhEaXN0YW5jZSk7XHJcbiAgICBcclxuICAgIC8vIFByZXBhcmUgcmVzcG9uc2UuXHJcbiAgICB2YXIgcmVzID0geydtaXNzcGVsbGVkJzogdHJ1ZSwgJ3N1Z2dlc3Rpb25zJzogW119O1xyXG4gICAgcmVzLm1pc3NwZWxsZWQgPSBzdWdnZXN0aW9ucy5sZW5ndGggPT0gMCB8fCBzdWdnZXN0aW9uc1swXS50b0xvd2VyQ2FzZSgpICE9IHdvcmQudG9Mb3dlckNhc2UoKTtcclxuICAgIHJlcy5zdWdnZXN0aW9ucyA9IHN1Z2dlc3Rpb25zO1xyXG4gICAgaWYocmVzLm1pc3NwZWxsZWQgJiYgKHN1Z2dlc3Rpb25zLmxlbmd0aCA+IGxpbWl0KSkgcmVzLnN1Z2dlc3Rpb25zID0gc3VnZ2VzdGlvbnMuc2xpY2UoMCwgbGltaXQpO1xyXG4gICAgaWYoIXJlcy5taXNzcGVsbGVkKSByZXMuc3VnZ2VzdGlvbnMgPSBzdWdnZXN0aW9ucy5zbGljZSgxLCBzdWdnZXN0aW9ucy5sZW5ndGgpO1xyXG5cclxuICAgIC8vIFZlcmlmeSBpZiB0aGUgd29yZCBzYXRpZmllcyBvbmUgb2YgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbnMuXHJcbiAgICBpZihyZXMubWlzc3BlbGxlZCkge1xyXG4gICAgICAgIGZvcih2YXIgaT0wOyBpPHRoaXMucmVnZXhzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmKHRoaXMucmVnZXhzW2ldLnRlc3Qod29yZCkpIHJlcy5taXNzcGVsbGVkID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gcmVzO1xyXG59XHJcblxyXG4vKipcclxuICogQWRkcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbiB0aGF0IHdpbGwgYmUgdXNlZCB0byB2ZXJpZnkgaWYgYSB3b3JkIGlzIHZhbGlkIGV2ZW4gdGhvdWdoIGlzIG5vdCBvbiB0aGUgZGljdGlvbmFyeS5cclxuICogVXNlZnVsIGluZGljYXRlIHRoYXQgbnVtYmVycywgVVJMcyBhbmQgZW1haWxzIHNob3VsZCBub3QgYmUgbWFya2VkIGFzIG1pc3NwZWxsZWQgd29yZHMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVnRXh9IHJlZ2V4cCBBIHJlZ3VsYXIgZXhwcmVzc2lvbi5cclxuICovXHJcbkRpY3Rpb25hcnkucHJvdG90eXBlLmFkZFJlZ2V4ID0gZnVuY3Rpb24ocmVnZXgpIHtcclxuICAgIHRoaXMucmVnZXhzLnB1c2gocmVnZXgpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENsZWFyIHRoZSBsaXN0IG9mIHJlZ3VsdGFyIGV4cHJlc3Npb25zIHVzZWQgdG8gdmVyaWZ5IGlmIGEgd29yZCBpcyB2YWxpZCBldmVuIHRob3VnaCBpcyBub3Qgb24gdGhlIGRpY3Rpb25hcnkuXHJcbiAqL1xyXG5EaWN0aW9uYXJ5LnByb3RvdHlwZS5jbGVhclJlZ2V4cyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5yZWdleHMgPSBbXTtcclxufTtcclxuXHJcbi8vIEV4cG9ydCBjbGFzcy5cclxubW9kdWxlLmV4cG9ydHMgPSBEaWN0aW9uYXJ5O1xyXG4iLCIvKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYgSm9zw6kgRi4gTWFsZG9uYWRvXHJcbiAqIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWMgTGljZW5zZSwgdi4gMi4wLiBcclxuICogSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXMgZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cclxuICovXHJcblxyXG4vLyBMb2FkIGRlcGVuZGVuY2llcy5cclxuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xyXG5jb25zdCB1bnppcCA9IHJlcXVpcmUoJ3VuemlwLXN0cmVhbScpO1xyXG5jb25zdCBzdHJpcEJPTSA9IHJlcXVpcmUoJ3N0cmlwLWJvbScpO1xyXG5jb25zdCBEaWN0aW9uYXJ5ID0gcmVxdWlyZSgnLi9kaWN0aW9uYXJ5LmpzJyk7XHJcblxyXG5jb25zdCBGT0xERVJfUEFUSCA9IF9fZGlybmFtZSArICcvZGljdCc7XHJcblxyXG4vLyBEZWZpbmUgbW9kdWxlLlxyXG52YXIgU3BlbGxDaGVja2VyID0ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYSBkaWN0aW9uYXJ5IGZyb20gYSBmaWxlLCB3aGljaCBtaWdodCBiZSBlaXRoZXIgYSAuZGljIG9yIGEgLnppcCBmaWxlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmaWxlTmFtZSBUaGUgbmFtZSBvZiB0aGUgZmlsZSBmcm9tIHdoaWNoIHJlYWQgdGhlIHdvcmQgbGlzdC5cclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmb2xkZXJQYXRoIFRoZSBwYXRoIHRvIHRoZSBkaXJlY3RvcnkgaW4gd2hpY2ggdGhlIGZpbGUgaXMgbG9jYXRlZCAob3B0aW9uYWwpLlxyXG4gICAgICogQHBhcmFtIHtDYWxsYmFja30gY2FsbGJhY2sgQSBmdW5jdGlvbiB0byBpbnZva2Ugd2hlbiBlaXRoZXIgdGhlIGRpY3Rpb25hcnkgd2FzIGNyZWF0ZWQgb3IgYW4gZXJyb3Igd2FzIGZvdW5kLlxyXG4gICAgICovXHJcbiAgICBnZXREaWN0aW9uYXJ5OiBmdW5jdGlvbihmaWxlTmFtZSwgZm9sZGVyUGF0aCAvKiwgY2FsbGJhY2sqLykge1xyXG4gICAgICAgIHRyeXtcclxuICAgICAgICAgICAgLy8gSW5pdGlhbGl6ZSB2YXJpYWJsZXMuXHJcbiAgICAgICAgICAgIHZhciBmb2xkZXIgPSAoIWZvbGRlclBhdGggfHwgdHlwZW9mIGZvbGRlclBhdGggIT0gJ3N0cmluZycpPyBGT0xERVJfUEFUSCA6IGZvbGRlclBhdGg7XHJcbiAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgIHZhciBkaWNfcGF0aCA9IGZvbGRlciArICcvJyArIGZpbGVOYW1lICsgJy5kaWMnO1xyXG4gICAgICAgICAgICB2YXIgemlwX3BhdGggPSBmb2xkZXIgKyAnLycgKyBmaWxlTmFtZSArICcuemlwJztcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIFZlcmlmeSBpZiB0aGUgZGljdGlvbmFyeSBmaWxlIGV4aXN0cy5cclxuICAgICAgICAgICAgZnMuZXhpc3RzKGRpY19wYXRoLCBmdW5jdGlvbihleGlzdHMpIHtcclxuICAgICAgICAgICAgICAgIGlmKGV4aXN0cykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBmaWxlIGV4aXN0cywgcmVhZCBpdC5cclxuICAgICAgICAgICAgICAgICAgICBTcGVsbENoZWNrZXIuX3JlYWRGaWxlKGRpY19wYXRoLCBjYWxsYmFjayk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBmaWxlIGRvIG5vdCBleGlzdHMsIHZlcmlmeSBpZiB0aGUgWklQIGZpbGUgZXhpc3RzLlxyXG4gICAgICAgICAgICAgICAgICAgIGZzLmV4aXN0cyh6aXBfcGF0aCwgZnVuY3Rpb24oZXhpc3RzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGV4aXN0cykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGZpbGUgWklQIGV4aXN0cywgdW56aXAgaXQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcy5jcmVhdGVSZWFkU3RyZWFtKHppcF9wYXRoKS5waXBlKCB1bnppcC5FeHRyYWN0KHsgcGF0aDogZm9sZGVyIH0pICkub24oJ2Nsb3NlJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGZpbGUgd2FzIGV4dHJhY3RlZCwgbm93IHJlYWQgaXQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU3BlbGxDaGVja2VyLl9yZWFkRmlsZShkaWNfcGF0aCwgY2FsbGJhY2spO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgWklQIGZpbGUgYWxzbyBkb2Vzbid0IGV4aXN0cywgcmV0dXJuIGFuIGVycm9yLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soJ1RoZSBkaWN0aW9uYXJ5IGNvdWxkIG5vdCBiZSByZWFkLCBubyBmaWxlIHdpdGggdGhlIG5hbWUgXCInICsgZmlsZU5hbWUgKyAnXCIgY291bGQgYmUgZm91bmQnLCBudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBjYXRjaChlcnIpIHtcclxuICAgICAgICAgICAgLy8gUmV0dXJuIGVycm9yLlxyXG4gICAgICAgICAgICBpZihjYWxsYmFjaykgY2FsbGJhY2soJ0FuIHVuZXhwZWN0ZWQgZXJyb3Igb2N1cnJlZDogJyArIGVyciwgbnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICBcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGEgZGljdGlvbmFyeSBmcm9tIGEgLmRpYyBmaWxlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmaWxlX3BhdGggVGhlIHBhdGggb2YgdGhlIGZpbGUuXHJcbiAgICAgKiBAcGFyYW0ge0NhbGxiYWNrfSBjYWxsYmFjayBBIGZ1bmN0aW9uIHRvIGludm9rZSB3aGVuIGVpdGhlciB0aGUgZGljdGlvbmFyeSB3YXMgY3JlYXRlZCBvciBhbiBlcnJvciB3YXMgZm91bmQuXHJcbiAgICAgKi8gIFxyXG4gICAgX3JlYWRGaWxlOiBmdW5jdGlvbihmaWxlX3BhdGgsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgZnMucmVhZEZpbGUoZmlsZV9wYXRoLCAndXRmOCcsIGZ1bmN0aW9uKGVyciwgdGV4dCkge1xyXG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgZXJyb3JzLlxyXG4gICAgICAgICAgICBpZiAoIWVycikge1xyXG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGRpY3Rpb25hcnkgYW5kIHJldHVybiBpdC5cclxuICAgICAgICAgICAgICAgIHZhciBkaWN0aW9uYXJ5ID0gbmV3IERpY3Rpb25hcnkodGV4dC5zcGxpdCgnXFxuJykpO1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgZGljdGlvbmFyeSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBSZXR1cm4gYW4gZXJyb3IuXHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhcIlRoZSBkaWN0aW9uYXJ5IGZpbGUgY291bGQgbm90IGJlIHJlYWQ6IFwiICsgZXJyLCBudWxsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxuICBcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGEgZGljdGlvbmFyeSBmcm9tIGEgLmRpYyBmaWxlIC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZmlsZU5hbWUgVGhlIG5hbWUgb2YgdGhlIGZpbGUgZnJvbSB3aGljaCByZWFkIHRoZSB3b3JkIGxpc3QuXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZm9sZGVyUGF0aCBUaGUgcGF0aCB0byB0aGUgZGlyZWN0b3J5IGluIHdoaWNoIHRoZSBmaWxlIGlzIGxvY2F0ZWQgKG9wdGlvbmFsKS5cclxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQW4gaW5zdGFuY2Ugb2YgdGhlIERpY3Rpb25hcnkgY2xhc3MuXHJcbiAgICAgKiBAdGhyb3dzIHtFeGNlcHRpb259IElmIHRoZSBkaWN0aW9uYXJ5J3MgZmlsZSBjYW4ndCBiZSBmb3VuZCBvciBpcyBpbnZhbGlkLlxyXG4gICAgICovICBcclxuICAgIGdldERpY3Rpb25hcnlTeW5jOiBmdW5jdGlvbihmaWxlTmFtZSwgZm9sZGVyUGF0aCkge1xyXG4gICAgICAgIHRyeXtcclxuICAgICAgICAgICAgLy8gSW5pdGlhbGl6ZSB2YXJpYWJsZXMuXHJcbiAgICAgICAgICAgIHZhciBmb2xkZXIgPSAoIWZvbGRlclBhdGggfHwgdHlwZW9mIGZvbGRlclBhdGggIT0gJ3N0cmluZycpPyBGT0xERVJfUEFUSCA6IGZvbGRlclBhdGg7XHJcbiAgICAgICAgICAgIHZhciBkaWNfcGF0aCA9IGZvbGRlciArICcvJyArIGZpbGVOYW1lICsgJy5kaWMnO1xyXG4gICAgICAgICAgICB2YXIgemlwX3BhdGggPSBmb2xkZXIgKyAnLycgKyBmaWxlTmFtZSArICcuemlwJztcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBWZXJpZnkgaWYgdGhlIGRpY3Rpb25hcnkgZmlsZSBleGlzdHMuXHJcbiAgICAgICAgICAgIGlmKGZzLmV4aXN0c1N5bmMoZGljX3BhdGgpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgZmlsZSBleGlzdHMsIHJlYWQgaXQuXHJcbiAgICAgICAgICAgICAgICB2YXIgdGV4dCA9IGZzLnJlYWRGaWxlU3luYyhkaWNfcGF0aCwgJ3V0ZjgnKTtcclxuICAgICAgICAgICAgICAgIHZhciBkaWN0aW9uYXJ5ID0gbmV3IERpY3Rpb25hcnkodGV4dC5zcGxpdCgnXFxuJykpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpY3Rpb25hcnk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgZmlsZSBkbyBub3QgZXhpc3RzLCB0aHJvdyBhbiBlcnJvciAob25seSB0aGUgYXN5bmNocm9ub3VzIHZlcnNpb25zIG9mIHRoaXMgbWV0aG9kIHVuemlwIHRoZSBjb21wcmVzc2VkIGZpbGVzKS5cclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGRpY3Rpb25hcnkgY291bGQgbm90IGJlIGNyZWF0ZWQsIG5vIGZpbGUgd2l0aCB0aGUgbmFtZSBcIicgKyBmaWxlTmFtZSArICdcIiBjb3VsZCBiZSBmb3VuZCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBjYXRjaChlcnIpIHtcclxuICAgICAgICAgICAgLy8gVGhyb3cgYW4gZXJyb3IuXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQW4gdW5leHBlY3RlZCBlcnJvciBvY3VycmVkOiAnICsgZXJyKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAqIFJlYWRzIGEgVVRGOCBkaWN0aW9uYXJ5IGZpbGUsIHJlbW92ZXMgdGhlIEJPTSBhbmQgXFxyIGNoYXJhY3RlcnMgYW5kIHNvcnRzIHRoZSBsaXN0IG9mIHdvcmRzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dFBhdGggVGhlIHBhdGggZm9yIHRoZSBpbnB1dCBmaWxlLlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG91dHB1dFBhdGggVGhlIHBhdGggdG8gb3V0cHV0IChvcHRpb25hbCwgYnkgZGVmYXVsdCBpcyBlcXVhbHMgdG8gdGhlIGlucHV0IGZpbGUpLlxyXG4gICAgICogQHBhcmFtIHtDYWxsYmFja30gY2FsbGJhY2sgQSBmdW5jdGlvbiB0byBpbnZva2UgYWZ0ZXIgZmluaXNoaW5nLlxyXG4gICAgICovXHJcbiAgICBub3JtYWxpemVEaWN0aW9uYXJ5OiBmdW5jdGlvbihpbnB1dFBhdGgsIG91dHB1dFBhdGggLyosIGNhbGxiYWNrKi8pIHtcclxuICAgICAgICB0cnl7XHJcbiAgICAgICAgICAgIC8vIFBhcnNlcyBhcmd1bWVudHNcclxuICAgICAgICAgICAgaWYoIW91dHB1dFBhdGggfHwgdHlwZW9mIG91dHB1dFBhdGggIT0gJ3N0cmluZycpIG91dHB1dFBhdGggPSBpbnB1dFBhdGg7XHJcbiAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3VtZW50cy5sZW5ndGggPiAwPyBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdIDogZnVuY3Rpb24oKSB7fTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIFZlcmlmeSBpZiB0aGUgZGljdGlvbmFyeSBmaWxlIGV4aXN0cy5cclxuICAgICAgICAgICAgZnMuZXhpc3RzKGlucHV0UGF0aCwgZnVuY3Rpb24oZXhpc3RzKSB7XHJcbiAgICAgICAgICAgICAgICBpZihleGlzdHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZmlsZSBleGlzdHMsIHJlYWQgaXQuXHJcbiAgICAgICAgICAgICAgICAgICAgZnMucmVhZEZpbGUoaW5wdXRQYXRoLCAndXRmOCcsIGZ1bmN0aW9uKGVyciwgY29udGVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBmb3IgZXJyb3JzLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWVycikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIEJPTSBhbmQgXFxyIGNoYXJhY3RlcnMuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50ID0gc3RyaXBCT00oY29udGVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5yZXBsYWNlKC9cXHIvZywgJycpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTb3J0IHdvcmRzLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxpbmVzID0gY29udGVudC5zcGxpdCgnXFxuJyk7ICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29sbGF0b3IgPSBuZXcgSW50bC5Db2xsYXRvcigpOyAvLyBVc2UgdGhpcyBjb21wYXJhdG9yIGZvciBjb25zaWRlciBhY2NlbnRzIGFuZCBzcGVjaWFsIGNoYXJhY3RlcnMuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lcyA9IGxpbmVzLnNvcnQoY29sbGF0b3IuY29tcGFyZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdlbmVyYXRlIG91dHB1dCBjb250ZW50LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld0NvbnRlbnQgPSAnJzsgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZpcnN0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaT0wOyBpPGxpbmVzLmxlbmd0aDsgaSsrKSB7ICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGxpbmVzW2ldICE9ICcnICYmIGxpbmVzW2ldICE9ICdcXG4nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFmaXJzdCkgbmV3Q29udGVudCArPSAnXFxuJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q29udGVudCArPSBsaW5lc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdyaXRlIG91dHB1dCBmaWxlLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnMud3JpdGVGaWxlKG91dHB1dFBhdGgsIG5ld0NvbnRlbnQsICd1dGY4JywgZnVuY3Rpb24oZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV0dXJuIHJlc3VsdC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnI/IChcIlRoZSBvdXRwdXQgZmlsZSBjb3VsZCBub3QgYmUgd3JpdHRlZDogXCIgKyBlcnIpIDogbnVsbCwgIWVycik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldHVybiBhbiBlcnJvci5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKFwiVGhlIGlucHV0IGZpbGUgY291bGQgbm90IGJlIHJlYWQ6IFwiICsgZXJyLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUmV0dXJuIGFuIGVycm9yIGluZGljYXRpbmcgdGhhdCB0aGUgZmlsZSBkb2Vucyd0IGV4aXN0cy5cclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhcIlRoZSBpbnB1dCBmaWxlIGRvZXMgbm90IGV4aXN0c1wiLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB9ICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gY2F0Y2goZXJyKSB7XHJcbiAgICAgICAgICAgIC8vIFJldHVybiBhbiBlcnJvci5cclxuICAgICAgICAgICAgY2FsbGJhY2soJ0FuIHVuZXhwZWN0ZWQgZXJyb3Igb2N1cnJlZDogJyArIGVyciwgZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuLy8gRXhwb3J0IG1vZHVsZS5cclxubW9kdWxlLmV4cG9ydHMgPSBTcGVsbENoZWNrZXI7XHJcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBzdHJpcEFuc2kgPSByZXF1aXJlKCdzdHJpcC1hbnNpJyk7XG52YXIgY29kZVBvaW50QXQgPSByZXF1aXJlKCdjb2RlLXBvaW50LWF0Jyk7XG52YXIgaXNGdWxsd2lkdGhDb2RlUG9pbnQgPSByZXF1aXJlKCdpcy1mdWxsd2lkdGgtY29kZS1wb2ludCcpO1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL2lvLmpzL2Jsb2IvY2ZmNzMwMGE1NzhiZTFiMTAwMDFmMmQ5NjdhYWVkYzg4YWVlNjQwMi9saWIvcmVhZGxpbmUuanMjTDEzNDVcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHN0cikge1xuXHRpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycgfHwgc3RyLmxlbmd0aCA9PT0gMCkge1xuXHRcdHJldHVybiAwO1xuXHR9XG5cblx0dmFyIHdpZHRoID0gMDtcblxuXHRzdHIgPSBzdHJpcEFuc2koc3RyKTtcblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBjb2RlID0gY29kZVBvaW50QXQoc3RyLCBpKTtcblxuXHRcdC8vIGlnbm9yZSBjb250cm9sIGNoYXJhY3RlcnNcblx0XHRpZiAoY29kZSA8PSAweDFmIHx8IChjb2RlID49IDB4N2YgJiYgY29kZSA8PSAweDlmKSkge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0Ly8gc3Vycm9nYXRlc1xuXHRcdGlmIChjb2RlID49IDB4MTAwMDApIHtcblx0XHRcdGkrKztcblx0XHR9XG5cblx0XHRpZiAoaXNGdWxsd2lkdGhDb2RlUG9pbnQoY29kZSkpIHtcblx0XHRcdHdpZHRoICs9IDI7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHdpZHRoKys7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHdpZHRoO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBhbnNpUmVnZXggPSByZXF1aXJlKCdhbnNpLXJlZ2V4JykoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3RyKSB7XG5cdHJldHVybiB0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyA/IHN0ci5yZXBsYWNlKGFuc2lSZWdleCwgJycpIDogc3RyO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBpc1V0ZjggPSByZXF1aXJlKCdpcy11dGY4Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHgpIHtcblx0Ly8gQ2F0Y2hlcyBFRkJCQkYgKFVURi04IEJPTSkgYmVjYXVzZSB0aGUgYnVmZmVyLXRvLXN0cmluZ1xuXHQvLyBjb252ZXJzaW9uIHRyYW5zbGF0ZXMgaXQgdG8gRkVGRiAoVVRGLTE2IEJPTSlcblx0aWYgKHR5cGVvZiB4ID09PSAnc3RyaW5nJyAmJiB4LmNoYXJDb2RlQXQoMCkgPT09IDB4RkVGRikge1xuXHRcdHJldHVybiB4LnNsaWNlKDEpO1xuXHR9XG5cblx0aWYgKEJ1ZmZlci5pc0J1ZmZlcih4KSAmJiBpc1V0ZjgoeCkgJiZcblx0XHR4WzBdID09PSAweEVGICYmIHhbMV0gPT09IDB4QkIgJiYgeFsyXSA9PT0gMHhCRikge1xuXHRcdHJldHVybiB4LnNsaWNlKDMpO1xuXHR9XG5cblx0cmV0dXJuIHg7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBUcmF2ZXJzZTtcbmZ1bmN0aW9uIFRyYXZlcnNlIChvYmopIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVHJhdmVyc2UpKSByZXR1cm4gbmV3IFRyYXZlcnNlKG9iaik7XG4gICAgdGhpcy52YWx1ZSA9IG9iajtcbn1cblxuVHJhdmVyc2UucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChwcykge1xuICAgIHZhciBub2RlID0gdGhpcy52YWx1ZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBzLmxlbmd0aDsgaSArKykge1xuICAgICAgICB2YXIga2V5ID0gcHNbaV07XG4gICAgICAgIGlmICghT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobm9kZSwga2V5KSkge1xuICAgICAgICAgICAgbm9kZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlW2tleV07XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xufTtcblxuVHJhdmVyc2UucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChwcywgdmFsdWUpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMudmFsdWU7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcy5sZW5ndGggLSAxOyBpICsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBwc1tpXTtcbiAgICAgICAgaWYgKCFPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChub2RlLCBrZXkpKSBub2RlW2tleV0gPSB7fTtcbiAgICAgICAgbm9kZSA9IG5vZGVba2V5XTtcbiAgICB9XG4gICAgbm9kZVtwc1tpXV0gPSB2YWx1ZTtcbiAgICByZXR1cm4gdmFsdWU7XG59O1xuXG5UcmF2ZXJzZS5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgcmV0dXJuIHdhbGsodGhpcy52YWx1ZSwgY2IsIHRydWUpO1xufTtcblxuVHJhdmVyc2UucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoY2IpIHtcbiAgICB0aGlzLnZhbHVlID0gd2Fsayh0aGlzLnZhbHVlLCBjYiwgZmFsc2UpO1xuICAgIHJldHVybiB0aGlzLnZhbHVlO1xufTtcblxuVHJhdmVyc2UucHJvdG90eXBlLnJlZHVjZSA9IGZ1bmN0aW9uIChjYiwgaW5pdCkge1xuICAgIHZhciBza2lwID0gYXJndW1lbnRzLmxlbmd0aCA9PT0gMTtcbiAgICB2YXIgYWNjID0gc2tpcCA/IHRoaXMudmFsdWUgOiBpbml0O1xuICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbiAoeCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNSb290IHx8ICFza2lwKSB7XG4gICAgICAgICAgICBhY2MgPSBjYi5jYWxsKHRoaXMsIGFjYywgeCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gYWNjO1xufTtcblxuVHJhdmVyc2UucHJvdG90eXBlLmRlZXBFcXVhbCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnZGVlcEVxdWFsIHJlcXVpcmVzIGV4YWN0bHkgb25lIG9iamVjdCB0byBjb21wYXJlIGFnYWluc3QnXG4gICAgICAgICk7XG4gICAgfVxuICAgIFxuICAgIHZhciBlcXVhbCA9IHRydWU7XG4gICAgdmFyIG5vZGUgPSBvYmo7XG4gICAgXG4gICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uICh5KSB7XG4gICAgICAgIHZhciBub3RFcXVhbCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBlcXVhbCA9IGZhbHNlO1xuICAgICAgICAgICAgLy90aGlzLnN0b3AoKTtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH0pLmJpbmQodGhpcyk7XG4gICAgICAgIFxuICAgICAgICAvL2lmIChub2RlID09PSB1bmRlZmluZWQgfHwgbm9kZSA9PT0gbnVsbCkgcmV0dXJuIG5vdEVxdWFsKCk7XG4gICAgICAgIFxuICAgICAgICBpZiAoIXRoaXMuaXNSb290KSB7XG4gICAgICAgIC8qXG4gICAgICAgICAgICBpZiAoIU9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG5vZGUsIHRoaXMua2V5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBub3RFcXVhbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0JykgcmV0dXJuIG5vdEVxdWFsKCk7XG4gICAgICAgICAgICBub2RlID0gbm9kZVt0aGlzLmtleV07XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHZhciB4ID0gbm9kZTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMucG9zdChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBub2RlID0geDtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICB2YXIgdG9TID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICBpZiAodGhpcy5jaXJjdWxhcikge1xuICAgICAgICAgICAgaWYgKFRyYXZlcnNlKG9iaikuZ2V0KHRoaXMuY2lyY3VsYXIucGF0aCkgIT09IHgpIG5vdEVxdWFsKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHggIT09IHR5cGVvZiB5KSB7XG4gICAgICAgICAgICBub3RFcXVhbCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHggPT09IG51bGwgfHwgeSA9PT0gbnVsbCB8fCB4ID09PSB1bmRlZmluZWQgfHwgeSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoeCAhPT0geSkgbm90RXF1YWwoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh4Ll9fcHJvdG9fXyAhPT0geS5fX3Byb3RvX18pIHtcbiAgICAgICAgICAgIG5vdEVxdWFsKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoeCA9PT0geSkge1xuICAgICAgICAgICAgLy8gbm9wXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGlmICh4IGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgICAgICAgICAgLy8gYm90aCByZWdleHBzIG9uIGFjY291bnQgb2YgdGhlIF9fcHJvdG9fXyBjaGVja1xuICAgICAgICAgICAgICAgIGlmICh4LnRvU3RyaW5nKCkgIT0geS50b1N0cmluZygpKSBub3RFcXVhbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoeCAhPT0geSkgbm90RXF1YWwoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgeCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGlmICh0b1MoeSkgPT09ICdbb2JqZWN0IEFyZ3VtZW50c10nXG4gICAgICAgICAgICB8fCB0b1MoeCkgPT09ICdbb2JqZWN0IEFyZ3VtZW50c10nKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRvUyh4KSAhPT0gdG9TKHkpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vdEVxdWFsKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoeCBpbnN0YW5jZW9mIERhdGUgfHwgeSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoISh4IGluc3RhbmNlb2YgRGF0ZSkgfHwgISh5IGluc3RhbmNlb2YgRGF0ZSlcbiAgICAgICAgICAgICAgICB8fCB4LmdldFRpbWUoKSAhPT0geS5nZXRUaW1lKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbm90RXF1YWwoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIga3ggPSBPYmplY3Qua2V5cyh4KTtcbiAgICAgICAgICAgICAgICB2YXIga3kgPSBPYmplY3Qua2V5cyh5KTtcbiAgICAgICAgICAgICAgICBpZiAoa3gubGVuZ3RoICE9PSBreS5sZW5ndGgpIHJldHVybiBub3RFcXVhbCgpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga3gubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGsgPSBreFtpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbCh5LCBrKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm90RXF1YWwoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIHJldHVybiBlcXVhbDtcbn07XG5cblRyYXZlcnNlLnByb3RvdHlwZS5wYXRocyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYWNjID0gW107XG4gICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIGFjYy5wdXNoKHRoaXMucGF0aCk7IFxuICAgIH0pO1xuICAgIHJldHVybiBhY2M7XG59O1xuXG5UcmF2ZXJzZS5wcm90b3R5cGUubm9kZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFjYyA9IFtdO1xuICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbiAoeCkge1xuICAgICAgICBhY2MucHVzaCh0aGlzLm5vZGUpO1xuICAgIH0pO1xuICAgIHJldHVybiBhY2M7XG59O1xuXG5UcmF2ZXJzZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBhcmVudHMgPSBbXSwgbm9kZXMgPSBbXTtcbiAgICBcbiAgICByZXR1cm4gKGZ1bmN0aW9uIGNsb25lIChzcmMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAocGFyZW50c1tpXSA9PT0gc3JjKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGVzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAodHlwZW9mIHNyYyA9PT0gJ29iamVjdCcgJiYgc3JjICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgZHN0ID0gY29weShzcmMpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBwYXJlbnRzLnB1c2goc3JjKTtcbiAgICAgICAgICAgIG5vZGVzLnB1c2goZHN0KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgT2JqZWN0LmtleXMoc3JjKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICBkc3Rba2V5XSA9IGNsb25lKHNyY1trZXldKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBwYXJlbnRzLnBvcCgpO1xuICAgICAgICAgICAgbm9kZXMucG9wKCk7XG4gICAgICAgICAgICByZXR1cm4gZHN0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHNyYztcbiAgICAgICAgfVxuICAgIH0pKHRoaXMudmFsdWUpO1xufTtcblxuZnVuY3Rpb24gd2FsayAocm9vdCwgY2IsIGltbXV0YWJsZSkge1xuICAgIHZhciBwYXRoID0gW107XG4gICAgdmFyIHBhcmVudHMgPSBbXTtcbiAgICB2YXIgYWxpdmUgPSB0cnVlO1xuICAgIFxuICAgIHJldHVybiAoZnVuY3Rpb24gd2Fsa2VyIChub2RlXykge1xuICAgICAgICB2YXIgbm9kZSA9IGltbXV0YWJsZSA/IGNvcHkobm9kZV8pIDogbm9kZV87XG4gICAgICAgIHZhciBtb2RpZmllcnMgPSB7fTtcbiAgICAgICAgXG4gICAgICAgIHZhciBzdGF0ZSA9IHtcbiAgICAgICAgICAgIG5vZGUgOiBub2RlLFxuICAgICAgICAgICAgbm9kZV8gOiBub2RlXyxcbiAgICAgICAgICAgIHBhdGggOiBbXS5jb25jYXQocGF0aCksXG4gICAgICAgICAgICBwYXJlbnQgOiBwYXJlbnRzLnNsaWNlKC0xKVswXSxcbiAgICAgICAgICAgIGtleSA6IHBhdGguc2xpY2UoLTEpWzBdLFxuICAgICAgICAgICAgaXNSb290IDogcGF0aC5sZW5ndGggPT09IDAsXG4gICAgICAgICAgICBsZXZlbCA6IHBhdGgubGVuZ3RoLFxuICAgICAgICAgICAgY2lyY3VsYXIgOiBudWxsLFxuICAgICAgICAgICAgdXBkYXRlIDogZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXN0YXRlLmlzUm9vdCkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5wYXJlbnQubm9kZVtzdGF0ZS5rZXldID0geDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhdGUubm9kZSA9IHg7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2RlbGV0ZScgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHN0YXRlLnBhcmVudC5ub2RlW3N0YXRlLmtleV07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVtb3ZlIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHN0YXRlLnBhcmVudC5ub2RlKSkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5wYXJlbnQubm9kZS5zcGxpY2Uoc3RhdGUua2V5LCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzdGF0ZS5wYXJlbnQubm9kZVtzdGF0ZS5rZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBiZWZvcmUgOiBmdW5jdGlvbiAoZikgeyBtb2RpZmllcnMuYmVmb3JlID0gZiB9LFxuICAgICAgICAgICAgYWZ0ZXIgOiBmdW5jdGlvbiAoZikgeyBtb2RpZmllcnMuYWZ0ZXIgPSBmIH0sXG4gICAgICAgICAgICBwcmUgOiBmdW5jdGlvbiAoZikgeyBtb2RpZmllcnMucHJlID0gZiB9LFxuICAgICAgICAgICAgcG9zdCA6IGZ1bmN0aW9uIChmKSB7IG1vZGlmaWVycy5wb3N0ID0gZiB9LFxuICAgICAgICAgICAgc3RvcCA6IGZ1bmN0aW9uICgpIHsgYWxpdmUgPSBmYWxzZSB9XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICBpZiAoIWFsaXZlKSByZXR1cm4gc3RhdGU7XG4gICAgICAgIFxuICAgICAgICBpZiAodHlwZW9mIG5vZGUgPT09ICdvYmplY3QnICYmIG5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHN0YXRlLmlzTGVhZiA9IE9iamVjdC5rZXlzKG5vZGUpLmxlbmd0aCA9PSAwO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50c1tpXS5ub2RlXyA9PT0gbm9kZV8pIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuY2lyY3VsYXIgPSBwYXJlbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGF0ZS5pc0xlYWYgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBzdGF0ZS5ub3RMZWFmID0gIXN0YXRlLmlzTGVhZjtcbiAgICAgICAgc3RhdGUubm90Um9vdCA9ICFzdGF0ZS5pc1Jvb3Q7XG4gICAgICAgIFxuICAgICAgICAvLyB1c2UgcmV0dXJuIHZhbHVlcyB0byB1cGRhdGUgaWYgZGVmaW5lZFxuICAgICAgICB2YXIgcmV0ID0gY2IuY2FsbChzdGF0ZSwgc3RhdGUubm9kZSk7XG4gICAgICAgIGlmIChyZXQgIT09IHVuZGVmaW5lZCAmJiBzdGF0ZS51cGRhdGUpIHN0YXRlLnVwZGF0ZShyZXQpO1xuICAgICAgICBpZiAobW9kaWZpZXJzLmJlZm9yZSkgbW9kaWZpZXJzLmJlZm9yZS5jYWxsKHN0YXRlLCBzdGF0ZS5ub2RlKTtcbiAgICAgICAgXG4gICAgICAgIGlmICh0eXBlb2Ygc3RhdGUubm9kZSA9PSAnb2JqZWN0J1xuICAgICAgICAmJiBzdGF0ZS5ub2RlICE9PSBudWxsICYmICFzdGF0ZS5jaXJjdWxhcikge1xuICAgICAgICAgICAgcGFyZW50cy5wdXNoKHN0YXRlKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhzdGF0ZS5ub2RlKTtcbiAgICAgICAgICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5LCBpKSB7XG4gICAgICAgICAgICAgICAgcGF0aC5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKG1vZGlmaWVycy5wcmUpIG1vZGlmaWVycy5wcmUuY2FsbChzdGF0ZSwgc3RhdGUubm9kZVtrZXldLCBrZXkpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IHdhbGtlcihzdGF0ZS5ub2RlW2tleV0pO1xuICAgICAgICAgICAgICAgIGlmIChpbW11dGFibGUgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoc3RhdGUubm9kZSwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5ub2RlW2tleV0gPSBjaGlsZC5ub2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBjaGlsZC5pc0xhc3QgPSBpID09IGtleXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICBjaGlsZC5pc0ZpcnN0ID0gaSA9PSAwO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmIChtb2RpZmllcnMucG9zdCkgbW9kaWZpZXJzLnBvc3QuY2FsbChzdGF0ZSwgY2hpbGQpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHBhdGgucG9wKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHBhcmVudHMucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmIChtb2RpZmllcnMuYWZ0ZXIpIG1vZGlmaWVycy5hZnRlci5jYWxsKHN0YXRlLCBzdGF0ZS5ub2RlKTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9KShyb290KS5ub2RlO1xufVxuXG5PYmplY3Qua2V5cyhUcmF2ZXJzZS5wcm90b3R5cGUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIFRyYXZlcnNlW2tleV0gPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICB2YXIgdCA9IFRyYXZlcnNlKG9iaik7XG4gICAgICAgIHJldHVybiB0W2tleV0uYXBwbHkodCwgYXJncyk7XG4gICAgfTtcbn0pO1xuXG5mdW5jdGlvbiBjb3B5IChzcmMpIHtcbiAgICBpZiAodHlwZW9mIHNyYyA9PT0gJ29iamVjdCcgJiYgc3JjICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBkc3Q7XG4gICAgICAgIFxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzcmMpKSB7XG4gICAgICAgICAgICBkc3QgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzcmMgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICBkc3QgPSBuZXcgRGF0ZShzcmMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNyYyBpbnN0YW5jZW9mIEJvb2xlYW4pIHtcbiAgICAgICAgICAgIGRzdCA9IG5ldyBCb29sZWFuKHNyYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3JjIGluc3RhbmNlb2YgTnVtYmVyKSB7XG4gICAgICAgICAgICBkc3QgPSBuZXcgTnVtYmVyKHNyYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3JjIGluc3RhbmNlb2YgU3RyaW5nKSB7XG4gICAgICAgICAgICBkc3QgPSBuZXcgU3RyaW5nKHNyYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkc3QgPSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZihzcmMpKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgT2JqZWN0LmtleXMoc3JjKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGRzdFtrZXldID0gc3JjW2tleV07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZHN0O1xuICAgIH1cbiAgICBlbHNlIHJldHVybiBzcmM7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGhvbWUgPSByZXF1aXJlKCdvcycpLmhvbWVkaXIoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBzdHIgPT4ge1xuXHRpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBhIHN0cmluZywgZ290ICR7dHlwZW9mIHN0cn1gKTtcblx0fVxuXG5cdHJldHVybiBob21lID8gc3RyLnJlcGxhY2UoL15+KD89JHxcXC98XFxcXCkvLCBob21lKSA6IHN0cjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBzdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ3V0aWwnKS5pbmhlcml0cztcblxuZnVuY3Rpb24gRW50cnkoKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEVudHJ5KSkge1xuICAgICAgICByZXR1cm4gbmV3IEVudHJ5KCk7XG4gICAgfVxuXG4gICAgc3RyZWFtLlBhc3NUaHJvdWdoLmNhbGwodGhpcyk7XG5cbiAgICB0aGlzLnBhdGggPSBudWxsO1xuICAgIHRoaXMudHlwZSA9IG51bGw7XG4gICAgdGhpcy5pc0RpcmVjdG9yeSA9IGZhbHNlO1xufVxuXG5pbmhlcml0cyhFbnRyeSwgc3RyZWFtLlBhc3NUaHJvdWdoKTtcblxuRW50cnkucHJvdG90eXBlLmF1dG9kcmFpbiA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5waXBlKG5ldyBzdHJlYW0uVHJhbnNmb3JtKHsgdHJhbnNmb3JtOiBmdW5jdGlvbiAoZCwgZSwgY2IpIHsgY2IoKTsgfSB9KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRW50cnk7IiwidmFyIGZzID0gcmVxdWlyZSgnZnMnKTtcbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgbWtkaXJwID0gcmVxdWlyZSgnbWtkaXJwJyk7XG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnc3RyZWFtJykuVHJhbnNmb3JtO1xudmFyIFVuemlwU3RyZWFtID0gcmVxdWlyZSgnLi91bnppcC1zdHJlYW0nKTtcblxuZnVuY3Rpb24gRXh0cmFjdCAob3B0cykge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBFeHRyYWN0KSlcbiAgICByZXR1cm4gbmV3IEV4dHJhY3Qob3B0cyk7XG5cbiAgICBUcmFuc2Zvcm0uY2FsbCh0aGlzKTtcblxuICAgIHRoaXMub3B0cyA9IG9wdHMgfHwge307XG4gICAgdGhpcy51bnppcFN0cmVhbSA9IG5ldyBVbnppcFN0cmVhbSgpO1xuICAgIHRoaXMudW5maW5pc2hlZEVudHJpZXMgPSAwO1xuICAgIHRoaXMuYWZ0ZXJGbHVzaFdhaXQgPSBmYWxzZTtcbiAgICB0aGlzLmNyZWF0ZWREaXJlY3RvcmllcyA9IHt9O1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMudW56aXBTdHJlYW0ub24oJ2VudHJ5JywgdGhpcy5fcHJvY2Vzc0VudHJ5LmJpbmQodGhpcykpO1xuICAgIHRoaXMudW56aXBTdHJlYW0ub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgc2VsZi5lbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgICB9KTtcbn1cblxudXRpbC5pbmhlcml0cyhFeHRyYWN0LCBUcmFuc2Zvcm0pO1xuXG5FeHRyYWN0LnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgICB0aGlzLnVuemlwU3RyZWFtLndyaXRlKGNodW5rLCBlbmNvZGluZywgY2IpO1xufVxuXG5FeHRyYWN0LnByb3RvdHlwZS5fZmx1c2ggPSBmdW5jdGlvbiAoY2IpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB2YXIgYWxsRG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkgeyBzZWxmLmVtaXQoJ2Nsb3NlJyk7IH0pO1xuICAgICAgICBjYigpO1xuICAgIH1cblxuICAgIHRoaXMudW56aXBTdHJlYW0uZW5kKGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoc2VsZi51bmZpbmlzaGVkRW50cmllcyA+IDApIHtcbiAgICAgICAgICAgIHNlbGYuYWZ0ZXJGbHVzaFdhaXQgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYub24oJ2F3YWl0LWZpbmlzaGVkJywgYWxsRG9uZSk7XG4gICAgICAgIH1cbiAgICAgICAgYWxsRG9uZSgpO1xuICAgIH0pO1xufVxuXG5FeHRyYWN0LnByb3RvdHlwZS5fcHJvY2Vzc0VudHJ5ID0gZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBkZXN0UGF0aCA9IHBhdGguam9pbih0aGlzLm9wdHMucGF0aCwgZW50cnkucGF0aCk7XG4gICAgdmFyIGRpcmVjdG9yeSA9IGVudHJ5LmlzRGlyZWN0b3J5ID8gZGVzdFBhdGggOiBwYXRoLmRpcm5hbWUoZGVzdFBhdGgpO1xuXG4gICAgdGhpcy51bmZpbmlzaGVkRW50cmllcysrO1xuXG4gICAgdmFyIHdyaXRlRmlsZUZuID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwaXBlZFN0cmVhbSA9IGZzLmNyZWF0ZVdyaXRlU3RyZWFtKGRlc3RQYXRoKTtcblxuICAgICAgICBwaXBlZFN0cmVhbS5vbignY2xvc2UnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlbGYudW5maW5pc2hlZEVudHJpZXMtLTtcbiAgICAgICAgICAgIHNlbGYuX25vdGlmeUF3YWl0ZXIoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHBpcGVkU3RyZWFtLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgc2VsZi5lbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGVudHJ5LnBpcGUocGlwZWRTdHJlYW0pO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmNyZWF0ZWREaXJlY3Rvcmllc1tkaXJlY3RvcnldIHx8IGRpcmVjdG9yeSA9PT0gJy4nKSB7XG4gICAgICAgIHJldHVybiB3cml0ZUZpbGVGbigpO1xuICAgIH1cblxuICAgIC8vIEZJWE1FOiBjYWxscyB0byBta2RpcnAgY2FuIHN0aWxsIGJlIGR1cGxpY2F0ZWRcbiAgICBta2RpcnAoZGlyZWN0b3J5LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpO1xuXG4gICAgICAgIHNlbGYuY3JlYXRlZERpcmVjdG9yaWVzW2RpcmVjdG9yeV0gPSB0cnVlO1xuXG4gICAgICAgIGlmIChlbnRyeS5pc0RpcmVjdG9yeSkge1xuICAgICAgICAgICAgc2VsZi51bmZpbmlzaGVkRW50cmllcy0tO1xuICAgICAgICAgICAgc2VsZi5fbm90aWZ5QXdhaXRlcigpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgd3JpdGVGaWxlRm4oKTtcbiAgICB9KTtcbn1cblxuRXh0cmFjdC5wcm90b3R5cGUuX25vdGlmeUF3YWl0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5hZnRlckZsdXNoV2FpdCAmJiB0aGlzLnVuZmluaXNoZWRFbnRyaWVzID09PSAwKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnYXdhaXQtZmluaXNoZWQnKTtcbiAgICAgICAgdGhpcy5hZnRlckZsdXNoV2FpdCA9IGZhbHNlO1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBFeHRyYWN0OyIsInZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCdzdHJlYW0nKS5UcmFuc2Zvcm07XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuZnVuY3Rpb24gTWF0Y2hlclN0cmVhbShwYXR0ZXJuRGVzYywgbWF0Y2hGbikge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBNYXRjaGVyU3RyZWFtKSkge1xuICAgICAgICByZXR1cm4gbmV3IE1hdGNoZXJTdHJlYW0oKTtcbiAgICB9XG5cbiAgICBUcmFuc2Zvcm0uY2FsbCh0aGlzKTtcblxuICAgIHZhciBwID0gdHlwZW9mIHBhdHRlcm5EZXNjID09PSAnb2JqZWN0JyA/IHBhdHRlcm5EZXNjLnBhdHRlcm4gOiBwYXR0ZXJuRGVzYztcblxuICAgIHRoaXMucGF0dGVybiA9IEJ1ZmZlci5pc0J1ZmZlcihwKSA/IHAgOiBCdWZmZXIuZnJvbShwKTtcbiAgICB0aGlzLnJlcXVpcmVkTGVuZ3RoID0gdGhpcy5wYXR0ZXJuLmxlbmd0aDtcbiAgICBpZiAocGF0dGVybkRlc2MucmVxdWlyZWRFeHRyYVNpemUpIHRoaXMucmVxdWlyZWRMZW5ndGggKz0gcGF0dGVybkRlc2MucmVxdWlyZWRFeHRyYVNpemU7XG5cbiAgICB0aGlzLmRhdGEgPSBuZXcgQnVmZmVyKCcnKTtcbiAgICB0aGlzLmJ5dGVzU29GYXIgPSAwO1xuXG4gICAgdGhpcy5tYXRjaEZuID0gbWF0Y2hGbjtcbn1cblxudXRpbC5pbmhlcml0cyhNYXRjaGVyU3RyZWFtLCBUcmFuc2Zvcm0pO1xuXG5NYXRjaGVyU3RyZWFtLnByb3RvdHlwZS5jaGVja0RhdGFDaHVuayA9IGZ1bmN0aW9uIChpZ25vcmVNYXRjaFplcm8pIHtcbiAgICB2YXIgZW5vdWdoRGF0YSA9IHRoaXMuZGF0YS5sZW5ndGggPj0gdGhpcy5yZXF1aXJlZExlbmd0aDsgLy8gc3RyaWN0IG1vcmUgdGhhbiA/XG4gICAgaWYgKCFlbm91Z2hEYXRhKSB7IHJldHVybjsgfVxuXG4gICAgdmFyIG1hdGNoSW5kZXggPSB0aGlzLmRhdGEuaW5kZXhPZih0aGlzLnBhdHRlcm4sIGlnbm9yZU1hdGNoWmVybyA/IDEgOiAwKTtcbiAgICBpZiAobWF0Y2hJbmRleCA+PSAwICYmIG1hdGNoSW5kZXggKyB0aGlzLnJlcXVpcmVkTGVuZ3RoID4gdGhpcy5kYXRhLmxlbmd0aCkge1xuICAgICAgICBpZiAobWF0Y2hJbmRleCA+IDApIHtcbiAgICAgICAgICAgIHZhciBwYWNrZXQgPSB0aGlzLmRhdGEuc2xpY2UoMCwgbWF0Y2hJbmRleCk7XG4gICAgICAgICAgICB0aGlzLnB1c2gocGFja2V0KTtcbiAgICAgICAgICAgIHRoaXMuYnl0ZXNTb0ZhciArPSBtYXRjaEluZGV4O1xuICAgICAgICAgICAgdGhpcy5kYXRhID0gdGhpcy5kYXRhLnNsaWNlKG1hdGNoSW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobWF0Y2hJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgdmFyIHBhY2tldExlbiA9IHRoaXMuZGF0YS5sZW5ndGggLSB0aGlzLnJlcXVpcmVkTGVuZ3RoICsgMTtcblxuICAgICAgICB2YXIgcGFja2V0ID0gdGhpcy5kYXRhLnNsaWNlKDAsIHBhY2tldExlbik7XG4gICAgICAgIHRoaXMucHVzaChwYWNrZXQpO1xuICAgICAgICB0aGlzLmJ5dGVzU29GYXIgKz0gcGFja2V0TGVuO1xuICAgICAgICB0aGlzLmRhdGEgPSB0aGlzLmRhdGEuc2xpY2UocGFja2V0TGVuKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGZvdW5kIG1hdGNoXG4gICAgaWYgKG1hdGNoSW5kZXggPiAwKSB7XG4gICAgICAgIHZhciBwYWNrZXQgPSB0aGlzLmRhdGEuc2xpY2UoMCwgbWF0Y2hJbmRleCk7XG4gICAgICAgIHRoaXMuZGF0YSA9IHRoaXMuZGF0YS5zbGljZShtYXRjaEluZGV4KTtcbiAgICAgICAgdGhpcy5wdXNoKHBhY2tldCk7XG4gICAgICAgIHRoaXMuYnl0ZXNTb0ZhciArPSBtYXRjaEluZGV4O1xuICAgIH1cblxuICAgIHZhciBmaW5pc2hlZCA9IHRoaXMubWF0Y2hGbiA/IHRoaXMubWF0Y2hGbih0aGlzLmRhdGEsIHRoaXMuYnl0ZXNTb0ZhcikgOiB0cnVlO1xuICAgIGlmIChmaW5pc2hlZCkge1xuICAgICAgICB0aGlzLmRhdGEgPSBuZXcgQnVmZmVyKCcnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufVxuXG5NYXRjaGVyU3RyZWFtLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgICB0aGlzLmRhdGEgPSBCdWZmZXIuY29uY2F0KFt0aGlzLmRhdGEsIGNodW5rXSk7XG5cbiAgICB2YXIgZmlyc3RJdGVyYXRpb24gPSB0cnVlO1xuICAgIHdoaWxlICh0aGlzLmNoZWNrRGF0YUNodW5rKCFmaXJzdEl0ZXJhdGlvbikpIHtcbiAgICAgICAgZmlyc3RJdGVyYXRpb24gPSBmYWxzZTtcbiAgICB9XG5cbiAgICBjYigpO1xufVxuXG5NYXRjaGVyU3RyZWFtLnByb3RvdHlwZS5fZmx1c2ggPSBmdW5jdGlvbiAoY2IpIHtcbiAgICBpZiAodGhpcy5kYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIGZpcnN0SXRlcmF0aW9uID0gdHJ1ZTtcbiAgICAgICAgd2hpbGUgKHRoaXMuY2hlY2tEYXRhQ2h1bmsoIWZpcnN0SXRlcmF0aW9uKSkge1xuICAgICAgICAgICAgZmlyc3RJdGVyYXRpb24gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmRhdGEubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLnB1c2godGhpcy5kYXRhKTtcbiAgICAgICAgdGhpcy5kYXRhID0gbnVsbDtcbiAgICB9XG5cbiAgICBjYigpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE1hdGNoZXJTdHJlYW07IiwidmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJ3N0cmVhbScpLlRyYW5zZm9ybTtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIFVuemlwU3RyZWFtID0gcmVxdWlyZSgnLi91bnppcC1zdHJlYW0nKTtcblxuZnVuY3Rpb24gUGFyc2VyU3RyZWFtKG9wdHMpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUGFyc2VyU3RyZWFtKSkge1xuICAgICAgICByZXR1cm4gbmV3IFBhcnNlclN0cmVhbShvcHRzKTtcbiAgICB9XG5cbiAgICB2YXIgdHJhbnNmb3JtT3B0cyA9IG9wdHMgfHwge307XG4gICAgVHJhbnNmb3JtLmNhbGwodGhpcywgeyByZWFkYWJsZU9iamVjdE1vZGU6IHRydWUgfSk7XG5cbiAgICB0aGlzLm9wdHMgPSBvcHRzIHx8IHt9O1xuICAgIHRoaXMudW56aXBTdHJlYW0gPSBuZXcgVW56aXBTdHJlYW0odGhpcy5vcHRzKTtcblxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLnVuemlwU3RyZWFtLm9uKCdlbnRyeScsIGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgICAgIHNlbGYucHVzaChlbnRyeSk7XG4gICAgfSk7XG4gICAgdGhpcy51bnppcFN0cmVhbS5vbignZXJyb3InLCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyb3IpO1xuICAgIH0pO1xufVxuXG51dGlsLmluaGVyaXRzKFBhcnNlclN0cmVhbSwgVHJhbnNmb3JtKTtcblxuUGFyc2VyU3RyZWFtLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgICB0aGlzLnVuemlwU3RyZWFtLndyaXRlKGNodW5rLCBlbmNvZGluZywgY2IpO1xufVxuXG5QYXJzZXJTdHJlYW0ucHJvdG90eXBlLl9mbHVzaCA9IGZ1bmN0aW9uIChjYikge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLnVuemlwU3RyZWFtLmVuZChmdW5jdGlvbigpIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHsgc2VsZi5lbWl0KCdjbG9zZScpOyB9KTtcbiAgICAgICAgY2IoKTtcbiAgICB9KTtcbn1cblxuUGFyc2VyU3RyZWFtLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKGV2ZW50TmFtZSwgZm4pIHtcbiAgICBpZiAoZXZlbnROYW1lID09PSAnZW50cnknKSB7XG4gICAgICAgIHJldHVybiBUcmFuc2Zvcm0ucHJvdG90eXBlLm9uLmNhbGwodGhpcywgJ2RhdGEnLCBmbik7XG4gICAgfVxuICAgIHJldHVybiBUcmFuc2Zvcm0ucHJvdG90eXBlLm9uLmNhbGwodGhpcywgZXZlbnROYW1lLCBmbik7XG59XG5cblBhcnNlclN0cmVhbS5wcm90b3R5cGUuZHJhaW5BbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy51bnppcFN0cmVhbS5kcmFpbkFsbCgpO1xuICAgIHJldHVybiB0aGlzLnBpcGUobmV3IFRyYW5zZm9ybSh7IG9iamVjdE1vZGU6IHRydWUsIHRyYW5zZm9ybTogZnVuY3Rpb24gKGQsIGUsIGNiKSB7IGNiKCk7IH0gfSkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFBhcnNlclN0cmVhbTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGJpbmFyeSA9IHJlcXVpcmUoJ2JpbmFyeScpO1xudmFyIHN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgemxpYiA9IHJlcXVpcmUoJ3psaWInKTtcbnZhciBNYXRjaGVyU3RyZWFtID0gcmVxdWlyZSgnLi9tYXRjaGVyLXN0cmVhbScpO1xudmFyIEVudHJ5ID0gcmVxdWlyZSgnLi9lbnRyeScpO1xuXG5jb25zdCBzdGF0ZXMgPSB7XG4gICAgU1RSRUFNX1NUQVJUOiAgICAgICAgICAgICAgICAgICAgICAgICAwLFxuICAgIFNUQVJUOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMSxcbiAgICBMT0NBTF9GSUxFX0hFQURFUjogICAgICAgICAgICAgICAgICAgIDIsXG4gICAgTE9DQUxfRklMRV9IRUFERVJfU1VGRklYOiAgICAgICAgICAgICAzLFxuICAgIEZJTEVfREFUQTogICAgICAgICAgICAgICAgICAgICAgICAgICAgNCxcbiAgICBGSUxFX0RBVEFfRU5EOiAgICAgICAgICAgICAgICAgICAgICAgIDUsXG4gICAgREFUQV9ERVNDUklQVE9SOiAgICAgICAgICAgICAgICAgICAgICA2LFxuICAgIENFTlRSQUxfRElSRUNUT1JZX0ZJTEVfSEVBREVSOiAgICAgICAgNyxcbiAgICBDRU5UUkFMX0RJUkVDVE9SWV9GSUxFX0hFQURFUl9TVUZGSVg6IDgsXG4gICAgQ0RJUjY0X0VORDogICAgICAgICAgICAgICAgICAgICAgICAgICA5LFxuICAgIENESVI2NF9FTkRfREFUQV9TRUNUT1I6ICAgICAgICAgICAgICAgMTAsXG4gICAgQ0RJUjY0X0xPQ0FUT1I6ICAgICAgICAgICAgICAgICAgICAgICAxMSxcbiAgICBDRU5UUkFMX0RJUkVDVE9SWV9FTkQ6ICAgICAgICAgICAgICAgIDEyLFxuICAgIENFTlRSQUxfRElSRUNUT1JZX0VORF9DT01NRU5UOiAgICAgICAgMTMsXG4gICAgVFJBSUxJTkdfSlVOSzogICAgICAgICAgICAgICAgICAgICAgICAxNCxcblxuICAgIEVSUk9SOiA5OVxufVxuXG5jb25zdCBGT1VSX0dJR1MgPSA0Mjk0OTY3Mjk2O1xuXG5jb25zdCBTSUdfTE9DQUxfRklMRV9IRUFERVIgID0gMHgwNDAzNGI1MDtcbmNvbnN0IFNJR19EQVRBX0RFU0NSSVBUT1IgICAgPSAweDA4MDc0YjUwO1xuY29uc3QgU0lHX0NESVJfUkVDT1JEICAgICAgICA9IDB4MDIwMTRiNTA7XG5jb25zdCBTSUdfQ0RJUjY0X1JFQ09SRF9FTkQgID0gMHgwNjA2NGI1MDtcbmNvbnN0IFNJR19DRElSNjRfTE9DQVRPUl9FTkQgPSAweDA3MDY0YjUwO1xuY29uc3QgU0lHX0NESVJfUkVDT1JEX0VORCAgICA9IDB4MDYwNTRiNTA7XG5cbmZ1bmN0aW9uIFVuemlwU3RyZWFtKG9wdGlvbnMpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVW56aXBTdHJlYW0pKSB7XG4gICAgICAgIHJldHVybiBuZXcgVW56aXBTdHJlYW0ob3B0aW9ucyk7XG4gICAgfVxuXG4gICAgc3RyZWFtLlRyYW5zZm9ybS5jYWxsKHRoaXMpO1xuXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB0aGlzLmRhdGEgPSBuZXcgQnVmZmVyKCcnKTtcbiAgICB0aGlzLnN0YXRlID0gc3RhdGVzLlNUUkVBTV9TVEFSVDtcbiAgICB0aGlzLnNraXBwZWRCeXRlcyA9IDA7XG4gICAgdGhpcy5wYXJzZWRFbnRpdHkgPSBudWxsO1xuICAgIHRoaXMub3V0U3RyZWFtSW5mbyA9IHt9O1xufVxuXG51dGlsLmluaGVyaXRzKFVuemlwU3RyZWFtLCBzdHJlYW0uVHJhbnNmb3JtKTtcblxuVW56aXBTdHJlYW0ucHJvdG90eXBlLnByb2Nlc3NEYXRhQ2h1bmsgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICB2YXIgcmVxdWlyZWRMZW5ndGg7XG5cbiAgICBzd2l0Y2ggKHRoaXMuc3RhdGUpIHtcbiAgICAgICAgY2FzZSBzdGF0ZXMuU1RSRUFNX1NUQVJUOlxuICAgICAgICBjYXNlIHN0YXRlcy5TVEFSVDpcbiAgICAgICAgICAgIHJlcXVpcmVkTGVuZ3RoID0gNDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHN0YXRlcy5MT0NBTF9GSUxFX0hFQURFUjpcbiAgICAgICAgICAgIHJlcXVpcmVkTGVuZ3RoID0gMjY7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBzdGF0ZXMuTE9DQUxfRklMRV9IRUFERVJfU1VGRklYOlxuICAgICAgICAgICAgcmVxdWlyZWRMZW5ndGggPSB0aGlzLnBhcnNlZEVudGl0eS5maWxlTmFtZUxlbmd0aCArIHRoaXMucGFyc2VkRW50aXR5LmV4dHJhRmllbGRMZW5ndGg7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBzdGF0ZXMuREFUQV9ERVNDUklQVE9SOlxuICAgICAgICAgICAgcmVxdWlyZWRMZW5ndGggPSAxMjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHN0YXRlcy5DRU5UUkFMX0RJUkVDVE9SWV9GSUxFX0hFQURFUjpcbiAgICAgICAgICAgIHJlcXVpcmVkTGVuZ3RoID0gNDI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBzdGF0ZXMuQ0VOVFJBTF9ESVJFQ1RPUllfRklMRV9IRUFERVJfU1VGRklYOlxuICAgICAgICAgICAgcmVxdWlyZWRMZW5ndGggPSB0aGlzLnBhcnNlZEVudGl0eS5maWxlTmFtZUxlbmd0aCArIHRoaXMucGFyc2VkRW50aXR5LmV4dHJhRmllbGRMZW5ndGggKyB0aGlzLnBhcnNlZEVudGl0eS5maWxlQ29tbWVudExlbmd0aDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHN0YXRlcy5DRElSNjRfRU5EOlxuICAgICAgICAgICAgcmVxdWlyZWRMZW5ndGggPSA1MjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHN0YXRlcy5DRElSNjRfRU5EX0RBVEFfU0VDVE9SOlxuICAgICAgICAgICAgcmVxdWlyZWRMZW5ndGggPSB0aGlzLnBhcnNlZEVudGl0eS5jZW50cmFsRGlyZWN0b3J5UmVjb3JkU2l6ZSAtIDQ0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Ugc3RhdGVzLkNESVI2NF9MT0NBVE9SOlxuICAgICAgICAgICAgcmVxdWlyZWRMZW5ndGggPSAxNjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHN0YXRlcy5DRU5UUkFMX0RJUkVDVE9SWV9FTkQ6XG4gICAgICAgICAgICByZXF1aXJlZExlbmd0aCA9IDE4O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Ugc3RhdGVzLkNFTlRSQUxfRElSRUNUT1JZX0VORF9DT01NRU5UOlxuICAgICAgICAgICAgcmVxdWlyZWRMZW5ndGggPSB0aGlzLnBhcnNlZEVudGl0eS5jb21tZW50TGVuZ3RoO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Ugc3RhdGVzLkZJTEVfREFUQTpcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBjYXNlIHN0YXRlcy5GSUxFX0RBVEFfRU5EOlxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIGNhc2Ugc3RhdGVzLlRSQUlMSU5HX0pVTks6XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmRlYnVnKSBjb25zb2xlLmxvZyhcImZvdW5kXCIsIGNodW5rLmxlbmd0aCwgXCJieXRlcyBvZiBUUkFJTElOR19KVU5LXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGNodW5rLmxlbmd0aDtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBjaHVuay5sZW5ndGg7XG4gICAgfVxuXG4gICAgdmFyIGNodW5rTGVuZ3RoID0gY2h1bmsubGVuZ3RoO1xuICAgIGlmIChjaHVua0xlbmd0aCA8IHJlcXVpcmVkTGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIHN3aXRjaCAodGhpcy5zdGF0ZSkge1xuICAgICAgICBjYXNlIHN0YXRlcy5TVFJFQU1fU1RBUlQ6XG4gICAgICAgIGNhc2Ugc3RhdGVzLlNUQVJUOlxuICAgICAgICAgICAgdmFyIHNpZ25hdHVyZSA9IGNodW5rLnJlYWRVSW50MzJMRSgwKTtcbiAgICAgICAgICAgIHN3aXRjaCAoc2lnbmF0dXJlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBTSUdfTE9DQUxfRklMRV9IRUFERVI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZXMuTE9DQUxfRklMRV9IRUFERVI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgU0lHX0NESVJfUkVDT1JEOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGVzLkNFTlRSQUxfRElSRUNUT1JZX0ZJTEVfSEVBREVSO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFNJR19DRElSNjRfUkVDT1JEX0VORDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlcy5DRElSNjRfRU5EO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFNJR19DRElSNjRfTE9DQVRPUl9FTkQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZXMuQ0RJUjY0X0xPQ0FUT1I7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgU0lHX0NESVJfUkVDT1JEX0VORDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlcy5DRU5UUkFMX0RJUkVDVE9SWV9FTkQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHZhciBpc1N0cmVhbVN0YXJ0ID0gdGhpcy5zdGF0ZSA9PT0gc3RhdGVzLlNUUkVBTV9TVEFSVDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1N0cmVhbVN0YXJ0ICYmIChzaWduYXR1cmUgJiAweGZmZmYpICE9PSAweDRiNTAgJiYgdGhpcy5za2lwcGVkQnl0ZXMgPCAyNikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UnbGwgYWxsb3cgYSBwYWRkaW5nIG9mIG1heCAyOCBieXRlc1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlbWFpbmluZyA9IHNpZ25hdHVyZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0b1NraXAgPSA0O1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCA0ICYmIHJlbWFpbmluZyAhPT0gMDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtYWluaW5nID0gcmVtYWluaW5nID4+PiA4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgocmVtYWluaW5nICYgMHhmZikgPT09IDB4NTApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9Ta2lwID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5za2lwcGVkQnl0ZXMgKz0gdG9Ta2lwO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5kZWJ1ZykgY29uc29sZS5sb2coJ1NraXBwZWQnLCB0aGlzLnNraXBwZWRCeXRlcywgJ2J5dGVzJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9Ta2lwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZXMuRVJST1I7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnJNc2cgPSBpc1N0cmVhbVN0YXJ0ID8gXCJOb3QgYSB2YWxpZCB6aXAgZmlsZVwiIDogXCJJbnZhbGlkIHNpZ25hdHVyZSBpbiB6aXAgZmlsZVwiO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmRlYnVnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2lnID0gY2h1bmsucmVhZFVJbnQzMkxFKDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFzU3RyaW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHsgYXNTdHJpbmcgPSBjaHVuay5zbGljZSgwLCA0KS50b1N0cmluZygpOyB9IGNhdGNoIChlKSB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJVbmV4cGVjdGVkIHNpZ25hdHVyZSBpbiB6aXAgZmlsZTogMHhcIiArIHNpZy50b1N0cmluZygxNiksICdcIicgKyBhc1N0cmluZyArICdcIiwgc2tpcHBlZCcsIHRoaXMuc2tpcHBlZEJ5dGVzLCAnYnl0ZXMnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBuZXcgRXJyb3IoZXJyTXNnKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjaHVuay5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNraXBwZWRCeXRlcyA9IDA7XG4gICAgICAgICAgICByZXR1cm4gcmVxdWlyZWRMZW5ndGg7XG5cbiAgICAgICAgY2FzZSBzdGF0ZXMuTE9DQUxfRklMRV9IRUFERVI6XG4gICAgICAgICAgICB0aGlzLnBhcnNlZEVudGl0eSA9IHRoaXMuX3JlYWRGaWxlKGNodW5rKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZXMuTE9DQUxfRklMRV9IRUFERVJfU1VGRklYO1xuXG4gICAgICAgICAgICByZXR1cm4gcmVxdWlyZWRMZW5ndGg7XG5cbiAgICAgICAgY2FzZSBzdGF0ZXMuTE9DQUxfRklMRV9IRUFERVJfU1VGRklYOlxuICAgICAgICAgICAgdmFyIGVudHJ5ID0gbmV3IEVudHJ5KCk7XG4gICAgICAgICAgICB2YXIgaXNVdGY4ID0gKHRoaXMucGFyc2VkRW50aXR5LmZsYWdzICYgMHg4MDApICE9PSAwO1xuICAgICAgICAgICAgZW50cnkucGF0aCA9IHRoaXMuX2RlY29kZVN0cmluZyhjaHVuay5zbGljZSgwLCB0aGlzLnBhcnNlZEVudGl0eS5maWxlTmFtZUxlbmd0aCksIGlzVXRmOCk7XG4gICAgICAgICAgICB2YXIgZXh0cmFEYXRhQnVmZmVyID0gY2h1bmsuc2xpY2UodGhpcy5wYXJzZWRFbnRpdHkuZmlsZU5hbWVMZW5ndGgsIHRoaXMucGFyc2VkRW50aXR5LmZpbGVOYW1lTGVuZ3RoICsgdGhpcy5wYXJzZWRFbnRpdHkuZXh0cmFGaWVsZExlbmd0aCk7XG4gICAgICAgICAgICB2YXIgZXh0cmEgPSB0aGlzLl9yZWFkRXh0cmFGaWVsZHMoZXh0cmFEYXRhQnVmZmVyKTtcbiAgICAgICAgICAgIGlmIChleHRyYSAmJiBleHRyYS5wYXJzZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXh0cmEucGFyc2VkLnBhdGggJiYgIWlzVXRmOCkge1xuICAgICAgICAgICAgICAgICAgICBlbnRyeS5wYXRoID0gZXh0cmEucGFyc2VkLnBhdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChOdW1iZXIuaXNGaW5pdGUoZXh0cmEucGFyc2VkLnVuY29tcHJlc3NlZFNpemUpICYmIHRoaXMucGFyc2VkRW50aXR5LnVuY29tcHJlc3NlZFNpemUgPT09IEZPVVJfR0lHUy0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyc2VkRW50aXR5LnVuY29tcHJlc3NlZFNpemUgPSBleHRyYS5wYXJzZWQudW5jb21wcmVzc2VkU2l6ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZShleHRyYS5wYXJzZWQuY29tcHJlc3NlZFNpemUpICYmIHRoaXMucGFyc2VkRW50aXR5LmNvbXByZXNzZWRTaXplID09PSBGT1VSX0dJR1MtMSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcnNlZEVudGl0eS5jb21wcmVzc2VkU2l6ZSA9IGV4dHJhLnBhcnNlZC5jb21wcmVzc2VkU2l6ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnBhcnNlZEVudGl0eS5leHRyYSA9IGV4dHJhLnBhcnNlZCB8fCB7fTtcblxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5kZWJ1Zykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlYnVnT2JqID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5wYXJzZWRFbnRpdHksIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogZW50cnkucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3M6ICcweCcgKyB0aGlzLnBhcnNlZEVudGl0eS5mbGFncy50b1N0cmluZygxNiksXG4gICAgICAgICAgICAgICAgICAgIGV4dHJhRmllbGRzOiBleHRyYSAmJiBleHRyYS5kZWJ1Z1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiZGVjb2RlZCBMT0NBTF9GSUxFX0hFQURFUjpcIiwgSlNPTi5zdHJpbmdpZnkoZGVidWdPYmosIG51bGwsIDIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3ByZXBhcmVPdXRTdHJlYW0odGhpcy5wYXJzZWRFbnRpdHksIGVudHJ5KTtcblxuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZW50cnlcIiwgZW50cnkpO1xuXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGVzLkZJTEVfREFUQTtcblxuICAgICAgICAgICAgcmV0dXJuIHJlcXVpcmVkTGVuZ3RoO1xuXG4gICAgICAgIGNhc2Ugc3RhdGVzLkNFTlRSQUxfRElSRUNUT1JZX0ZJTEVfSEVBREVSOlxuICAgICAgICAgICAgdGhpcy5wYXJzZWRFbnRpdHkgPSB0aGlzLl9yZWFkQ2VudHJhbERpcmVjdG9yeUVudHJ5KGNodW5rKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZXMuQ0VOVFJBTF9ESVJFQ1RPUllfRklMRV9IRUFERVJfU1VGRklYO1xuXG4gICAgICAgICAgICByZXR1cm4gcmVxdWlyZWRMZW5ndGg7XG5cbiAgICAgICAgY2FzZSBzdGF0ZXMuQ0VOVFJBTF9ESVJFQ1RPUllfRklMRV9IRUFERVJfU1VGRklYOlxuICAgICAgICAgICAgLy8gZ290IGZpbGUgbmFtZSBpbiBjaHVua1swLi5dXG4gICAgICAgICAgICB2YXIgaXNVdGY4ID0gKHRoaXMucGFyc2VkRW50aXR5LmZsYWdzICYgMHg4MDApICE9PSAwO1xuICAgICAgICAgICAgdmFyIHBhdGggPSB0aGlzLl9kZWNvZGVTdHJpbmcoY2h1bmsuc2xpY2UoMCwgdGhpcy5wYXJzZWRFbnRpdHkuZmlsZU5hbWVMZW5ndGgpLCBpc1V0ZjgpO1xuICAgICAgICAgICAgdmFyIGV4dHJhRGF0YUJ1ZmZlciA9IGNodW5rLnNsaWNlKHRoaXMucGFyc2VkRW50aXR5LmZpbGVOYW1lTGVuZ3RoLCB0aGlzLnBhcnNlZEVudGl0eS5maWxlTmFtZUxlbmd0aCArIHRoaXMucGFyc2VkRW50aXR5LmV4dHJhRmllbGRMZW5ndGgpO1xuICAgICAgICAgICAgdmFyIGV4dHJhID0gdGhpcy5fcmVhZEV4dHJhRmllbGRzKGV4dHJhRGF0YUJ1ZmZlcik7XG4gICAgICAgICAgICBpZiAoZXh0cmEgJiYgZXh0cmEucGFyc2VkICYmIGV4dHJhLnBhcnNlZC5wYXRoICYmICFpc1V0ZjgpIHtcbiAgICAgICAgICAgICAgICBwYXRoID0gZXh0cmEucGFyc2VkLnBhdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnBhcnNlZEVudGl0eS5leHRyYSA9IGV4dHJhLnBhcnNlZDtcblxuICAgICAgICAgICAgdmFyIGlzVW5peCA9ICgodGhpcy5wYXJzZWRFbnRpdHkudmVyc2lvbk1hZGVCeSAmIDB4ZmYwMCkgPj4gOCkgPT09IDM7XG4gICAgICAgICAgICB2YXIgdW5peEF0dHJzLCBpc1N5bWxpbms7XG4gICAgICAgICAgICBpZiAoaXNVbml4KSB7XG4gICAgICAgICAgICAgICAgdW5peEF0dHJzID0gdGhpcy5wYXJzZWRFbnRpdHkuZXh0ZXJuYWxGaWxlQXR0cmlidXRlcyA+Pj4gMTY7XG4gICAgICAgICAgICAgICAgdmFyIGZpbGVUeXBlID0gdW5peEF0dHJzID4+PiAxMjtcbiAgICAgICAgICAgICAgICBpc1N5bWxpbmsgPSAoZmlsZVR5cGUgJiAwbzEyKSA9PT0gMG8xMjsgLy8gX19TX0lGTE5LXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmRlYnVnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVidWdPYmogPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnBhcnNlZEVudGl0eSwge1xuICAgICAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgICAgICBmbGFnczogJzB4JyArIHRoaXMucGFyc2VkRW50aXR5LmZsYWdzLnRvU3RyaW5nKDE2KSxcbiAgICAgICAgICAgICAgICAgICAgdW5peEF0dHJzOiB1bml4QXR0cnMgJiYgJzAnICsgdW5peEF0dHJzLnRvU3RyaW5nKDgpLFxuICAgICAgICAgICAgICAgICAgICBpc1N5bWxpbms6IGlzU3ltbGluayxcbiAgICAgICAgICAgICAgICAgICAgZXh0cmFGaWVsZHM6IGV4dHJhLmRlYnVnLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiZGVjb2RlZCBDRU5UUkFMX0RJUkVDVE9SWV9GSUxFX0hFQURFUjpcIiwgSlNPTi5zdHJpbmdpZnkoZGVidWdPYmosIG51bGwsIDIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZXMuU1RBUlQ7XG5cbiAgICAgICAgICAgIHJldHVybiByZXF1aXJlZExlbmd0aDtcblxuICAgICAgICBjYXNlIHN0YXRlcy5DRElSNjRfRU5EOlxuICAgICAgICAgICAgdGhpcy5wYXJzZWRFbnRpdHkgPSB0aGlzLl9yZWFkRW5kT2ZDZW50cmFsRGlyZWN0b3J5NjQoY2h1bmspO1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5kZWJ1Zykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiZGVjb2RlZCBDRElSNjRfRU5EX1JFQ09SRDpcIiwgdGhpcy5wYXJzZWRFbnRpdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlcy5DRElSNjRfRU5EX0RBVEFfU0VDVE9SO1xuXG4gICAgICAgICAgICByZXR1cm4gcmVxdWlyZWRMZW5ndGg7XG5cbiAgICAgICAgY2FzZSBzdGF0ZXMuQ0RJUjY0X0VORF9EQVRBX1NFQ1RPUjpcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZXMuU1RBUlQ7XG5cbiAgICAgICAgICAgIHJldHVybiByZXF1aXJlZExlbmd0aDtcblxuICAgICAgICBjYXNlIHN0YXRlcy5DRElSNjRfTE9DQVRPUjpcbiAgICAgICAgICAgIC8vIGlnbm9yZSwgbm90aGluZyBpbnRlcmVzdGluZ1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlcy5TVEFSVDtcblxuICAgICAgICAgICAgcmV0dXJuIHJlcXVpcmVkTGVuZ3RoO1xuXG4gICAgICAgIGNhc2Ugc3RhdGVzLkNFTlRSQUxfRElSRUNUT1JZX0VORDpcbiAgICAgICAgICAgIHRoaXMucGFyc2VkRW50aXR5ID0gdGhpcy5fcmVhZEVuZE9mQ2VudHJhbERpcmVjdG9yeShjaHVuayk7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmRlYnVnKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJkZWNvZGVkIENFTlRSQUxfRElSRUNUT1JZX0VORDpcIiwgdGhpcy5wYXJzZWRFbnRpdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlcy5DRU5UUkFMX0RJUkVDVE9SWV9FTkRfQ09NTUVOVDtcblxuICAgICAgICAgICAgcmV0dXJuIHJlcXVpcmVkTGVuZ3RoO1xuXG4gICAgICAgIGNhc2Ugc3RhdGVzLkNFTlRSQUxfRElSRUNUT1JZX0VORF9DT01NRU5UOlxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5kZWJ1Zykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiZGVjb2RlZCBDRU5UUkFMX0RJUkVDVE9SWV9FTkRfQ09NTUVOVDpcIiwgY2h1bmsuc2xpY2UoMCwgcmVxdWlyZWRMZW5ndGgpLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlcy5UUkFJTElOR19KVU5LO1xuXG4gICAgICAgICAgICByZXR1cm4gcmVxdWlyZWRMZW5ndGg7XG5cbiAgICAgICAgY2FzZSBzdGF0ZXMuRVJST1I6XG4gICAgICAgICAgICByZXR1cm4gY2h1bmsubGVuZ3RoOyAvLyBkaXNjYXJkXG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiZGlkbid0IGhhbmRsZSBzdGF0ZSAjXCIsIHRoaXMuc3RhdGUsIFwiZGlzY2FyZGluZ1wiKTtcbiAgICAgICAgICAgIHJldHVybiBjaHVuay5sZW5ndGg7XG4gICAgfVxufVxuXG5VbnppcFN0cmVhbS5wcm90b3R5cGUuX3ByZXBhcmVPdXRTdHJlYW0gPSBmdW5jdGlvbiAodmFycywgZW50cnkpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB2YXIgaXNEaXJlY3RvcnkgPSB2YXJzLnVuY29tcHJlc3NlZFNpemUgPT09IDAgJiYgL1tcXC9cXFxcXSQvLnRlc3QoZW50cnkucGF0aCk7XG4gICAgLy8gcHJvdGVjdCBhZ2FpbnN0IG1hbGljaW91cyB6aXAgZmlsZXMgd2hpY2ggd2FudCB0byBleHRyYWN0IHRvIHBhcmVudCBkaXJzXG4gICAgZW50cnkucGF0aCA9IGVudHJ5LnBhdGgucmVwbGFjZSgvXihbL1xcXFxdKlsuXStbL1xcXFxdKykqWy9cXFxcXSovLCBcIlwiKTtcbiAgICBlbnRyeS50eXBlID0gaXNEaXJlY3RvcnkgPyAnRGlyZWN0b3J5JyA6ICdGaWxlJztcbiAgICBlbnRyeS5pc0RpcmVjdG9yeSA9IGlzRGlyZWN0b3J5O1xuXG4gICAgdmFyIGZpbGVTaXplS25vd24gPSAhKHZhcnMuZmxhZ3MgJiAweDA4KTtcbiAgICBpZiAoZmlsZVNpemVLbm93bikge1xuICAgICAgICBlbnRyeS5zaXplID0gdmFycy51bmNvbXByZXNzZWRTaXplO1xuICAgIH1cblxuICAgIHZhciBpc1ZlcnNpb25TdXBwb3J0ZWQgPSB2YXJzLnZlcnNpb25zTmVlZGVkVG9FeHRyYWN0IDw9IDQ1O1xuXG4gICAgdGhpcy5vdXRTdHJlYW1JbmZvID0ge1xuICAgICAgICBzdHJlYW06IG51bGwsXG4gICAgICAgIGxpbWl0OiBmaWxlU2l6ZUtub3duID8gdmFycy5jb21wcmVzc2VkU2l6ZSA6IC0xLFxuICAgICAgICB3cml0dGVuOiAwXG4gICAgfTtcblxuICAgIGlmICghZmlsZVNpemVLbm93bikge1xuICAgICAgICB2YXIgcGF0dGVybiA9IG5ldyBCdWZmZXIoNCk7XG4gICAgICAgIHBhdHRlcm4ud3JpdGVVSW50MzJMRShTSUdfREFUQV9ERVNDUklQVE9SLCAwKTtcbiAgICAgICAgdmFyIHppcDY0TW9kZSA9IHZhcnMuZXh0cmEuemlwNjRNb2RlO1xuICAgICAgICB2YXIgZXh0cmFTaXplID0gemlwNjRNb2RlID8gMjAgOiAxMjtcbiAgICAgICAgdmFyIHNlYXJjaFBhdHRlcm4gPSB7XG4gICAgICAgICAgICBwYXR0ZXJuOiBwYXR0ZXJuLFxuICAgICAgICAgICAgcmVxdWlyZWRFeHRyYVNpemU6IGV4dHJhU2l6ZVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1hdGNoZXJTdHJlYW0gPSBuZXcgTWF0Y2hlclN0cmVhbShzZWFyY2hQYXR0ZXJuLCBmdW5jdGlvbiAobWF0Y2hlZENodW5rLCBzaXplU29GYXIpIHtcbiAgICAgICAgICAgIHZhciB2YXJzID0gc2VsZi5fcmVhZERhdGFEZXNjcmlwdG9yKG1hdGNoZWRDaHVuaywgemlwNjRNb2RlKTtcblxuICAgICAgICAgICAgdmFyIGNvbXByZXNzZWRTaXplTWF0Y2hlcyA9IHZhcnMuY29tcHJlc3NlZFNpemUgPT09IHNpemVTb0ZhcjtcbiAgICAgICAgICAgIC8vIGxldCdzIGFsc28gZGVhbCB3aXRoIGFyY2hpdmVzIHdpdGggNEdpQisgZmlsZXMgd2l0aG91dCB6aXA2NFxuICAgICAgICAgICAgaWYgKCF6aXA2NE1vZGUgJiYgIWNvbXByZXNzZWRTaXplTWF0Y2hlcyAmJiBzaXplU29GYXIgPj0gRk9VUl9HSUdTKSB7XG4gICAgICAgICAgICAgICAgdmFyIG92ZXJmbG93biA9IHNpemVTb0ZhciAtIEZPVVJfR0lHUztcbiAgICAgICAgICAgICAgICB3aGlsZSAob3ZlcmZsb3duID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcHJlc3NlZFNpemVNYXRjaGVzID0gdmFycy5jb21wcmVzc2VkU2l6ZSA9PT0gb3ZlcmZsb3duO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcHJlc3NlZFNpemVNYXRjaGVzKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmZsb3duIC09IEZPVVJfR0lHUztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWNvbXByZXNzZWRTaXplTWF0Y2hlcykgeyByZXR1cm47IH1cblxuICAgICAgICAgICAgc2VsZi5zdGF0ZSA9IHN0YXRlcy5GSUxFX0RBVEFfRU5EO1xuICAgICAgICAgICAgdmFyIHNsaWNlT2Zmc2V0ID0gemlwNjRNb2RlID8gMjQgOiAxNjtcbiAgICAgICAgICAgIGlmIChzZWxmLmRhdGEubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHNlbGYuZGF0YSA9IEJ1ZmZlci5jb25jYXQoW21hdGNoZWRDaHVuay5zbGljZShzbGljZU9mZnNldCksIHNlbGYuZGF0YV0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxmLmRhdGEgPSBtYXRjaGVkQ2h1bmsuc2xpY2Uoc2xpY2VPZmZzZXQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub3V0U3RyZWFtSW5mby5zdHJlYW0gPSBtYXRjaGVyU3RyZWFtO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMub3V0U3RyZWFtSW5mby5zdHJlYW0gPSBuZXcgc3RyZWFtLlBhc3NUaHJvdWdoKCk7XG4gICAgfVxuXG4gICAgdmFyIGlzRW5jcnlwdGVkID0gKHZhcnMuZmxhZ3MgJiAweDAxKSB8fCAodmFycy5mbGFncyAmIDB4NDApO1xuICAgIGlmIChpc0VuY3J5cHRlZCB8fCAhaXNWZXJzaW9uU3VwcG9ydGVkKSB7XG4gICAgICAgIHZhciBtZXNzYWdlID0gaXNFbmNyeXB0ZWQgPyBcIkVuY3J5cHRlZCBmaWxlcyBhcmUgbm90IHN1cHBvcnRlZCFcIlxuICAgICAgICAgICAgOiAoXCJaaXAgdmVyc2lvbiBcIiArIE1hdGguZmxvb3IodmFycy52ZXJzaW9uc05lZWRlZFRvRXh0cmFjdCAvIDEwKSArIFwiLlwiICsgdmFycy52ZXJzaW9uc05lZWRlZFRvRXh0cmFjdCAlIDEwICsgXCIgaXMgbm90IHN1cHBvcnRlZFwiKTtcblxuICAgICAgICBlbnRyeS5za2lwID0gdHJ1ZTtcbiAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgICAgICAgIGVudHJ5LmVtaXQoXCJlcnJvclwiLCBuZXcgRXJyb3IobWVzc2FnZSkpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyB0cnkgdG8gc2tpcCBvdmVyIHRoaXMgZW50cnlcbiAgICAgICAgdGhpcy5vdXRTdHJlYW1JbmZvLnN0cmVhbS5waXBlKG5ldyBFbnRyeSgpLmF1dG9kcmFpbigpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBpc0NvbXByZXNzZWQgPSB2YXJzLmNvbXByZXNzaW9uTWV0aG9kID4gMDtcbiAgICBpZiAoaXNDb21wcmVzc2VkKSB7XG4gICAgICAgIHZhciBpbmZsYXRlciA9IHpsaWIuY3JlYXRlSW5mbGF0ZVJhdygpO1xuICAgICAgICBpbmZsYXRlci5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBzZWxmLnN0YXRlID0gc3RhdGVzLkVSUk9SO1xuICAgICAgICAgICAgc2VsZi5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm91dFN0cmVhbUluZm8uc3RyZWFtLnBpcGUoaW5mbGF0ZXIpLnBpcGUoZW50cnkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMub3V0U3RyZWFtSW5mby5zdHJlYW0ucGlwZShlbnRyeSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2RyYWluQWxsRW50cmllcykge1xuICAgICAgICBlbnRyeS5hdXRvZHJhaW4oKTtcbiAgICB9XG59XG5cblVuemlwU3RyZWFtLnByb3RvdHlwZS5fcmVhZEZpbGUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciB2YXJzID0gYmluYXJ5LnBhcnNlKGRhdGEpXG4gICAgICAgIC53b3JkMTZsdSgndmVyc2lvbnNOZWVkZWRUb0V4dHJhY3QnKVxuICAgICAgICAud29yZDE2bHUoJ2ZsYWdzJylcbiAgICAgICAgLndvcmQxNmx1KCdjb21wcmVzc2lvbk1ldGhvZCcpXG4gICAgICAgIC53b3JkMTZsdSgnbGFzdE1vZGlmaWVkVGltZScpXG4gICAgICAgIC53b3JkMTZsdSgnbGFzdE1vZGlmaWVkRGF0ZScpXG4gICAgICAgIC53b3JkMzJsdSgnY3JjMzInKVxuICAgICAgICAud29yZDMybHUoJ2NvbXByZXNzZWRTaXplJylcbiAgICAgICAgLndvcmQzMmx1KCd1bmNvbXByZXNzZWRTaXplJylcbiAgICAgICAgLndvcmQxNmx1KCdmaWxlTmFtZUxlbmd0aCcpXG4gICAgICAgIC53b3JkMTZsdSgnZXh0cmFGaWVsZExlbmd0aCcpXG4gICAgICAgIC52YXJzO1xuXG4gICAgcmV0dXJuIHZhcnM7XG59XG5cblVuemlwU3RyZWFtLnByb3RvdHlwZS5fcmVhZEV4dHJhRmllbGRzID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgZXh0cmEgPSB7fTtcbiAgICB2YXIgcmVzdWx0ID0geyBwYXJzZWQ6IGV4dHJhIH07XG4gICAgaWYgKHRoaXMub3B0aW9ucy5kZWJ1Zykge1xuICAgICAgICByZXN1bHQuZGVidWcgPSBbXTtcbiAgICB9XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB3aGlsZSAoaW5kZXggPCBkYXRhLmxlbmd0aCkge1xuICAgICAgICB2YXIgdmFycyA9IGJpbmFyeS5wYXJzZShkYXRhKVxuICAgICAgICAgICAgLnNraXAoaW5kZXgpXG4gICAgICAgICAgICAud29yZDE2bHUoJ2V4dHJhSWQnKVxuICAgICAgICAgICAgLndvcmQxNmx1KCdleHRyYVNpemUnKVxuICAgICAgICAgICAgLnZhcnM7XG5cbiAgICAgICAgaW5kZXggKz0gNDtcblxuICAgICAgICB2YXIgZmllbGRUeXBlID0gdW5kZWZpbmVkO1xuICAgICAgICBzd2l0Y2ggKHZhcnMuZXh0cmFJZCkge1xuICAgICAgICAgICAgY2FzZSAweDAwMDE6XG4gICAgICAgICAgICAgICAgZmllbGRUeXBlID0gXCJaaXA2NCBleHRlbmRlZCBpbmZvcm1hdGlvbiBleHRyYSBmaWVsZFwiO1xuICAgICAgICAgICAgICAgIHZhciB6NjR2YXJzID0gYmluYXJ5LnBhcnNlKGRhdGEuc2xpY2UoaW5kZXgsIGluZGV4K3ZhcnMuZXh0cmFTaXplKSlcbiAgICAgICAgICAgICAgICAgICAgLndvcmQ2NGx1KCd1bmNvbXByZXNzZWRTaXplJylcbiAgICAgICAgICAgICAgICAgICAgLndvcmQ2NGx1KCdjb21wcmVzc2VkU2l6ZScpXG4gICAgICAgICAgICAgICAgICAgIC53b3JkNjRsdSgnb2Zmc2V0VG9Mb2NhbEhlYWRlcicpXG4gICAgICAgICAgICAgICAgICAgIC53b3JkMzJsdSgnZGlza1N0YXJ0TnVtYmVyJylcbiAgICAgICAgICAgICAgICAgICAgLnZhcnM7XG4gICAgICAgICAgICAgICAgaWYgKHo2NHZhcnMudW5jb21wcmVzc2VkU2l6ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBleHRyYS51bmNvbXByZXNzZWRTaXplID0gejY0dmFycy51bmNvbXByZXNzZWRTaXplO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoejY0dmFycy5jb21wcmVzc2VkU2l6ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBleHRyYS5jb21wcmVzc2VkU2l6ZSA9IHo2NHZhcnMuY29tcHJlc3NlZFNpemU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGV4dHJhLnppcDY0TW9kZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDB4MDAwYTpcbiAgICAgICAgICAgICAgICBmaWVsZFR5cGUgPSBcIk5URlMgZXh0cmEgZmllbGRcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMHg1NDU1OlxuICAgICAgICAgICAgICAgIGZpZWxkVHlwZSA9IFwiZXh0ZW5kZWQgdGltZXN0YW1wXCI7XG4gICAgICAgICAgICAgICAgdmFyIHRpbWVzdGFtcEZpZWxkcyA9IGRhdGEucmVhZFVJbnQ4KGluZGV4KTtcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gMTtcbiAgICAgICAgICAgICAgICBpZiAodGltZXN0YW1wRmllbGRzICYgMSkge1xuICAgICAgICAgICAgICAgICAgICBleHRyYS5tdGltZSA9IG5ldyBEYXRlKGRhdGEucmVhZFVJbnQzMkxFKGluZGV4ICsgb2Zmc2V0KSAqIDEwMDApO1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgKz0gNDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRpbWVzdGFtcEZpZWxkcyAmIDIpIHtcbiAgICAgICAgICAgICAgICAgICAgZXh0cmEuYXRpbWUgPSBuZXcgRGF0ZShkYXRhLnJlYWRVSW50MzJMRShpbmRleCArIG9mZnNldCkgKiAxMDAwKTtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aW1lc3RhbXBGaWVsZHMgJiA0KSB7XG4gICAgICAgICAgICAgICAgICAgIGV4dHJhLmN0aW1lID0gbmV3IERhdGUoZGF0YS5yZWFkVUludDMyTEUoaW5kZXggKyBvZmZzZXQpICogMTAwMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAweDcwNzU6XG4gICAgICAgICAgICAgICAgZmllbGRUeXBlID0gXCJJbmZvLVpJUCBVbmljb2RlIFBhdGggRXh0cmEgRmllbGRcIjtcbiAgICAgICAgICAgICAgICB2YXIgZmllbGRWZXIgPSBkYXRhLnJlYWRVSW50OChpbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkVmVyID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvZmZzZXQgPSAxO1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBzaG91bGQgYmUgY2hlY2tpbmcgdGhpcyBhZ2FpbnN0IG91ciBwYXRoIGJ1ZmZlclxuICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZUNyYzMyID0gZGF0YS5yZWFkVUludDMyTEUoaW5kZXggKyBvZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgKz0gNDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhdGhCdWZmZXIgPSBkYXRhLnNsaWNlKGluZGV4ICsgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgZXh0cmEucGF0aCA9IHBhdGhCdWZmZXIudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDB4MDAwZDpcbiAgICAgICAgICAgIGNhc2UgMHg1ODU1OlxuICAgICAgICAgICAgICAgIGZpZWxkVHlwZSA9IHZhcnMuZXh0cmFJZCA9PT0gMHgwMDBkID8gXCJQS1dBUkUgVW5peFwiIDogXCJJbmZvLVpJUCBVTklYICh0eXBlIDEpXCI7XG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKHZhcnMuZXh0cmFTaXplID49IDgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGF0aW1lID0gbmV3IERhdGUoZGF0YS5yZWFkVUludDMyTEUoaW5kZXggKyBvZmZzZXQpICogMTAwMCk7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCArPSA0O1xuICAgICAgICAgICAgICAgICAgICB2YXIgbXRpbWUgPSBuZXcgRGF0ZShkYXRhLnJlYWRVSW50MzJMRShpbmRleCArIG9mZnNldCkgKiAxMDAwKTtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgICAgICAgICAgIGV4dHJhLmF0aW1lID0gYXRpbWU7XG4gICAgICAgICAgICAgICAgICAgIGV4dHJhLm10aW1lID0gbXRpbWU7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhcnMuZXh0cmFTaXplID49IDEyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdWlkID0gZGF0YS5yZWFkVUludDE2TEUoaW5kZXggKyBvZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ICs9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZ2lkID0gZGF0YS5yZWFkVUludDE2TEUoaW5kZXggKyBvZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ICs9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHRyYS51aWQgPSB1aWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHRyYS5naWQgPSBnaWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDB4Nzg1NTpcbiAgICAgICAgICAgICAgICBmaWVsZFR5cGUgPSBcIkluZm8tWklQIFVOSVggKHR5cGUgMilcIjtcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgICBpZiAodmFycy5leHRyYVNpemUgPj0gNCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdWlkID0gZGF0YS5yZWFkVUludDE2TEUoaW5kZXggKyBvZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgKz0gMjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGdpZCA9IGRhdGEucmVhZFVJbnQxNkxFKGluZGV4ICsgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ICs9IDI7XG4gICAgICAgICAgICAgICAgICAgIGV4dHJhLnVpZCA9IHVpZDtcbiAgICAgICAgICAgICAgICAgICAgZXh0cmEuZ2lkID0gZ2lkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMHg3ODc1OlxuICAgICAgICAgICAgICAgIGZpZWxkVHlwZSA9IFwiSW5mby1aSVAgTmV3IFVuaXhcIjtcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgICB2YXIgZXh0cmFWZXIgPSBkYXRhLnJlYWRVSW50OChpbmRleCk7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IDE7XG4gICAgICAgICAgICAgICAgaWYgKGV4dHJhVmVyID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB1aWRTaXplID0gZGF0YS5yZWFkVUludDgoaW5kZXggKyBvZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVpZFNpemUgPD0gNikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmEudWlkID0gZGF0YS5yZWFkVUludExFKGluZGV4ICsgb2Zmc2V0LCB1aWRTaXplKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgKz0gdWlkU2l6ZTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgZ2lkU2l6ZSA9IGRhdGEucmVhZFVJbnQ4KGluZGV4ICsgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChnaWRTaXplIDw9IDYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhLmdpZCA9IGRhdGEucmVhZFVJbnRMRShpbmRleCArIG9mZnNldCwgZ2lkU2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDB4NzU2ZTpcbiAgICAgICAgICAgICAgICBmaWVsZFR5cGUgPSBcIkFTaSBVbml4XCI7XG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKHZhcnMuZXh0cmFTaXplID49IDE0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjcmMgPSBkYXRhLnJlYWRVSW50MzJMRShpbmRleCArIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCArPSA0O1xuICAgICAgICAgICAgICAgICAgICB2YXIgbW9kZSA9IGRhdGEucmVhZFVJbnQxNkxFKGluZGV4ICsgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ICs9IDI7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzaXpkZXYgPSBkYXRhLnJlYWRVSW50MzJMRShpbmRleCArIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCArPSA0O1xuICAgICAgICAgICAgICAgICAgICB2YXIgdWlkID0gZGF0YS5yZWFkVUludDE2TEUoaW5kZXggKyBvZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgKz0gMjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGdpZCA9IGRhdGEucmVhZFVJbnQxNkxFKGluZGV4ICsgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ICs9IDI7XG4gICAgICAgICAgICAgICAgICAgIGV4dHJhLm1vZGUgPSBtb2RlO1xuICAgICAgICAgICAgICAgICAgICBleHRyYS51aWQgPSB1aWQ7XG4gICAgICAgICAgICAgICAgICAgIGV4dHJhLmdpZCA9IGdpZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhcnMuZXh0cmFTaXplID4gMTQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IGluZGV4ICsgb2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVuZCA9IGluZGV4ICsgdmFycy5leHRyYVNpemUgLSAxNDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzeW1saW5rTmFtZSA9IHRoaXMuX2RlY29kZVN0cmluZyhkYXRhLnNsaWNlKHN0YXJ0LCBlbmQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhLnN5bWxpbmsgPSBzeW1saW5rTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGVidWcpIHtcbiAgICAgICAgICAgIHJlc3VsdC5kZWJ1Zy5wdXNoKHtcbiAgICAgICAgICAgICAgICBleHRyYUlkOiAnMHgnICsgdmFycy5leHRyYUlkLnRvU3RyaW5nKDE2KSxcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogZmllbGRUeXBlLFxuICAgICAgICAgICAgICAgIGRhdGE6IGRhdGEuc2xpY2UoaW5kZXgsIGluZGV4ICsgdmFycy5leHRyYVNpemUpLmluc3BlY3QoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpbmRleCArPSB2YXJzLmV4dHJhU2l6ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5VbnppcFN0cmVhbS5wcm90b3R5cGUuX3JlYWREYXRhRGVzY3JpcHRvciA9IGZ1bmN0aW9uIChkYXRhLCB6aXA2NE1vZGUpIHtcbiAgICBpZiAoemlwNjRNb2RlKSB7XG4gICAgICAgIHZhciB2YXJzID0gYmluYXJ5LnBhcnNlKGRhdGEpXG4gICAgICAgICAgICAud29yZDMybHUoJ2RhdGFEZXNjcmlwdG9yU2lnbmF0dXJlJylcbiAgICAgICAgICAgIC53b3JkMzJsdSgnY3JjMzInKVxuICAgICAgICAgICAgLndvcmQ2NGx1KCdjb21wcmVzc2VkU2l6ZScpXG4gICAgICAgICAgICAud29yZDY0bHUoJ3VuY29tcHJlc3NlZFNpemUnKVxuICAgICAgICAgICAgLnZhcnM7XG5cbiAgICAgICAgcmV0dXJuIHZhcnM7XG4gICAgfVxuXG4gICAgdmFyIHZhcnMgPSBiaW5hcnkucGFyc2UoZGF0YSlcbiAgICAgICAgLndvcmQzMmx1KCdkYXRhRGVzY3JpcHRvclNpZ25hdHVyZScpXG4gICAgICAgIC53b3JkMzJsdSgnY3JjMzInKVxuICAgICAgICAud29yZDMybHUoJ2NvbXByZXNzZWRTaXplJylcbiAgICAgICAgLndvcmQzMmx1KCd1bmNvbXByZXNzZWRTaXplJylcbiAgICAgICAgLnZhcnM7XG5cbiAgICByZXR1cm4gdmFycztcbn1cblxuVW56aXBTdHJlYW0ucHJvdG90eXBlLl9yZWFkQ2VudHJhbERpcmVjdG9yeUVudHJ5ID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgdmFycyA9IGJpbmFyeS5wYXJzZShkYXRhKVxuICAgICAgICAud29yZDE2bHUoJ3ZlcnNpb25NYWRlQnknKVxuICAgICAgICAud29yZDE2bHUoJ3ZlcnNpb25zTmVlZGVkVG9FeHRyYWN0JylcbiAgICAgICAgLndvcmQxNmx1KCdmbGFncycpXG4gICAgICAgIC53b3JkMTZsdSgnY29tcHJlc3Npb25NZXRob2QnKVxuICAgICAgICAud29yZDE2bHUoJ2xhc3RNb2RpZmllZFRpbWUnKVxuICAgICAgICAud29yZDE2bHUoJ2xhc3RNb2RpZmllZERhdGUnKVxuICAgICAgICAud29yZDMybHUoJ2NyYzMyJylcbiAgICAgICAgLndvcmQzMmx1KCdjb21wcmVzc2VkU2l6ZScpXG4gICAgICAgIC53b3JkMzJsdSgndW5jb21wcmVzc2VkU2l6ZScpXG4gICAgICAgIC53b3JkMTZsdSgnZmlsZU5hbWVMZW5ndGgnKVxuICAgICAgICAud29yZDE2bHUoJ2V4dHJhRmllbGRMZW5ndGgnKVxuICAgICAgICAud29yZDE2bHUoJ2ZpbGVDb21tZW50TGVuZ3RoJylcbiAgICAgICAgLndvcmQxNmx1KCdkaXNrTnVtYmVyJylcbiAgICAgICAgLndvcmQxNmx1KCdpbnRlcm5hbEZpbGVBdHRyaWJ1dGVzJylcbiAgICAgICAgLndvcmQzMmx1KCdleHRlcm5hbEZpbGVBdHRyaWJ1dGVzJylcbiAgICAgICAgLndvcmQzMmx1KCdvZmZzZXRUb0xvY2FsRmlsZUhlYWRlcicpXG4gICAgICAgIC52YXJzO1xuXG4gICAgcmV0dXJuIHZhcnM7XG59XG5cblVuemlwU3RyZWFtLnByb3RvdHlwZS5fcmVhZEVuZE9mQ2VudHJhbERpcmVjdG9yeTY0ID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgdmFycyA9IGJpbmFyeS5wYXJzZShkYXRhKVxuICAgICAgICAud29yZDY0bHUoJ2NlbnRyYWxEaXJlY3RvcnlSZWNvcmRTaXplJylcbiAgICAgICAgLndvcmQxNmx1KCd2ZXJzaW9uTWFkZUJ5JylcbiAgICAgICAgLndvcmQxNmx1KCd2ZXJzaW9uc05lZWRlZFRvRXh0cmFjdCcpXG4gICAgICAgIC53b3JkMzJsdSgnZGlza051bWJlcicpXG4gICAgICAgIC53b3JkMzJsdSgnZGlza051bWJlcldpdGhDZW50cmFsRGlyZWN0b3J5U3RhcnQnKVxuICAgICAgICAud29yZDY0bHUoJ2NlbnRyYWxEaXJlY3RvcnlFbnRyaWVzJylcbiAgICAgICAgLndvcmQ2NGx1KCd0b3RhbENlbnRyYWxEaXJlY3RvcnlFbnRyaWVzJylcbiAgICAgICAgLndvcmQ2NGx1KCdzaXplT2ZDZW50cmFsRGlyZWN0b3J5JylcbiAgICAgICAgLndvcmQ2NGx1KCdvZmZzZXRUb1N0YXJ0T2ZDZW50cmFsRGlyZWN0b3J5JylcbiAgICAgICAgLnZhcnM7XG5cbiAgICByZXR1cm4gdmFycztcbn1cblxuVW56aXBTdHJlYW0ucHJvdG90eXBlLl9yZWFkRW5kT2ZDZW50cmFsRGlyZWN0b3J5ID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgdmFycyA9IGJpbmFyeS5wYXJzZShkYXRhKVxuICAgICAgICAud29yZDE2bHUoJ2Rpc2tOdW1iZXInKVxuICAgICAgICAud29yZDE2bHUoJ2Rpc2tTdGFydCcpXG4gICAgICAgIC53b3JkMTZsdSgnY2VudHJhbERpcmVjdG9yeUVudHJpZXMnKVxuICAgICAgICAud29yZDE2bHUoJ3RvdGFsQ2VudHJhbERpcmVjdG9yeUVudHJpZXMnKVxuICAgICAgICAud29yZDMybHUoJ3NpemVPZkNlbnRyYWxEaXJlY3RvcnknKVxuICAgICAgICAud29yZDMybHUoJ29mZnNldFRvU3RhcnRPZkNlbnRyYWxEaXJlY3RvcnknKVxuICAgICAgICAud29yZDE2bHUoJ2NvbW1lbnRMZW5ndGgnKVxuICAgICAgICAudmFycztcblxuICAgIHJldHVybiB2YXJzO1xufVxuXG5jb25zdCBjcDQzNyA9ICdcXHUwMDAw4pi64pi74pml4pmm4pmj4pmg4oCi4peY4peL4peZ4pmC4pmA4pmq4pmr4pi84pa64peE4oaV4oC8wrbCp+KWrOKGqOKGkeKGk+KGkuKGkOKIn+KGlOKWsuKWvCAhXCIjJCUmXFwnKCkqKywtLi8wMTIzNDU2Nzg5Ojs8PT4/QEFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaW1xcXFxdXl9gYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXp7fH1+4oyCw4fDvMOpw6LDpMOgw6XDp8Oqw6vDqMOvw67DrMOEw4XDicOmw4bDtMO2w7LDu8O5w7/DlsOcwqLCo8Kl4oKnxpLDocOtw7PDusOxw5HCqsK6wr/ijJDCrMK9wrzCocKrwrvilpHilpLilpPilILilKTilaHilaLilZbilZXilaPilZHilZfilZ3ilZzilZvilJDilJTilLTilKzilJzilIDilLzilZ7ilZ/ilZrilZTilanilabilaDilZDilazilafilajilaTilaXilZnilZjilZLilZPilavilarilJjilIzilojiloTilozilpDiloDOscOfzpPPgM6jz4PCtc+EzqbOmM6pzrTiiJ7Phs614oip4omhwrHiiaXiiaTijKDijKHDt+KJiMKw4oiZwrfiiJrigb/CsuKWoCAnO1xuXG5VbnppcFN0cmVhbS5wcm90b3R5cGUuX2RlY29kZVN0cmluZyA9IGZ1bmN0aW9uIChidWZmZXIsIGlzVXRmOCkge1xuICAgIGlmIChpc1V0ZjgpIHtcbiAgICAgICAgcmV0dXJuIGJ1ZmZlci50b1N0cmluZygndXRmOCcpO1xuICAgIH1cbiAgICAvLyBhbGxvdyBwYXNzaW5nIGN1c3RvbSBkZWNvZGVyXG4gICAgaWYgKHRoaXMub3B0aW9ucy5kZWNvZGVTdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5kZWNvZGVTdHJpbmcoYnVmZmVyKTtcbiAgICB9XG4gICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgZm9yICh2YXIgaT0wOyBpPGJ1ZmZlci5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHQgKz0gY3A0MzdbYnVmZmVyW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuVW56aXBTdHJlYW0ucHJvdG90eXBlLl9wYXJzZU9yT3V0cHV0ID0gZnVuY3Rpb24gKGVuY29kaW5nLCBjYikge1xuICAgIHZhciBjb25zdW1lO1xuICAgIHdoaWxlICgoY29uc3VtZSA9IHRoaXMucHJvY2Vzc0RhdGFDaHVuayh0aGlzLmRhdGEpKSA+IDApIHtcbiAgICAgICAgdGhpcy5kYXRhID0gdGhpcy5kYXRhLnNsaWNlKGNvbnN1bWUpO1xuICAgICAgICBpZiAodGhpcy5kYXRhLmxlbmd0aCA9PT0gMCkgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IHN0YXRlcy5GSUxFX0RBVEEpIHtcbiAgICAgICAgaWYgKHRoaXMub3V0U3RyZWFtSW5mby5saW1pdCA+PSAwKSB7XG4gICAgICAgICAgICB2YXIgcmVtYWluaW5nID0gdGhpcy5vdXRTdHJlYW1JbmZvLmxpbWl0IC0gdGhpcy5vdXRTdHJlYW1JbmZvLndyaXR0ZW47XG4gICAgICAgICAgICB2YXIgcGFja2V0O1xuICAgICAgICAgICAgaWYgKHJlbWFpbmluZyA8IHRoaXMuZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBwYWNrZXQgPSB0aGlzLmRhdGEuc2xpY2UoMCwgcmVtYWluaW5nKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGEgPSB0aGlzLmRhdGEuc2xpY2UocmVtYWluaW5nKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFja2V0ID0gdGhpcy5kYXRhO1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YSA9IG5ldyBCdWZmZXIoJycpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLm91dFN0cmVhbUluZm8ud3JpdHRlbiArPSBwYWNrZXQubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHRoaXMub3V0U3RyZWFtSW5mby5saW1pdCA9PT0gdGhpcy5vdXRTdHJlYW1JbmZvLndyaXR0ZW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGVzLlNUQVJUO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5vdXRTdHJlYW1JbmZvLnN0cmVhbS5lbmQocGFja2V0LCBlbmNvZGluZywgY2IpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm91dFN0cmVhbUluZm8uc3RyZWFtLndyaXRlKHBhY2tldCwgZW5jb2RpbmcsIGNiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBwYWNrZXQgPSB0aGlzLmRhdGE7XG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBuZXcgQnVmZmVyKCcnKTtcblxuICAgICAgICAgICAgdGhpcy5vdXRTdHJlYW1JbmZvLndyaXR0ZW4gKz0gcGFja2V0Lmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBvdXRwdXRTdHJlYW0gPSB0aGlzLm91dFN0cmVhbUluZm8uc3RyZWFtO1xuICAgICAgICAgICAgb3V0cHV0U3RyZWFtLndyaXRlKHBhY2tldCwgZW5jb2RpbmcsICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gc3RhdGVzLkZJTEVfREFUQV9FTkQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlcy5TVEFSVDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG91dHB1dFN0cmVhbS5lbmQoY2IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gd2UndmUgd3JpdHRlbiB0byB0aGUgb3V0cHV0IHN0cmVhbSwgbGV0dGluZyB0aGF0IHdyaXRlIGRlYWwgd2l0aCB0aGUgY2FsbGJhY2tcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNiKCk7XG59XG5cblVuemlwU3RyZWFtLnByb3RvdHlwZS5kcmFpbkFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9kcmFpbkFsbEVudHJpZXMgPSB0cnVlO1xufVxuXG5VbnppcFN0cmVhbS5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGlmIChzZWxmLmRhdGEubGVuZ3RoID4gMCkge1xuICAgICAgICBzZWxmLmRhdGEgPSBCdWZmZXIuY29uY2F0KFtzZWxmLmRhdGEsIGNodW5rXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZi5kYXRhID0gY2h1bms7XG4gICAgfVxuXG4gICAgdmFyIHN0YXJ0RGF0YUxlbmd0aCA9IHNlbGYuZGF0YS5sZW5ndGg7XG4gICAgdmFyIGRvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChzZWxmLmRhdGEubGVuZ3RoID4gMCAmJiBzZWxmLmRhdGEubGVuZ3RoIDwgc3RhcnREYXRhTGVuZ3RoKSB7XG4gICAgICAgICAgICBzdGFydERhdGFMZW5ndGggPSBzZWxmLmRhdGEubGVuZ3RoO1xuICAgICAgICAgICAgc2VsZi5fcGFyc2VPck91dHB1dChlbmNvZGluZywgZG9uZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY2IoKTtcbiAgICB9O1xuICAgIHNlbGYuX3BhcnNlT3JPdXRwdXQoZW5jb2RpbmcsIGRvbmUpO1xufVxuXG5VbnppcFN0cmVhbS5wcm90b3R5cGUuX2ZsdXNoID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGlmIChzZWxmLmRhdGEubGVuZ3RoID4gMCkge1xuICAgICAgICBzZWxmLl9wYXJzZU9yT3V0cHV0KCdidWZmZXInLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5kYXRhLmxlbmd0aCA+IDApIHJldHVybiBzZXRJbW1lZGlhdGUoZnVuY3Rpb24gKCkgeyBzZWxmLl9mbHVzaChjYik7IH0pO1xuICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChzZWxmLnN0YXRlID09PSBzdGF0ZXMuRklMRV9EQVRBKSB7XG4gICAgICAgIC8vIHVoIG9oLCBzb21ldGhpbmcgd2VudCB3cm9uZ1xuICAgICAgICByZXR1cm4gY2IobmV3IEVycm9yKFwiU3RyZWFtIGZpbmlzaGVkIGluIGFuIGludmFsaWQgc3RhdGUsIHVuY29tcHJlc3Npb24gZmFpbGVkXCIpKTtcbiAgICB9XG5cbiAgICBzZXRJbW1lZGlhdGUoY2IpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFVuemlwU3RyZWFtO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLlBhcnNlID0gcmVxdWlyZSgnLi9saWIvcGFyc2VyLXN0cmVhbScpO1xuZXhwb3J0cy5FeHRyYWN0ID0gcmVxdWlyZSgnLi9saWIvZXh0cmFjdCcpOyIsIihmdW5jdGlvbihtb2R1bGUpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBtb2R1bGUuZXhwb3J0cy5pc191cmkgPSBpc19pcmk7XG4gICAgbW9kdWxlLmV4cG9ydHMuaXNfaHR0cF91cmkgPSBpc19odHRwX2lyaTtcbiAgICBtb2R1bGUuZXhwb3J0cy5pc19odHRwc191cmkgPSBpc19odHRwc19pcmk7XG4gICAgbW9kdWxlLmV4cG9ydHMuaXNfd2ViX3VyaSA9IGlzX3dlYl9pcmk7XG4gICAgLy8gQ3JlYXRlIGFsaWFzZXNcbiAgICBtb2R1bGUuZXhwb3J0cy5pc1VyaSA9IGlzX2lyaTtcbiAgICBtb2R1bGUuZXhwb3J0cy5pc0h0dHBVcmkgPSBpc19odHRwX2lyaTtcbiAgICBtb2R1bGUuZXhwb3J0cy5pc0h0dHBzVXJpID0gaXNfaHR0cHNfaXJpO1xuICAgIG1vZHVsZS5leHBvcnRzLmlzV2ViVXJpID0gaXNfd2ViX2lyaTtcblxuXG4gICAgLy8gcHJpdmF0ZSBmdW5jdGlvblxuICAgIC8vIGludGVybmFsIFVSSSBzcGl0dGVyIG1ldGhvZCAtIGRpcmVjdCBmcm9tIFJGQyAzOTg2XG4gICAgdmFyIHNwbGl0VXJpID0gZnVuY3Rpb24odXJpKSB7XG4gICAgICAgIHZhciBzcGxpdHRlZCA9IHVyaS5tYXRjaCgvKD86KFteOlxcLz8jXSspOik/KD86XFwvXFwvKFteXFwvPyNdKikpPyhbXj8jXSopKD86XFw/KFteI10qKSk/KD86IyguKikpPy8pO1xuICAgICAgICByZXR1cm4gc3BsaXR0ZWQ7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGlzX2lyaSh2YWx1ZSkge1xuICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjaGVjayBmb3IgaWxsZWdhbCBjaGFyYWN0ZXJzXG4gICAgICAgIGlmICgvW15hLXowLTlcXDpcXC9cXD9cXCNcXFtcXF1cXEBcXCFcXCRcXCZcXCdcXChcXClcXCpcXCtcXCxcXDtcXD1cXC5cXC1cXF9cXH5cXCVdL2kudGVzdCh2YWx1ZSkpIHJldHVybjtcblxuICAgICAgICAvLyBjaGVjayBmb3IgaGV4IGVzY2FwZXMgdGhhdCBhcmVuJ3QgY29tcGxldGVcbiAgICAgICAgaWYgKC8lW14wLTlhLWZdL2kudGVzdCh2YWx1ZSkpIHJldHVybjtcbiAgICAgICAgaWYgKC8lWzAtOWEtZl0oOj9bXjAtOWEtZl18JCkvaS50ZXN0KHZhbHVlKSkgcmV0dXJuO1xuXG4gICAgICAgIHZhciBzcGxpdHRlZCA9IFtdO1xuICAgICAgICB2YXIgc2NoZW1lID0gJyc7XG4gICAgICAgIHZhciBhdXRob3JpdHkgPSAnJztcbiAgICAgICAgdmFyIHBhdGggPSAnJztcbiAgICAgICAgdmFyIHF1ZXJ5ID0gJyc7XG4gICAgICAgIHZhciBmcmFnbWVudCA9ICcnO1xuICAgICAgICB2YXIgb3V0ID0gJyc7XG5cbiAgICAgICAgLy8gZnJvbSBSRkMgMzk4NlxuICAgICAgICBzcGxpdHRlZCA9IHNwbGl0VXJpKHZhbHVlKTtcbiAgICAgICAgc2NoZW1lID0gc3BsaXR0ZWRbMV07IFxuICAgICAgICBhdXRob3JpdHkgPSBzcGxpdHRlZFsyXTtcbiAgICAgICAgcGF0aCA9IHNwbGl0dGVkWzNdO1xuICAgICAgICBxdWVyeSA9IHNwbGl0dGVkWzRdO1xuICAgICAgICBmcmFnbWVudCA9IHNwbGl0dGVkWzVdO1xuXG4gICAgICAgIC8vIHNjaGVtZSBhbmQgcGF0aCBhcmUgcmVxdWlyZWQsIHRob3VnaCB0aGUgcGF0aCBjYW4gYmUgZW1wdHlcbiAgICAgICAgaWYgKCEoc2NoZW1lICYmIHNjaGVtZS5sZW5ndGggJiYgcGF0aC5sZW5ndGggPj0gMCkpIHJldHVybjtcblxuICAgICAgICAvLyBpZiBhdXRob3JpdHkgaXMgcHJlc2VudCwgdGhlIHBhdGggbXVzdCBiZSBlbXB0eSBvciBiZWdpbiB3aXRoIGEgL1xuICAgICAgICBpZiAoYXV0aG9yaXR5ICYmIGF1dGhvcml0eS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICghKHBhdGgubGVuZ3RoID09PSAwIHx8IC9eXFwvLy50ZXN0KHBhdGgpKSkgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaWYgYXV0aG9yaXR5IGlzIG5vdCBwcmVzZW50LCB0aGUgcGF0aCBtdXN0IG5vdCBzdGFydCB3aXRoIC8vXG4gICAgICAgICAgICBpZiAoL15cXC9cXC8vLnRlc3QocGF0aCkpIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNjaGVtZSBtdXN0IGJlZ2luIHdpdGggYSBsZXR0ZXIsIHRoZW4gY29uc2lzdCBvZiBsZXR0ZXJzLCBkaWdpdHMsICssIC4sIG9yIC1cbiAgICAgICAgaWYgKCEvXlthLXpdW2EtejAtOVxcK1xcLVxcLl0qJC8udGVzdChzY2hlbWUudG9Mb3dlckNhc2UoKSkpICByZXR1cm47XG5cbiAgICAgICAgLy8gcmUtYXNzZW1ibGUgdGhlIFVSTCBwZXIgc2VjdGlvbiA1LjMgaW4gUkZDIDM5ODZcbiAgICAgICAgb3V0ICs9IHNjaGVtZSArICc6JztcbiAgICAgICAgaWYgKGF1dGhvcml0eSAmJiBhdXRob3JpdHkubGVuZ3RoKSB7XG4gICAgICAgICAgICBvdXQgKz0gJy8vJyArIGF1dGhvcml0eTtcbiAgICAgICAgfVxuXG4gICAgICAgIG91dCArPSBwYXRoO1xuXG4gICAgICAgIGlmIChxdWVyeSAmJiBxdWVyeS5sZW5ndGgpIHtcbiAgICAgICAgICAgIG91dCArPSAnPycgKyBxdWVyeTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmcmFnbWVudCAmJiBmcmFnbWVudC5sZW5ndGgpIHtcbiAgICAgICAgICAgIG91dCArPSAnIycgKyBmcmFnbWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNfaHR0cF9pcmkodmFsdWUsIGFsbG93SHR0cHMpIHtcbiAgICAgICAgaWYgKCFpc19pcmkodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3BsaXR0ZWQgPSBbXTtcbiAgICAgICAgdmFyIHNjaGVtZSA9ICcnO1xuICAgICAgICB2YXIgYXV0aG9yaXR5ID0gJyc7XG4gICAgICAgIHZhciBwYXRoID0gJyc7XG4gICAgICAgIHZhciBwb3J0ID0gJyc7XG4gICAgICAgIHZhciBxdWVyeSA9ICcnO1xuICAgICAgICB2YXIgZnJhZ21lbnQgPSAnJztcbiAgICAgICAgdmFyIG91dCA9ICcnO1xuXG4gICAgICAgIC8vIGZyb20gUkZDIDM5ODZcbiAgICAgICAgc3BsaXR0ZWQgPSBzcGxpdFVyaSh2YWx1ZSk7XG4gICAgICAgIHNjaGVtZSA9IHNwbGl0dGVkWzFdOyBcbiAgICAgICAgYXV0aG9yaXR5ID0gc3BsaXR0ZWRbMl07XG4gICAgICAgIHBhdGggPSBzcGxpdHRlZFszXTtcbiAgICAgICAgcXVlcnkgPSBzcGxpdHRlZFs0XTtcbiAgICAgICAgZnJhZ21lbnQgPSBzcGxpdHRlZFs1XTtcblxuICAgICAgICBpZiAoIXNjaGVtZSkgIHJldHVybjtcblxuICAgICAgICBpZihhbGxvd0h0dHBzKSB7XG4gICAgICAgICAgICBpZiAoc2NoZW1lLnRvTG93ZXJDYXNlKCkgIT0gJ2h0dHBzJykgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHNjaGVtZS50b0xvd2VyQ2FzZSgpICE9ICdodHRwJykgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZnVsbHktcXVhbGlmaWVkIFVSSXMgbXVzdCBoYXZlIGFuIGF1dGhvcml0eSBzZWN0aW9uIHRoYXQgaXNcbiAgICAgICAgLy8gYSB2YWxpZCBob3N0XG4gICAgICAgIGlmICghYXV0aG9yaXR5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBlbmFibGUgcG9ydCBjb21wb25lbnRcbiAgICAgICAgaWYgKC86KFxcZCspJC8udGVzdChhdXRob3JpdHkpKSB7XG4gICAgICAgICAgICBwb3J0ID0gYXV0aG9yaXR5Lm1hdGNoKC86KFxcZCspJC8pWzBdO1xuICAgICAgICAgICAgYXV0aG9yaXR5ID0gYXV0aG9yaXR5LnJlcGxhY2UoLzpcXGQrJC8sICcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG91dCArPSBzY2hlbWUgKyAnOic7XG4gICAgICAgIG91dCArPSAnLy8nICsgYXV0aG9yaXR5O1xuICAgICAgICBcbiAgICAgICAgaWYgKHBvcnQpIHtcbiAgICAgICAgICAgIG91dCArPSBwb3J0O1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBvdXQgKz0gcGF0aDtcbiAgICAgICAgXG4gICAgICAgIGlmKHF1ZXJ5ICYmIHF1ZXJ5Lmxlbmd0aCl7XG4gICAgICAgICAgICBvdXQgKz0gJz8nICsgcXVlcnk7XG4gICAgICAgIH1cblxuICAgICAgICBpZihmcmFnbWVudCAmJiBmcmFnbWVudC5sZW5ndGgpe1xuICAgICAgICAgICAgb3V0ICs9ICcjJyArIGZyYWdtZW50O1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzX2h0dHBzX2lyaSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gaXNfaHR0cF9pcmkodmFsdWUsIHRydWUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzX3dlYl9pcmkodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIChpc19odHRwX2lyaSh2YWx1ZSkgfHwgaXNfaHR0cHNfaXJpKHZhbHVlKSk7XG4gICAgfVxuXG59KShtb2R1bGUpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiFcbiAqIHdpbmRvdy1zaXplIDxodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC93aW5kb3ctc2l6ZT5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxNSBKb24gU2NobGlua2VydFxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICovXG5cbnZhciB0dHkgPSByZXF1aXJlKCd0dHknKTtcblxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgd2lkdGg7XG4gIHZhciBoZWlnaHQ7XG5cbiAgaWYgKHR0eS5pc2F0dHkoMSkgJiYgdHR5LmlzYXR0eSgyKSkge1xuICAgIGlmIChwcm9jZXNzLnN0ZG91dC5nZXRXaW5kb3dTaXplKSB7XG4gICAgICB3aWR0aCA9IHByb2Nlc3Muc3Rkb3V0LmdldFdpbmRvd1NpemUoMSlbMF07XG4gICAgICBoZWlnaHQgPSBwcm9jZXNzLnN0ZG91dC5nZXRXaW5kb3dTaXplKDEpWzFdO1xuICAgIH0gZWxzZSBpZiAodHR5LmdldFdpbmRvd1NpemUpIHtcbiAgICAgIHdpZHRoID0gdHR5LmdldFdpbmRvd1NpemUoKVsxXTtcbiAgICAgIGhlaWdodCA9IHR0eS5nZXRXaW5kb3dTaXplKClbMF07XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLnN0ZG91dC5jb2x1bW5zICYmIHByb2Nlc3Muc3Rkb3V0LnJvd3MpIHtcbiAgICAgIGhlaWdodCA9IHByb2Nlc3Muc3Rkb3V0LmNvbHVtbnM7XG4gICAgICB3aWR0aCA9IHByb2Nlc3Muc3Rkb3V0LnJvd3M7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIEVycm9yKCd3aW5kb3ctc2l6ZSBjb3VsZCBub3QgZ2V0IHNpemUgd2l0aCB0dHkgb3IgcHJvY2Vzcy5zdGRvdXQuJyk7XG4gIH1cblxuICByZXR1cm4ge2hlaWdodDogaGVpZ2h0LCB3aWR0aDogd2lkdGh9O1xufSkoKTtcbiIsIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICogcmVnaXN0cnkuanMgLSBjb250YWlucyBhIHdyYXBwZXIgZm9yIHRoZSBSRUcgY29tbWFuZCB1bmRlciBXaW5kb3dzLCB3aGljaCBwcm92aWRlcyBhY2Nlc3MgdG8gdGhlIHJlZ2lzdHJ5XHJcbiAqXHJcbiAqIEBhdXRob3IgUGF1bCBCb3R0aW4gYS9rL2EgRnJFc0NcclxuICpcclxuICovXHJcblxyXG4vKiBpbXBvcnRzICovXHJcbnZhciB1dGlsICAgICAgICAgID0gcmVxdWlyZSgndXRpbCcpXHJcbiwgICBwYXRoICAgICAgICAgID0gcmVxdWlyZSgncGF0aCcpXHJcbiwgICBzcGF3biAgICAgICAgID0gcmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpLnNwYXduXHJcblxyXG4vKiBzZXQgdG8gY29uc29sZS5sb2cgZm9yIGRlYnVnZ2luZyAqL1xyXG4sICAgbG9nICAgICAgICAgICA9IGZ1bmN0aW9uICgpIHt9XHJcblxyXG4vKiByZWdpc3RyeSBoaXZlIGlkcyAqL1xyXG4sICAgSEtMTSAgICAgICAgICA9ICdIS0xNJ1xyXG4sICAgSEtDVSAgICAgICAgICA9ICdIS0NVJ1xyXG4sICAgSEtDUiAgICAgICAgICA9ICdIS0NSJ1xyXG4sICAgSEtVICAgICAgICAgICA9ICdIS1UnXHJcbiwgICBIS0NDICAgICAgICAgID0gJ0hLQ0MnXHJcbiwgICBISVZFUyAgICAgICAgID0gWyBIS0xNLCBIS0NVLCBIS0NSLCBIS1UsIEhLQ0MgXVxyXG5cclxuLyogcmVnaXN0cnkgdmFsdWUgdHlwZSBpZHMgKi9cclxuLCAgIFJFR19TWiAgICAgICAgPSAnUkVHX1NaJ1xyXG4sICAgUkVHX01VTFRJX1NaICA9ICdSRUdfTVVMVElfU1onXHJcbiwgICBSRUdfRVhQQU5EX1NaID0gJ1JFR19FWFBBTkRfU1onXHJcbiwgICBSRUdfRFdPUkQgICAgID0gJ1JFR19EV09SRCdcclxuLCAgIFJFR19RV09SRCAgICAgPSAnUkVHX1FXT1JEJ1xyXG4sICAgUkVHX0JJTkFSWSAgICA9ICdSRUdfQklOQVJZJ1xyXG4sICAgUkVHX05PTkUgICAgICA9ICdSRUdfTk9ORSdcclxuLCAgIFJFR19UWVBFUyAgICAgPSBbIFJFR19TWiwgUkVHX01VTFRJX1NaLCBSRUdfRVhQQU5EX1NaLCBSRUdfRFdPUkQsIFJFR19RV09SRCwgUkVHX0JJTkFSWSwgUkVHX05PTkUgXVxyXG5cclxuLyogZGVmYXVsdCByZWdpc3RyeSB2YWx1ZSBuYW1lICovXHJcbiwgICBERUZBVUxUX1ZBTFVFID0gJydcclxuXHJcbi8qIGdlbmVyYWwga2V5IHBhdHRlcm4gKi9cclxuLCAgIEtFWV9QQVRURVJOICAgPSAvKFxcXFxbYS16QS1aMC05X1xcc10rKSovXHJcblxyXG4vKiBrZXkgcGF0aCBwYXR0ZXJuIChhcyByZXR1cm5lZCBieSBSRUctY2xpKSAqL1xyXG4sICAgUEFUSF9QQVRURVJOICA9IC9eKEhLRVlfTE9DQUxfTUFDSElORXxIS0VZX0NVUlJFTlRfVVNFUnxIS0VZX0NMQVNTRVNfUk9PVHxIS0VZX1VTRVJTfEhLRVlfQ1VSUkVOVF9DT05GSUcpKC4qKSQvXHJcblxyXG4vKiByZWdpc3RyeSBpdGVtIHBhdHRlcm4gKi9cclxuLCAgIElURU1fUEFUVEVSTiAgPSAvXiguKilcXHMoUkVHX1NafFJFR19NVUxUSV9TWnxSRUdfRVhQQU5EX1NafFJFR19EV09SRHxSRUdfUVdPUkR8UkVHX0JJTkFSWXxSRUdfTk9ORSlcXHMrKFteXFxzXS4qKSQvXHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhbiBFcnJvciBvYmplY3QgdGhhdCBjb250YWlucyB0aGUgZXhpdCBjb2RlIG9mIHRoZSBSRUcuRVhFIHByb2Nlc3MuXHJcbiAqIFRoaXMgY29udHJ1Y3RvciBpcyBwcml2YXRlLiBPYmplY3RzIG9mIHRoaXMgdHlwZSBhcmUgY3JlYXRlZCBpbnRlcm5hbGx5IGFuZCByZXR1cm5lZCBpbiB0aGUgPGNvZGU+ZXJyPC9jb2RlPiBwYXJhbWV0ZXJzIGluIGNhc2UgdGhlIFJFRy5FWEUgcHJvY2VzcyBkb2Vzbid0IGV4aXQgY2xlYW5seS5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQGNsYXNzXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIC0gdGhlIGVycm9yIG1lc3NhZ2VcclxuICogQHBhcmFtIHtudW1iZXJ9IGNvZGUgLSB0aGUgcHJvY2VzcyBleGl0IGNvZGVcclxuICpcclxuICovXHJcbmZ1bmN0aW9uIFByb2Nlc3NVbmNsZWFuRXhpdEVycm9yKG1lc3NhZ2UsIGNvZGUpIHtcclxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUHJvY2Vzc1VuY2xlYW5FeGl0RXJyb3IpKVxyXG4gICAgcmV0dXJuIG5ldyBQcm9jZXNzVW5jbGVhbkV4aXRFcnJvcihtZXNzYWdlLCBjb2RlKTtcclxuXHJcbiAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgUHJvY2Vzc1VuY2xlYW5FeGl0RXJyb3IpO1xyXG5cclxuICAvKipcclxuICAgKiBUaGUgZXJyb3IgbmFtZS5cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKiBAbWVtYmVyIHtzdHJpbmd9IFByb2Nlc3NVbmNsZWFuRXhpdEVycm9yI25hbWVcclxuICAgKi9cclxuICB0aGlzLl9fZGVmaW5lR2V0dGVyX18oJ25hbWUnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBQcm9jZXNzVW5jbGVhbkV4aXRFcnJvci5uYW1lOyB9KTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIGVycm9yIG1lc3NhZ2UuXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICogQG1lbWJlciB7c3RyaW5nfSBQcm9jZXNzVW5jbGVhbkV4aXRFcnJvciNtZXNzYWdlXHJcbiAgICovXHJcbiAgdGhpcy5fX2RlZmluZUdldHRlcl9fKCdtZXNzYWdlJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZTsgfSk7XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSBwcm9jZXNzIGV4aXQgY29kZS5cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKiBAbWVtYmVyIHtudW1iZXJ9IFByb2Nlc3NVbmNsZWFuRXhpdEVycm9yI2NvZGVcclxuICAgKi9cclxuICB0aGlzLl9fZGVmaW5lR2V0dGVyX18oJ2NvZGUnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlOyB9KTtcclxuXHJcbn1cclxuXHJcbnV0aWwuaW5oZXJpdHMoUHJvY2Vzc1VuY2xlYW5FeGl0RXJyb3IsIEVycm9yKTtcclxuXHJcbi8qXHJcbiAqIENhcHR1cmVzIHN0ZG91dC9zdGRlcnIgZm9yIGEgY2hpbGQgcHJvY2Vzc1xyXG4gKi9cclxuZnVuY3Rpb24gY2FwdHVyZU91dHB1dChjaGlsZCkge1xyXG4gIC8vIFVzZSBhIG11dGFibGUgZGF0YSBzdHJ1Y3R1cmUgc28gd2UgY2FuIGFwcGVuZCBhcyB3ZSBnZXQgbmV3IGRhdGEgYW5kIGhhdmVcclxuICAvLyB0aGUgY2FsbGluZyBjb250ZXh0IHNlZSB0aGUgbmV3IGRhdGFcclxuICB2YXIgb3V0cHV0ID0geydzdGRvdXQnOiAnJywgJ3N0ZGVycic6ICcnfTtcclxuXHJcbiAgY2hpbGQuc3Rkb3V0Lm9uKCdkYXRhJywgZnVuY3Rpb24oZGF0YSkgeyBvdXRwdXRbXCJzdGRvdXRcIl0gKz0gZGF0YS50b1N0cmluZygpOyB9KTtcclxuICBjaGlsZC5zdGRlcnIub24oJ2RhdGEnLCBmdW5jdGlvbihkYXRhKSB7IG91dHB1dFtcInN0ZGVyclwiXSArPSBkYXRhLnRvU3RyaW5nKCk7IH0pO1xyXG5cclxuICByZXR1cm4gb3V0cHV0O1xyXG59XHJcblxyXG5cclxuLypcclxuICogUmV0dXJucyBhbiBlcnJvciBtZXNzYWdlIGNvbnRhaW5pbmcgdGhlIHN0ZG91dC9zdGRlcnIgb2YgdGhlIGNoaWxkIHByb2Nlc3NcclxuICovXHJcbmZ1bmN0aW9uIG1rRXJyb3JNc2cocmVnaXN0cnlDb21tYW5kLCBjb2RlLCBvdXRwdXQpIHtcclxuICAgIHZhciBzdGRvdXQgPSBvdXRwdXRbJ3N0ZG91dCddLnRyaW0oKTtcclxuICAgIHZhciBzdGRlcnIgPSBvdXRwdXRbJ3N0ZGVyciddLnRyaW0oKTtcclxuXHJcbiAgICB2YXIgbXNnID0gdXRpbC5mb3JtYXQoXCIlcyBjb21tYW5kIGV4aXRlZCB3aXRoIGNvZGUgJWQ6XFxuJXNcXG4lc1wiLCByZWdpc3RyeUNvbW1hbmQsIGNvZGUsIHN0ZG91dCwgc3RkZXJyKTtcclxuICAgIHJldHVybiBuZXcgUHJvY2Vzc1VuY2xlYW5FeGl0RXJyb3IobXNnLCBjb2RlKTtcclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIENvbnZlcnRzIHg4Ni94NjQgdG8gMzIvNjRcclxuICovXHJcbmZ1bmN0aW9uIGNvbnZlcnRBcmNoU3RyaW5nKGFyY2hTdHJpbmcpIHtcclxuICBpZiAoYXJjaFN0cmluZyA9PSAneDY0Jykge1xyXG4gICAgcmV0dXJuICc2NCc7XHJcbiAgfSBlbHNlIGlmIChhcmNoU3RyaW5nID09ICd4ODYnKSB7XHJcbiAgICByZXR1cm4gJzMyJztcclxuICB9IGVsc2Uge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbGxlZ2FsIGFyY2hpdGVjdHVyZTogJyArIGFyY2hTdHJpbmcgKyAnICh1c2UgeDg2IG9yIHg2NCknKTtcclxuICB9XHJcbn1cclxuXHJcblxyXG4vKlxyXG4gKiBBZGRzIGNvcnJlY3QgYXJjaGl0ZWN0dXJlIHRvIHJlZyBhcmdzXHJcbiAqL1xyXG5mdW5jdGlvbiBwdXNoQXJjaChhcmdzLCBhcmNoKSB7XHJcbiAgaWYgKGFyY2gpIHtcclxuICAgIGFyZ3MucHVzaCgnL3JlZzonICsgY29udmVydEFyY2hTdHJpbmcoYXJjaCkpO1xyXG4gIH1cclxufVxyXG5cclxuLypcclxuICogR2V0IHRoZSBwYXRoIHRvIHN5c3RlbSdzIHJlZy5leGUuIFVzZWZ1bCB3aGVuIGFub3RoZXIgcmVnLmV4ZSBpcyBhZGRlZCB0byB0aGUgUEFUSFxyXG4gKiBJbXBsZW1lbnRlZCBvbmx5IGZvciBXaW5kb3dzXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRSZWdFeGVQYXRoKCkge1xyXG4gICAgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicpIHtcclxuICAgICAgICByZXR1cm4gcGF0aC5qb2luKHByb2Nlc3MuZW52LndpbmRpciwgJ3N5c3RlbTMyJywgJ3JlZy5leGUnKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIFwiUkVHXCI7XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIHNpbmdsZSByZWdpc3RyeSB2YWx1ZSByZWNvcmQuXHJcbiAqIFRoaXMgY29udHJ1Y3RvciBpcyBwcml2YXRlLiBPYmplY3RzIG9mIHRoaXMgdHlwZSBhcmUgY3JlYXRlZCBpbnRlcm5hbGx5IGFuZCByZXR1cm5lZCBieSBtZXRob2RzIG9mIHtAbGluayBSZWdpc3RyeX0gb2JqZWN0cy5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQGNsYXNzXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBob3N0IC0gdGhlIGhvc3RuYW1lXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBoaXZlIC0gdGhlIGhpdmUgaWRcclxuICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIHRoZSByZWdpc3RyeSBrZXlcclxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSB0aGUgdmFsdWUgbmFtZVxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIHRoZSB2YWx1ZSB0eXBlXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSAtIHRoZSB2YWx1ZVxyXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJjaCAtIHRoZSBoaXZlIGFyY2hpdGVjdHVyZSAoJ3g4Nicgb3IgJ3g2NCcpXHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiBSZWdpc3RyeUl0ZW0gKGhvc3QsIGhpdmUsIGtleSwgbmFtZSwgdHlwZSwgdmFsdWUsIGFyY2gpIHtcclxuXHJcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlZ2lzdHJ5SXRlbSkpXHJcbiAgICByZXR1cm4gbmV3IFJlZ2lzdHJ5SXRlbShob3N0LCBoaXZlLCBrZXksIG5hbWUsIHR5cGUsIHZhbHVlLCBhcmNoKTtcclxuXHJcbiAgLyogcHJpdmF0ZSBtZW1iZXJzICovXHJcbiAgdmFyIF9ob3N0ID0gaG9zdCAgICAvLyBob3N0bmFtZVxyXG4gICwgICBfaGl2ZSA9IGhpdmUgICAgLy8gcmVnaXN0cnkgaGl2ZVxyXG4gICwgICBfa2V5ID0ga2V5ICAgICAgLy8gcmVnaXN0cnkga2V5XHJcbiAgLCAgIF9uYW1lID0gbmFtZSAgICAvLyBwcm9wZXJ0eSBuYW1lXHJcbiAgLCAgIF90eXBlID0gdHlwZSAgICAvLyBwcm9wZXJ0eSB0eXBlXHJcbiAgLCAgIF92YWx1ZSA9IHZhbHVlICAvLyBwcm9wZXJ0eSB2YWx1ZVxyXG4gICwgICBfYXJjaCA9IGFyY2ggICAgLy8gaGl2ZSBhcmNoaXRlY3R1cmVcclxuXHJcbiAgLyogZ2V0dGVycy9zZXR0ZXJzICovXHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSBob3N0bmFtZS5cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKiBAbWVtYmVyIHtzdHJpbmd9IFJlZ2lzdHJ5SXRlbSNob3N0XHJcbiAgICovXHJcbiAgdGhpcy5fX2RlZmluZUdldHRlcl9fKCdob3N0JywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX2hvc3Q7IH0pO1xyXG5cclxuICAvKipcclxuICAgKiBUaGUgaGl2ZSBpZC5cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKiBAbWVtYmVyIHtzdHJpbmd9IFJlZ2lzdHJ5SXRlbSNoaXZlXHJcbiAgICovXHJcbiAgdGhpcy5fX2RlZmluZUdldHRlcl9fKCdoaXZlJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX2hpdmU7IH0pO1xyXG5cclxuICAvKipcclxuICAgKiBUaGUgcmVnaXN0cnkga2V5LlxyXG4gICAqIEByZWFkb25seVxyXG4gICAqIEBtZW1iZXIge3N0cmluZ30gUmVnaXN0cnlJdGVtI2tleVxyXG4gICAqL1xyXG4gIHRoaXMuX19kZWZpbmVHZXR0ZXJfXygna2V5JywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX2tleTsgfSk7XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSB2YWx1ZSBuYW1lLlxyXG4gICAqIEByZWFkb25seVxyXG4gICAqIEBtZW1iZXIge3N0cmluZ30gUmVnaXN0cnlJdGVtI25hbWVcclxuICAgKi9cclxuICB0aGlzLl9fZGVmaW5lR2V0dGVyX18oJ25hbWUnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfbmFtZTsgfSk7XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSB2YWx1ZSB0eXBlLlxyXG4gICAqIEByZWFkb25seVxyXG4gICAqIEBtZW1iZXIge3N0cmluZ30gUmVnaXN0cnlJdGVtI3R5cGVcclxuICAgKi9cclxuICB0aGlzLl9fZGVmaW5lR2V0dGVyX18oJ3R5cGUnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdHlwZTsgfSk7XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSB2YWx1ZS5cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKiBAbWVtYmVyIHtzdHJpbmd9IFJlZ2lzdHJ5SXRlbSN2YWx1ZVxyXG4gICAqL1xyXG4gIHRoaXMuX19kZWZpbmVHZXR0ZXJfXygndmFsdWUnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdmFsdWU7IH0pO1xyXG5cclxuICAvKipcclxuICAgKiBUaGUgaGl2ZSBhcmNoaXRlY3R1cmUuXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICogQG1lbWJlciB7c3RyaW5nfSBSZWdpc3RyeUl0ZW0jYXJjaFxyXG4gICAqL1xyXG4gIHRoaXMuX19kZWZpbmVHZXR0ZXJfXygnYXJjaCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9hcmNoOyB9KTtcclxuXHJcbn1cclxuXHJcbnV0aWwuaW5oZXJpdHMoUmVnaXN0cnlJdGVtLCBPYmplY3QpO1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSByZWdpc3RyeSBvYmplY3QsIHdoaWNoIHByb3ZpZGVzIGFjY2VzcyB0byBhIHNpbmdsZSByZWdpc3RyeSBrZXkuXHJcbiAqIE5vdGU6IFRoaXMgY2xhc3MgaXMgcmV0dXJuZWQgYnkgYSBjYWxsIHRvIGBgYHJlcXVpcmUoJ3dpbnJlZycpYGBgLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqIEBjbGFzc1xyXG4gKlxyXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIHRoZSBvcHRpb25zXHJcbiAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0aW9ucy5ob3N0IC0gdGhlIGhvc3RuYW1lXHJcbiAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0aW9ucy5oaXZlIC0gdGhlIGhpdmUgaWRcclxuICogQHBhcmFtIHtzdHJpbmc9fSBvcHRpb25zLmtleSAtIHRoZSByZWdpc3RyeSBrZXlcclxuICogQHBhcmFtIHtzdHJpbmc9fSBvcHRpb25zLmFyY2ggLSB0aGUgb3B0aW9uYWwgcmVnaXN0cnkgaGl2ZSBhcmNoaXRlY3R1cmUgKCd4ODYnIG9yICd4NjQnOyBvbmx5IHZhbGlkIG9uIFdpbmRvd3MgNjQgQml0IE9wZXJhdGluZyBTeXN0ZW1zKVxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiB2YXIgUmVnaXN0cnkgPSByZXF1aXJlKCd3aW5yZWcnKVxyXG4gKiAsICAgYXV0b1N0YXJ0Q3VycmVudFVzZXIgPSBuZXcgUmVnaXN0cnkoe1xyXG4gKiAgICAgICBoaXZlOiBSZWdpc3RyeS5IS0NVLFxyXG4gKiAgICAgICBrZXk6ICAnXFxcXFNvZnR3YXJlXFxcXE1pY3Jvc29mdFxcXFxXaW5kb3dzXFxcXEN1cnJlbnRWZXJzaW9uXFxcXFJ1bidcclxuICogICAgIH0pO1xyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gUmVnaXN0cnkgKG9wdGlvbnMpIHtcclxuXHJcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlZ2lzdHJ5KSlcclxuICAgIHJldHVybiBuZXcgUmVnaXN0cnkob3B0aW9ucyk7XHJcblxyXG4gIC8qIHByaXZhdGUgbWVtYmVycyAqL1xyXG4gIHZhciBfb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cclxuICAsICAgX2hvc3QgPSAnJyArIChfb3B0aW9ucy5ob3N0IHx8ICcnKSAgICAvLyBob3N0bmFtZVxyXG4gICwgICBfaGl2ZSA9ICcnICsgKF9vcHRpb25zLmhpdmUgfHwgSEtMTSkgIC8vIHJlZ2lzdHJ5IGhpdmVcclxuICAsICAgX2tleSAgPSAnJyArIChfb3B0aW9ucy5rZXkgIHx8ICcnKSAgICAvLyByZWdpc3RyeSBrZXlcclxuICAsICAgX2FyY2ggPSBfb3B0aW9ucy5hcmNoIHx8IG51bGwgICAgICAgICAvLyBoaXZlIGFyY2hpdGVjdHVyZVxyXG5cclxuICAvKiBnZXR0ZXJzL3NldHRlcnMgKi9cclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIGhvc3RuYW1lLlxyXG4gICAqIEByZWFkb25seVxyXG4gICAqIEBtZW1iZXIge3N0cmluZ30gUmVnaXN0cnkjaG9zdFxyXG4gICAqL1xyXG4gIHRoaXMuX19kZWZpbmVHZXR0ZXJfXygnaG9zdCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9ob3N0OyB9KTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIGhpdmUgaWQuXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICogQG1lbWJlciB7c3RyaW5nfSBSZWdpc3RyeSNoaXZlXHJcbiAgICovXHJcbiAgdGhpcy5fX2RlZmluZUdldHRlcl9fKCdoaXZlJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX2hpdmU7IH0pO1xyXG5cclxuICAvKipcclxuICAgKiBUaGUgcmVnaXN0cnkga2V5IG5hbWUuXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICogQG1lbWJlciB7c3RyaW5nfSBSZWdpc3RyeSNrZXlcclxuICAgKi9cclxuICB0aGlzLl9fZGVmaW5lR2V0dGVyX18oJ2tleScsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9rZXk7IH0pO1xyXG5cclxuICAvKipcclxuICAgKiBUaGUgZnVsbCBwYXRoIHRvIHRoZSByZWdpc3RyeSBrZXkuXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICogQG1lbWJlciB7c3RyaW5nfSBSZWdpc3RyeSNwYXRoXHJcbiAgICovXHJcbiAgdGhpcy5fX2RlZmluZUdldHRlcl9fKCdwYXRoJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gKF9ob3N0Lmxlbmd0aCA9PSAwID8gJycgOiAnXFxcXFxcXFwnICsgX2hvc3QgKyAnXFxcXCcpICsgX2hpdmUgKyBfa2V5OyB9KTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIHJlZ2lzdHJ5IGhpdmUgYXJjaGl0ZWN0dXJlICgneDg2JyBvciAneDY0JykuXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICogQG1lbWJlciB7c3RyaW5nfSBSZWdpc3RyeSNhcmNoXHJcbiAgICovXHJcbiAgdGhpcy5fX2RlZmluZUdldHRlcl9fKCdhcmNoJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX2FyY2g7IH0pO1xyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIGEgbmV3IHtAbGluayBSZWdpc3RyeX0gaW5zdGFuY2UgdGhhdCBwb2ludHMgdG8gdGhlIHBhcmVudCByZWdpc3RyeSBrZXkuXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICogQG1lbWJlciB7UmVnaXN0cnl9IFJlZ2lzdHJ5I3BhcmVudFxyXG4gICAqL1xyXG4gIHRoaXMuX19kZWZpbmVHZXR0ZXJfXygncGFyZW50JywgZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGkgPSBfa2V5Lmxhc3RJbmRleE9mKCdcXFxcJylcclxuICAgIHJldHVybiBuZXcgUmVnaXN0cnkoe1xyXG4gICAgICBob3N0OiB0aGlzLmhvc3QsXHJcbiAgICAgIGhpdmU6IHRoaXMuaGl2ZSxcclxuICAgICAga2V5OiAgKGkgPT0gLTEpPycnOl9rZXkuc3Vic3RyaW5nKDAsIGkpLFxyXG4gICAgICBhcmNoOiB0aGlzLmFyY2hcclxuICAgIH0pO1xyXG4gIH0pO1xyXG5cclxuICAvLyB2YWxpZGF0ZSBvcHRpb25zLi4uXHJcbiAgaWYgKEhJVkVTLmluZGV4T2YoX2hpdmUpID09IC0xKVxyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbGxlZ2FsIGhpdmUgc3BlY2lmaWVkLicpO1xyXG5cclxuICBpZiAoIUtFWV9QQVRURVJOLnRlc3QoX2tleSkpXHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2lsbGVnYWwga2V5IHNwZWNpZmllZC4nKTtcclxuXHJcbiAgaWYgKF9hcmNoICYmIF9hcmNoICE9ICd4NjQnICYmIF9hcmNoICE9ICd4ODYnKVxyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbGxlZ2FsIGFyY2hpdGVjdHVyZSBzcGVjaWZpZWQgKHVzZSB4ODYgb3IgeDY0KScpO1xyXG5cclxufVxyXG5cclxuLyoqXHJcbiAqIFJlZ2lzdHJ5IGhpdmUga2V5IEhLRVlfTE9DQUxfTUFDSElORS5cclxuICogTm90ZTogRm9yIHdyaXRpbmcgdG8gdGhpcyBoaXZlIHlvdXIgcHJvZ3JhbSBoYXMgdG8gcnVuIHdpdGggYWRtaW4gcHJpdmlsZWdlcy5cclxuICogQHR5cGUge3N0cmluZ31cclxuICovXHJcblJlZ2lzdHJ5LkhLTE0gPSBIS0xNO1xyXG5cclxuLyoqXHJcbiAqIFJlZ2lzdHJ5IGhpdmUga2V5IEhLRVlfQ1VSUkVOVF9VU0VSLlxyXG4gKiBAdHlwZSB7c3RyaW5nfVxyXG4gKi9cclxuUmVnaXN0cnkuSEtDVSA9IEhLQ1U7XHJcblxyXG4vKipcclxuICogUmVnaXN0cnkgaGl2ZSBrZXkgSEtFWV9DTEFTU0VTX1JPT1QuXHJcbiAqIE5vdGU6IEZvciB3cml0aW5nIHRvIHRoaXMgaGl2ZSB5b3VyIHByb2dyYW0gaGFzIHRvIHJ1biB3aXRoIGFkbWluIHByaXZpbGVnZXMuXHJcbiAqIEB0eXBlIHtzdHJpbmd9XHJcbiAqL1xyXG5SZWdpc3RyeS5IS0NSID0gSEtDUjtcclxuXHJcbi8qKlxyXG4gKiBSZWdpc3RyeSBoaXZlIGtleSBIS0VZX1VTRVJTLlxyXG4gKiBOb3RlOiBGb3Igd3JpdGluZyB0byB0aGlzIGhpdmUgeW91ciBwcm9ncmFtIGhhcyB0byBydW4gd2l0aCBhZG1pbiBwcml2aWxlZ2VzLlxyXG4gKiBAdHlwZSB7c3RyaW5nfVxyXG4gKi9cclxuUmVnaXN0cnkuSEtVID0gSEtVO1xyXG5cclxuLyoqXHJcbiAqIFJlZ2lzdHJ5IGhpdmUga2V5IEhLRVlfQ1VSUkVOVF9DT05GSUcuXHJcbiAqIE5vdGU6IEZvciB3cml0aW5nIHRvIHRoaXMgaGl2ZSB5b3VyIHByb2dyYW0gaGFzIHRvIHJ1biB3aXRoIGFkbWluIHByaXZpbGVnZXMuXHJcbiAqIEB0eXBlIHtzdHJpbmd9XHJcbiAqL1xyXG5SZWdpc3RyeS5IS0NDID0gSEtDQztcclxuXHJcbi8qKlxyXG4gKiBDb2xsZWN0aW9uIG9mIGF2YWlsYWJsZSByZWdpc3RyeSBoaXZlIGtleXMuXHJcbiAqIEB0eXBlIHthcnJheX1cclxuICovXHJcblJlZ2lzdHJ5LkhJVkVTID0gSElWRVM7XHJcblxyXG4vKipcclxuICogUmVnaXN0cnkgdmFsdWUgdHlwZSBTVFJJTkcuXHJcbiAqIEB0eXBlIHtzdHJpbmd9XHJcbiAqL1xyXG5SZWdpc3RyeS5SRUdfU1ogPSBSRUdfU1o7XHJcblxyXG4vKipcclxuICogUmVnaXN0cnkgdmFsdWUgdHlwZSBNVUxUSUxJTkVfU1RSSU5HLlxyXG4gKiBAdHlwZSB7c3RyaW5nfVxyXG4gKi9cclxuUmVnaXN0cnkuUkVHX01VTFRJX1NaID0gUkVHX01VTFRJX1NaO1xyXG5cclxuLyoqXHJcbiAqIFJlZ2lzdHJ5IHZhbHVlIHR5cGUgRVhQQU5EQUJMRV9TVFJJTkcuXHJcbiAqIEB0eXBlIHtzdHJpbmd9XHJcbiAqL1xyXG5SZWdpc3RyeS5SRUdfRVhQQU5EX1NaID0gUkVHX0VYUEFORF9TWjtcclxuXHJcbi8qKlxyXG4gKiBSZWdpc3RyeSB2YWx1ZSB0eXBlIERPVUJMRV9XT1JELlxyXG4gKiBAdHlwZSB7c3RyaW5nfVxyXG4gKi9cclxuUmVnaXN0cnkuUkVHX0RXT1JEID0gUkVHX0RXT1JEO1xyXG5cclxuLyoqXHJcbiAqIFJlZ2lzdHJ5IHZhbHVlIHR5cGUgUVVBRF9XT1JELlxyXG4gKiBAdHlwZSB7c3RyaW5nfVxyXG4gKi9cclxuUmVnaXN0cnkuUkVHX1FXT1JEID0gUkVHX1FXT1JEO1xyXG5cclxuLyoqXHJcbiAqIFJlZ2lzdHJ5IHZhbHVlIHR5cGUgQklOQVJZLlxyXG4gKiBAdHlwZSB7c3RyaW5nfVxyXG4gKi9cclxuUmVnaXN0cnkuUkVHX0JJTkFSWSA9IFJFR19CSU5BUlk7XHJcblxyXG4vKipcclxuICogUmVnaXN0cnkgdmFsdWUgdHlwZSBVTktOT1dOLlxyXG4gKiBAdHlwZSB7c3RyaW5nfVxyXG4gKi9cclxuUmVnaXN0cnkuUkVHX05PTkUgPSBSRUdfTk9ORTtcclxuXHJcbi8qKlxyXG4gKiBDb2xsZWN0aW9uIG9mIGF2YWlsYWJsZSByZWdpc3RyeSB2YWx1ZSB0eXBlcy5cclxuICogQHR5cGUge2FycmF5fVxyXG4gKi9cclxuUmVnaXN0cnkuUkVHX1RZUEVTID0gUkVHX1RZUEVTO1xyXG5cclxuLyoqXHJcbiAqIFRoZSBuYW1lIG9mIHRoZSBkZWZhdWx0IHZhbHVlLiBNYXkgYmUgdXNlZCBpbnN0ZWFkIG9mIHRoZSBlbXB0eSBzdHJpbmcgbGl0ZXJhbCBmb3IgYmV0dGVyIHJlYWRhYmlsaXR5LlxyXG4gKiBAdHlwZSB7c3RyaW5nfVxyXG4gKi9cclxuUmVnaXN0cnkuREVGQVVMVF9WQUxVRSA9IERFRkFVTFRfVkFMVUU7XHJcblxyXG4vKipcclxuICogUmV0cmlldmUgYWxsIHZhbHVlcyBmcm9tIHRoaXMgcmVnaXN0cnkga2V5LlxyXG4gKiBAcGFyYW0ge3ZhbHVlc0NhbGxiYWNrfSBjYiAtIGNhbGxiYWNrIGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7UHJvY2Vzc1VuY2xlYW5FeGl0RXJyb3I9fSBjYi5lcnIgLSBlcnJvciBvYmplY3Qgb3IgbnVsbCBpZiBzdWNjZXNzZnVsXHJcbiAqIEBwYXJhbSB7YXJyYXk9fSBjYi5pdGVtcyAtIGFuIGFycmF5IG9mIHtAbGluayBSZWdpc3RyeUl0ZW19IG9iamVjdHNcclxuICogQHJldHVybnMge1JlZ2lzdHJ5fSB0aGlzIHJlZ2lzdHJ5IGtleSBvYmplY3RcclxuICovXHJcblJlZ2lzdHJ5LnByb3RvdHlwZS52YWx1ZXMgPSBmdW5jdGlvbiB2YWx1ZXMgKGNiKSB7XHJcblxyXG4gIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpXHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtdXN0IHNwZWNpZnkgYSBjYWxsYmFjaycpO1xyXG5cclxuICB2YXIgYXJncyA9IFsgJ1FVRVJZJywgdGhpcy5wYXRoIF07XHJcblxyXG4gIHB1c2hBcmNoKGFyZ3MsIHRoaXMuYXJjaCk7XHJcblxyXG4gIHZhciBwcm9jID0gc3Bhd24oZ2V0UmVnRXhlUGF0aCgpLCBhcmdzLCB7XHJcbiAgICAgICAgY3dkOiB1bmRlZmluZWQsXHJcbiAgICAgICAgZW52OiBwcm9jZXNzLmVudixcclxuICAgICAgICBzdGRpbzogWyAnaWdub3JlJywgJ3BpcGUnLCAncGlwZScgXVxyXG4gICAgICB9KVxyXG4gICwgICBidWZmZXIgPSAnJ1xyXG4gICwgICBzZWxmID0gdGhpc1xyXG4gICwgICBlcnJvciA9IG51bGwgLy8gbnVsbCBtZWFucyBubyBlcnJvciBwcmV2aW91c2x5IHJlcG9ydGVkLlxyXG5cclxuICB2YXIgb3V0cHV0ID0gY2FwdHVyZU91dHB1dChwcm9jKTtcclxuXHJcbiAgcHJvYy5vbignY2xvc2UnLCBmdW5jdGlvbiAoY29kZSkge1xyXG4gICAgaWYgKGVycm9yKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH0gZWxzZSBpZiAoY29kZSAhPT0gMCkge1xyXG4gICAgICBsb2coJ3Byb2Nlc3MgZXhpdGVkIHdpdGggY29kZSAnICsgY29kZSk7XHJcbiAgICAgIGNiKG1rRXJyb3JNc2coJ1FVRVJZJywgY29kZSwgb3V0cHV0KSwgbnVsbCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB2YXIgaXRlbXMgPSBbXVxyXG4gICAgICAsICAgcmVzdWx0ID0gW11cclxuICAgICAgLCAgIGxpbmVzID0gYnVmZmVyLnNwbGl0KCdcXG4nKVxyXG4gICAgICAsICAgbGluZU51bWJlciA9IDBcclxuXHJcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbGluZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgdmFyIGxpbmUgPSBsaW5lc1tpXS50cmltKCk7XHJcbiAgICAgICAgaWYgKGxpbmUubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgbG9nKGxpbmUpO1xyXG4gICAgICAgICAgaWYgKGxpbmVOdW1iZXIgIT0gMCkge1xyXG4gICAgICAgICAgICBpdGVtcy5wdXNoKGxpbmUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgKytsaW5lTnVtYmVyO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBpdGVtcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuXHJcbiAgICAgICAgdmFyIG1hdGNoID0gSVRFTV9QQVRURVJOLmV4ZWMoaXRlbXNbaV0pXHJcbiAgICAgICAgLCAgIG5hbWVcclxuICAgICAgICAsICAgdHlwZVxyXG4gICAgICAgICwgICB2YWx1ZVxyXG5cclxuICAgICAgICBpZiAobWF0Y2gpIHtcclxuICAgICAgICAgIG5hbWUgPSBtYXRjaFsxXS50cmltKCk7XHJcbiAgICAgICAgICB0eXBlID0gbWF0Y2hbMl0udHJpbSgpO1xyXG4gICAgICAgICAgdmFsdWUgPSBtYXRjaFszXTtcclxuICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyBSZWdpc3RyeUl0ZW0oc2VsZi5ob3N0LCBzZWxmLmhpdmUsIHNlbGYua2V5LCBuYW1lLCB0eXBlLCB2YWx1ZSwgc2VsZi5hcmNoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBjYihudWxsLCByZXN1bHQpO1xyXG5cclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgcHJvYy5zdGRvdXQub24oJ2RhdGEnLCBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgYnVmZmVyICs9IGRhdGEudG9TdHJpbmcoKTtcclxuICB9KTtcclxuXHJcbiAgcHJvYy5vbignZXJyb3InLCBmdW5jdGlvbihlcnIpIHtcclxuICAgIGVycm9yID0gZXJyO1xyXG4gICAgY2IoZXJyKTtcclxuICB9KTtcclxuXHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0cmlldmUgYWxsIHN1YmtleXMgZnJvbSB0aGlzIHJlZ2lzdHJ5IGtleS5cclxuICogQHBhcmFtIHtmdW5jdGlvbiAoZXJyLCBpdGVtcyl9IGNiIC0gY2FsbGJhY2sgZnVuY3Rpb25cclxuICogQHBhcmFtIHtQcm9jZXNzVW5jbGVhbkV4aXRFcnJvcj19IGNiLmVyciAtIGVycm9yIG9iamVjdCBvciBudWxsIGlmIHN1Y2Nlc3NmdWxcclxuICogQHBhcmFtIHthcnJheT19IGNiLml0ZW1zIC0gYW4gYXJyYXkgb2Yge0BsaW5rIFJlZ2lzdHJ5fSBvYmplY3RzXHJcbiAqIEByZXR1cm5zIHtSZWdpc3RyeX0gdGhpcyByZWdpc3RyeSBrZXkgb2JqZWN0XHJcbiAqL1xyXG5SZWdpc3RyeS5wcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uIGtleXMgKGNiKSB7XHJcblxyXG4gIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpXHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtdXN0IHNwZWNpZnkgYSBjYWxsYmFjaycpO1xyXG5cclxuICB2YXIgYXJncyA9IFsgJ1FVRVJZJywgdGhpcy5wYXRoIF07XHJcblxyXG4gIHB1c2hBcmNoKGFyZ3MsIHRoaXMuYXJjaCk7XHJcblxyXG4gIHZhciBwcm9jID0gc3Bhd24oZ2V0UmVnRXhlUGF0aCgpLCBhcmdzLCB7XHJcbiAgICAgICAgY3dkOiB1bmRlZmluZWQsXHJcbiAgICAgICAgZW52OiBwcm9jZXNzLmVudixcclxuICAgICAgICBzdGRpbzogWyAnaWdub3JlJywgJ3BpcGUnLCAncGlwZScgXVxyXG4gICAgICB9KVxyXG4gICwgICBidWZmZXIgPSAnJ1xyXG4gICwgICBzZWxmID0gdGhpc1xyXG4gICwgICBlcnJvciA9IG51bGwgLy8gbnVsbCBtZWFucyBubyBlcnJvciBwcmV2aW91c2x5IHJlcG9ydGVkLlxyXG5cclxuICB2YXIgb3V0cHV0ID0gY2FwdHVyZU91dHB1dChwcm9jKTtcclxuXHJcbiAgcHJvYy5vbignY2xvc2UnLCBmdW5jdGlvbiAoY29kZSkge1xyXG4gICAgaWYgKGVycm9yKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH0gZWxzZSBpZiAoY29kZSAhPT0gMCkge1xyXG4gICAgICBsb2coJ3Byb2Nlc3MgZXhpdGVkIHdpdGggY29kZSAnICsgY29kZSk7XHJcbiAgICAgIGNiKG1rRXJyb3JNc2coJ1FVRVJZJywgY29kZSwgb3V0cHV0KSwgbnVsbCk7XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIHByb2Muc3Rkb3V0Lm9uKCdkYXRhJywgZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgIGJ1ZmZlciArPSBkYXRhLnRvU3RyaW5nKCk7XHJcbiAgfSk7XHJcblxyXG4gIHByb2Muc3Rkb3V0Lm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgdmFyIGl0ZW1zID0gW11cclxuICAgICwgICByZXN1bHQgPSBbXVxyXG4gICAgLCAgIGxpbmVzID0gYnVmZmVyLnNwbGl0KCdcXG4nKVxyXG5cclxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gbGluZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgIHZhciBsaW5lID0gbGluZXNbaV0udHJpbSgpO1xyXG4gICAgICBpZiAobGluZS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgbG9nKGxpbmUpO1xyXG4gICAgICAgIGl0ZW1zLnB1c2gobGluZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGl0ZW1zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG5cclxuICAgICAgdmFyIG1hdGNoID0gUEFUSF9QQVRURVJOLmV4ZWMoaXRlbXNbaV0pXHJcbiAgICAgICwgICBoaXZlXHJcbiAgICAgICwgICBrZXlcclxuXHJcbiAgICAgIGlmIChtYXRjaCkge1xyXG4gICAgICAgIGhpdmUgPSBtYXRjaFsxXTtcclxuICAgICAgICBrZXkgID0gbWF0Y2hbMl07XHJcbiAgICAgICAgaWYgKGtleSAmJiAoa2V5ICE9PSBzZWxmLmtleSkpIHtcclxuICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyBSZWdpc3RyeSh7XHJcbiAgICAgICAgICAgIGhvc3Q6IHNlbGYuaG9zdCxcclxuICAgICAgICAgICAgaGl2ZTogc2VsZi5oaXZlLFxyXG4gICAgICAgICAgICBrZXk6ICBrZXksXHJcbiAgICAgICAgICAgIGFyY2g6IHNlbGYuYXJjaFxyXG4gICAgICAgICAgfSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNiKG51bGwsIHJlc3VsdCk7XHJcblxyXG4gIH0pO1xyXG5cclxuICBwcm9jLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGVycikge1xyXG4gICAgZXJyb3IgPSBlcnI7XHJcbiAgICBjYihlcnIpO1xyXG4gIH0pO1xyXG5cclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXRzIGEgbmFtZWQgdmFsdWUgZnJvbSB0aGlzIHJlZ2lzdHJ5IGtleS5cclxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSB0aGUgdmFsdWUgbmFtZSwgdXNlIHtAbGluayBSZWdpc3RyeS5ERUZBVUxUX1ZBTFVFfSBvciBhbiBlbXB0eSBzdHJpbmcgZm9yIHRoZSBkZWZhdWx0IHZhbHVlXHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb24gKGVyciwgaXRlbSl9IGNiIC0gY2FsbGJhY2sgZnVuY3Rpb25cclxuICogQHBhcmFtIHtQcm9jZXNzVW5jbGVhbkV4aXRFcnJvcj19IGNiLmVyciAtIGVycm9yIG9iamVjdCBvciBudWxsIGlmIHN1Y2Nlc3NmdWxcclxuICogQHBhcmFtIHtSZWdpc3RyeUl0ZW09fSBjYi5pdGVtIC0gdGhlIHJldHJpZXZlZCByZWdpc3RyeSBpdGVtXHJcbiAqIEByZXR1cm5zIHtSZWdpc3RyeX0gdGhpcyByZWdpc3RyeSBrZXkgb2JqZWN0XHJcbiAqL1xyXG5SZWdpc3RyeS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChuYW1lLCBjYikge1xyXG5cclxuICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKVxyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbXVzdCBzcGVjaWZ5IGEgY2FsbGJhY2snKTtcclxuXHJcbiAgdmFyIGFyZ3MgPSBbJ1FVRVJZJywgdGhpcy5wYXRoXTtcclxuICBpZiAobmFtZSA9PSAnJylcclxuICAgIGFyZ3MucHVzaCgnL3ZlJyk7XHJcbiAgZWxzZVxyXG4gICAgYXJncyA9IGFyZ3MuY29uY2F0KFsnL3YnLCBuYW1lXSk7XHJcblxyXG4gIHB1c2hBcmNoKGFyZ3MsIHRoaXMuYXJjaCk7XHJcblxyXG4gIHZhciBwcm9jID0gc3Bhd24oZ2V0UmVnRXhlUGF0aCgpLCBhcmdzLCB7XHJcbiAgICAgICAgY3dkOiB1bmRlZmluZWQsXHJcbiAgICAgICAgZW52OiBwcm9jZXNzLmVudixcclxuICAgICAgICBzdGRpbzogWyAnaWdub3JlJywgJ3BpcGUnLCAncGlwZScgXVxyXG4gICAgICB9KVxyXG4gICwgICBidWZmZXIgPSAnJ1xyXG4gICwgICBzZWxmID0gdGhpc1xyXG4gICwgICBlcnJvciA9IG51bGwgLy8gbnVsbCBtZWFucyBubyBlcnJvciBwcmV2aW91c2x5IHJlcG9ydGVkLlxyXG5cclxuICB2YXIgb3V0cHV0ID0gY2FwdHVyZU91dHB1dChwcm9jKTtcclxuXHJcbiAgcHJvYy5vbignY2xvc2UnLCBmdW5jdGlvbiAoY29kZSkge1xyXG4gICAgaWYgKGVycm9yKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH0gZWxzZSBpZiAoY29kZSAhPT0gMCkge1xyXG4gICAgICBsb2coJ3Byb2Nlc3MgZXhpdGVkIHdpdGggY29kZSAnICsgY29kZSk7XHJcbiAgICAgIGNiKG1rRXJyb3JNc2coJ1FVRVJZJywgY29kZSwgb3V0cHV0KSwgbnVsbCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB2YXIgaXRlbXMgPSBbXVxyXG4gICAgICAsICAgcmVzdWx0ID0gbnVsbFxyXG4gICAgICAsICAgbGluZXMgPSBidWZmZXIuc3BsaXQoJ1xcbicpXHJcbiAgICAgICwgICBsaW5lTnVtYmVyID0gMFxyXG5cclxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaW5lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICB2YXIgbGluZSA9IGxpbmVzW2ldLnRyaW0oKTtcclxuICAgICAgICBpZiAobGluZS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICBsb2cobGluZSk7XHJcbiAgICAgICAgICBpZiAobGluZU51bWJlciAhPSAwKSB7XHJcbiAgICAgICAgICAgICBpdGVtcy5wdXNoKGxpbmUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgKytsaW5lTnVtYmVyO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy9HZXQgbGFzdCBpdGVtIC0gc28gaXQgd29ya3MgaW4gWFAgd2hlcmUgUkVHIFFVRVJZIHJldHVybnMgd2l0aCBhIGhlYWRlclxyXG4gICAgICB2YXIgaXRlbSA9IGl0ZW1zW2l0ZW1zLmxlbmd0aC0xXSB8fCAnJ1xyXG4gICAgICAsICAgbWF0Y2ggPSBJVEVNX1BBVFRFUk4uZXhlYyhpdGVtKVxyXG4gICAgICAsICAgbmFtZVxyXG4gICAgICAsICAgdHlwZVxyXG4gICAgICAsICAgdmFsdWVcclxuXHJcbiAgICAgIGlmIChtYXRjaCkge1xyXG4gICAgICAgIG5hbWUgPSBtYXRjaFsxXS50cmltKCk7XHJcbiAgICAgICAgdHlwZSA9IG1hdGNoWzJdLnRyaW0oKTtcclxuICAgICAgICB2YWx1ZSA9IG1hdGNoWzNdO1xyXG4gICAgICAgIHJlc3VsdCA9IG5ldyBSZWdpc3RyeUl0ZW0oc2VsZi5ob3N0LCBzZWxmLmhpdmUsIHNlbGYua2V5LCBuYW1lLCB0eXBlLCB2YWx1ZSwgc2VsZi5hcmNoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY2IobnVsbCwgcmVzdWx0KTtcclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgcHJvYy5zdGRvdXQub24oJ2RhdGEnLCBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgYnVmZmVyICs9IGRhdGEudG9TdHJpbmcoKTtcclxuICB9KTtcclxuXHJcbiAgcHJvYy5vbignZXJyb3InLCBmdW5jdGlvbihlcnIpIHtcclxuICAgIGVycm9yID0gZXJyO1xyXG4gICAgY2IoZXJyKTtcclxuICB9KTtcclxuXHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogU2V0cyBhIG5hbWVkIHZhbHVlIGluIHRoaXMgcmVnaXN0cnkga2V5LCBvdmVyd3JpdGluZyBhbiBhbHJlYWR5IGV4aXN0aW5nIHZhbHVlLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIHRoZSB2YWx1ZSBuYW1lLCB1c2Uge0BsaW5rIFJlZ2lzdHJ5LkRFRkFVTFRfVkFMVUV9IG9yIGFuIGVtcHR5IHN0cmluZyBmb3IgdGhlIGRlZmF1bHQgdmFsdWVcclxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSB0aGUgdmFsdWUgdHlwZVxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSB0aGUgdmFsdWVcclxuICogQHBhcmFtIHtmdW5jdGlvbiAoZXJyKX0gY2IgLSBjYWxsYmFjayBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge1Byb2Nlc3NVbmNsZWFuRXhpdEVycm9yPX0gY2IuZXJyIC0gZXJyb3Igb2JqZWN0IG9yIG51bGwgaWYgc3VjY2Vzc2Z1bFxyXG4gKiBAcmV0dXJucyB7UmVnaXN0cnl9IHRoaXMgcmVnaXN0cnkga2V5IG9iamVjdFxyXG4gKi9cclxuUmVnaXN0cnkucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIHNldCAobmFtZSwgdHlwZSwgdmFsdWUsIGNiKSB7XHJcblxyXG4gIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpXHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtdXN0IHNwZWNpZnkgYSBjYWxsYmFjaycpO1xyXG5cclxuICBpZiAoUkVHX1RZUEVTLmluZGV4T2YodHlwZSkgPT0gLTEpXHJcbiAgICB0aHJvdyBFcnJvcignaWxsZWdhbCB0eXBlIHNwZWNpZmllZC4nKTtcclxuXHJcbiAgdmFyIGFyZ3MgPSBbJ0FERCcsIHRoaXMucGF0aF07XHJcbiAgaWYgKG5hbWUgPT0gJycpXHJcbiAgICBhcmdzLnB1c2goJy92ZScpO1xyXG4gIGVsc2VcclxuICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChbJy92JywgbmFtZV0pO1xyXG5cclxuICBhcmdzID0gYXJncy5jb25jYXQoWycvdCcsIHR5cGUsICcvZCcsIHZhbHVlLCAnL2YnXSk7XHJcblxyXG4gIHB1c2hBcmNoKGFyZ3MsIHRoaXMuYXJjaCk7XHJcblxyXG4gIHZhciBwcm9jID0gc3Bhd24oZ2V0UmVnRXhlUGF0aCgpLCBhcmdzLCB7XHJcbiAgICAgICAgY3dkOiB1bmRlZmluZWQsXHJcbiAgICAgICAgZW52OiBwcm9jZXNzLmVudixcclxuICAgICAgICBzdGRpbzogWyAnaWdub3JlJywgJ3BpcGUnLCAncGlwZScgXVxyXG4gICAgICB9KVxyXG4gICwgICBlcnJvciA9IG51bGwgLy8gbnVsbCBtZWFucyBubyBlcnJvciBwcmV2aW91c2x5IHJlcG9ydGVkLlxyXG5cclxuICB2YXIgb3V0cHV0ID0gY2FwdHVyZU91dHB1dChwcm9jKTtcclxuXHJcbiAgcHJvYy5vbignY2xvc2UnLCBmdW5jdGlvbiAoY29kZSkge1xyXG4gICAgaWYoZXJyb3IpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfSBlbHNlIGlmIChjb2RlICE9PSAwKSB7XHJcbiAgICAgIGxvZygncHJvY2VzcyBleGl0ZWQgd2l0aCBjb2RlICcgKyBjb2RlKTtcclxuICAgICAgY2IobWtFcnJvck1zZygnQUREJywgY29kZSwgb3V0cHV0LCBudWxsKSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjYihudWxsKTtcclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgcHJvYy5zdGRvdXQub24oJ2RhdGEnLCBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgLy8gc2ltcGx5IGRpc2NhcmQgb3V0cHV0XHJcbiAgICBsb2coJycrZGF0YSk7XHJcbiAgfSk7XHJcblxyXG4gIHByb2Mub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyKSB7XHJcbiAgICBlcnJvciA9IGVycjtcclxuICAgIGNiKGVycik7XHJcbiAgfSk7XHJcblxyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlbW92ZSBhIG5hbWVkIHZhbHVlIGZyb20gdGhpcyByZWdpc3RyeSBrZXkuIElmIG5hbWUgaXMgZW1wdHksIHNldHMgdGhlIGRlZmF1bHQgdmFsdWUgb2YgdGhpcyBrZXkuXHJcbiAqIE5vdGU6IFRoaXMga2V5IG11c3QgYmUgYWxyZWFkeSBleGlzdGluZy5cclxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSB0aGUgdmFsdWUgbmFtZSwgdXNlIHtAbGluayBSZWdpc3RyeS5ERUZBVUxUX1ZBTFVFfSBvciBhbiBlbXB0eSBzdHJpbmcgZm9yIHRoZSBkZWZhdWx0IHZhbHVlXHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb24gKGVycil9IGNiIC0gY2FsbGJhY2sgZnVuY3Rpb25cclxuICogQHBhcmFtIHtQcm9jZXNzVW5jbGVhbkV4aXRFcnJvcj19IGNiLmVyciAtIGVycm9yIG9iamVjdCBvciBudWxsIGlmIHN1Y2Nlc3NmdWxcclxuICogQHJldHVybnMge1JlZ2lzdHJ5fSB0aGlzIHJlZ2lzdHJ5IGtleSBvYmplY3RcclxuICovXHJcblJlZ2lzdHJ5LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUgKG5hbWUsIGNiKSB7XHJcblxyXG4gIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpXHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtdXN0IHNwZWNpZnkgYSBjYWxsYmFjaycpO1xyXG5cclxuICB2YXIgYXJncyA9IG5hbWUgPyBbJ0RFTEVURScsIHRoaXMucGF0aCwgJy9mJywgJy92JywgbmFtZV0gOiBbJ0RFTEVURScsIHRoaXMucGF0aCwgJy9mJywgJy92ZSddO1xyXG5cclxuICBwdXNoQXJjaChhcmdzLCB0aGlzLmFyY2gpO1xyXG5cclxuICB2YXIgcHJvYyA9IHNwYXduKGdldFJlZ0V4ZVBhdGgoKSwgYXJncywge1xyXG4gICAgICAgIGN3ZDogdW5kZWZpbmVkLFxyXG4gICAgICAgIGVudjogcHJvY2Vzcy5lbnYsXHJcbiAgICAgICAgc3RkaW86IFsgJ2lnbm9yZScsICdwaXBlJywgJ3BpcGUnIF1cclxuICAgICAgfSlcclxuICAsICAgZXJyb3IgPSBudWxsIC8vIG51bGwgbWVhbnMgbm8gZXJyb3IgcHJldmlvdXNseSByZXBvcnRlZC5cclxuXHJcbiAgdmFyIG91dHB1dCA9IGNhcHR1cmVPdXRwdXQocHJvYyk7XHJcblxyXG4gIHByb2Mub24oJ2Nsb3NlJywgZnVuY3Rpb24gKGNvZGUpIHtcclxuICAgIGlmKGVycm9yKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH0gZWxzZSBpZiAoY29kZSAhPT0gMCkge1xyXG4gICAgICBsb2coJ3Byb2Nlc3MgZXhpdGVkIHdpdGggY29kZSAnICsgY29kZSk7XHJcbiAgICAgIGNiKG1rRXJyb3JNc2coJ0RFTEVURScsIGNvZGUsIG91dHB1dCksIG51bGwpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY2IobnVsbCk7XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIHByb2Muc3Rkb3V0Lm9uKCdkYXRhJywgZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgIC8vIHNpbXBseSBkaXNjYXJkIG91dHB1dFxyXG4gICAgbG9nKCcnK2RhdGEpO1xyXG4gIH0pO1xyXG5cclxuICBwcm9jLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGVycikge1xyXG4gICAgZXJyb3IgPSBlcnI7XHJcbiAgICBjYihlcnIpO1xyXG4gIH0pO1xyXG5cclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZW1vdmUgYWxsIHN1YmtleXMgYW5kIHZhbHVlcyAoaW5jbHVkaW5nIHRoZSBkZWZhdWx0IHZhbHVlKSBmcm9tIHRoaXMgcmVnaXN0cnkga2V5LlxyXG4gKiBAcGFyYW0ge2Z1bmN0aW9uIChlcnIpfSBjYiAtIGNhbGxiYWNrIGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7UHJvY2Vzc1VuY2xlYW5FeGl0RXJyb3I9fSBjYi5lcnIgLSBlcnJvciBvYmplY3Qgb3IgbnVsbCBpZiBzdWNjZXNzZnVsXHJcbiAqIEByZXR1cm5zIHtSZWdpc3RyeX0gdGhpcyByZWdpc3RyeSBrZXkgb2JqZWN0XHJcbiAqL1xyXG5SZWdpc3RyeS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhciAoY2IpIHtcclxuXHJcbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJylcclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ211c3Qgc3BlY2lmeSBhIGNhbGxiYWNrJyk7XHJcblxyXG4gIHZhciBhcmdzID0gWydERUxFVEUnLCB0aGlzLnBhdGgsICcvZicsICcvdmEnXTtcclxuXHJcbiAgcHVzaEFyY2goYXJncywgdGhpcy5hcmNoKTtcclxuXHJcbiAgdmFyIHByb2MgPSBzcGF3bihnZXRSZWdFeGVQYXRoKCksIGFyZ3MsIHtcclxuICAgICAgICBjd2Q6IHVuZGVmaW5lZCxcclxuICAgICAgICBlbnY6IHByb2Nlc3MuZW52LFxyXG4gICAgICAgIHN0ZGlvOiBbICdpZ25vcmUnLCAncGlwZScsICdwaXBlJyBdXHJcbiAgICAgIH0pXHJcbiAgLCAgIGVycm9yID0gbnVsbCAvLyBudWxsIG1lYW5zIG5vIGVycm9yIHByZXZpb3VzbHkgcmVwb3J0ZWQuXHJcblxyXG4gIHZhciBvdXRwdXQgPSBjYXB0dXJlT3V0cHV0KHByb2MpO1xyXG5cclxuICBwcm9jLm9uKCdjbG9zZScsIGZ1bmN0aW9uIChjb2RlKSB7XHJcbiAgICBpZihlcnJvcikge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9IGVsc2UgaWYgKGNvZGUgIT09IDApIHtcclxuICAgICAgbG9nKCdwcm9jZXNzIGV4aXRlZCB3aXRoIGNvZGUgJyArIGNvZGUpO1xyXG4gICAgICBjYihta0Vycm9yTXNnKFwiREVMRVRFXCIsIGNvZGUsIG91dHB1dCksIG51bGwpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY2IobnVsbCk7XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIHByb2Muc3Rkb3V0Lm9uKCdkYXRhJywgZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgIC8vIHNpbXBseSBkaXNjYXJkIG91dHB1dFxyXG4gICAgbG9nKCcnK2RhdGEpO1xyXG4gIH0pO1xyXG5cclxuICBwcm9jLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGVycikge1xyXG4gICAgZXJyb3IgPSBlcnI7XHJcbiAgICBjYihlcnIpO1xyXG4gIH0pO1xyXG5cclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBbGlhcyBmb3IgdGhlIGNsZWFyIG1ldGhvZCB0byBrZWVwIGl0IGJhY2t3YXJkIGNvbXBhdGlibGUuXHJcbiAqIEBtZXRob2RcclxuICogQGRlcHJlY2F0ZWQgVXNlIHtAbGluayBSZWdpc3RyeSNjbGVhcn0gb3Ige0BsaW5rIFJlZ2lzdHJ5I2Rlc3Ryb3l9IGluIGZhdm91ciBvZiB0aGlzIG1ldGhvZC5cclxuICogQHBhcmFtIHtmdW5jdGlvbiAoZXJyKX0gY2IgLSBjYWxsYmFjayBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge1Byb2Nlc3NVbmNsZWFuRXhpdEVycm9yPX0gY2IuZXJyIC0gZXJyb3Igb2JqZWN0IG9yIG51bGwgaWYgc3VjY2Vzc2Z1bFxyXG4gKiBAcmV0dXJucyB7UmVnaXN0cnl9IHRoaXMgcmVnaXN0cnkga2V5IG9iamVjdFxyXG4gKi9cclxuUmVnaXN0cnkucHJvdG90eXBlLmVyYXNlID0gUmVnaXN0cnkucHJvdG90eXBlLmNsZWFyO1xyXG5cclxuLyoqXHJcbiAqIERlbGV0ZSB0aGlzIGtleSBhbmQgYWxsIHN1YmtleXMgZnJvbSB0aGUgcmVnaXN0cnkuXHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb24gKGVycil9IGNiIC0gY2FsbGJhY2sgZnVuY3Rpb25cclxuICogQHBhcmFtIHtQcm9jZXNzVW5jbGVhbkV4aXRFcnJvcj19IGNiLmVyciAtIGVycm9yIG9iamVjdCBvciBudWxsIGlmIHN1Y2Nlc3NmdWxcclxuICogQHJldHVybnMge1JlZ2lzdHJ5fSB0aGlzIHJlZ2lzdHJ5IGtleSBvYmplY3RcclxuICovXHJcblJlZ2lzdHJ5LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSAoY2IpIHtcclxuXHJcbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJylcclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ211c3Qgc3BlY2lmeSBhIGNhbGxiYWNrJyk7XHJcblxyXG4gIHZhciBhcmdzID0gWydERUxFVEUnLCB0aGlzLnBhdGgsICcvZiddO1xyXG5cclxuICBwdXNoQXJjaChhcmdzLCB0aGlzLmFyY2gpO1xyXG5cclxuICB2YXIgcHJvYyA9IHNwYXduKGdldFJlZ0V4ZVBhdGgoKSwgYXJncywge1xyXG4gICAgICAgIGN3ZDogdW5kZWZpbmVkLFxyXG4gICAgICAgIGVudjogcHJvY2Vzcy5lbnYsXHJcbiAgICAgICAgc3RkaW86IFsgJ2lnbm9yZScsICdwaXBlJywgJ3BpcGUnIF1cclxuICAgICAgfSlcclxuICAsICAgZXJyb3IgPSBudWxsIC8vIG51bGwgbWVhbnMgbm8gZXJyb3IgcHJldmlvdXNseSByZXBvcnRlZC5cclxuXHJcbiAgdmFyIG91dHB1dCA9IGNhcHR1cmVPdXRwdXQocHJvYyk7XHJcblxyXG4gIHByb2Mub24oJ2Nsb3NlJywgZnVuY3Rpb24gKGNvZGUpIHtcclxuICAgIGlmIChlcnJvcikge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9IGVsc2UgaWYgKGNvZGUgIT09IDApIHtcclxuICAgICAgbG9nKCdwcm9jZXNzIGV4aXRlZCB3aXRoIGNvZGUgJyArIGNvZGUpO1xyXG4gICAgICBjYihta0Vycm9yTXNnKCdERUxFVEUnLCBjb2RlLCBvdXRwdXQpLCBudWxsKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNiKG51bGwpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG5cclxuICBwcm9jLnN0ZG91dC5vbignZGF0YScsIGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAvLyBzaW1wbHkgZGlzY2FyZCBvdXRwdXRcclxuICAgIGxvZygnJytkYXRhKTtcclxuICB9KTtcclxuXHJcbiAgcHJvYy5vbignZXJyb3InLCBmdW5jdGlvbihlcnIpIHtcclxuICAgIGVycm9yID0gZXJyO1xyXG4gICAgY2IoZXJyKTtcclxuICB9KTtcclxuXHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogQ3JlYXRlIHRoaXMgcmVnaXN0cnkga2V5LiBOb3RlIHRoYXQgdGhpcyBpcyBhIG5vLW9wIGlmIHRoZSBrZXkgYWxyZWFkeSBleGlzdHMuXHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb24gKGVycil9IGNiIC0gY2FsbGJhY2sgZnVuY3Rpb25cclxuICogQHBhcmFtIHtQcm9jZXNzVW5jbGVhbkV4aXRFcnJvcj19IGNiLmVyciAtIGVycm9yIG9iamVjdCBvciBudWxsIGlmIHN1Y2Nlc3NmdWxcclxuICogQHJldHVybnMge1JlZ2lzdHJ5fSB0aGlzIHJlZ2lzdHJ5IGtleSBvYmplY3RcclxuICovXHJcblJlZ2lzdHJ5LnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUgKGNiKSB7XHJcblxyXG4gIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpXHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtdXN0IHNwZWNpZnkgYSBjYWxsYmFjaycpO1xyXG5cclxuICB2YXIgYXJncyA9IFsnQUREJywgdGhpcy5wYXRoLCAnL2YnXTtcclxuXHJcbiAgcHVzaEFyY2goYXJncywgdGhpcy5hcmNoKTtcclxuXHJcbiAgdmFyIHByb2MgPSBzcGF3bihnZXRSZWdFeGVQYXRoKCksIGFyZ3MsIHtcclxuICAgICAgICBjd2Q6IHVuZGVmaW5lZCxcclxuICAgICAgICBlbnY6IHByb2Nlc3MuZW52LFxyXG4gICAgICAgIHN0ZGlvOiBbICdpZ25vcmUnLCAncGlwZScsICdwaXBlJyBdXHJcbiAgICAgIH0pXHJcbiAgLCAgIGVycm9yID0gbnVsbCAvLyBudWxsIG1lYW5zIG5vIGVycm9yIHByZXZpb3VzbHkgcmVwb3J0ZWQuXHJcblxyXG4gIHZhciBvdXRwdXQgPSBjYXB0dXJlT3V0cHV0KHByb2MpO1xyXG5cclxuICBwcm9jLm9uKCdjbG9zZScsIGZ1bmN0aW9uIChjb2RlKSB7XHJcbiAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfSBlbHNlIGlmIChjb2RlICE9PSAwKSB7XHJcbiAgICAgIGxvZygncHJvY2VzcyBleGl0ZWQgd2l0aCBjb2RlICcgKyBjb2RlKTtcclxuICAgICAgY2IobWtFcnJvck1zZygnQUREJywgY29kZSwgb3V0cHV0KSwgbnVsbCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjYihudWxsKTtcclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgcHJvYy5zdGRvdXQub24oJ2RhdGEnLCBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgLy8gc2ltcGx5IGRpc2NhcmQgb3V0cHV0XHJcbiAgICBsb2coJycrZGF0YSk7XHJcbiAgfSk7XHJcblxyXG4gIHByb2Mub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyKSB7XHJcbiAgICBlcnJvciA9IGVycjtcclxuICAgIGNiKGVycik7XHJcbiAgfSk7XHJcblxyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENoZWNrcyBpZiB0aGlzIGtleSBhbHJlYWR5IGV4aXN0cy5cclxuICogQHBhcmFtIHtmdW5jdGlvbiAoZXJyLCBleGlzdHMpfSBjYiAtIGNhbGxiYWNrIGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7UHJvY2Vzc1VuY2xlYW5FeGl0RXJyb3I9fSBjYi5lcnIgLSBlcnJvciBvYmplY3Qgb3IgbnVsbCBpZiBzdWNjZXNzZnVsXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IGNiLmV4aXN0cyAtIHRydWUgaWYgYSByZWdpc3RyeSBrZXkgd2l0aCB0aGlzIG5hbWUgYWxyZWFkeSBleGlzdHNcclxuICogQHJldHVybnMge1JlZ2lzdHJ5fSB0aGlzIHJlZ2lzdHJ5IGtleSBvYmplY3RcclxuICovXHJcblJlZ2lzdHJ5LnByb3RvdHlwZS5rZXlFeGlzdHMgPSBmdW5jdGlvbiBrZXlFeGlzdHMgKGNiKSB7XHJcblxyXG4gIHRoaXMudmFsdWVzKGZ1bmN0aW9uIChlcnIsIGl0ZW1zKSB7XHJcbiAgICBpZiAoZXJyKSB7XHJcbiAgICAgIC8vIHByb2Nlc3Mgc2hvdWxkIHJldHVybiB3aXRoIGNvZGUgMSBpZiBrZXkgbm90IGZvdW5kXHJcbiAgICAgIGlmIChlcnIuY29kZSA9PSAxKSB7XHJcbiAgICAgICAgcmV0dXJuIGNiKG51bGwsIGZhbHNlKTtcclxuICAgICAgfVxyXG4gICAgICAvLyBvdGhlciBlcnJvclxyXG4gICAgICByZXR1cm4gY2IoZXJyKTtcclxuICAgIH1cclxuICAgIGNiKG51bGwsIHRydWUpO1xyXG4gIH0pO1xyXG5cclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgYSB2YWx1ZSB3aXRoIHRoZSBnaXZlbiBuYW1lIGFscmVhZHkgZXhpc3RzIHdpdGhpbiB0aGlzIGtleS5cclxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSB0aGUgdmFsdWUgbmFtZSwgdXNlIHtAbGluayBSZWdpc3RyeS5ERUZBVUxUX1ZBTFVFfSBvciBhbiBlbXB0eSBzdHJpbmcgZm9yIHRoZSBkZWZhdWx0IHZhbHVlXHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb24gKGVyciwgZXhpc3RzKX0gY2IgLSBjYWxsYmFjayBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge1Byb2Nlc3NVbmNsZWFuRXhpdEVycm9yPX0gY2IuZXJyIC0gZXJyb3Igb2JqZWN0IG9yIG51bGwgaWYgc3VjY2Vzc2Z1bFxyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBjYi5leGlzdHMgLSB0cnVlIGlmIGEgdmFsdWUgd2l0aCB0aGUgZ2l2ZW4gbmFtZSB3YXMgZm91bmQgaW4gdGhpcyBrZXlcclxuICogQHJldHVybnMge1JlZ2lzdHJ5fSB0aGlzIHJlZ2lzdHJ5IGtleSBvYmplY3RcclxuICovXHJcblJlZ2lzdHJ5LnByb3RvdHlwZS52YWx1ZUV4aXN0cyA9IGZ1bmN0aW9uIHZhbHVlRXhpc3RzIChuYW1lLCBjYikge1xyXG5cclxuICB0aGlzLmdldChuYW1lLCBmdW5jdGlvbiAoZXJyLCBpdGVtKSB7XHJcbiAgICBpZiAoZXJyKSB7XHJcbiAgICAgIC8vIHByb2Nlc3Mgc2hvdWxkIHJldHVybiB3aXRoIGNvZGUgMSBpZiB2YWx1ZSBub3QgZm91bmRcclxuICAgICAgaWYgKGVyci5jb2RlID09IDEpIHtcclxuICAgICAgICByZXR1cm4gY2IobnVsbCwgZmFsc2UpO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIG90aGVyIGVycm9yXHJcbiAgICAgIHJldHVybiBjYihlcnIpO1xyXG4gICAgfVxyXG4gICAgY2IobnVsbCwgdHJ1ZSk7XHJcbiAgfSk7XHJcblxyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZWdpc3RyeTtcclxuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHN0cmluZ1dpZHRoID0gcmVxdWlyZSgnc3RyaW5nLXdpZHRoJyk7XG52YXIgc3RyaXBBbnNpID0gcmVxdWlyZSgnc3RyaXAtYW5zaScpO1xuXG52YXIgRVNDQVBFUyA9IFtcblx0J1xcdTAwMWInLFxuXHQnXFx1MDA5Yidcbl07XG5cbnZhciBFTkRfQ09ERSA9IDM5O1xuXG52YXIgRVNDQVBFX0NPREVTID0ge1xuXHQwOiAwLFxuXHQxOiAyMixcblx0MjogMjIsXG5cdDM6IDIzLFxuXHQ0OiAyNCxcblx0NzogMjcsXG5cdDg6IDI4LFxuXHQ5OiAyOSxcblx0MzA6IDM5LFxuXHQzMTogMzksXG5cdDMyOiAzOSxcblx0MzM6IDM5LFxuXHQzNDogMzksXG5cdDM1OiAzOSxcblx0MzY6IDM5LFxuXHQzNzogMzksXG5cdDkwOiAzOSxcblx0NDA6IDQ5LFxuXHQ0MTogNDksXG5cdDQyOiA0OSxcblx0NDM6IDQ5LFxuXHQ0NDogNDksXG5cdDQ1OiA0OSxcblx0NDY6IDQ5LFxuXHQ0NzogNDlcbn07XG5cbmZ1bmN0aW9uIHdyYXBBbnNpKGNvZGUpIHtcblx0cmV0dXJuIEVTQ0FQRVNbMF0gKyAnWycgKyBjb2RlICsgJ20nO1xufVxuXG4vLyBjYWxjdWxhdGUgdGhlIGxlbmd0aCBvZiB3b3JkcyBzcGxpdCBvbiAnICcsIGlnbm9yaW5nXG4vLyB0aGUgZXh0cmEgY2hhcmFjdGVycyBhZGRlZCBieSBhbnNpIGVzY2FwZSBjb2Rlcy5cbmZ1bmN0aW9uIHdvcmRMZW5ndGhzKHN0cikge1xuXHRyZXR1cm4gc3RyLnNwbGl0KCcgJykubWFwKGZ1bmN0aW9uIChzKSB7XG5cdFx0cmV0dXJuIHN0cmluZ1dpZHRoKHMpO1xuXHR9KTtcbn1cblxuLy8gd3JhcCBhIGxvbmcgd29yZCBhY3Jvc3MgbXVsdGlwbGUgcm93cy5cbi8vIGFuc2kgZXNjYXBlIGNvZGVzIGRvIG5vdCBjb3VudCB0b3dhcmRzIGxlbmd0aC5cbmZ1bmN0aW9uIHdyYXBXb3JkKHJvd3MsIHdvcmQsIGNvbHMpIHtcblx0dmFyIGluc2lkZUVzY2FwZSA9IGZhbHNlO1xuXHR2YXIgdmlzaWJsZSA9IHN0cmlwQW5zaShyb3dzW3Jvd3MubGVuZ3RoIC0gMV0pLmxlbmd0aDtcblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IHdvcmQubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgeCA9IHdvcmRbaV07XG5cblx0XHRyb3dzW3Jvd3MubGVuZ3RoIC0gMV0gKz0geDtcblxuXHRcdGlmIChFU0NBUEVTLmluZGV4T2YoeCkgIT09IC0xKSB7XG5cdFx0XHRpbnNpZGVFc2NhcGUgPSB0cnVlO1xuXHRcdH0gZWxzZSBpZiAoaW5zaWRlRXNjYXBlICYmIHggPT09ICdtJykge1xuXHRcdFx0aW5zaWRlRXNjYXBlID0gZmFsc2U7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRpZiAoaW5zaWRlRXNjYXBlKSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHR2aXNpYmxlKys7XG5cblx0XHRpZiAodmlzaWJsZSA+PSBjb2xzICYmIGkgPCB3b3JkLmxlbmd0aCAtIDEpIHtcblx0XHRcdHJvd3MucHVzaCgnJyk7XG5cdFx0XHR2aXNpYmxlID0gMDtcblx0XHR9XG5cdH1cblxuXHQvLyBpdCdzIHBvc3NpYmxlIHRoYXQgdGhlIGxhc3Qgcm93IHdlIGNvcHkgb3ZlciBpcyBvbmx5XG5cdC8vIGFuc2kgZXNjYXBlIGNoYXJhY3RlcnMsIGhhbmRsZSB0aGlzIGVkZ2UtY2FzZS5cblx0aWYgKCF2aXNpYmxlICYmIHJvd3Nbcm93cy5sZW5ndGggLSAxXS5sZW5ndGggPiAwICYmIHJvd3MubGVuZ3RoID4gMSkge1xuXHRcdHJvd3Nbcm93cy5sZW5ndGggLSAyXSArPSByb3dzLnBvcCgpO1xuXHR9XG59XG5cbi8vIHRoZSB3cmFwLWFuc2kgbW9kdWxlIGNhbiBiZSBpbnZva2VkXG4vLyBpbiBlaXRoZXIgJ2hhcmQnIG9yICdzb2Z0JyB3cmFwIG1vZGUuXG4vL1xuLy8gJ2hhcmQnIHdpbGwgbmV2ZXIgYWxsb3cgYSBzdHJpbmcgdG8gdGFrZSB1cCBtb3JlXG4vLyB0aGFuIGNvbHMgY2hhcmFjdGVycy5cbi8vXG4vLyAnc29mdCcgYWxsb3dzIGxvbmcgd29yZHMgdG8gZXhwYW5kIHBhc3QgdGhlIGNvbHVtbiBsZW5ndGguXG5mdW5jdGlvbiBleGVjKHN0ciwgY29scywgb3B0cykge1xuXHR2YXIgb3B0aW9ucyA9IG9wdHMgfHwge307XG5cblx0dmFyIHByZSA9ICcnO1xuXHR2YXIgcmV0ID0gJyc7XG5cdHZhciBlc2NhcGVDb2RlO1xuXG5cdHZhciBsZW5ndGhzID0gd29yZExlbmd0aHMoc3RyKTtcblx0dmFyIHdvcmRzID0gc3RyLnNwbGl0KCcgJyk7XG5cdHZhciByb3dzID0gWycnXTtcblxuXHRmb3IgKHZhciBpID0gMCwgd29yZDsgKHdvcmQgPSB3b3Jkc1tpXSkgIT09IHVuZGVmaW5lZDsgaSsrKSB7XG5cdFx0dmFyIHJvd0xlbmd0aCA9IHN0cmluZ1dpZHRoKHJvd3Nbcm93cy5sZW5ndGggLSAxXSk7XG5cblx0XHRpZiAocm93TGVuZ3RoKSB7XG5cdFx0XHRyb3dzW3Jvd3MubGVuZ3RoIC0gMV0gKz0gJyAnO1xuXHRcdFx0cm93TGVuZ3RoKys7XG5cdFx0fVxuXG5cdFx0Ly8gaW4gJ2hhcmQnIHdyYXAgbW9kZSwgdGhlIGxlbmd0aCBvZiBhIGxpbmUgaXNcblx0XHQvLyBuZXZlciBhbGxvd2VkIHRvIGV4dGVuZCBwYXN0ICdjb2xzJy5cblx0XHRpZiAobGVuZ3Roc1tpXSA+IGNvbHMgJiYgb3B0aW9ucy5oYXJkKSB7XG5cdFx0XHRpZiAocm93TGVuZ3RoKSB7XG5cdFx0XHRcdHJvd3MucHVzaCgnJyk7XG5cdFx0XHR9XG5cdFx0XHR3cmFwV29yZChyb3dzLCB3b3JkLCBjb2xzKTtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGlmIChyb3dMZW5ndGggKyBsZW5ndGhzW2ldID4gY29scyAmJiByb3dMZW5ndGggPiAwKSB7XG5cdFx0XHRpZiAob3B0aW9ucy53b3JkV3JhcCA9PT0gZmFsc2UgJiYgcm93TGVuZ3RoIDwgY29scykge1xuXHRcdFx0XHR3cmFwV29yZChyb3dzLCB3b3JkLCBjb2xzKTtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdHJvd3MucHVzaCgnJyk7XG5cdFx0fVxuXG5cdFx0cm93c1tyb3dzLmxlbmd0aCAtIDFdICs9IHdvcmQ7XG5cdH1cblxuXHRwcmUgPSByb3dzLm1hcChmdW5jdGlvbiAocikge1xuXHRcdHJldHVybiByLnRyaW0oKTtcblx0fSkuam9pbignXFxuJyk7XG5cblx0Zm9yICh2YXIgaiA9IDA7IGogPCBwcmUubGVuZ3RoOyBqKyspIHtcblx0XHR2YXIgeSA9IHByZVtqXTtcblxuXHRcdHJldCArPSB5O1xuXG5cdFx0aWYgKEVTQ0FQRVMuaW5kZXhPZih5KSAhPT0gLTEpIHtcblx0XHRcdHZhciBjb2RlID0gcGFyc2VGbG9hdCgvWzAtOV1bXm1dKi8uZXhlYyhwcmUuc2xpY2UoaiwgaiArIDQpKSk7XG5cdFx0XHRlc2NhcGVDb2RlID0gY29kZSA9PT0gRU5EX0NPREUgPyBudWxsIDogY29kZTtcblx0XHR9XG5cblx0XHRpZiAoZXNjYXBlQ29kZSAmJiBFU0NBUEVfQ09ERVNbZXNjYXBlQ29kZV0pIHtcblx0XHRcdGlmIChwcmVbaiArIDFdID09PSAnXFxuJykge1xuXHRcdFx0XHRyZXQgKz0gd3JhcEFuc2koRVNDQVBFX0NPREVTW2VzY2FwZUNvZGVdKTtcblx0XHRcdH0gZWxzZSBpZiAoeSA9PT0gJ1xcbicpIHtcblx0XHRcdFx0cmV0ICs9IHdyYXBBbnNpKGVzY2FwZUNvZGUpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiByZXQ7XG59XG5cbi8vIGZvciBlYWNoIGxpbmUgYnJlYWssIGludm9rZSB0aGUgbWV0aG9kIHNlcGFyYXRlbHkuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdHIsIGNvbHMsIG9wdHMpIHtcblx0cmV0dXJuIFN0cmluZyhzdHIpLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24gKHN1YnN0cikge1xuXHRcdHJldHVybiBleGVjKHN1YnN0ciwgY29scywgb3B0cyk7XG5cdH0pLmpvaW4oJ1xcbicpO1xufTtcbiIsIi8vIFJldHVybnMgYSB3cmFwcGVyIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHdyYXBwZWQgY2FsbGJhY2tcbi8vIFRoZSB3cmFwcGVyIGZ1bmN0aW9uIHNob3VsZCBkbyBzb21lIHN0dWZmLCBhbmQgcmV0dXJuIGFcbi8vIHByZXN1bWFibHkgZGlmZmVyZW50IGNhbGxiYWNrIGZ1bmN0aW9uLlxuLy8gVGhpcyBtYWtlcyBzdXJlIHRoYXQgb3duIHByb3BlcnRpZXMgYXJlIHJldGFpbmVkLCBzbyB0aGF0XG4vLyBkZWNvcmF0aW9ucyBhbmQgc3VjaCBhcmUgbm90IGxvc3QgYWxvbmcgdGhlIHdheS5cbm1vZHVsZS5leHBvcnRzID0gd3JhcHB5XG5mdW5jdGlvbiB3cmFwcHkgKGZuLCBjYikge1xuICBpZiAoZm4gJiYgY2IpIHJldHVybiB3cmFwcHkoZm4pKGNiKVxuXG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbmVlZCB3cmFwcGVyIGZ1bmN0aW9uJylcblxuICBPYmplY3Qua2V5cyhmbikuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgIHdyYXBwZXJba10gPSBmbltrXVxuICB9KVxuXG4gIHJldHVybiB3cmFwcGVyXG5cbiAgZnVuY3Rpb24gd3JhcHBlcigpIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXVxuICAgIH1cbiAgICB2YXIgcmV0ID0gZm4uYXBwbHkodGhpcywgYXJncylcbiAgICB2YXIgY2IgPSBhcmdzW2FyZ3MubGVuZ3RoLTFdXG4gICAgaWYgKHR5cGVvZiByZXQgPT09ICdmdW5jdGlvbicgJiYgcmV0ICE9PSBjYikge1xuICAgICAgT2JqZWN0LmtleXMoY2IpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgICAgcmV0W2tdID0gY2Jba11cbiAgICAgIH0pXG4gICAgfVxuICAgIHJldHVybiByZXRcbiAgfVxufVxuIiwidmFyIGZzID0gcmVxdWlyZSgnZnMnKVxudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJylcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpXG5cbmZ1bmN0aW9uIFkxOE4gKG9wdHMpIHtcbiAgLy8gY29uZmlndXJhYmxlIG9wdGlvbnMuXG4gIG9wdHMgPSBvcHRzIHx8IHt9XG4gIHRoaXMuZGlyZWN0b3J5ID0gb3B0cy5kaXJlY3RvcnkgfHwgJy4vbG9jYWxlcydcbiAgdGhpcy51cGRhdGVGaWxlcyA9IHR5cGVvZiBvcHRzLnVwZGF0ZUZpbGVzID09PSAnYm9vbGVhbicgPyBvcHRzLnVwZGF0ZUZpbGVzIDogdHJ1ZVxuICB0aGlzLmxvY2FsZSA9IG9wdHMubG9jYWxlIHx8ICdlbidcbiAgdGhpcy5mYWxsYmFja1RvTGFuZ3VhZ2UgPSB0eXBlb2Ygb3B0cy5mYWxsYmFja1RvTGFuZ3VhZ2UgPT09ICdib29sZWFuJyA/IG9wdHMuZmFsbGJhY2tUb0xhbmd1YWdlIDogdHJ1ZVxuXG4gIC8vIGludGVybmFsIHN0dWZmLlxuICB0aGlzLmNhY2hlID0ge31cbiAgdGhpcy53cml0ZVF1ZXVlID0gW11cbn1cblxuWTE4Ti5wcm90b3R5cGUuX18gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKVxuICB2YXIgc3RyID0gYXJncy5zaGlmdCgpXG4gIHZhciBjYiA9IGZ1bmN0aW9uICgpIHt9IC8vIHN0YXJ0IHdpdGggbm9vcC5cblxuICBpZiAodHlwZW9mIGFyZ3NbYXJncy5sZW5ndGggLSAxXSA9PT0gJ2Z1bmN0aW9uJykgY2IgPSBhcmdzLnBvcCgpXG4gIGNiID0gY2IgfHwgZnVuY3Rpb24gKCkge30gLy8gbm9vcC5cblxuICBpZiAoIXRoaXMuY2FjaGVbdGhpcy5sb2NhbGVdKSB0aGlzLl9yZWFkTG9jYWxlRmlsZSgpXG5cbiAgLy8gd2UndmUgb2JzZXJ2ZWQgYSBuZXcgc3RyaW5nLCB1cGRhdGUgdGhlIGxhbmd1YWdlIGZpbGUuXG4gIGlmICghdGhpcy5jYWNoZVt0aGlzLmxvY2FsZV1bc3RyXSAmJiB0aGlzLnVwZGF0ZUZpbGVzKSB7XG4gICAgdGhpcy5jYWNoZVt0aGlzLmxvY2FsZV1bc3RyXSA9IHN0clxuXG4gICAgLy8gaW5jbHVkZSB0aGUgY3VycmVudCBkaXJlY3RvcnkgYW5kIGxvY2FsZSxcbiAgICAvLyBzaW5jZSB0aGVzZSB2YWx1ZXMgY291bGQgY2hhbmdlIGJlZm9yZSB0aGVcbiAgICAvLyB3cml0ZSBpcyBwZXJmb3JtZWQuXG4gICAgdGhpcy5fZW5xdWV1ZVdyaXRlKFt0aGlzLmRpcmVjdG9yeSwgdGhpcy5sb2NhbGUsIGNiXSlcbiAgfSBlbHNlIHtcbiAgICBjYigpXG4gIH1cblxuICByZXR1cm4gdXRpbC5mb3JtYXQuYXBwbHkodXRpbCwgW3RoaXMuY2FjaGVbdGhpcy5sb2NhbGVdW3N0cl0gfHwgc3RyXS5jb25jYXQoYXJncykpXG59XG5cblkxOE4ucHJvdG90eXBlLl9lbnF1ZXVlV3JpdGUgPSBmdW5jdGlvbiAod29yaykge1xuICB0aGlzLndyaXRlUXVldWUucHVzaCh3b3JrKVxuICBpZiAodGhpcy53cml0ZVF1ZXVlLmxlbmd0aCA9PT0gMSkgdGhpcy5fcHJvY2Vzc1dyaXRlUXVldWUoKVxufVxuXG5ZMThOLnByb3RvdHlwZS5fcHJvY2Vzc1dyaXRlUXVldWUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBfdGhpcyA9IHRoaXNcbiAgdmFyIHdvcmsgPSB0aGlzLndyaXRlUXVldWVbMF1cblxuICAvLyBkZXN0cnVjdHVyZSB0aGUgZW5xdWV1ZWQgd29yay5cbiAgdmFyIGRpcmVjdG9yeSA9IHdvcmtbMF1cbiAgdmFyIGxvY2FsZSA9IHdvcmtbMV1cbiAgdmFyIGNiID0gd29ya1syXVxuXG4gIHZhciBsYW5ndWFnZUZpbGUgPSB0aGlzLl9yZXNvbHZlTG9jYWxlRmlsZShkaXJlY3RvcnksIGxvY2FsZSlcbiAgdmFyIHNlcmlhbGl6ZWRMb2NhbGUgPSBKU09OLnN0cmluZ2lmeSh0aGlzLmNhY2hlW2xvY2FsZV0sIG51bGwsIDIpXG5cbiAgZnMud3JpdGVGaWxlKGxhbmd1YWdlRmlsZSwgc2VyaWFsaXplZExvY2FsZSwgJ3V0Zi04JywgZnVuY3Rpb24gKGVycikge1xuICAgIF90aGlzLndyaXRlUXVldWUuc2hpZnQoKVxuICAgIGlmIChfdGhpcy53cml0ZVF1ZXVlLmxlbmd0aCA+IDApIF90aGlzLl9wcm9jZXNzV3JpdGVRdWV1ZSgpXG4gICAgY2IoZXJyKVxuICB9KVxufVxuXG5ZMThOLnByb3RvdHlwZS5fcmVhZExvY2FsZUZpbGUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBsb2NhbGVMb29rdXAgPSB7fVxuICB2YXIgbGFuZ3VhZ2VGaWxlID0gdGhpcy5fcmVzb2x2ZUxvY2FsZUZpbGUodGhpcy5kaXJlY3RvcnksIHRoaXMubG9jYWxlKVxuXG4gIHRyeSB7XG4gICAgbG9jYWxlTG9va3VwID0gSlNPTi5wYXJzZShmcy5yZWFkRmlsZVN5bmMobGFuZ3VhZ2VGaWxlLCAndXRmLTgnKSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKGVyciBpbnN0YW5jZW9mIFN5bnRheEVycm9yKSB7XG4gICAgICBlcnIubWVzc2FnZSA9ICdzeW50YXggZXJyb3IgaW4gJyArIGxhbmd1YWdlRmlsZVxuICAgIH1cblxuICAgIGlmIChlcnIuY29kZSA9PT0gJ0VOT0VOVCcpIGxvY2FsZUxvb2t1cCA9IHt9XG4gICAgZWxzZSB0aHJvdyBlcnJcbiAgfVxuXG4gIHRoaXMuY2FjaGVbdGhpcy5sb2NhbGVdID0gbG9jYWxlTG9va3VwXG59XG5cblkxOE4ucHJvdG90eXBlLl9yZXNvbHZlTG9jYWxlRmlsZSA9IGZ1bmN0aW9uIChkaXJlY3RvcnksIGxvY2FsZSkge1xuICB2YXIgZmlsZSA9IHBhdGgucmVzb2x2ZShkaXJlY3RvcnksICcuLycsIGxvY2FsZSArICcuanNvbicpXG4gIGlmICh0aGlzLmZhbGxiYWNrVG9MYW5ndWFnZSAmJiAhdGhpcy5fZmlsZUV4aXN0c1N5bmMoZmlsZSkgJiYgfmxvY2FsZS5sYXN0SW5kZXhPZignXycpKSB7XG4gICAgLy8gYXR0ZW1wdCBmYWxsYmFjayB0byBsYW5ndWFnZSBvbmx5XG4gICAgdmFyIGxhbmd1YWdlRmlsZSA9IHBhdGgucmVzb2x2ZShkaXJlY3RvcnksICcuLycsIGxvY2FsZS5zcGxpdCgnXycpWzBdICsgJy5qc29uJylcbiAgICBpZiAodGhpcy5fZmlsZUV4aXN0c1N5bmMobGFuZ3VhZ2VGaWxlKSkgZmlsZSA9IGxhbmd1YWdlRmlsZVxuICB9XG4gIHJldHVybiBmaWxlXG59XG5cbi8vIHRoaXMgb25seSBleGlzdHMgYmVjYXVzZSBmcy5leGlzdHNTeW5jKCkgXCJ3aWxsIGJlIGRlcHJlY2F0ZWRcIlxuLy8gc2VlIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvZnMuaHRtbCNmc19mc19leGlzdHNzeW5jX3BhdGhcblkxOE4ucHJvdG90eXBlLl9maWxlRXhpc3RzU3luYyA9IGZ1bmN0aW9uIChmaWxlKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGZzLnN0YXRTeW5jKGZpbGUpLmlzRmlsZSgpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cblkxOE4ucHJvdG90eXBlLl9fbiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpXG4gIHZhciBzaW5ndWxhciA9IGFyZ3Muc2hpZnQoKVxuICB2YXIgcGx1cmFsID0gYXJncy5zaGlmdCgpXG4gIHZhciBxdWFudGl0eSA9IGFyZ3Muc2hpZnQoKVxuXG4gIHZhciBjYiA9IGZ1bmN0aW9uICgpIHt9IC8vIHN0YXJ0IHdpdGggbm9vcC5cbiAgaWYgKHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gPT09ICdmdW5jdGlvbicpIGNiID0gYXJncy5wb3AoKVxuXG4gIGlmICghdGhpcy5jYWNoZVt0aGlzLmxvY2FsZV0pIHRoaXMuX3JlYWRMb2NhbGVGaWxlKClcblxuICB2YXIgc3RyID0gcXVhbnRpdHkgPT09IDEgPyBzaW5ndWxhciA6IHBsdXJhbFxuICBpZiAodGhpcy5jYWNoZVt0aGlzLmxvY2FsZV1bc2luZ3VsYXJdKSB7XG4gICAgc3RyID0gdGhpcy5jYWNoZVt0aGlzLmxvY2FsZV1bc2luZ3VsYXJdW3F1YW50aXR5ID09PSAxID8gJ29uZScgOiAnb3RoZXInXVxuICB9XG5cbiAgLy8gd2UndmUgb2JzZXJ2ZWQgYSBuZXcgc3RyaW5nLCB1cGRhdGUgdGhlIGxhbmd1YWdlIGZpbGUuXG4gIGlmICghdGhpcy5jYWNoZVt0aGlzLmxvY2FsZV1bc2luZ3VsYXJdICYmIHRoaXMudXBkYXRlRmlsZXMpIHtcbiAgICB0aGlzLmNhY2hlW3RoaXMubG9jYWxlXVtzaW5ndWxhcl0gPSB7XG4gICAgICBvbmU6IHNpbmd1bGFyLFxuICAgICAgb3RoZXI6IHBsdXJhbFxuICAgIH1cblxuICAgIC8vIGluY2x1ZGUgdGhlIGN1cnJlbnQgZGlyZWN0b3J5IGFuZCBsb2NhbGUsXG4gICAgLy8gc2luY2UgdGhlc2UgdmFsdWVzIGNvdWxkIGNoYW5nZSBiZWZvcmUgdGhlXG4gICAgLy8gd3JpdGUgaXMgcGVyZm9ybWVkLlxuICAgIHRoaXMuX2VucXVldWVXcml0ZShbdGhpcy5kaXJlY3RvcnksIHRoaXMubG9jYWxlLCBjYl0pXG4gIH0gZWxzZSB7XG4gICAgY2IoKVxuICB9XG5cbiAgLy8gaWYgYSAlZCBwbGFjZWhvbGRlciBpcyBwcm92aWRlZCwgYWRkIHF1YW50aXR5XG4gIC8vIHRvIHRoZSBhcmd1bWVudHMgZXhwYW5kZWQgYnkgdXRpbC5mb3JtYXQuXG4gIHZhciB2YWx1ZXMgPSBbc3RyXVxuICBpZiAofnN0ci5pbmRleE9mKCclZCcpKSB2YWx1ZXMucHVzaChxdWFudGl0eSlcblxuICByZXR1cm4gdXRpbC5mb3JtYXQuYXBwbHkodXRpbCwgdmFsdWVzLmNvbmNhdChhcmdzKSlcbn1cblxuWTE4Ti5wcm90b3R5cGUuc2V0TG9jYWxlID0gZnVuY3Rpb24gKGxvY2FsZSkge1xuICB0aGlzLmxvY2FsZSA9IGxvY2FsZVxufVxuXG5ZMThOLnByb3RvdHlwZS5nZXRMb2NhbGUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmxvY2FsZVxufVxuXG5ZMThOLnByb3RvdHlwZS51cGRhdGVMb2NhbGUgPSBmdW5jdGlvbiAob2JqKSB7XG4gIGlmICghdGhpcy5jYWNoZVt0aGlzLmxvY2FsZV0pIHRoaXMuX3JlYWRMb2NhbGVGaWxlKClcblxuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgdGhpcy5jYWNoZVt0aGlzLmxvY2FsZV1ba2V5XSA9IG9ialtrZXldXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3B0cykge1xuICB2YXIgeTE4biA9IG5ldyBZMThOKG9wdHMpXG5cbiAgLy8gYmluZCBhbGwgZnVuY3Rpb25zIHRvIHkxOG4sIHNvIHRoYXRcbiAgLy8gdGhleSBjYW4gYmUgdXNlZCBpbiBpc29sYXRpb24uXG4gIGZvciAodmFyIGtleSBpbiB5MThuKSB7XG4gICAgaWYgKHR5cGVvZiB5MThuW2tleV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHkxOG5ba2V5XSA9IHkxOG5ba2V5XS5iaW5kKHkxOG4pXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHkxOG5cbn1cbiIsInZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKVxudmFyIENvbXBsZXRpb24gPSByZXF1aXJlKCcuL2xpYi9jb21wbGV0aW9uJylcbnZhciBQYXJzZXIgPSByZXF1aXJlKCcuL2xpYi9wYXJzZXInKVxudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJylcbnZhciB0b2tlbml6ZUFyZ1N0cmluZyA9IHJlcXVpcmUoJy4vbGliL3Rva2VuaXplLWFyZy1zdHJpbmcnKVxudmFyIFVzYWdlID0gcmVxdWlyZSgnLi9saWIvdXNhZ2UnKVxudmFyIFZhbGlkYXRpb24gPSByZXF1aXJlKCcuL2xpYi92YWxpZGF0aW9uJylcbnZhciBZMThuID0gcmVxdWlyZSgneTE4bicpXG5cbkFyZ3YocHJvY2Vzcy5hcmd2LnNsaWNlKDIpKVxuXG52YXIgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gQXJndlxuZnVuY3Rpb24gQXJndiAocHJvY2Vzc0FyZ3MsIGN3ZCkge1xuICBwcm9jZXNzQXJncyA9IHByb2Nlc3NBcmdzIHx8IFtdIC8vIGhhbmRsZSBjYWxsaW5nIHlhcmdzKCkuXG5cbiAgdmFyIHNlbGYgPSB7fVxuICB2YXIgY29tcGxldGlvbiA9IG51bGxcbiAgdmFyIHVzYWdlID0gbnVsbFxuICB2YXIgdmFsaWRhdGlvbiA9IG51bGxcbiAgdmFyIHkxOG4gPSBZMThuKHtcbiAgICBkaXJlY3Rvcnk6IHBhdGgucmVzb2x2ZShfX2Rpcm5hbWUsICcuL2xvY2FsZXMnKSxcbiAgICB1cGRhdGVGaWxlczogZmFsc2VcbiAgfSlcblxuICBpZiAoIWN3ZCkgY3dkID0gcHJvY2Vzcy5jd2QoKVxuXG4gIHNlbGYuJDAgPSBwcm9jZXNzLmFyZ3ZcbiAgICAuc2xpY2UoMCwgMilcbiAgICAubWFwKGZ1bmN0aW9uICh4LCBpKSB7XG4gICAgICAvLyBpZ25vcmUgdGhlIG5vZGUgYmluLCBzcGVjaWZ5IHRoaXMgaW4geW91clxuICAgICAgLy8gYmluIGZpbGUgd2l0aCAjIS91c3IvYmluL2VudiBub2RlXG4gICAgICBpZiAoaSA9PT0gMCAmJiAvXFxiKG5vZGV8aW9qcykkLy50ZXN0KHgpKSByZXR1cm5cbiAgICAgIHZhciBiID0gcmViYXNlKGN3ZCwgeClcbiAgICAgIHJldHVybiB4Lm1hdGNoKC9eXFwvLykgJiYgYi5sZW5ndGggPCB4Lmxlbmd0aCA/IGIgOiB4XG4gICAgfSlcbiAgICAuam9pbignICcpLnRyaW0oKVxuXG4gIGlmIChwcm9jZXNzLmVudi5fICE9PSB1bmRlZmluZWQgJiYgcHJvY2Vzcy5hcmd2WzFdID09PSBwcm9jZXNzLmVudi5fKSB7XG4gICAgc2VsZi4kMCA9IHByb2Nlc3MuZW52Ll8ucmVwbGFjZShcbiAgICAgIHBhdGguZGlybmFtZShwcm9jZXNzLmV4ZWNQYXRoKSArICcvJywgJydcbiAgICApXG4gIH1cblxuICB2YXIgb3B0aW9uc1xuICBzZWxmLnJlc2V0T3B0aW9ucyA9IHNlbGYucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gcHV0IHlhcmdzIGJhY2sgaW50byBpdHMgaW5pdGlhbFxuICAgIC8vIHN0YXRlLCB0aGlzIGlzIHVzZWZ1bCBmb3IgY3JlYXRpbmcgYVxuICAgIC8vIG5lc3RlZCBDTEkuXG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIGFycmF5OiBbXSxcbiAgICAgIGJvb2xlYW46IFtdLFxuICAgICAgc3RyaW5nOiBbXSxcbiAgICAgIG5hcmc6IHt9LFxuICAgICAga2V5OiB7fSxcbiAgICAgIGFsaWFzOiB7fSxcbiAgICAgIGRlZmF1bHQ6IHt9LFxuICAgICAgZGVmYXVsdERlc2NyaXB0aW9uOiB7fSxcbiAgICAgIGNob2ljZXM6IHt9LFxuICAgICAgcmVxdWlyZXNBcmc6IFtdLFxuICAgICAgY291bnQ6IFtdLFxuICAgICAgbm9ybWFsaXplOiBbXSxcbiAgICAgIGNvbmZpZzoge30sXG4gICAgICBlbnZQcmVmaXg6IHVuZGVmaW5lZFxuICAgIH1cblxuICAgIHVzYWdlID0gVXNhZ2Uoc2VsZiwgeTE4bikgLy8gaGFuZGxlIHVzYWdlIG91dHB1dC5cbiAgICB2YWxpZGF0aW9uID0gVmFsaWRhdGlvbihzZWxmLCB1c2FnZSwgeTE4bikgLy8gaGFuZGxlIGFyZyB2YWxpZGF0aW9uLlxuICAgIGNvbXBsZXRpb24gPSBDb21wbGV0aW9uKHNlbGYsIHVzYWdlKVxuXG4gICAgZGVtYW5kZWQgPSB7fVxuICAgIGdyb3VwcyA9IHt9XG5cbiAgICBleGl0UHJvY2VzcyA9IHRydWVcbiAgICBzdHJpY3QgPSBmYWxzZVxuICAgIGhlbHBPcHQgPSBudWxsXG4gICAgdmVyc2lvbk9wdCA9IG51bGxcbiAgICBjb21tYW5kSGFuZGxlcnMgPSB7fVxuICAgIHNlbGYucGFyc2VkID0gZmFsc2VcblxuICAgIHJldHVybiBzZWxmXG4gIH1cbiAgc2VsZi5yZXNldE9wdGlvbnMoKVxuXG4gIHNlbGYuYm9vbGVhbiA9IGZ1bmN0aW9uIChib29scykge1xuICAgIG9wdGlvbnMuYm9vbGVhbi5wdXNoLmFwcGx5KG9wdGlvbnMuYm9vbGVhbiwgW10uY29uY2F0KGJvb2xzKSlcbiAgICByZXR1cm4gc2VsZlxuICB9XG5cbiAgc2VsZi5hcnJheSA9IGZ1bmN0aW9uIChhcnJheXMpIHtcbiAgICBvcHRpb25zLmFycmF5LnB1c2guYXBwbHkob3B0aW9ucy5hcnJheSwgW10uY29uY2F0KGFycmF5cykpXG4gICAgcmV0dXJuIHNlbGZcbiAgfVxuXG4gIHNlbGYubmFyZ3MgPSBmdW5jdGlvbiAoa2V5LCBuKSB7XG4gICAgaWYgKHR5cGVvZiBrZXkgPT09ICdvYmplY3QnKSB7XG4gICAgICBPYmplY3Qua2V5cyhrZXkpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgICAgc2VsZi5uYXJncyhrLCBrZXlba10pXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb25zLm5hcmdba2V5XSA9IG5cbiAgICB9XG4gICAgcmV0dXJuIHNlbGZcbiAgfVxuXG4gIHNlbGYuY2hvaWNlcyA9IGZ1bmN0aW9uIChrZXksIHZhbHVlcykge1xuICAgIGlmICh0eXBlb2Yga2V5ID09PSAnb2JqZWN0Jykge1xuICAgICAgT2JqZWN0LmtleXMoa2V5KS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHNlbGYuY2hvaWNlcyhrLCBrZXlba10pXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb25zLmNob2ljZXNba2V5XSA9IChvcHRpb25zLmNob2ljZXNba2V5XSB8fCBbXSkuY29uY2F0KHZhbHVlcylcbiAgICB9XG4gICAgcmV0dXJuIHNlbGZcbiAgfVxuXG4gIHNlbGYubm9ybWFsaXplID0gZnVuY3Rpb24gKHN0cmluZ3MpIHtcbiAgICBvcHRpb25zLm5vcm1hbGl6ZS5wdXNoLmFwcGx5KG9wdGlvbnMubm9ybWFsaXplLCBbXS5jb25jYXQoc3RyaW5ncykpXG4gICAgcmV0dXJuIHNlbGZcbiAgfVxuXG4gIHNlbGYuY29uZmlnID0gZnVuY3Rpb24gKGtleSwgbXNnLCBwYXJzZUZuKSB7XG4gICAgaWYgKHR5cGVvZiBtc2cgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBhcnNlRm4gPSBtc2dcbiAgICAgIG1zZyA9IG51bGxcbiAgICB9XG4gICAgc2VsZi5kZXNjcmliZShrZXksIG1zZyB8fCB1c2FnZS5kZWZlclkxOG5Mb29rdXAoJ1BhdGggdG8gSlNPTiBjb25maWcgZmlsZScpKVxuICAgIDsoQXJyYXkuaXNBcnJheShrZXkpID8ga2V5IDogW2tleV0pLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgIG9wdGlvbnMuY29uZmlnW2tdID0gcGFyc2VGbiB8fCB0cnVlXG4gICAgfSlcbiAgICByZXR1cm4gc2VsZlxuICB9XG5cbiAgc2VsZi5leGFtcGxlID0gZnVuY3Rpb24gKGNtZCwgZGVzY3JpcHRpb24pIHtcbiAgICB1c2FnZS5leGFtcGxlKGNtZCwgZGVzY3JpcHRpb24pXG4gICAgcmV0dXJuIHNlbGZcbiAgfVxuXG4gIHNlbGYuY29tbWFuZCA9IGZ1bmN0aW9uIChjbWQsIGRlc2NyaXB0aW9uLCBmbikge1xuICAgIGlmIChkZXNjcmlwdGlvbiAhPT0gZmFsc2UpIHtcbiAgICAgIHVzYWdlLmNvbW1hbmQoY21kLCBkZXNjcmlwdGlvbilcbiAgICB9XG4gICAgaWYgKGZuKSBjb21tYW5kSGFuZGxlcnNbY21kXSA9IGZuXG4gICAgcmV0dXJuIHNlbGZcbiAgfVxuXG4gIHZhciBjb21tYW5kSGFuZGxlcnMgPSB7fVxuICBzZWxmLmdldENvbW1hbmRIYW5kbGVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gY29tbWFuZEhhbmRsZXJzXG4gIH1cblxuICBzZWxmLnN0cmluZyA9IGZ1bmN0aW9uIChzdHJpbmdzKSB7XG4gICAgb3B0aW9ucy5zdHJpbmcucHVzaC5hcHBseShvcHRpb25zLnN0cmluZywgW10uY29uY2F0KHN0cmluZ3MpKVxuICAgIHJldHVybiBzZWxmXG4gIH1cblxuICBzZWxmLmRlZmF1bHQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSwgZGVmYXVsdERlc2NyaXB0aW9uKSB7XG4gICAgaWYgKHR5cGVvZiBrZXkgPT09ICdvYmplY3QnKSB7XG4gICAgICBPYmplY3Qua2V5cyhrZXkpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgICAgc2VsZi5kZWZhdWx0KGssIGtleVtrXSlcbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChkZWZhdWx0RGVzY3JpcHRpb24pIG9wdGlvbnMuZGVmYXVsdERlc2NyaXB0aW9uW2tleV0gPSBkZWZhdWx0RGVzY3JpcHRpb25cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaWYgKCFvcHRpb25zLmRlZmF1bHREZXNjcmlwdGlvbltrZXldKSBvcHRpb25zLmRlZmF1bHREZXNjcmlwdGlvbltrZXldID0gdXNhZ2UuZnVuY3Rpb25EZXNjcmlwdGlvbih2YWx1ZSlcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5jYWxsKClcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMuZGVmYXVsdFtrZXldID0gdmFsdWVcbiAgICB9XG4gICAgcmV0dXJuIHNlbGZcbiAgfVxuXG4gIHNlbGYuYWxpYXMgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgIGlmICh0eXBlb2YgeCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIE9iamVjdC5rZXlzKHgpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBzZWxmLmFsaWFzKGtleSwgeFtrZXldKVxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcGVyaGFwcyAneCcgaXMgYWxyZWFkeSBhbiBhbGlhcyBpbiBhbm90aGVyIGxpc3Q/XG4gICAgICAvLyBpZiBzbyB3ZSBzaG91bGQgYXBwZW5kIHRvIHgncyBsaXN0LlxuICAgICAgdmFyIGFsaWFzZXMgPSBudWxsXG4gICAgICBPYmplY3Qua2V5cyhvcHRpb25zLmFsaWFzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKH5vcHRpb25zLmFsaWFzW2tleV0uaW5kZXhPZih4KSkgYWxpYXNlcyA9IG9wdGlvbnMuYWxpYXNba2V5XVxuICAgICAgfSlcblxuICAgICAgaWYgKGFsaWFzZXMpIHsgLy8geCB3YXMgYW4gYWxpYXMgaXRzZWxmLlxuICAgICAgICBhbGlhc2VzLnB1c2goeSlcbiAgICAgIH0gZWxzZSB7IC8vIHggaXMgYSBuZXcgYWxpYXMga2V5LlxuICAgICAgICBvcHRpb25zLmFsaWFzW3hdID0gKG9wdGlvbnMuYWxpYXNbeF0gfHwgW10pLmNvbmNhdCh5KVxuICAgICAgfVxuXG4gICAgICAvLyB3YWl0ISBwZXJoYXBzIHdlJ3ZlIGNyZWF0ZWQgdHdvIGxpc3RzIG9mIGFsaWFzZXNcbiAgICAgIC8vIHRoYXQgcmVmZXJlbmNlIGVhY2ggb3RoZXI/XG4gICAgICBpZiAob3B0aW9ucy5hbGlhc1t5XSkge1xuICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseSgob3B0aW9ucy5hbGlhc1t4XSB8fCBhbGlhc2VzKSwgb3B0aW9ucy5hbGlhc1t5XSlcbiAgICAgICAgZGVsZXRlIG9wdGlvbnMuYWxpYXNbeV1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNlbGZcbiAgfVxuXG4gIHNlbGYuY291bnQgPSBmdW5jdGlvbiAoY291bnRzKSB7XG4gICAgb3B0aW9ucy5jb3VudC5wdXNoLmFwcGx5KG9wdGlvbnMuY291bnQsIFtdLmNvbmNhdChjb3VudHMpKVxuICAgIHJldHVybiBzZWxmXG4gIH1cblxuICB2YXIgZGVtYW5kZWQgPSB7fVxuICBzZWxmLmRlbWFuZCA9IHNlbGYucmVxdWlyZWQgPSBzZWxmLnJlcXVpcmUgPSBmdW5jdGlvbiAoa2V5cywgbWF4LCBtc2cpIHtcbiAgICAvLyB5b3UgY2FuIG9wdGlvbmFsbHkgcHJvdmlkZSBhICdtYXgnIGtleSxcbiAgICAvLyB3aGljaCB3aWxsIHJhaXNlIGFuIGV4Y2VwdGlvbiBpZiB0b28gbWFueSAnXydcbiAgICAvLyBvcHRpb25zIGFyZSBwcm92aWRlZC5cbiAgICBpZiAodHlwZW9mIG1heCAhPT0gJ251bWJlcicpIHtcbiAgICAgIG1zZyA9IG1heFxuICAgICAgbWF4ID0gSW5maW5pdHlcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGtleXMgPT09ICdudW1iZXInKSB7XG4gICAgICBpZiAoIWRlbWFuZGVkLl8pIGRlbWFuZGVkLl8gPSB7IGNvdW50OiAwLCBtc2c6IG51bGwsIG1heDogbWF4IH1cbiAgICAgIGRlbWFuZGVkLl8uY291bnQgPSBrZXlzXG4gICAgICBkZW1hbmRlZC5fLm1zZyA9IG1zZ1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShrZXlzKSkge1xuICAgICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgc2VsZi5kZW1hbmQoa2V5LCBtc2cpXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZW9mIG1zZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZGVtYW5kZWRba2V5c10gPSB7IG1zZzogbXNnIH1cbiAgICAgIH0gZWxzZSBpZiAobXNnID09PSB0cnVlIHx8IHR5cGVvZiBtc2cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGRlbWFuZGVkW2tleXNdID0geyBtc2c6IHVuZGVmaW5lZCB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlbGZcbiAgfVxuICBzZWxmLmdldERlbWFuZGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBkZW1hbmRlZFxuICB9XG5cbiAgc2VsZi5yZXF1aXJlc0FyZyA9IGZ1bmN0aW9uIChyZXF1aXJlc0FyZ3MpIHtcbiAgICBvcHRpb25zLnJlcXVpcmVzQXJnLnB1c2guYXBwbHkob3B0aW9ucy5yZXF1aXJlc0FyZywgW10uY29uY2F0KHJlcXVpcmVzQXJncykpXG4gICAgcmV0dXJuIHNlbGZcbiAgfVxuXG4gIHNlbGYuaW1wbGllcyA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgdmFsaWRhdGlvbi5pbXBsaWVzKGtleSwgdmFsdWUpXG4gICAgcmV0dXJuIHNlbGZcbiAgfVxuXG4gIHNlbGYudXNhZ2UgPSBmdW5jdGlvbiAobXNnLCBvcHRzKSB7XG4gICAgaWYgKCFvcHRzICYmIHR5cGVvZiBtc2cgPT09ICdvYmplY3QnKSB7XG4gICAgICBvcHRzID0gbXNnXG4gICAgICBtc2cgPSBudWxsXG4gICAgfVxuXG4gICAgdXNhZ2UudXNhZ2UobXNnKVxuXG4gICAgaWYgKG9wdHMpIHNlbGYub3B0aW9ucyhvcHRzKVxuXG4gICAgcmV0dXJuIHNlbGZcbiAgfVxuXG4gIHNlbGYuZXBpbG9ndWUgPSBzZWxmLmVwaWxvZyA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICB1c2FnZS5lcGlsb2cobXNnKVxuICAgIHJldHVybiBzZWxmXG4gIH1cblxuICBzZWxmLmZhaWwgPSBmdW5jdGlvbiAoZikge1xuICAgIHVzYWdlLmZhaWxGbihmKVxuICAgIHJldHVybiBzZWxmXG4gIH1cblxuICBzZWxmLmNoZWNrID0gZnVuY3Rpb24gKGYpIHtcbiAgICB2YWxpZGF0aW9uLmNoZWNrKGYpXG4gICAgcmV0dXJuIHNlbGZcbiAgfVxuXG4gIHNlbGYuZGVmYXVsdHMgPSBzZWxmLmRlZmF1bHRcblxuICBzZWxmLmRlc2NyaWJlID0gZnVuY3Rpb24gKGtleSwgZGVzYykge1xuICAgIG9wdGlvbnMua2V5W2tleV0gPSB0cnVlXG4gICAgdXNhZ2UuZGVzY3JpYmUoa2V5LCBkZXNjKVxuICAgIHJldHVybiBzZWxmXG4gIH1cblxuICBzZWxmLnBhcnNlID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICByZXR1cm4gcGFyc2VBcmdzKGFyZ3MpXG4gIH1cblxuICBzZWxmLm9wdGlvbiA9IHNlbGYub3B0aW9ucyA9IGZ1bmN0aW9uIChrZXksIG9wdCkge1xuICAgIGlmICh0eXBlb2Yga2V5ID09PSAnb2JqZWN0Jykge1xuICAgICAgT2JqZWN0LmtleXMoa2V5KS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHNlbGYub3B0aW9ucyhrLCBrZXlba10pXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICBhc3NlcnQodHlwZW9mIG9wdCA9PT0gJ29iamVjdCcsICdzZWNvbmQgYXJndW1lbnQgdG8gb3B0aW9uIG11c3QgYmUgYW4gb2JqZWN0JylcblxuICAgICAgb3B0aW9ucy5rZXlba2V5XSA9IHRydWUgLy8gdHJhY2sgbWFudWFsbHkgc2V0IGtleXMuXG5cbiAgICAgIGlmIChvcHQuYWxpYXMpIHNlbGYuYWxpYXMoa2V5LCBvcHQuYWxpYXMpXG5cbiAgICAgIHZhciBkZW1hbmQgPSBvcHQuZGVtYW5kIHx8IG9wdC5yZXF1aXJlZCB8fCBvcHQucmVxdWlyZVxuXG4gICAgICBpZiAoZGVtYW5kKSB7XG4gICAgICAgIHNlbGYuZGVtYW5kKGtleSwgZGVtYW5kKVxuICAgICAgfSBpZiAoJ2NvbmZpZycgaW4gb3B0KSB7XG4gICAgICAgIHNlbGYuY29uZmlnKGtleSwgb3B0LmNvbmZpZ1BhcnNlcilcbiAgICAgIH0gaWYgKCdkZWZhdWx0JyBpbiBvcHQpIHtcbiAgICAgICAgc2VsZi5kZWZhdWx0KGtleSwgb3B0LmRlZmF1bHQpXG4gICAgICB9IGlmICgnbmFyZ3MnIGluIG9wdCkge1xuICAgICAgICBzZWxmLm5hcmdzKGtleSwgb3B0Lm5hcmdzKVxuICAgICAgfSBpZiAoJ2Nob2ljZXMnIGluIG9wdCkge1xuICAgICAgICBzZWxmLmNob2ljZXMoa2V5LCBvcHQuY2hvaWNlcylcbiAgICAgIH0gaWYgKCdncm91cCcgaW4gb3B0KSB7XG4gICAgICAgIHNlbGYuZ3JvdXAoa2V5LCBvcHQuZ3JvdXApXG4gICAgICB9IGlmIChvcHQuYm9vbGVhbiB8fCBvcHQudHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHNlbGYuYm9vbGVhbihrZXkpXG4gICAgICAgIGlmIChvcHQuYWxpYXMpIHNlbGYuYm9vbGVhbihvcHQuYWxpYXMpXG4gICAgICB9IGlmIChvcHQuYXJyYXkgfHwgb3B0LnR5cGUgPT09ICdhcnJheScpIHtcbiAgICAgICAgc2VsZi5hcnJheShrZXkpXG4gICAgICAgIGlmIChvcHQuYWxpYXMpIHNlbGYuYXJyYXkob3B0LmFsaWFzKVxuICAgICAgfSBpZiAob3B0LnN0cmluZyB8fCBvcHQudHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgc2VsZi5zdHJpbmcoa2V5KVxuICAgICAgICBpZiAob3B0LmFsaWFzKSBzZWxmLnN0cmluZyhvcHQuYWxpYXMpXG4gICAgICB9IGlmIChvcHQuY291bnQgfHwgb3B0LnR5cGUgPT09ICdjb3VudCcpIHtcbiAgICAgICAgc2VsZi5jb3VudChrZXkpXG4gICAgICB9IGlmIChvcHQuZGVmYXVsdERlc2NyaXB0aW9uKSB7XG4gICAgICAgIG9wdGlvbnMuZGVmYXVsdERlc2NyaXB0aW9uW2tleV0gPSBvcHQuZGVmYXVsdERlc2NyaXB0aW9uXG4gICAgICB9XG5cbiAgICAgIHZhciBkZXNjID0gb3B0LmRlc2NyaWJlIHx8IG9wdC5kZXNjcmlwdGlvbiB8fCBvcHQuZGVzY1xuICAgICAgaWYgKGRlc2MpIHtcbiAgICAgICAgc2VsZi5kZXNjcmliZShrZXksIGRlc2MpXG4gICAgICB9XG5cbiAgICAgIGlmIChvcHQucmVxdWlyZXNBcmcpIHtcbiAgICAgICAgc2VsZi5yZXF1aXJlc0FyZyhrZXkpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlbGZcbiAgfVxuICBzZWxmLmdldE9wdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG9wdGlvbnNcbiAgfVxuXG4gIHZhciBncm91cHMgPSB7fVxuICBzZWxmLmdyb3VwID0gZnVuY3Rpb24gKG9wdHMsIGdyb3VwTmFtZSkge1xuICAgIHZhciBzZWVuID0ge31cbiAgICBncm91cHNbZ3JvdXBOYW1lXSA9IChncm91cHNbZ3JvdXBOYW1lXSB8fCBbXSkuY29uY2F0KG9wdHMpLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBpZiAoc2VlbltrZXldKSByZXR1cm4gZmFsc2VcbiAgICAgIHJldHVybiAoc2VlbltrZXldID0gdHJ1ZSlcbiAgICB9KVxuICAgIHJldHVybiBzZWxmXG4gIH1cbiAgc2VsZi5nZXRHcm91cHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGdyb3Vwc1xuICB9XG5cbiAgLy8gYXMgbG9uZyBhcyBvcHRpb25zLmVudlByZWZpeCBpcyBub3QgdW5kZWZpbmVkLFxuICAvLyBwYXJzZXIgd2lsbCBhcHBseSBlbnYgdmFycyBtYXRjaGluZyBwcmVmaXggdG8gYXJndlxuICBzZWxmLmVudiA9IGZ1bmN0aW9uIChwcmVmaXgpIHtcbiAgICBpZiAocHJlZml4ID09PSBmYWxzZSkgb3B0aW9ucy5lbnZQcmVmaXggPSB1bmRlZmluZWRcbiAgICBlbHNlIG9wdGlvbnMuZW52UHJlZml4ID0gcHJlZml4IHx8ICcnXG4gICAgcmV0dXJuIHNlbGZcbiAgfVxuXG4gIHNlbGYud3JhcCA9IGZ1bmN0aW9uIChjb2xzKSB7XG4gICAgdXNhZ2Uud3JhcChjb2xzKVxuICAgIHJldHVybiBzZWxmXG4gIH1cblxuICB2YXIgc3RyaWN0ID0gZmFsc2VcbiAgc2VsZi5zdHJpY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgc3RyaWN0ID0gdHJ1ZVxuICAgIHJldHVybiBzZWxmXG4gIH1cbiAgc2VsZi5nZXRTdHJpY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHN0cmljdFxuICB9XG5cbiAgc2VsZi5zaG93SGVscCA9IGZ1bmN0aW9uIChsZXZlbCkge1xuICAgIGlmICghc2VsZi5wYXJzZWQpIHBhcnNlQXJncyhwcm9jZXNzQXJncykgLy8gcnVuIHBhcnNlciwgaWYgaXQgaGFzIG5vdCBhbHJlYWR5IGJlZW4gZXhlY3V0ZWQuXG4gICAgdXNhZ2Uuc2hvd0hlbHAobGV2ZWwpXG4gICAgcmV0dXJuIHNlbGZcbiAgfVxuXG4gIHZhciB2ZXJzaW9uT3B0ID0gbnVsbFxuICBzZWxmLnZlcnNpb24gPSBmdW5jdGlvbiAodmVyLCBvcHQsIG1zZykge1xuICAgIHZlcnNpb25PcHQgPSBvcHQgfHwgJ3ZlcnNpb24nXG4gICAgdXNhZ2UudmVyc2lvbih2ZXIpXG4gICAgc2VsZi5ib29sZWFuKHZlcnNpb25PcHQpXG4gICAgc2VsZi5kZXNjcmliZSh2ZXJzaW9uT3B0LCBtc2cgfHwgdXNhZ2UuZGVmZXJZMThuTG9va3VwKCdTaG93IHZlcnNpb24gbnVtYmVyJykpXG4gICAgcmV0dXJuIHNlbGZcbiAgfVxuXG4gIHZhciBoZWxwT3B0ID0gbnVsbFxuICBzZWxmLmFkZEhlbHBPcHQgPSBmdW5jdGlvbiAob3B0LCBtc2cpIHtcbiAgICBoZWxwT3B0ID0gb3B0XG4gICAgc2VsZi5ib29sZWFuKG9wdClcbiAgICBzZWxmLmRlc2NyaWJlKG9wdCwgbXNnIHx8IHVzYWdlLmRlZmVyWTE4bkxvb2t1cCgnU2hvdyBoZWxwJykpXG4gICAgcmV0dXJuIHNlbGZcbiAgfVxuXG4gIHNlbGYuc2hvd0hlbHBPbkZhaWwgPSBmdW5jdGlvbiAoZW5hYmxlZCwgbWVzc2FnZSkge1xuICAgIHVzYWdlLnNob3dIZWxwT25GYWlsKGVuYWJsZWQsIG1lc3NhZ2UpXG4gICAgcmV0dXJuIHNlbGZcbiAgfVxuXG4gIHZhciBleGl0UHJvY2VzcyA9IHRydWVcbiAgc2VsZi5leGl0UHJvY2VzcyA9IGZ1bmN0aW9uIChlbmFibGVkKSB7XG4gICAgaWYgKHR5cGVvZiBlbmFibGVkICE9PSAnYm9vbGVhbicpIHtcbiAgICAgIGVuYWJsZWQgPSB0cnVlXG4gICAgfVxuICAgIGV4aXRQcm9jZXNzID0gZW5hYmxlZFxuICAgIHJldHVybiBzZWxmXG4gIH1cbiAgc2VsZi5nZXRFeGl0UHJvY2VzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZXhpdFByb2Nlc3NcbiAgfVxuXG4gIHNlbGYuaGVscCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHJldHVybiBzZWxmLmFkZEhlbHBPcHQuYXBwbHkoc2VsZiwgYXJndW1lbnRzKVxuXG4gICAgaWYgKCFzZWxmLnBhcnNlZCkgcGFyc2VBcmdzKHByb2Nlc3NBcmdzKSAvLyBydW4gcGFyc2VyLCBpZiBpdCBoYXMgbm90IGFscmVhZHkgYmVlbiBleGVjdXRlZC5cblxuICAgIHJldHVybiB1c2FnZS5oZWxwKClcbiAgfVxuXG4gIHZhciBjb21wbGV0aW9uQ29tbWFuZCA9IG51bGxcbiAgc2VsZi5jb21wbGV0aW9uID0gZnVuY3Rpb24gKGNtZCwgZGVzYywgZm4pIHtcbiAgICAvLyBhIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgd2hlbiBnZW5lcmF0aW5nXG4gICAgLy8gY29tcGxldGlvbnMgY2FuIGJlIHByb3ZpZGVkIGFzIHRoZSBzZWNvbmRcbiAgICAvLyBvciB0aGlyZCBhcmd1bWVudCB0byBjb21wbGV0aW9uLlxuICAgIGlmICh0eXBlb2YgZGVzYyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZm4gPSBkZXNjXG4gICAgICBkZXNjID0gbnVsbFxuICAgIH1cblxuICAgIC8vIHJlZ2lzdGVyIHRoZSBjb21wbGV0aW9uIGNvbW1hbmQuXG4gICAgY29tcGxldGlvbkNvbW1hbmQgPSBjbWQgfHwgJ2NvbXBsZXRpb24nXG4gICAgaWYgKCFkZXNjICYmIGRlc2MgIT09IGZhbHNlKSB7XG4gICAgICBkZXNjID0gJ2dlbmVyYXRlIGJhc2ggY29tcGxldGlvbiBzY3JpcHQnXG4gICAgfVxuICAgIHNlbGYuY29tbWFuZChjb21wbGV0aW9uQ29tbWFuZCwgZGVzYylcblxuICAgIC8vIGEgZnVuY3Rpb24gY2FuIGJlIHByb3ZpZGVkXG4gICAgaWYgKGZuKSBjb21wbGV0aW9uLnJlZ2lzdGVyRnVuY3Rpb24oZm4pXG5cbiAgICByZXR1cm4gc2VsZlxuICB9XG5cbiAgc2VsZi5zaG93Q29tcGxldGlvblNjcmlwdCA9IGZ1bmN0aW9uICgkMCkge1xuICAgICQwID0gJDAgfHwgc2VsZi4kMFxuICAgIGNvbnNvbGUubG9nKGNvbXBsZXRpb24uZ2VuZXJhdGVDb21wbGV0aW9uU2NyaXB0KCQwKSlcbiAgICByZXR1cm4gc2VsZlxuICB9XG5cbiAgc2VsZi5sb2NhbGUgPSBmdW5jdGlvbiAobG9jYWxlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIGd1ZXNzTG9jYWxlKClcbiAgICAgIHJldHVybiB5MThuLmdldExvY2FsZSgpXG4gICAgfVxuICAgIGRldGVjdExvY2FsZSA9IGZhbHNlXG4gICAgeTE4bi5zZXRMb2NhbGUobG9jYWxlKVxuICAgIHJldHVybiBzZWxmXG4gIH1cblxuICBzZWxmLnVwZGF0ZVN0cmluZ3MgPSBzZWxmLnVwZGF0ZUxvY2FsZSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICBkZXRlY3RMb2NhbGUgPSBmYWxzZVxuICAgIHkxOG4udXBkYXRlTG9jYWxlKG9iailcbiAgICByZXR1cm4gc2VsZlxuICB9XG5cbiAgdmFyIGRldGVjdExvY2FsZSA9IHRydWVcbiAgc2VsZi5kZXRlY3RMb2NhbGUgPSBmdW5jdGlvbiAoZGV0ZWN0KSB7XG4gICAgZGV0ZWN0TG9jYWxlID0gZGV0ZWN0XG4gICAgcmV0dXJuIHNlbGZcbiAgfVxuICBzZWxmLmdldERldGVjdExvY2FsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZGV0ZWN0TG9jYWxlXG4gIH1cblxuICBzZWxmLmdldFVzYWdlSW5zdGFuY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHVzYWdlXG4gIH1cblxuICBzZWxmLmdldFZhbGlkYXRpb25JbnN0YW5jZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdmFsaWRhdGlvblxuICB9XG5cbiAgc2VsZi50ZXJtaW5hbFdpZHRoID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiByZXF1aXJlKCd3aW5kb3ctc2l6ZScpLndpZHRoXG4gIH1cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2VsZiwgJ2FyZ3YnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYXJncyA9IG51bGxcblxuICAgICAgdHJ5IHtcbiAgICAgICAgYXJncyA9IHBhcnNlQXJncyhwcm9jZXNzQXJncylcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB1c2FnZS5mYWlsKGVyci5tZXNzYWdlKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXJnc1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogdHJ1ZVxuICB9KVxuXG4gIGZ1bmN0aW9uIHBhcnNlQXJncyAoYXJncykge1xuICAgIGFyZ3MgPSBub3JtYWxpemVBcmdzKGFyZ3MpXG5cbiAgICB2YXIgcGFyc2VkID0gUGFyc2VyKGFyZ3MsIG9wdGlvbnMsIHkxOG4pXG4gICAgdmFyIGFyZ3YgPSBwYXJzZWQuYXJndlxuICAgIHZhciBhbGlhc2VzID0gcGFyc2VkLmFsaWFzZXNcblxuICAgIGFyZ3YuJDAgPSBzZWxmLiQwXG5cbiAgICBzZWxmLnBhcnNlZCA9IHBhcnNlZFxuXG4gICAgZ3Vlc3NMb2NhbGUoKSAvLyBndWVzcyBsb2NhbGUgbGF6aWx5LCBzbyB0aGF0IGl0IGNhbiBiZSB0dXJuZWQgb2ZmIGluIGNoYWluLlxuXG4gICAgLy8gd2hpbGUgYnVpbGRpbmcgdXAgdGhlIGFyZ3Ygb2JqZWN0LCB0aGVyZVxuICAgIC8vIGFyZSB0d28gcGFzc2VzIHRocm91Z2ggdGhlIHBhcnNlci4gSWYgY29tcGxldGlvblxuICAgIC8vIGlzIGJlaW5nIHBlcmZvcm1lZCBzaG9ydC1jaXJjdWl0IG9uIHRoZSBmaXJzdCBwYXNzLlxuICAgIGlmIChjb21wbGV0aW9uQ29tbWFuZCAmJlxuICAgICAgKHByb2Nlc3MuYXJndi5qb2luKCcgJykpLmluZGV4T2YoY29tcGxldGlvbi5jb21wbGV0aW9uS2V5KSAhPT0gLTEgJiZcbiAgICAgICFhcmd2W2NvbXBsZXRpb24uY29tcGxldGlvbktleV0pIHtcbiAgICAgIHJldHVybiBhcmd2XG4gICAgfVxuXG4gICAgLy8gaWYgdGhlcmUncyBhIGhhbmRsZXIgYXNzb2NpYXRlZCB3aXRoIGFcbiAgICAvLyBjb21tYW5kIGRlZmVyIHByb2Nlc3NpbmcgdG8gaXQuXG4gICAgdmFyIGhhbmRsZXJLZXlzID0gT2JqZWN0LmtleXMoc2VsZi5nZXRDb21tYW5kSGFuZGxlcnMoKSlcbiAgICBmb3IgKHZhciBpID0gMCwgY29tbWFuZDsgKGNvbW1hbmQgPSBoYW5kbGVyS2V5c1tpXSkgIT09IHVuZGVmaW5lZDsgaSsrKSB7XG4gICAgICBpZiAofmFyZ3YuXy5pbmRleE9mKGNvbW1hbmQpKSB7XG4gICAgICAgIHJ1bkNvbW1hbmQoY29tbWFuZCwgc2VsZiwgYXJndilcbiAgICAgICAgcmV0dXJuIHNlbGYuYXJndlxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGdlbmVyYXRlIGEgY29tcGxldGlvbiBzY3JpcHQgZm9yIGFkZGluZyB0byB+Ly5iYXNocmMuXG4gICAgaWYgKGNvbXBsZXRpb25Db21tYW5kICYmIH5hcmd2Ll8uaW5kZXhPZihjb21wbGV0aW9uQ29tbWFuZCkgJiYgIWFyZ3ZbY29tcGxldGlvbi5jb21wbGV0aW9uS2V5XSkge1xuICAgICAgc2VsZi5zaG93Q29tcGxldGlvblNjcmlwdCgpXG4gICAgICBpZiAoZXhpdFByb2Nlc3MpIHtcbiAgICAgICAgcHJvY2Vzcy5leGl0KDApXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gd2UgbXVzdCBydW4gY29tcGxldGlvbnMgZmlyc3QsIGEgdXNlciBtaWdodFxuICAgIC8vIHdhbnQgdG8gY29tcGxldGUgdGhlIC0taGVscCBvciAtLXZlcnNpb24gb3B0aW9uLlxuICAgIGlmIChjb21wbGV0aW9uLmNvbXBsZXRpb25LZXkgaW4gYXJndikge1xuICAgICAgLy8gd2UgYWxsb3cgZm9yIGFzeW5jaHJvbm91cyBjb21wbGV0aW9ucyxcbiAgICAgIC8vIGUuZy4sIGxvYWRpbmcgaW4gYSBsaXN0IG9mIGNvbW1hbmRzIGZyb20gYW4gQVBJLlxuICAgICAgY29tcGxldGlvbi5nZXRDb21wbGV0aW9uKGZ1bmN0aW9uIChjb21wbGV0aW9ucykge1xuICAgICAgICA7KGNvbXBsZXRpb25zIHx8IFtdKS5mb3JFYWNoKGZ1bmN0aW9uIChjb21wbGV0aW9uKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coY29tcGxldGlvbilcbiAgICAgICAgfSlcblxuICAgICAgICBpZiAoZXhpdFByb2Nlc3MpIHtcbiAgICAgICAgICBwcm9jZXNzLmV4aXQoMClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBoZWxwT3JWZXJzaW9uID0gZmFsc2VcbiAgICBPYmplY3Qua2V5cyhhcmd2KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIGlmIChrZXkgPT09IGhlbHBPcHQgJiYgYXJndltrZXldKSB7XG4gICAgICAgIGhlbHBPclZlcnNpb24gPSB0cnVlXG4gICAgICAgIHNlbGYuc2hvd0hlbHAoJ2xvZycpXG4gICAgICAgIGlmIChleGl0UHJvY2Vzcykge1xuICAgICAgICAgIHByb2Nlc3MuZXhpdCgwKVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGtleSA9PT0gdmVyc2lvbk9wdCAmJiBhcmd2W2tleV0pIHtcbiAgICAgICAgaGVscE9yVmVyc2lvbiA9IHRydWVcbiAgICAgICAgdXNhZ2Uuc2hvd1ZlcnNpb24oKVxuICAgICAgICBpZiAoZXhpdFByb2Nlc3MpIHtcbiAgICAgICAgICBwcm9jZXNzLmV4aXQoMClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG5cbiAgICAvLyBJZiB0aGUgaGVscCBvciB2ZXJzaW9uIG9wdGlvbnMgd2hlcmUgdXNlZCBhbmQgZXhpdFByb2Nlc3MgaXMgZmFsc2UsXG4gICAgLy8gd2Ugd29uJ3QgcnVuIHZhbGlkYXRpb25zXG4gICAgaWYgKCFoZWxwT3JWZXJzaW9uKSB7XG4gICAgICBpZiAocGFyc2VkLmVycm9yKSB0aHJvdyBwYXJzZWQuZXJyb3JcblxuICAgICAgLy8gaWYgd2UncmUgZXhlY3V0ZWQgdmlhIGJhc2ggY29tcGxldGlvbiwgZG9uJ3RcbiAgICAgIC8vIGJvdGhlciB3aXRoIHZhbGlkYXRpb24uXG4gICAgICBpZiAoIWFyZ3ZbY29tcGxldGlvbi5jb21wbGV0aW9uS2V5XSkge1xuICAgICAgICB2YWxpZGF0aW9uLm5vbk9wdGlvbkNvdW50KGFyZ3YpXG4gICAgICAgIHZhbGlkYXRpb24ubWlzc2luZ0FyZ3VtZW50VmFsdWUoYXJndilcbiAgICAgICAgdmFsaWRhdGlvbi5yZXF1aXJlZEFyZ3VtZW50cyhhcmd2KVxuICAgICAgICBpZiAoc3RyaWN0KSB2YWxpZGF0aW9uLnVua25vd25Bcmd1bWVudHMoYXJndiwgYWxpYXNlcylcbiAgICAgICAgdmFsaWRhdGlvbi5jdXN0b21DaGVja3MoYXJndiwgYWxpYXNlcylcbiAgICAgICAgdmFsaWRhdGlvbi5saW1pdGVkQ2hvaWNlcyhhcmd2KVxuICAgICAgICB2YWxpZGF0aW9uLmltcGxpY2F0aW9ucyhhcmd2KVxuICAgICAgfVxuICAgIH1cblxuICAgIHNldFBsYWNlaG9sZGVyS2V5cyhhcmd2KVxuXG4gICAgcmV0dXJuIGFyZ3ZcbiAgfVxuXG4gIGZ1bmN0aW9uIGd1ZXNzTG9jYWxlICgpIHtcbiAgICBpZiAoIWRldGVjdExvY2FsZSkgcmV0dXJuXG5cbiAgICB0cnkge1xuICAgICAgdmFyIG9zTG9jYWxlID0gcmVxdWlyZSgnb3MtbG9jYWxlJylcbiAgICAgIHNlbGYubG9jYWxlKG9zTG9jYWxlLnN5bmMoeyBzcGF3bjogZmFsc2UgfSkpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBpZiB3ZSBleHBsb2RlIGxvb2tpbmcgdXAgbG9jYWxlIGp1c3Qgbm9vcFxuICAgICAgLy8gd2UnbGwga2VlcCB1c2luZyB0aGUgZGVmYXVsdCBsYW5ndWFnZSAnZW4nLlxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJ1bkNvbW1hbmQgKGNvbW1hbmQsIHlhcmdzLCBhcmd2KSB7XG4gICAgc2V0UGxhY2Vob2xkZXJLZXlzKGFyZ3YpXG4gICAgeWFyZ3MuZ2V0Q29tbWFuZEhhbmRsZXJzKClbY29tbWFuZF0oeWFyZ3MucmVzZXQoKSwgYXJndilcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldFBsYWNlaG9sZGVyS2V5cyAoYXJndikge1xuICAgIE9iamVjdC5rZXlzKG9wdGlvbnMua2V5KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIC8vIGRvbid0IHNldCBwbGFjZWhvbGRlciBrZXlzIGZvciBkb3RcbiAgICAgIC8vIG5vdGF0aW9uIG9wdGlvbnMgJ2Zvby5iYXInLlxuICAgICAgaWYgKH5rZXkuaW5kZXhPZignLicpKSByZXR1cm5cbiAgICAgIGlmICh0eXBlb2YgYXJndltrZXldID09PSAndW5kZWZpbmVkJykgYXJndltrZXldID0gdW5kZWZpbmVkXG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZUFyZ3MgKGFyZ3MpIHtcbiAgICBpZiAodHlwZW9mIGFyZ3MgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gdG9rZW5pemVBcmdTdHJpbmcoYXJncylcbiAgICB9XG4gICAgcmV0dXJuIGFyZ3NcbiAgfVxuXG4gIHNpbmdsZXRvbmlmeShzZWxmKVxuICByZXR1cm4gc2VsZlxufVxuXG4vLyByZWJhc2UgYW4gYWJzb2x1dGUgcGF0aCB0byBhIHJlbGF0aXZlIG9uZSB3aXRoIHJlc3BlY3QgdG8gYSBiYXNlIGRpcmVjdG9yeVxuLy8gZXhwb3J0ZWQgZm9yIHRlc3RzXG5leHBvcnRzLnJlYmFzZSA9IHJlYmFzZVxuZnVuY3Rpb24gcmViYXNlIChiYXNlLCBkaXIpIHtcbiAgcmV0dXJuIHBhdGgucmVsYXRpdmUoYmFzZSwgZGlyKVxufVxuXG4vKiAgSGFjayBhbiBpbnN0YW5jZSBvZiBBcmd2IHdpdGggcHJvY2Vzcy5hcmd2IGludG8gQXJndlxuICAgIHNvIHBlb3BsZSBjYW4gZG9cbiAgICByZXF1aXJlKCd5YXJncycpKFsnLS1iZWVibGU9MScsJy16Jywneml6emxlJ10pLmFyZ3ZcbiAgICB0byBwYXJzZSBhIGxpc3Qgb2YgYXJncyBhbmRcbiAgICByZXF1aXJlKCd5YXJncycpLmFyZ3ZcbiAgICB0byBnZXQgYSBwYXJzZWQgdmVyc2lvbiBvZiBwcm9jZXNzLmFyZ3YuXG4qL1xuZnVuY3Rpb24gc2luZ2xldG9uaWZ5IChpbnN0KSB7XG4gIE9iamVjdC5rZXlzKGluc3QpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIGlmIChrZXkgPT09ICdhcmd2Jykge1xuICAgICAgQXJndi5fX2RlZmluZUdldHRlcl9fKGtleSwgaW5zdC5fX2xvb2t1cEdldHRlcl9fKGtleSkpXG4gICAgfSBlbHNlIHtcbiAgICAgIEFyZ3Zba2V5XSA9IHR5cGVvZiBpbnN0W2tleV0gPT09ICdmdW5jdGlvbicgPyBpbnN0W2tleV0uYmluZChpbnN0KSA6IGluc3Rba2V5XVxuICAgIH1cbiAgfSlcbn1cbiIsImZ1bmN0aW9uIHdlYnBhY2tFbXB0eUNvbnRleHQocmVxKSB7XG5cdHZhciBlID0gbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIiArIHJlcSArIFwiJ1wiKTtcblx0ZS5jb2RlID0gJ01PRFVMRV9OT1RfRk9VTkQnO1xuXHR0aHJvdyBlO1xufVxud2VicGFja0VtcHR5Q29udGV4dC5rZXlzID0gZnVuY3Rpb24oKSB7IHJldHVybiBbXTsgfTtcbndlYnBhY2tFbXB0eUNvbnRleHQucmVzb2x2ZSA9IHdlYnBhY2tFbXB0eUNvbnRleHQ7XG5tb2R1bGUuZXhwb3J0cyA9IHdlYnBhY2tFbXB0eUNvbnRleHQ7XG53ZWJwYWNrRW1wdHlDb250ZXh0LmlkID0gXCIuL3NyYy9ub2RlX21vZHVsZXMveWFyZ3MvbGliIHN5bmMgcmVjdXJzaXZlXCI7IiwidmFyIGZzID0gcmVxdWlyZSgnZnMnKVxudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJylcblxuLy8gYWRkIGJhc2ggY29tcGxldGlvbnMgdG8geW91clxuLy8gIHlhcmdzLXBvd2VyZWQgYXBwbGljYXRpb25zLlxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoeWFyZ3MsIHVzYWdlKSB7XG4gIHZhciBzZWxmID0ge1xuICAgIGNvbXBsZXRpb25LZXk6ICdnZXQteWFyZ3MtY29tcGxldGlvbnMnXG4gIH1cblxuICAvLyBnZXQgYSBsaXN0IG9mIGNvbXBsZXRpb24gY29tbWFuZHMuXG4gIHNlbGYuZ2V0Q29tcGxldGlvbiA9IGZ1bmN0aW9uIChkb25lKSB7XG4gICAgdmFyIGNvbXBsZXRpb25zID0gW11cbiAgICB2YXIgY3VycmVudCA9IHByb2Nlc3MuYXJndltwcm9jZXNzLmFyZ3YubGVuZ3RoIC0gMV1cbiAgICB2YXIgcHJldmlvdXMgPSBwcm9jZXNzLmFyZ3Yuc2xpY2UocHJvY2Vzcy5hcmd2LmluZGV4T2YoJy0tJyArIHNlbGYuY29tcGxldGlvbktleSkgKyAxKVxuICAgIHZhciBhcmd2ID0geWFyZ3MucGFyc2UocHJldmlvdXMpXG5cbiAgICAvLyBhIGN1c3RvbSBjb21wbGV0aW9uIGZ1bmN0aW9uIGNhbiBiZSBwcm92aWRlZFxuICAgIC8vIHRvIGNvbXBsZXRpb24oKS5cbiAgICBpZiAoY29tcGxldGlvbkZ1bmN0aW9uKSB7XG4gICAgICBpZiAoY29tcGxldGlvbkZ1bmN0aW9uLmxlbmd0aCA8IDMpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGNvbXBsZXRpb25GdW5jdGlvbihjdXJyZW50LCBhcmd2KVxuXG4gICAgICAgIC8vIHByb21pc2UgYmFzZWQgY29tcGxldGlvbiBmdW5jdGlvbi5cbiAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHJldHVybiByZXN1bHQudGhlbihmdW5jdGlvbiAobGlzdCkge1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7IGRvbmUobGlzdCkgfSlcbiAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHsgdGhyb3cgZXJyIH0pXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHN5bmNocm9ub3VzIGNvbXBsZXRpb24gZnVuY3Rpb24uXG4gICAgICAgIHJldHVybiBkb25lKHJlc3VsdClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGFzeW5jaHJvbm91cyBjb21wbGV0aW9uIGZ1bmN0aW9uXG4gICAgICAgIHJldHVybiBjb21wbGV0aW9uRnVuY3Rpb24oY3VycmVudCwgYXJndiwgZnVuY3Rpb24gKGNvbXBsZXRpb25zKSB7XG4gICAgICAgICAgZG9uZShjb21wbGV0aW9ucylcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgaGFuZGxlcnMgPSB5YXJncy5nZXRDb21tYW5kSGFuZGxlcnMoKVxuICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHByZXZpb3VzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIGlmIChoYW5kbGVyc1twcmV2aW91c1tpXV0pIHtcbiAgICAgICAgcmV0dXJuIGhhbmRsZXJzW3ByZXZpb3VzW2ldXSh5YXJncy5yZXNldCgpKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghY3VycmVudC5tYXRjaCgvXi0vKSkge1xuICAgICAgdXNhZ2UuZ2V0Q29tbWFuZHMoKS5mb3JFYWNoKGZ1bmN0aW9uIChjb21tYW5kKSB7XG4gICAgICAgIGlmIChwcmV2aW91cy5pbmRleE9mKGNvbW1hbmRbMF0pID09PSAtMSkge1xuICAgICAgICAgIGNvbXBsZXRpb25zLnB1c2goY29tbWFuZFswXSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBpZiAoY3VycmVudC5tYXRjaCgvXi0vKSkge1xuICAgICAgT2JqZWN0LmtleXMoeWFyZ3MuZ2V0T3B0aW9ucygpLmtleSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGNvbXBsZXRpb25zLnB1c2goJy0tJyArIGtleSlcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgZG9uZShjb21wbGV0aW9ucylcbiAgfVxuXG4gIC8vIGdlbmVyYXRlIHRoZSBjb21wbGV0aW9uIHNjcmlwdCB0byBhZGQgdG8geW91ciAuYmFzaHJjLlxuICBzZWxmLmdlbmVyYXRlQ29tcGxldGlvblNjcmlwdCA9IGZ1bmN0aW9uICgkMCkge1xuICAgIHZhciBzY3JpcHQgPSBmcy5yZWFkRmlsZVN5bmMoXG4gICAgICBwYXRoLnJlc29sdmUoX19kaXJuYW1lLCAnLi4vY29tcGxldGlvbi5zaC5oYnMnKSxcbiAgICAgICd1dGYtOCdcbiAgICApXG4gICAgdmFyIG5hbWUgPSBwYXRoLmJhc2VuYW1lKCQwKVxuXG4gICAgLy8gYWRkIC4vdG8gYXBwbGljYXRpb25zIG5vdCB5ZXQgaW5zdGFsbGVkIGFzIGJpbi5cbiAgICBpZiAoJDAubWF0Y2goL1xcLmpzJC8pKSAkMCA9ICcuLycgKyAkMFxuXG4gICAgc2NyaXB0ID0gc2NyaXB0LnJlcGxhY2UoL3t7YXBwX25hbWV9fS9nLCBuYW1lKVxuICAgIHJldHVybiBzY3JpcHQucmVwbGFjZSgve3thcHBfcGF0aH19L2csICQwKVxuICB9XG5cbiAgLy8gcmVnaXN0ZXIgYSBmdW5jdGlvbiB0byBwZXJmb3JtIHlvdXIgb3duIGN1c3RvbVxuICAvLyBjb21wbGV0aW9ucy4sIHRoaXMgZnVuY3Rpb24gY2FuIGJlIGVpdGhlclxuICAvLyBzeW5jaHJub3VzIG9yIGFzeW5jaHJvbm91cy5cbiAgdmFyIGNvbXBsZXRpb25GdW5jdGlvbiA9IG51bGxcbiAgc2VsZi5yZWdpc3RlckZ1bmN0aW9uID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgY29tcGxldGlvbkZ1bmN0aW9uID0gZm5cbiAgfVxuXG4gIHJldHVybiBzZWxmXG59XG4iLCIvLyBmYW5jeS1wYW50cyBwYXJzaW5nIG9mIGFyZ3YsIG9yaWdpbmFsbHkgZm9ya2VkXG4vLyBmcm9tIG1pbmltaXN0OiBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9taW5pbWlzdFxudmFyIGNhbWVsQ2FzZSA9IHJlcXVpcmUoJ2NhbWVsY2FzZScpXG52YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuXG5mdW5jdGlvbiBpbmNyZW1lbnQgKG9yaWcpIHtcbiAgcmV0dXJuIG9yaWcgIT09IHVuZGVmaW5lZCA/IG9yaWcgKyAxIDogMFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmdzLCBvcHRzLCB5MThuKSB7XG4gIGlmICghb3B0cykgb3B0cyA9IHt9XG5cbiAgdmFyIF9fID0geTE4bi5fX1xuICB2YXIgZXJyb3IgPSBudWxsXG4gIHZhciBmbGFncyA9IHsgYXJyYXlzOiB7fSwgYm9vbHM6IHt9LCBzdHJpbmdzOiB7fSwgY291bnRzOiB7fSwgbm9ybWFsaXplOiB7fSwgY29uZmlnczoge30sIGRlZmF1bHRlZDoge30gfVxuXG4gIDtbXS5jb25jYXQob3B0c1snYXJyYXknXSkuZmlsdGVyKEJvb2xlYW4pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIGZsYWdzLmFycmF5c1trZXldID0gdHJ1ZVxuICB9KVxuXG4gIDtbXS5jb25jYXQob3B0c1snYm9vbGVhbiddKS5maWx0ZXIoQm9vbGVhbikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgZmxhZ3MuYm9vbHNba2V5XSA9IHRydWVcbiAgfSlcblxuICA7W10uY29uY2F0KG9wdHMuc3RyaW5nKS5maWx0ZXIoQm9vbGVhbikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgZmxhZ3Muc3RyaW5nc1trZXldID0gdHJ1ZVxuICB9KVxuXG4gIDtbXS5jb25jYXQob3B0cy5jb3VudCkuZmlsdGVyKEJvb2xlYW4pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIGZsYWdzLmNvdW50c1trZXldID0gdHJ1ZVxuICB9KVxuXG4gIDtbXS5jb25jYXQob3B0cy5ub3JtYWxpemUpLmZpbHRlcihCb29sZWFuKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBmbGFncy5ub3JtYWxpemVba2V5XSA9IHRydWVcbiAgfSlcblxuICBPYmplY3Qua2V5cyhvcHRzLmNvbmZpZykuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgIGZsYWdzLmNvbmZpZ3Nba10gPSBvcHRzLmNvbmZpZ1trXVxuICB9KVxuXG4gIHZhciBhbGlhc2VzID0ge31cbiAgdmFyIG5ld0FsaWFzZXMgPSB7fVxuXG4gIGV4dGVuZEFsaWFzZXMob3B0cy5rZXkpXG4gIGV4dGVuZEFsaWFzZXMob3B0cy5hbGlhcylcbiAgZXh0ZW5kQWxpYXNlcyhvcHRzLmRlZmF1bHQpXG5cbiAgdmFyIGRlZmF1bHRzID0gb3B0c1snZGVmYXVsdCddIHx8IHt9XG4gIE9iamVjdC5rZXlzKGRlZmF1bHRzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBpZiAoLy0vLnRlc3Qoa2V5KSAmJiAhb3B0cy5hbGlhc1trZXldKSB7XG4gICAgICBhbGlhc2VzW2tleV0gPSBhbGlhc2VzW2tleV0gfHwgW11cbiAgICB9XG4gICAgKGFsaWFzZXNba2V5XSB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbiAoYWxpYXMpIHtcbiAgICAgIGRlZmF1bHRzW2FsaWFzXSA9IGRlZmF1bHRzW2tleV1cbiAgICB9KVxuICB9KVxuXG4gIHZhciBhcmd2ID0geyBfOiBbXSB9XG5cbiAgT2JqZWN0LmtleXMoZmxhZ3MuYm9vbHMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHNldEFyZyhrZXksICEoa2V5IGluIGRlZmF1bHRzKSA/IGZhbHNlIDogZGVmYXVsdHNba2V5XSlcbiAgICBzZXREZWZhdWx0ZWQoa2V5KVxuICB9KVxuXG4gIHZhciBub3RGbGFncyA9IFtdXG4gIGlmIChhcmdzLmluZGV4T2YoJy0tJykgIT09IC0xKSB7XG4gICAgbm90RmxhZ3MgPSBhcmdzLnNsaWNlKGFyZ3MuaW5kZXhPZignLS0nKSArIDEpXG4gICAgYXJncyA9IGFyZ3Muc2xpY2UoMCwgYXJncy5pbmRleE9mKCctLScpKVxuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGFyZyA9IGFyZ3NbaV1cbiAgICB2YXIgYnJva2VuXG4gICAgdmFyIGtleVxuICAgIHZhciBsZXR0ZXJzXG4gICAgdmFyIG1cbiAgICB2YXIgbmV4dFxuICAgIHZhciB2YWx1ZVxuXG4gICAgLy8gLS0gc2VwZXJhdGVkIGJ5ID1cbiAgICBpZiAoYXJnLm1hdGNoKC9eLS0uKz0vKSkge1xuICAgICAgLy8gVXNpbmcgW1xcc1xcU10gaW5zdGVhZCBvZiAuIGJlY2F1c2UganMgZG9lc24ndCBzdXBwb3J0IHRoZVxuICAgICAgLy8gJ2RvdGFsbCcgcmVnZXggbW9kaWZpZXIuIFNlZTpcbiAgICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzEwNjgzMDgvMTMyMTZcbiAgICAgIG0gPSBhcmcubWF0Y2goL14tLShbXj1dKyk9KFtcXHNcXFNdKikkLylcblxuICAgICAgLy8gbmFyZ3MgZm9ybWF0ID0gJy0tZj1tb25rZXkgd2FzaGluZyBjYXQnXG4gICAgICBpZiAoY2hlY2tBbGxBbGlhc2VzKG1bMV0sIG9wdHMubmFyZykpIHtcbiAgICAgICAgYXJncy5zcGxpY2UoaSArIDEsIG1bMV0sIG1bMl0pXG4gICAgICAgIGkgPSBlYXROYXJncyhpLCBtWzFdLCBhcmdzKVxuICAgICAgLy8gYXJyYXlzIGZvcm1hdCA9ICctLWY9YSBiIGMnXG4gICAgICB9IGVsc2UgaWYgKGNoZWNrQWxsQWxpYXNlcyhtWzFdLCBmbGFncy5hcnJheXMpICYmIGFyZ3MubGVuZ3RoID4gaSArIDEpIHtcbiAgICAgICAgYXJncy5zcGxpY2UoaSArIDEsIG1bMV0sIG1bMl0pXG4gICAgICAgIGkgPSBlYXRBcnJheShpLCBtWzFdLCBhcmdzKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0QXJnKG1bMV0sIG1bMl0pXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhcmcubWF0Y2goL14tLW5vLS4rLykpIHtcbiAgICAgIGtleSA9IGFyZy5tYXRjaCgvXi0tbm8tKC4rKS8pWzFdXG4gICAgICBzZXRBcmcoa2V5LCBmYWxzZSlcblxuICAgIC8vIC0tIHNlcGVyYXRlZCBieSBzcGFjZS5cbiAgICB9IGVsc2UgaWYgKGFyZy5tYXRjaCgvXi0tLisvKSkge1xuICAgICAga2V5ID0gYXJnLm1hdGNoKC9eLS0oLispLylbMV1cblxuICAgICAgLy8gbmFyZ3MgZm9ybWF0ID0gJy0tZm9vIGEgYiBjJ1xuICAgICAgaWYgKGNoZWNrQWxsQWxpYXNlcyhrZXksIG9wdHMubmFyZykpIHtcbiAgICAgICAgaSA9IGVhdE5hcmdzKGksIGtleSwgYXJncylcbiAgICAgIC8vIGFycmF5IGZvcm1hdCA9ICctLWZvbyBhIGIgYydcbiAgICAgIH0gZWxzZSBpZiAoY2hlY2tBbGxBbGlhc2VzKGtleSwgZmxhZ3MuYXJyYXlzKSAmJiBhcmdzLmxlbmd0aCA+IGkgKyAxKSB7XG4gICAgICAgIGkgPSBlYXRBcnJheShpLCBrZXksIGFyZ3MpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0ID0gYXJnc1tpICsgMV1cblxuICAgICAgICBpZiAobmV4dCAhPT0gdW5kZWZpbmVkICYmICFuZXh0Lm1hdGNoKC9eLS8pICYmXG4gICAgICAgICAgIWNoZWNrQWxsQWxpYXNlcyhrZXksIGZsYWdzLmJvb2xzKSAmJlxuICAgICAgICAgICFjaGVja0FsbEFsaWFzZXMoa2V5LCBmbGFncy5jb3VudHMpKSB7XG4gICAgICAgICAgc2V0QXJnKGtleSwgbmV4dClcbiAgICAgICAgICBpKytcbiAgICAgICAgfSBlbHNlIGlmICgvXih0cnVlfGZhbHNlKSQvLnRlc3QobmV4dCkpIHtcbiAgICAgICAgICBzZXRBcmcoa2V5LCBuZXh0KVxuICAgICAgICAgIGkrK1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNldEFyZyhrZXksIGRlZmF1bHRGb3JUeXBlKGd1ZXNzVHlwZShrZXksIGZsYWdzKSkpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIC8vIGRvdC1ub3RhdGlvbiBmbGFnIHNlcGVyYXRlZCBieSAnPScuXG4gICAgfSBlbHNlIGlmIChhcmcubWF0Y2goL14tLlxcLi4rPS8pKSB7XG4gICAgICBtID0gYXJnLm1hdGNoKC9eLShbXj1dKyk9KFtcXHNcXFNdKikkLylcbiAgICAgIHNldEFyZyhtWzFdLCBtWzJdKVxuXG4gICAgLy8gZG90LW5vdGF0aW9uIGZsYWcgc2VwZXJhdGVkIGJ5IHNwYWNlLlxuICAgIH0gZWxzZSBpZiAoYXJnLm1hdGNoKC9eLS5cXC4uKy8pKSB7XG4gICAgICBuZXh0ID0gYXJnc1tpICsgMV1cbiAgICAgIGtleSA9IGFyZy5tYXRjaCgvXi0oLlxcLi4rKS8pWzFdXG5cbiAgICAgIGlmIChuZXh0ICE9PSB1bmRlZmluZWQgJiYgIW5leHQubWF0Y2goL14tLykgJiZcbiAgICAgICAgIWNoZWNrQWxsQWxpYXNlcyhrZXksIGZsYWdzLmJvb2xzKSAmJlxuICAgICAgICAhY2hlY2tBbGxBbGlhc2VzKGtleSwgZmxhZ3MuY291bnRzKSkge1xuICAgICAgICBzZXRBcmcoa2V5LCBuZXh0KVxuICAgICAgICBpKytcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldEFyZyhrZXksIGRlZmF1bHRGb3JUeXBlKGd1ZXNzVHlwZShrZXksIGZsYWdzKSkpXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhcmcubWF0Y2goL14tW14tXSsvKSkge1xuICAgICAgbGV0dGVycyA9IGFyZy5zbGljZSgxLCAtMSkuc3BsaXQoJycpXG4gICAgICBicm9rZW4gPSBmYWxzZVxuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxldHRlcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgbmV4dCA9IGFyZy5zbGljZShqICsgMilcblxuICAgICAgICBpZiAobGV0dGVyc1tqICsgMV0gJiYgbGV0dGVyc1tqICsgMV0gPT09ICc9Jykge1xuICAgICAgICAgIHZhbHVlID0gYXJnLnNsaWNlKGogKyAzKVxuICAgICAgICAgIGtleSA9IGxldHRlcnNbal1cblxuICAgICAgICAgIC8vIG5hcmdzIGZvcm1hdCA9ICctZj1tb25rZXkgd2FzaGluZyBjYXQnXG4gICAgICAgICAgaWYgKGNoZWNrQWxsQWxpYXNlcyhsZXR0ZXJzW2pdLCBvcHRzLm5hcmcpKSB7XG4gICAgICAgICAgICBhcmdzLnNwbGljZShpICsgMSwgMCwgdmFsdWUpXG4gICAgICAgICAgICBpID0gZWF0TmFyZ3MoaSwga2V5LCBhcmdzKVxuICAgICAgICAgIC8vIGFycmF5IGZvcm1hdCA9ICctZj1hIGIgYydcbiAgICAgICAgICB9IGVsc2UgaWYgKGNoZWNrQWxsQWxpYXNlcyhrZXksIGZsYWdzLmFycmF5cykgJiYgYXJncy5sZW5ndGggPiBpICsgMSkge1xuICAgICAgICAgICAgYXJncy5zcGxpY2UoaSArIDEsIDAsIHZhbHVlKVxuICAgICAgICAgICAgaSA9IGVhdEFycmF5KGksIGtleSwgYXJncylcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2V0QXJnKGtleSwgdmFsdWUpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJva2VuID0gdHJ1ZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmV4dCA9PT0gJy0nKSB7XG4gICAgICAgICAgc2V0QXJnKGxldHRlcnNbal0sIG5leHQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgvW0EtWmEtel0vLnRlc3QobGV0dGVyc1tqXSkgJiZcbiAgICAgICAgICAvLT9cXGQrKFxcLlxcZCopPyhlLT9cXGQrKT8kLy50ZXN0KG5leHQpKSB7XG4gICAgICAgICAgc2V0QXJnKGxldHRlcnNbal0sIG5leHQpXG4gICAgICAgICAgYnJva2VuID0gdHJ1ZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGV0dGVyc1tqICsgMV0gJiYgbGV0dGVyc1tqICsgMV0ubWF0Y2goL1xcVy8pKSB7XG4gICAgICAgICAgc2V0QXJnKGxldHRlcnNbal0sIGFyZy5zbGljZShqICsgMikpXG4gICAgICAgICAgYnJva2VuID0gdHJ1ZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2V0QXJnKGxldHRlcnNbal0sIGRlZmF1bHRGb3JUeXBlKGd1ZXNzVHlwZShsZXR0ZXJzW2pdLCBmbGFncykpKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGtleSA9IGFyZy5zbGljZSgtMSlbMF1cblxuICAgICAgaWYgKCFicm9rZW4gJiYga2V5ICE9PSAnLScpIHtcbiAgICAgICAgLy8gbmFyZ3MgZm9ybWF0ID0gJy1mIGEgYiBjJ1xuICAgICAgICBpZiAoY2hlY2tBbGxBbGlhc2VzKGtleSwgb3B0cy5uYXJnKSkge1xuICAgICAgICAgIGkgPSBlYXROYXJncyhpLCBrZXksIGFyZ3MpXG4gICAgICAgIC8vIGFycmF5IGZvcm1hdCA9ICctZiBhIGIgYydcbiAgICAgICAgfSBlbHNlIGlmIChjaGVja0FsbEFsaWFzZXMoa2V5LCBmbGFncy5hcnJheXMpICYmIGFyZ3MubGVuZ3RoID4gaSArIDEpIHtcbiAgICAgICAgICBpID0gZWF0QXJyYXkoaSwga2V5LCBhcmdzKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChhcmdzW2kgKyAxXSAmJiAhL14oLXwtLSlbXi1dLy50ZXN0KGFyZ3NbaSArIDFdKSAmJlxuICAgICAgICAgICAgIWNoZWNrQWxsQWxpYXNlcyhrZXksIGZsYWdzLmJvb2xzKSAmJlxuICAgICAgICAgICAgIWNoZWNrQWxsQWxpYXNlcyhrZXksIGZsYWdzLmNvdW50cykpIHtcbiAgICAgICAgICAgIHNldEFyZyhrZXksIGFyZ3NbaSArIDFdKVxuICAgICAgICAgICAgaSsrXG4gICAgICAgICAgfSBlbHNlIGlmIChhcmdzW2kgKyAxXSAmJiAvdHJ1ZXxmYWxzZS8udGVzdChhcmdzW2kgKyAxXSkpIHtcbiAgICAgICAgICAgIHNldEFyZyhrZXksIGFyZ3NbaSArIDFdKVxuICAgICAgICAgICAgaSsrXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldEFyZyhrZXksIGRlZmF1bHRGb3JUeXBlKGd1ZXNzVHlwZShrZXksIGZsYWdzKSkpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGFyZ3YuXy5wdXNoKFxuICAgICAgICBmbGFncy5zdHJpbmdzWydfJ10gfHwgIWlzTnVtYmVyKGFyZykgPyBhcmcgOiBOdW1iZXIoYXJnKVxuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIC8vIG9yZGVyIG9mIHByZWNlZGVuY2U6XG4gIC8vIDEuIGNvbW1hbmQgbGluZSBhcmdcbiAgLy8gMi4gdmFsdWUgZnJvbSBjb25maWcgZmlsZVxuICAvLyAzLiB2YWx1ZSBmcm9tIGVudiB2YXJcbiAgLy8gNC4gY29uZmlndXJlZCBkZWZhdWx0IHZhbHVlXG4gIGFwcGx5RW52VmFycyhvcHRzLCBhcmd2LCB0cnVlKSAvLyBzcGVjaWFsIGNhc2U6IGNoZWNrIGVudiB2YXJzIHRoYXQgcG9pbnQgdG8gY29uZmlnIGZpbGVcbiAgc2V0Q29uZmlnKGFyZ3YpXG4gIGFwcGx5RW52VmFycyhvcHRzLCBhcmd2LCBmYWxzZSlcbiAgYXBwbHlEZWZhdWx0c0FuZEFsaWFzZXMoYXJndiwgYWxpYXNlcywgZGVmYXVsdHMpXG5cbiAgT2JqZWN0LmtleXMoZmxhZ3MuY291bnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBzZXRBcmcoa2V5LCBkZWZhdWx0c1trZXldKVxuICB9KVxuXG4gIG5vdEZsYWdzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIGFyZ3YuXy5wdXNoKGtleSlcbiAgfSlcblxuICAvLyBob3cgbWFueSBhcmd1bWVudHMgc2hvdWxkIHdlIGNvbnN1bWUsIGJhc2VkXG4gIC8vIG9uIHRoZSBuYXJncyBvcHRpb24/XG4gIGZ1bmN0aW9uIGVhdE5hcmdzIChpLCBrZXksIGFyZ3MpIHtcbiAgICB2YXIgdG9FYXQgPSBjaGVja0FsbEFsaWFzZXMoa2V5LCBvcHRzLm5hcmcpXG5cbiAgICBpZiAoYXJncy5sZW5ndGggLSAoaSArIDEpIDwgdG9FYXQpIGVycm9yID0gRXJyb3IoX18oJ05vdCBlbm91Z2ggYXJndW1lbnRzIGZvbGxvd2luZzogJXMnLCBrZXkpKVxuXG4gICAgZm9yICh2YXIgaWkgPSBpICsgMTsgaWkgPCAodG9FYXQgKyBpICsgMSk7IGlpKyspIHtcbiAgICAgIHNldEFyZyhrZXksIGFyZ3NbaWldKVxuICAgIH1cblxuICAgIHJldHVybiAoaSArIHRvRWF0KVxuICB9XG5cbiAgLy8gaWYgYW4gb3B0aW9uIGlzIGFuIGFycmF5LCBlYXQgYWxsIG5vbi1oeXBoZW5hdGVkIGFyZ3VtZW50c1xuICAvLyBmb2xsb3dpbmcgaXQuLi4gWVVNIVxuICAvLyBlLmcuLCAtLWZvbyBhcHBsZSBiYW5hbmEgY2F0IGJlY29tZXMgW1wiYXBwbGVcIiwgXCJiYW5hbmFcIiwgXCJjYXRcIl1cbiAgZnVuY3Rpb24gZWF0QXJyYXkgKGksIGtleSwgYXJncykge1xuICAgIGZvciAodmFyIGlpID0gaSArIDE7IGlpIDwgYXJncy5sZW5ndGg7IGlpKyspIHtcbiAgICAgIGlmICgvXi0vLnRlc3QoYXJnc1tpaV0pKSBicmVha1xuICAgICAgaSA9IGlpXG4gICAgICBzZXRBcmcoa2V5LCBhcmdzW2lpXSlcbiAgICB9XG5cbiAgICByZXR1cm4gaVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0QXJnIChrZXksIHZhbCkge1xuICAgIHVuc2V0RGVmYXVsdGVkKGtleSlcblxuICAgIC8vIGhhbmRsZSBwYXJzaW5nIGJvb2xlYW4gYXJndW1lbnRzIC0tZm9vPXRydWUgLS1iYXIgZmFsc2UuXG4gICAgaWYgKGNoZWNrQWxsQWxpYXNlcyhrZXksIGZsYWdzLmJvb2xzKSB8fCBjaGVja0FsbEFsaWFzZXMoa2V5LCBmbGFncy5jb3VudHMpKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHZhbCA9IHZhbCA9PT0gJ3RydWUnXG4gICAgfVxuXG4gICAgaWYgKC8tLy50ZXN0KGtleSkgJiYgIShhbGlhc2VzW2tleV0gJiYgYWxpYXNlc1trZXldLmxlbmd0aCkpIHtcbiAgICAgIHZhciBjID0gY2FtZWxDYXNlKGtleSlcbiAgICAgIGFsaWFzZXNba2V5XSA9IFtjXVxuICAgICAgbmV3QWxpYXNlc1tjXSA9IHRydWVcbiAgICB9XG5cbiAgICB2YXIgdmFsdWUgPSAhY2hlY2tBbGxBbGlhc2VzKGtleSwgZmxhZ3Muc3RyaW5ncykgJiYgaXNOdW1iZXIodmFsKSA/IE51bWJlcih2YWwpIDogdmFsXG5cbiAgICBpZiAoY2hlY2tBbGxBbGlhc2VzKGtleSwgZmxhZ3MuY291bnRzKSkge1xuICAgICAgdmFsdWUgPSBpbmNyZW1lbnRcbiAgICB9XG5cbiAgICB2YXIgc3BsaXRLZXkgPSBrZXkuc3BsaXQoJy4nKVxuICAgIHNldEtleShhcmd2LCBzcGxpdEtleSwgdmFsdWUpXG5cbiAgICAvLyBhbGlhcyByZWZlcmVuY2VzIGFuIGlubmVyLXZhbHVlIHdpdGhpblxuICAgIC8vIGEgZG90LW5vdGF0aW9uIG9iamVjdC4gc2VlICMyNzkuXG4gICAgaWYgKH5rZXkuaW5kZXhPZignLicpICYmIGFsaWFzZXNba2V5XSkge1xuICAgICAgYWxpYXNlc1trZXldLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgeCA9IHguc3BsaXQoJy4nKVxuICAgICAgICBzZXRLZXkoYXJndiwgeCwgdmFsdWUpXG4gICAgICB9KVxuICAgIH1cblxuICAgIDsoYWxpYXNlc1tzcGxpdEtleVswXV0gfHwgW10pLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcbiAgICAgIHggPSB4LnNwbGl0KCcuJylcblxuICAgICAgLy8gaGFuZGxlIHBvcHVsYXRpbmcgZG90IG5vdGF0aW9uIGZvciBib3RoXG4gICAgICAvLyB0aGUga2V5IGFuZCBpdHMgYWxpYXNlcy5cbiAgICAgIGlmIChzcGxpdEtleS5sZW5ndGggPiAxKSB7XG4gICAgICAgIHZhciBhID0gW10uY29uY2F0KHNwbGl0S2V5KVxuICAgICAgICBhLnNoaWZ0KCkgLy8gbnVrZSB0aGUgb2xkIGtleS5cbiAgICAgICAgeCA9IHguY29uY2F0KGEpXG4gICAgICB9XG5cbiAgICAgIHNldEtleShhcmd2LCB4LCB2YWx1ZSlcbiAgICB9KVxuXG4gICAgdmFyIGtleXMgPSBba2V5XS5jb25jYXQoYWxpYXNlc1trZXldIHx8IFtdKVxuICAgIGZvciAodmFyIGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmIChmbGFncy5ub3JtYWxpemVba2V5c1tpXV0pIHtcbiAgICAgICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICBhcmd2Ll9fZGVmaW5lU2V0dGVyX18oa2V5LCBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgdmFsID0gcGF0aC5ub3JtYWxpemUodilcbiAgICAgICAgICB9KVxuXG4gICAgICAgICAgYXJndi5fX2RlZmluZUdldHRlcl9fKGtleSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnID8gcGF0aC5ub3JtYWxpemUodmFsKSA6IHZhbFxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gc2V0IGFyZ3MgZnJvbSBjb25maWcuanNvbiBmaWxlLCB0aGlzIHNob3VsZCBiZVxuICAvLyBhcHBsaWVkIGxhc3Qgc28gdGhhdCBkZWZhdWx0cyBjYW4gYmUgYXBwbGllZC5cbiAgZnVuY3Rpb24gc2V0Q29uZmlnIChhcmd2KSB7XG4gICAgdmFyIGNvbmZpZ0xvb2t1cCA9IHt9XG5cbiAgICAvLyBleHBhbmQgZGVmYXVsdHMvYWxpYXNlcywgaW4tY2FzZSBhbnkgaGFwcGVuIHRvIHJlZmVyZW5jZVxuICAgIC8vIHRoZSBjb25maWcuanNvbiBmaWxlLlxuICAgIGFwcGx5RGVmYXVsdHNBbmRBbGlhc2VzKGNvbmZpZ0xvb2t1cCwgYWxpYXNlcywgZGVmYXVsdHMpXG5cbiAgICBPYmplY3Qua2V5cyhmbGFncy5jb25maWdzKS5mb3JFYWNoKGZ1bmN0aW9uIChjb25maWdLZXkpIHtcbiAgICAgIHZhciBjb25maWdQYXRoID0gYXJndltjb25maWdLZXldIHx8IGNvbmZpZ0xvb2t1cFtjb25maWdLZXldXG4gICAgICBpZiAoY29uZmlnUGF0aCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBjb25maWcgPSBudWxsXG4gICAgICAgICAgdmFyIHJlc29sdmVkQ29uZmlnUGF0aCA9IHBhdGgucmVzb2x2ZShwcm9jZXNzLmN3ZCgpLCBjb25maWdQYXRoKVxuXG4gICAgICAgICAgaWYgKHR5cGVvZiBmbGFncy5jb25maWdzW2NvbmZpZ0tleV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbmZpZyA9IGZsYWdzLmNvbmZpZ3NbY29uZmlnS2V5XShyZXNvbHZlZENvbmZpZ1BhdGgpXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIGNvbmZpZyA9IGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25maWcgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICBlcnJvciA9IGNvbmZpZ1xuICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uZmlnID0gcmVxdWlyZShyZXNvbHZlZENvbmZpZ1BhdGgpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgT2JqZWN0LmtleXMoY29uZmlnKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIC8vIHNldHRpbmcgYXJndW1lbnRzIHZpYSBDTEkgdGFrZXMgcHJlY2VkZW5jZSBvdmVyXG4gICAgICAgICAgICAvLyB2YWx1ZXMgd2l0aGluIHRoZSBjb25maWcgZmlsZS5cbiAgICAgICAgICAgIGlmIChhcmd2W2tleV0gPT09IHVuZGVmaW5lZCB8fCAoZmxhZ3MuZGVmYXVsdGVkW2tleV0pKSB7XG4gICAgICAgICAgICAgIGRlbGV0ZSBhcmd2W2tleV1cbiAgICAgICAgICAgICAgc2V0QXJnKGtleSwgY29uZmlnW2tleV0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBpZiAoYXJndltjb25maWdLZXldKSBlcnJvciA9IEVycm9yKF9fKCdJbnZhbGlkIEpTT04gY29uZmlnIGZpbGU6ICVzJywgY29uZmlnUGF0aCkpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gYXBwbHlFbnZWYXJzIChvcHRzLCBhcmd2LCBjb25maWdPbmx5KSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzLmVudlByZWZpeCA9PT0gJ3VuZGVmaW5lZCcpIHJldHVyblxuXG4gICAgdmFyIHByZWZpeCA9IHR5cGVvZiBvcHRzLmVudlByZWZpeCA9PT0gJ3N0cmluZycgPyBvcHRzLmVudlByZWZpeCA6ICcnXG4gICAgT2JqZWN0LmtleXMocHJvY2Vzcy5lbnYpLmZvckVhY2goZnVuY3Rpb24gKGVudlZhcikge1xuICAgICAgaWYgKHByZWZpeCA9PT0gJycgfHwgZW52VmFyLmxhc3RJbmRleE9mKHByZWZpeCwgMCkgPT09IDApIHtcbiAgICAgICAgdmFyIGtleSA9IGNhbWVsQ2FzZShlbnZWYXIuc3Vic3RyaW5nKHByZWZpeC5sZW5ndGgpKVxuICAgICAgICBpZiAoKChjb25maWdPbmx5ICYmIGZsYWdzLmNvbmZpZ3Nba2V5XSkgfHwgIWNvbmZpZ09ubHkpICYmICghKGtleSBpbiBhcmd2KSB8fCBmbGFncy5kZWZhdWx0ZWRba2V5XSkpIHtcbiAgICAgICAgICBzZXRBcmcoa2V5LCBwcm9jZXNzLmVudltlbnZWYXJdKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGFwcGx5RGVmYXVsdHNBbmRBbGlhc2VzIChvYmosIGFsaWFzZXMsIGRlZmF1bHRzKSB7XG4gICAgT2JqZWN0LmtleXMoZGVmYXVsdHMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgaWYgKCFoYXNLZXkob2JqLCBrZXkuc3BsaXQoJy4nKSkpIHtcbiAgICAgICAgc2V0S2V5KG9iaiwga2V5LnNwbGl0KCcuJyksIGRlZmF1bHRzW2tleV0pXG5cbiAgICAgICAgOyhhbGlhc2VzW2tleV0gfHwgW10pLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICBpZiAoaGFzS2V5KG9iaiwgeC5zcGxpdCgnLicpKSkgcmV0dXJuXG4gICAgICAgICAgc2V0S2V5KG9iaiwgeC5zcGxpdCgnLicpLCBkZWZhdWx0c1trZXldKVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiBoYXNLZXkgKG9iaiwga2V5cykge1xuICAgIHZhciBvID0gb2JqXG4gICAga2V5cy5zbGljZSgwLCAtMSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBvID0gKG9ba2V5XSB8fCB7fSlcbiAgICB9KVxuXG4gICAgdmFyIGtleSA9IGtleXNba2V5cy5sZW5ndGggLSAxXVxuXG4gICAgaWYgKHR5cGVvZiBvICE9PSAnb2JqZWN0JykgcmV0dXJuIGZhbHNlXG4gICAgZWxzZSByZXR1cm4ga2V5IGluIG9cbiAgfVxuXG4gIGZ1bmN0aW9uIHNldEtleSAob2JqLCBrZXlzLCB2YWx1ZSkge1xuICAgIHZhciBvID0gb2JqXG4gICAga2V5cy5zbGljZSgwLCAtMSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBpZiAob1trZXldID09PSB1bmRlZmluZWQpIG9ba2V5XSA9IHt9XG4gICAgICBvID0gb1trZXldXG4gICAgfSlcblxuICAgIHZhciBrZXkgPSBrZXlzW2tleXMubGVuZ3RoIC0gMV1cbiAgICBpZiAodmFsdWUgPT09IGluY3JlbWVudCkge1xuICAgICAgb1trZXldID0gaW5jcmVtZW50KG9ba2V5XSlcbiAgICB9IGVsc2UgaWYgKG9ba2V5XSA9PT0gdW5kZWZpbmVkICYmIGNoZWNrQWxsQWxpYXNlcyhrZXksIGZsYWdzLmFycmF5cykpIHtcbiAgICAgIG9ba2V5XSA9IEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbdmFsdWVdXG4gICAgfSBlbHNlIGlmIChvW2tleV0gPT09IHVuZGVmaW5lZCB8fCB0eXBlb2Ygb1trZXldID09PSAnYm9vbGVhbicpIHtcbiAgICAgIG9ba2V5XSA9IHZhbHVlXG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9ba2V5XSkpIHtcbiAgICAgIG9ba2V5XS5wdXNoKHZhbHVlKVxuICAgIH0gZWxzZSB7XG4gICAgICBvW2tleV0gPSBbIG9ba2V5XSwgdmFsdWUgXVxuICAgIH1cbiAgfVxuXG4gIC8vIGV4dGVuZCB0aGUgYWxpYXNlcyBsaXN0IHdpdGggaW5mZXJyZWQgYWxpYXNlcy5cbiAgZnVuY3Rpb24gZXh0ZW5kQWxpYXNlcyAob2JqKSB7XG4gICAgT2JqZWN0LmtleXMob2JqIHx8IHt9KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIC8vIHNob3J0LWNpcmN1aXQgaWYgd2UndmUgYWxyZWFkeSBhZGRlZCBhIGtleVxuICAgICAgLy8gdG8gdGhlIGFsaWFzZXMgYXJyYXksIGZvciBleGFtcGxlIGl0IG1pZ2h0XG4gICAgICAvLyBleGlzdCBpbiBib3RoICdvcHRzLmRlZmF1bHQnIGFuZCAnb3B0cy5rZXknLlxuICAgICAgaWYgKGFsaWFzZXNba2V5XSkgcmV0dXJuXG5cbiAgICAgIGFsaWFzZXNba2V5XSA9IFtdLmNvbmNhdChvcHRzLmFsaWFzW2tleV0gfHwgW10pXG4gICAgICAvLyBGb3IgXCItLW9wdGlvbi1uYW1lXCIsIGFsc28gc2V0IGFyZ3Yub3B0aW9uTmFtZVxuICAgICAgYWxpYXNlc1trZXldLmNvbmNhdChrZXkpLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgaWYgKC8tLy50ZXN0KHgpKSB7XG4gICAgICAgICAgdmFyIGMgPSBjYW1lbENhc2UoeClcbiAgICAgICAgICBhbGlhc2VzW2tleV0ucHVzaChjKVxuICAgICAgICAgIG5ld0FsaWFzZXNbY10gPSB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICBhbGlhc2VzW2tleV0uZm9yRWFjaChmdW5jdGlvbiAoeCkge1xuICAgICAgICBhbGlhc2VzW3hdID0gW2tleV0uY29uY2F0KGFsaWFzZXNba2V5XS5maWx0ZXIoZnVuY3Rpb24gKHkpIHtcbiAgICAgICAgICByZXR1cm4geCAhPT0geVxuICAgICAgICB9KSlcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIC8vIGNoZWNrIGlmIGEgZmxhZyBpcyBzZXQgZm9yIGFueSBvZiBhIGtleSdzIGFsaWFzZXMuXG4gIGZ1bmN0aW9uIGNoZWNrQWxsQWxpYXNlcyAoa2V5LCBmbGFnKSB7XG4gICAgdmFyIGlzU2V0ID0gZmFsc2VcbiAgICB2YXIgdG9DaGVjayA9IFtdLmNvbmNhdChhbGlhc2VzW2tleV0gfHwgW10sIGtleSlcblxuICAgIHRvQ2hlY2suZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBpZiAoZmxhZ1trZXldKSBpc1NldCA9IGZsYWdba2V5XVxuICAgIH0pXG5cbiAgICByZXR1cm4gaXNTZXRcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldERlZmF1bHRlZCAoa2V5KSB7XG4gICAgW10uY29uY2F0KGFsaWFzZXNba2V5XSB8fCBbXSwga2V5KS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICBmbGFncy5kZWZhdWx0ZWRba10gPSB0cnVlXG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIHVuc2V0RGVmYXVsdGVkIChrZXkpIHtcbiAgICBbXS5jb25jYXQoYWxpYXNlc1trZXldIHx8IFtdLCBrZXkpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgIGRlbGV0ZSBmbGFncy5kZWZhdWx0ZWRba11cbiAgICB9KVxuICB9XG5cbiAgLy8gcmV0dXJuIGEgZGVmYXVsdCB2YWx1ZSwgZ2l2ZW4gdGhlIHR5cGUgb2YgYSBmbGFnLixcbiAgLy8gZS5nLiwga2V5IG9mIHR5cGUgJ3N0cmluZycgd2lsbCBkZWZhdWx0IHRvICcnLCByYXRoZXIgdGhhbiAndHJ1ZScuXG4gIGZ1bmN0aW9uIGRlZmF1bHRGb3JUeXBlICh0eXBlKSB7XG4gICAgdmFyIGRlZiA9IHtcbiAgICAgIGJvb2xlYW46IHRydWUsXG4gICAgICBzdHJpbmc6ICcnLFxuICAgICAgYXJyYXk6IFtdXG4gICAgfVxuXG4gICAgcmV0dXJuIGRlZlt0eXBlXVxuICB9XG5cbiAgLy8gZ2l2ZW4gYSBmbGFnLCBlbmZvcmNlIGEgZGVmYXVsdCB0eXBlLlxuICBmdW5jdGlvbiBndWVzc1R5cGUgKGtleSwgZmxhZ3MpIHtcbiAgICB2YXIgdHlwZSA9ICdib29sZWFuJ1xuXG4gICAgaWYgKGZsYWdzLnN0cmluZ3MgJiYgZmxhZ3Muc3RyaW5nc1trZXldKSB0eXBlID0gJ3N0cmluZydcbiAgICBlbHNlIGlmIChmbGFncy5hcnJheXMgJiYgZmxhZ3MuYXJyYXlzW2tleV0pIHR5cGUgPSAnYXJyYXknXG5cbiAgICByZXR1cm4gdHlwZVxuICB9XG5cbiAgZnVuY3Rpb24gaXNOdW1iZXIgKHgpIHtcbiAgICBpZiAodHlwZW9mIHggPT09ICdudW1iZXInKSByZXR1cm4gdHJ1ZVxuICAgIGlmICgvXjB4WzAtOWEtZl0rJC9pLnRlc3QoeCkpIHJldHVybiB0cnVlXG4gICAgcmV0dXJuIC9eWy0rXT8oPzpcXGQrKD86XFwuXFxkKik/fFxcLlxcZCspKGVbLStdP1xcZCspPyQvLnRlc3QoeClcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYXJndjogYXJndixcbiAgICBhbGlhc2VzOiBhbGlhc2VzLFxuICAgIGVycm9yOiBlcnJvcixcbiAgICBuZXdBbGlhc2VzOiBuZXdBbGlhc2VzXG4gIH1cbn1cbiIsIi8vIHRha2UgYW4gdW4tc3BsaXQgYXJndiBzdHJpbmcgYW5kIHRva2VuaXplIGl0LlxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJnU3RyaW5nKSB7XG4gIHZhciBpID0gMFxuICB2YXIgYyA9IG51bGxcbiAgdmFyIG9wZW5pbmcgPSBudWxsXG4gIHZhciBhcmdzID0gW11cblxuICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgYXJnU3RyaW5nLmxlbmd0aDsgaWkrKykge1xuICAgIGMgPSBhcmdTdHJpbmcuY2hhckF0KGlpKVxuXG4gICAgLy8gc3BsaXQgb24gc3BhY2VzIHVubGVzcyB3ZSdyZSBpbiBxdW90ZXMuXG4gICAgaWYgKGMgPT09ICcgJyAmJiAhb3BlbmluZykge1xuICAgICAgaSsrXG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIC8vIGRvbid0IHNwbGl0IHRoZSBzdHJpbmcgaWYgd2UncmUgaW4gbWF0Y2hpbmdcbiAgICAvLyBvcGVuaW5nIG9yIGNsb3Npbmcgc2luZ2xlIGFuZCBkb3VibGUgcXVvdGVzLlxuICAgIGlmIChjID09PSBvcGVuaW5nKSB7XG4gICAgICBvcGVuaW5nID0gbnVsbFxuICAgICAgY29udGludWVcbiAgICB9IGVsc2UgaWYgKChjID09PSBcIidcIiB8fCBjID09PSAnXCInKSAmJiAhb3BlbmluZykge1xuICAgICAgb3BlbmluZyA9IGNcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgaWYgKCFhcmdzW2ldKSBhcmdzW2ldID0gJydcbiAgICBhcmdzW2ldICs9IGNcbiAgfVxuXG4gIHJldHVybiBhcmdzXG59XG4iLCIvLyB0aGlzIGZpbGUgaGFuZGxlcyBvdXRwdXR0aW5nIHVzYWdlIGluc3RydWN0aW9ucyxcbi8vIGZhaWx1cmVzLCBldGMuIGtlZXBzIGxvZ2dpbmcgaW4gb25lIHBsYWNlLlxudmFyIGNsaXVpID0gcmVxdWlyZSgnY2xpdWknKVxudmFyIGRlY2FtZWxpemUgPSByZXF1aXJlKCdkZWNhbWVsaXplJylcbnZhciBzdHJpbmdXaWR0aCA9IHJlcXVpcmUoJ3N0cmluZy13aWR0aCcpXG52YXIgd3NpemUgPSByZXF1aXJlKCd3aW5kb3ctc2l6ZScpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHlhcmdzLCB5MThuKSB7XG4gIHZhciBfXyA9IHkxOG4uX19cbiAgdmFyIHNlbGYgPSB7fVxuXG4gIC8vIG1ldGhvZHMgZm9yIG91cHV0dGluZy9idWlsZGluZyBmYWlsdXJlIG1lc3NhZ2UuXG4gIHZhciBmYWlscyA9IFtdXG4gIHNlbGYuZmFpbEZuID0gZnVuY3Rpb24gKGYpIHtcbiAgICBmYWlscy5wdXNoKGYpXG4gIH1cblxuICB2YXIgZmFpbE1lc3NhZ2UgPSBudWxsXG4gIHZhciBzaG93SGVscE9uRmFpbCA9IHRydWVcbiAgc2VsZi5zaG93SGVscE9uRmFpbCA9IGZ1bmN0aW9uIChlbmFibGVkLCBtZXNzYWdlKSB7XG4gICAgaWYgKHR5cGVvZiBlbmFibGVkID09PSAnc3RyaW5nJykge1xuICAgICAgbWVzc2FnZSA9IGVuYWJsZWRcbiAgICAgIGVuYWJsZWQgPSB0cnVlXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5hYmxlZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGVuYWJsZWQgPSB0cnVlXG4gICAgfVxuICAgIGZhaWxNZXNzYWdlID0gbWVzc2FnZVxuICAgIHNob3dIZWxwT25GYWlsID0gZW5hYmxlZFxuICAgIHJldHVybiBzZWxmXG4gIH1cblxuICB2YXIgZmFpbHVyZU91dHB1dCA9IGZhbHNlXG4gIHNlbGYuZmFpbCA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICBpZiAoZmFpbHMubGVuZ3RoKSB7XG4gICAgICBmYWlscy5mb3JFYWNoKGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIGYobXNnKVxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZG9uJ3Qgb3V0cHV0IGZhaWx1cmUgbWVzc2FnZSBtb3JlIHRoYW4gb25jZVxuICAgICAgaWYgKCFmYWlsdXJlT3V0cHV0KSB7XG4gICAgICAgIGZhaWx1cmVPdXRwdXQgPSB0cnVlXG4gICAgICAgIGlmIChzaG93SGVscE9uRmFpbCkgeWFyZ3Muc2hvd0hlbHAoJ2Vycm9yJylcbiAgICAgICAgaWYgKG1zZykgY29uc29sZS5lcnJvcihtc2cpXG4gICAgICAgIGlmIChmYWlsTWVzc2FnZSkge1xuICAgICAgICAgIGlmIChtc2cpIGNvbnNvbGUuZXJyb3IoJycpXG4gICAgICAgICAgY29uc29sZS5lcnJvcihmYWlsTWVzc2FnZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHlhcmdzLmdldEV4aXRQcm9jZXNzKCkpIHtcbiAgICAgICAgcHJvY2Vzcy5leGl0KDEpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIG1ldGhvZHMgZm9yIG91cHV0dGluZy9idWlsZGluZyBoZWxwICh1c2FnZSkgbWVzc2FnZS5cbiAgdmFyIHVzYWdlXG4gIHNlbGYudXNhZ2UgPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgdXNhZ2UgPSBtc2dcbiAgfVxuXG4gIHZhciBleGFtcGxlcyA9IFtdXG4gIHNlbGYuZXhhbXBsZSA9IGZ1bmN0aW9uIChjbWQsIGRlc2NyaXB0aW9uKSB7XG4gICAgZXhhbXBsZXMucHVzaChbY21kLCBkZXNjcmlwdGlvbiB8fCAnJ10pXG4gIH1cblxuICB2YXIgY29tbWFuZHMgPSBbXVxuICBzZWxmLmNvbW1hbmQgPSBmdW5jdGlvbiAoY21kLCBkZXNjcmlwdGlvbikge1xuICAgIGNvbW1hbmRzLnB1c2goW2NtZCwgZGVzY3JpcHRpb24gfHwgJyddKVxuICB9XG4gIHNlbGYuZ2V0Q29tbWFuZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNvbW1hbmRzXG4gIH1cblxuICB2YXIgZGVzY3JpcHRpb25zID0ge31cbiAgc2VsZi5kZXNjcmliZSA9IGZ1bmN0aW9uIChrZXksIGRlc2MpIHtcbiAgICBpZiAodHlwZW9mIGtleSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIE9iamVjdC5rZXlzKGtleSkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICBzZWxmLmRlc2NyaWJlKGssIGtleVtrXSlcbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIGRlc2NyaXB0aW9uc1trZXldID0gZGVzY1xuICAgIH1cbiAgfVxuICBzZWxmLmdldERlc2NyaXB0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZGVzY3JpcHRpb25zXG4gIH1cblxuICB2YXIgZXBpbG9nXG4gIHNlbGYuZXBpbG9nID0gZnVuY3Rpb24gKG1zZykge1xuICAgIGVwaWxvZyA9IG1zZ1xuICB9XG5cbiAgdmFyIHdyYXAgPSB3aW5kb3dXaWR0aCgpXG4gIHNlbGYud3JhcCA9IGZ1bmN0aW9uIChjb2xzKSB7XG4gICAgd3JhcCA9IGNvbHNcbiAgfVxuXG4gIHZhciBkZWZlclkxOG5Mb29rdXBQcmVmaXggPSAnX195YXJnc1N0cmluZ19fOidcbiAgc2VsZi5kZWZlclkxOG5Mb29rdXAgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgcmV0dXJuIGRlZmVyWTE4bkxvb2t1cFByZWZpeCArIHN0clxuICB9XG5cbiAgdmFyIGRlZmF1bHRHcm91cCA9ICdPcHRpb25zOidcbiAgc2VsZi5oZWxwID0gZnVuY3Rpb24gKCkge1xuICAgIG5vcm1hbGl6ZUFsaWFzZXMoKVxuXG4gICAgdmFyIGRlbWFuZGVkID0geWFyZ3MuZ2V0RGVtYW5kZWQoKVxuICAgIHZhciBncm91cHMgPSB5YXJncy5nZXRHcm91cHMoKVxuICAgIHZhciBvcHRpb25zID0geWFyZ3MuZ2V0T3B0aW9ucygpXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhcbiAgICAgIE9iamVjdC5rZXlzKGRlc2NyaXB0aW9ucylcbiAgICAgIC5jb25jYXQoT2JqZWN0LmtleXMoZGVtYW5kZWQpKVxuICAgICAgLmNvbmNhdChPYmplY3Qua2V5cyhvcHRpb25zLmRlZmF1bHQpKVxuICAgICAgLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBrZXkpIHtcbiAgICAgICAgaWYgKGtleSAhPT0gJ18nKSBhY2Nba2V5XSA9IHRydWVcbiAgICAgICAgcmV0dXJuIGFjY1xuICAgICAgfSwge30pXG4gICAgKVxuICAgIHZhciB1aSA9IGNsaXVpKHtcbiAgICAgIHdpZHRoOiB3cmFwLFxuICAgICAgd3JhcDogISF3cmFwXG4gICAgfSlcblxuICAgIC8vIHRoZSB1c2FnZSBzdHJpbmcuXG4gICAgaWYgKHVzYWdlKSB7XG4gICAgICB2YXIgdSA9IHVzYWdlLnJlcGxhY2UoL1xcJDAvZywgeWFyZ3MuJDApXG4gICAgICB1aS5kaXYodSArICdcXG4nKVxuICAgIH1cblxuICAgIC8vIHlvdXIgYXBwbGljYXRpb24ncyBjb21tYW5kcywgaS5lLiwgbm9uLW9wdGlvblxuICAgIC8vIGFyZ3VtZW50cyBwb3B1bGF0ZWQgaW4gJ18nLlxuICAgIGlmIChjb21tYW5kcy5sZW5ndGgpIHtcbiAgICAgIHVpLmRpdihfXygnQ29tbWFuZHM6JykpXG5cbiAgICAgIGNvbW1hbmRzLmZvckVhY2goZnVuY3Rpb24gKGNvbW1hbmQpIHtcbiAgICAgICAgdWkuZGl2KFxuICAgICAgICAgIHt0ZXh0OiBjb21tYW5kWzBdLCBwYWRkaW5nOiBbMCwgMiwgMCwgMl0sIHdpZHRoOiBtYXhXaWR0aChjb21tYW5kcykgKyA0fSxcbiAgICAgICAgICB7dGV4dDogY29tbWFuZFsxXX1cbiAgICAgICAgKVxuICAgICAgfSlcblxuICAgICAgdWkuZGl2KClcbiAgICB9XG5cbiAgICAvLyBwZXJmb3JtIHNvbWUgY2xlYW51cCBvbiB0aGUga2V5cyBhcnJheSwgbWFraW5nIGl0XG4gICAgLy8gb25seSBpbmNsdWRlIHRvcC1sZXZlbCBrZXlzIG5vdCB0aGVpciBhbGlhc2VzLlxuICAgIHZhciBhbGlhc0tleXMgPSAoT2JqZWN0LmtleXMob3B0aW9ucy5hbGlhcykgfHwgW10pXG4gICAgICAuY29uY2F0KE9iamVjdC5rZXlzKHlhcmdzLnBhcnNlZC5uZXdBbGlhc2VzKSB8fCBbXSlcblxuICAgIGtleXMgPSBrZXlzLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4gIXlhcmdzLnBhcnNlZC5uZXdBbGlhc2VzW2tleV0gJiYgYWxpYXNLZXlzLmV2ZXJ5KGZ1bmN0aW9uIChhbGlhcykge1xuICAgICAgICByZXR1cm4gKG9wdGlvbnMuYWxpYXNbYWxpYXNdIHx8IFtdKS5pbmRleE9mKGtleSkgPT09IC0xXG4gICAgICB9KVxuICAgIH0pXG5cbiAgICAvLyBwb3B1bGF0ZSAnT3B0aW9uczonIGdyb3VwIHdpdGggYW55IGtleXMgdGhhdCBoYXZlIG5vdFxuICAgIC8vIGV4cGxpY2l0bHkgaGFkIGEgZ3JvdXAgc2V0LlxuICAgIGlmICghZ3JvdXBzW2RlZmF1bHRHcm91cF0pIGdyb3Vwc1tkZWZhdWx0R3JvdXBdID0gW11cbiAgICBhZGRVbmdyb3VwZWRLZXlzKGtleXMsIG9wdGlvbnMuYWxpYXMsIGdyb3VwcylcblxuICAgIC8vIGRpc3BsYXkgJ09wdGlvbnM6JyB0YWJsZSBhbG9uZyB3aXRoIGFueSBjdXN0b20gdGFibGVzOlxuICAgIE9iamVjdC5rZXlzKGdyb3VwcykuZm9yRWFjaChmdW5jdGlvbiAoZ3JvdXBOYW1lKSB7XG4gICAgICBpZiAoIWdyb3Vwc1tncm91cE5hbWVdLmxlbmd0aCkgcmV0dXJuXG5cbiAgICAgIHVpLmRpdihfXyhncm91cE5hbWUpKVxuXG4gICAgICAvLyBpZiB3ZSd2ZSBncm91cGVkIHRoZSBrZXkgJ2YnLCBidXQgJ2YnIGFsaWFzZXMgJ2Zvb2JhcicsXG4gICAgICAvLyBub3JtYWxpemVkS2V5cyBzaG91bGQgY29udGFpbiBvbmx5ICdmb29iYXInLlxuICAgICAgdmFyIG5vcm1hbGl6ZWRLZXlzID0gZ3JvdXBzW2dyb3VwTmFtZV0ubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKH5hbGlhc0tleXMuaW5kZXhPZihrZXkpKSByZXR1cm4ga2V5XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBhbGlhc0tleTsgKGFsaWFzS2V5ID0gYWxpYXNLZXlzW2ldKSAhPT0gdW5kZWZpbmVkOyBpKyspIHtcbiAgICAgICAgICBpZiAofihvcHRpb25zLmFsaWFzW2FsaWFzS2V5XSB8fCBbXSkuaW5kZXhPZihrZXkpKSByZXR1cm4gYWxpYXNLZXlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ga2V5XG4gICAgICB9KVxuXG4gICAgICAvLyBhY3R1YWxseSBnZW5lcmF0ZSB0aGUgc3dpdGNoZXMgc3RyaW5nIC0tZm9vLCAtZiwgLS1iYXIuXG4gICAgICB2YXIgc3dpdGNoZXMgPSBub3JtYWxpemVkS2V5cy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywga2V5KSB7XG4gICAgICAgIGFjY1trZXldID0gWyBrZXkgXS5jb25jYXQob3B0aW9ucy5hbGlhc1trZXldIHx8IFtdKVxuICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHN3KSB7XG4gICAgICAgICAgICByZXR1cm4gKHN3Lmxlbmd0aCA+IDEgPyAnLS0nIDogJy0nKSArIHN3XG4gICAgICAgICAgfSlcbiAgICAgICAgICAuam9pbignLCAnKVxuXG4gICAgICAgIHJldHVybiBhY2NcbiAgICAgIH0sIHt9KVxuXG4gICAgICBub3JtYWxpemVkS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIGtzd2l0Y2ggPSBzd2l0Y2hlc1trZXldXG4gICAgICAgIHZhciBkZXNjID0gZGVzY3JpcHRpb25zW2tleV0gfHwgJydcbiAgICAgICAgdmFyIHR5cGUgPSBudWxsXG5cbiAgICAgICAgaWYgKH5kZXNjLmxhc3RJbmRleE9mKGRlZmVyWTE4bkxvb2t1cFByZWZpeCkpIGRlc2MgPSBfXyhkZXNjLnN1YnN0cmluZyhkZWZlclkxOG5Mb29rdXBQcmVmaXgubGVuZ3RoKSlcblxuICAgICAgICBpZiAofm9wdGlvbnMuYm9vbGVhbi5pbmRleE9mKGtleSkpIHR5cGUgPSAnWycgKyBfXygnYm9vbGVhbicpICsgJ10nXG4gICAgICAgIGlmICh+b3B0aW9ucy5jb3VudC5pbmRleE9mKGtleSkpIHR5cGUgPSAnWycgKyBfXygnY291bnQnKSArICddJ1xuICAgICAgICBpZiAofm9wdGlvbnMuc3RyaW5nLmluZGV4T2Yoa2V5KSkgdHlwZSA9ICdbJyArIF9fKCdzdHJpbmcnKSArICddJ1xuICAgICAgICBpZiAofm9wdGlvbnMubm9ybWFsaXplLmluZGV4T2Yoa2V5KSkgdHlwZSA9ICdbJyArIF9fKCdzdHJpbmcnKSArICddJ1xuICAgICAgICBpZiAofm9wdGlvbnMuYXJyYXkuaW5kZXhPZihrZXkpKSB0eXBlID0gJ1snICsgX18oJ2FycmF5JykgKyAnXSdcblxuICAgICAgICB2YXIgZXh0cmEgPSBbXG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICBkZW1hbmRlZFtrZXldID8gJ1snICsgX18oJ3JlcXVpcmVkJykgKyAnXScgOiBudWxsLFxuICAgICAgICAgIG9wdGlvbnMuY2hvaWNlcyAmJiBvcHRpb25zLmNob2ljZXNba2V5XSA/ICdbJyArIF9fKCdjaG9pY2VzOicpICsgJyAnICtcbiAgICAgICAgICAgIHNlbGYuc3RyaW5naWZpZWRWYWx1ZXMob3B0aW9ucy5jaG9pY2VzW2tleV0pICsgJ10nIDogbnVsbCxcbiAgICAgICAgICBkZWZhdWx0U3RyaW5nKG9wdGlvbnMuZGVmYXVsdFtrZXldLCBvcHRpb25zLmRlZmF1bHREZXNjcmlwdGlvbltrZXldKVxuICAgICAgICBdLmZpbHRlcihCb29sZWFuKS5qb2luKCcgJylcblxuICAgICAgICB1aS5zcGFuKFxuICAgICAgICAgIHt0ZXh0OiBrc3dpdGNoLCBwYWRkaW5nOiBbMCwgMiwgMCwgMl0sIHdpZHRoOiBtYXhXaWR0aChzd2l0Y2hlcykgKyA0fSxcbiAgICAgICAgICBkZXNjXG4gICAgICAgIClcblxuICAgICAgICBpZiAoZXh0cmEpIHVpLmRpdih7dGV4dDogZXh0cmEsIHBhZGRpbmc6IFswLCAwLCAwLCAyXSwgYWxpZ246ICdyaWdodCd9KVxuICAgICAgICBlbHNlIHVpLmRpdigpXG4gICAgICB9KVxuXG4gICAgICB1aS5kaXYoKVxuICAgIH0pXG5cbiAgICAvLyBkZXNjcmliZSBzb21lIGNvbW1vbiB1c2UtY2FzZXMgZm9yIHlvdXIgYXBwbGljYXRpb24uXG4gICAgaWYgKGV4YW1wbGVzLmxlbmd0aCkge1xuICAgICAgdWkuZGl2KF9fKCdFeGFtcGxlczonKSlcblxuICAgICAgZXhhbXBsZXMuZm9yRWFjaChmdW5jdGlvbiAoZXhhbXBsZSkge1xuICAgICAgICBleGFtcGxlWzBdID0gZXhhbXBsZVswXS5yZXBsYWNlKC9cXCQwL2csIHlhcmdzLiQwKVxuICAgICAgfSlcblxuICAgICAgZXhhbXBsZXMuZm9yRWFjaChmdW5jdGlvbiAoZXhhbXBsZSkge1xuICAgICAgICB1aS5kaXYoXG4gICAgICAgICAge3RleHQ6IGV4YW1wbGVbMF0sIHBhZGRpbmc6IFswLCAyLCAwLCAyXSwgd2lkdGg6IG1heFdpZHRoKGV4YW1wbGVzKSArIDR9LFxuICAgICAgICAgIGV4YW1wbGVbMV1cbiAgICAgICAgKVxuICAgICAgfSlcblxuICAgICAgdWkuZGl2KClcbiAgICB9XG5cbiAgICAvLyB0aGUgdXNhZ2Ugc3RyaW5nLlxuICAgIGlmIChlcGlsb2cpIHtcbiAgICAgIHZhciBlID0gZXBpbG9nLnJlcGxhY2UoL1xcJDAvZywgeWFyZ3MuJDApXG4gICAgICB1aS5kaXYoZSArICdcXG4nKVxuICAgIH1cblxuICAgIHJldHVybiB1aS50b1N0cmluZygpXG4gIH1cblxuICAvLyByZXR1cm4gdGhlIG1heGltdW0gd2lkdGggb2YgYSBzdHJpbmdcbiAgLy8gaW4gdGhlIGxlZnQtaGFuZCBjb2x1bW4gb2YgYSB0YWJsZS5cbiAgZnVuY3Rpb24gbWF4V2lkdGggKHRhYmxlKSB7XG4gICAgdmFyIHdpZHRoID0gMFxuXG4gICAgLy8gdGFibGUgbWlnaHQgYmUgb2YgdGhlIGZvcm0gW2xlZnRDb2x1bW5dLFxuICAgIC8vIG9yIHtrZXk6IGxlZnRDb2x1bW59fVxuICAgIGlmICghQXJyYXkuaXNBcnJheSh0YWJsZSkpIHtcbiAgICAgIHRhYmxlID0gT2JqZWN0LmtleXModGFibGUpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiBbdGFibGVba2V5XV1cbiAgICAgIH0pXG4gICAgfVxuXG4gICAgdGFibGUuZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgICAgd2lkdGggPSBNYXRoLm1heChzdHJpbmdXaWR0aCh2WzBdKSwgd2lkdGgpXG4gICAgfSlcblxuICAgIC8vIGlmIHdlJ3ZlIGVuYWJsZWQgJ3dyYXAnIHdlIHNob3VsZCBsaW1pdFxuICAgIC8vIHRoZSBtYXgtd2lkdGggb2YgdGhlIGxlZnQtY29sdW1uLlxuICAgIGlmICh3cmFwKSB3aWR0aCA9IE1hdGgubWluKHdpZHRoLCBwYXJzZUludCh3cmFwICogMC41LCAxMCkpXG5cbiAgICByZXR1cm4gd2lkdGhcbiAgfVxuXG4gIC8vIG1ha2Ugc3VyZSBhbnkgb3B0aW9ucyBzZXQgZm9yIGFsaWFzZXMsXG4gIC8vIGFyZSBjb3BpZWQgdG8gdGhlIGtleXMgYmVpbmcgYWxpYXNlZC5cbiAgZnVuY3Rpb24gbm9ybWFsaXplQWxpYXNlcyAoKSB7XG4gICAgdmFyIGRlbWFuZGVkID0geWFyZ3MuZ2V0RGVtYW5kZWQoKVxuICAgIHZhciBvcHRpb25zID0geWFyZ3MuZ2V0T3B0aW9ucygpXG5cbiAgICA7KE9iamVjdC5rZXlzKG9wdGlvbnMuYWxpYXMpIHx8IFtdKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIG9wdGlvbnMuYWxpYXNba2V5XS5mb3JFYWNoKGZ1bmN0aW9uIChhbGlhcykge1xuICAgICAgICAvLyBjb3B5IGRlc2NyaXB0aW9ucy5cbiAgICAgICAgaWYgKGRlc2NyaXB0aW9uc1thbGlhc10pIHNlbGYuZGVzY3JpYmUoa2V5LCBkZXNjcmlwdGlvbnNbYWxpYXNdKVxuICAgICAgICAvLyBjb3B5IGRlbWFuZGVkLlxuICAgICAgICBpZiAoZGVtYW5kZWRbYWxpYXNdKSB5YXJncy5kZW1hbmQoa2V5LCBkZW1hbmRlZFthbGlhc10ubXNnKVxuICAgICAgICAvLyB0eXBlIG1lc3NhZ2VzLlxuICAgICAgICBpZiAofm9wdGlvbnMuYm9vbGVhbi5pbmRleE9mKGFsaWFzKSkgeWFyZ3MuYm9vbGVhbihrZXkpXG4gICAgICAgIGlmICh+b3B0aW9ucy5jb3VudC5pbmRleE9mKGFsaWFzKSkgeWFyZ3MuY291bnQoa2V5KVxuICAgICAgICBpZiAofm9wdGlvbnMuc3RyaW5nLmluZGV4T2YoYWxpYXMpKSB5YXJncy5zdHJpbmcoa2V5KVxuICAgICAgICBpZiAofm9wdGlvbnMubm9ybWFsaXplLmluZGV4T2YoYWxpYXMpKSB5YXJncy5ub3JtYWxpemUoa2V5KVxuICAgICAgICBpZiAofm9wdGlvbnMuYXJyYXkuaW5kZXhPZihhbGlhcykpIHlhcmdzLmFycmF5KGtleSlcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIC8vIGdpdmVuIGEgc2V0IG9mIGtleXMsIHBsYWNlIGFueSBrZXlzIHRoYXQgYXJlXG4gIC8vIHVuZ3JvdXBlZCB1bmRlciB0aGUgJ09wdGlvbnM6JyBncm91cGluZy5cbiAgZnVuY3Rpb24gYWRkVW5ncm91cGVkS2V5cyAoa2V5cywgYWxpYXNlcywgZ3JvdXBzKSB7XG4gICAgdmFyIGdyb3VwZWRLZXlzID0gW11cbiAgICB2YXIgdG9DaGVjayA9IG51bGxcbiAgICBPYmplY3Qua2V5cyhncm91cHMpLmZvckVhY2goZnVuY3Rpb24gKGdyb3VwKSB7XG4gICAgICBncm91cGVkS2V5cyA9IGdyb3VwZWRLZXlzLmNvbmNhdChncm91cHNbZ3JvdXBdKVxuICAgIH0pXG5cbiAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgdG9DaGVjayA9IFtrZXldLmNvbmNhdChhbGlhc2VzW2tleV0pXG4gICAgICBpZiAoIXRvQ2hlY2suc29tZShmdW5jdGlvbiAoaykge1xuICAgICAgICByZXR1cm4gZ3JvdXBlZEtleXMuaW5kZXhPZihrKSAhPT0gLTFcbiAgICAgIH0pKSB7XG4gICAgICAgIGdyb3Vwc1tkZWZhdWx0R3JvdXBdLnB1c2goa2V5KVxuICAgICAgfVxuICAgIH0pXG4gICAgcmV0dXJuIGdyb3VwZWRLZXlzXG4gIH1cblxuICBzZWxmLnNob3dIZWxwID0gZnVuY3Rpb24gKGxldmVsKSB7XG4gICAgbGV2ZWwgPSBsZXZlbCB8fCAnZXJyb3InXG4gICAgY29uc29sZVtsZXZlbF0oc2VsZi5oZWxwKCkpXG4gIH1cblxuICBzZWxmLmZ1bmN0aW9uRGVzY3JpcHRpb24gPSBmdW5jdGlvbiAoZm4pIHtcbiAgICB2YXIgZGVzY3JpcHRpb24gPSBmbi5uYW1lID8gZGVjYW1lbGl6ZShmbi5uYW1lLCAnLScpIDogX18oJ2dlbmVyYXRlZC12YWx1ZScpXG4gICAgcmV0dXJuIFsnKCcsIGRlc2NyaXB0aW9uLCAnKSddLmpvaW4oJycpXG4gIH1cblxuICBzZWxmLnN0cmluZ2lmaWVkVmFsdWVzID0gZnVuY3Rpb24gKHZhbHVlcywgc2VwYXJhdG9yKSB7XG4gICAgdmFyIHN0cmluZyA9ICcnXG4gICAgdmFyIHNlcCA9IHNlcGFyYXRvciB8fCAnLCAnXG4gICAgdmFyIGFycmF5ID0gW10uY29uY2F0KHZhbHVlcylcblxuICAgIGlmICghdmFsdWVzIHx8ICFhcnJheS5sZW5ndGgpIHJldHVybiBzdHJpbmdcblxuICAgIGFycmF5LmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBpZiAoc3RyaW5nLmxlbmd0aCkgc3RyaW5nICs9IHNlcFxuICAgICAgc3RyaW5nICs9IEpTT04uc3RyaW5naWZ5KHZhbHVlKVxuICAgIH0pXG5cbiAgICByZXR1cm4gc3RyaW5nXG4gIH1cblxuICAvLyBmb3JtYXQgdGhlIGRlZmF1bHQtdmFsdWUtc3RyaW5nIGRpc3BsYXllZCBpblxuICAvLyB0aGUgcmlnaHQtaGFuZCBjb2x1bW4uXG4gIGZ1bmN0aW9uIGRlZmF1bHRTdHJpbmcgKHZhbHVlLCBkZWZhdWx0RGVzY3JpcHRpb24pIHtcbiAgICB2YXIgc3RyaW5nID0gJ1snICsgX18oJ2RlZmF1bHQ6JykgKyAnICdcblxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICFkZWZhdWx0RGVzY3JpcHRpb24pIHJldHVybiBudWxsXG5cbiAgICBpZiAoZGVmYXVsdERlc2NyaXB0aW9uKSB7XG4gICAgICBzdHJpbmcgKz0gZGVmYXVsdERlc2NyaXB0aW9uXG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgc3RyaW5nICs9IEpTT04uc3RyaW5naWZ5KHZhbHVlKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgc3RyaW5nICs9IEpTT04uc3RyaW5naWZ5KHZhbHVlKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgc3RyaW5nICs9IHZhbHVlXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cmluZyArICddJ1xuICB9XG5cbiAgLy8gZ3Vlc3MgdGhlIHdpZHRoIG9mIHRoZSBjb25zb2xlIHdpbmRvdywgbWF4LXdpZHRoIDgwLlxuICBmdW5jdGlvbiB3aW5kb3dXaWR0aCAoKSB7XG4gICAgcmV0dXJuIHdzaXplLndpZHRoID8gTWF0aC5taW4oODAsIHdzaXplLndpZHRoKSA6IG51bGxcbiAgfVxuXG4gIC8vIGxvZ2ljIGZvciBkaXNwbGF5aW5nIGFwcGxpY2F0aW9uIHZlcnNpb24uXG4gIHZhciB2ZXJzaW9uID0gbnVsbFxuICBzZWxmLnZlcnNpb24gPSBmdW5jdGlvbiAodmVyLCBvcHQsIG1zZykge1xuICAgIHZlcnNpb24gPSB2ZXJcbiAgfVxuXG4gIHNlbGYuc2hvd1ZlcnNpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHR5cGVvZiB2ZXJzaW9uID09PSAnZnVuY3Rpb24nKSBjb25zb2xlLmxvZyh2ZXJzaW9uKCkpXG4gICAgZWxzZSBjb25zb2xlLmxvZyh2ZXJzaW9uKVxuICB9XG5cbiAgcmV0dXJuIHNlbGZcbn1cbiIsIi8vIHZhbGlkYXRpb24tdHlwZS1zdHVmZiwgbWlzc2luZyBwYXJhbXMsXG4vLyBiYWQgaW1wbGljYXRpb25zLCBjdXN0b20gY2hlY2tzLlxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoeWFyZ3MsIHVzYWdlLCB5MThuKSB7XG4gIHZhciBfXyA9IHkxOG4uX19cbiAgdmFyIF9fbiA9IHkxOG4uX19uXG4gIHZhciBzZWxmID0ge31cblxuICAvLyB2YWxpZGF0ZSBhcHByb3ByaWF0ZSAjIG9mIG5vbi1vcHRpb25cbiAgLy8gYXJndW1lbnRzIHdlcmUgcHJvdmlkZWQsIGkuZS4sICdfJy5cbiAgc2VsZi5ub25PcHRpb25Db3VudCA9IGZ1bmN0aW9uIChhcmd2KSB7XG4gICAgdmFyIGRlbWFuZGVkID0geWFyZ3MuZ2V0RGVtYW5kZWQoKVxuICAgIHZhciBfcyA9IGFyZ3YuXy5sZW5ndGhcblxuICAgIGlmIChkZW1hbmRlZC5fICYmIChfcyA8IGRlbWFuZGVkLl8uY291bnQgfHwgX3MgPiBkZW1hbmRlZC5fLm1heCkpIHtcbiAgICAgIGlmIChkZW1hbmRlZC5fLm1zZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHVzYWdlLmZhaWwoZGVtYW5kZWQuXy5tc2cpXG4gICAgICB9IGVsc2UgaWYgKF9zIDwgZGVtYW5kZWQuXy5jb3VudCkge1xuICAgICAgICB1c2FnZS5mYWlsKFxuICAgICAgICAgIF9fKCdOb3QgZW5vdWdoIG5vbi1vcHRpb24gYXJndW1lbnRzOiBnb3QgJXMsIG5lZWQgYXQgbGVhc3QgJXMnLCBhcmd2Ll8ubGVuZ3RoLCBkZW1hbmRlZC5fLmNvdW50KVxuICAgICAgICApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1c2FnZS5mYWlsKFxuICAgICAgICAgIF9fKCdUb28gbWFueSBub24tb3B0aW9uIGFyZ3VtZW50czogZ290ICVzLCBtYXhpbXVtIG9mICVzJywgYXJndi5fLmxlbmd0aCwgZGVtYW5kZWQuXy5tYXgpXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBtYWtlIHN1cmUgdGhhdCBhbnkgYXJncyB0aGF0IHJlcXVpcmUgYW5cbiAgLy8gdmFsdWUgKC0tZm9vPWJhciksIGhhdmUgYSB2YWx1ZS5cbiAgc2VsZi5taXNzaW5nQXJndW1lbnRWYWx1ZSA9IGZ1bmN0aW9uIChhcmd2KSB7XG4gICAgdmFyIGRlZmF1bHRWYWx1ZXMgPSBbdHJ1ZSwgZmFsc2UsICcnXVxuICAgIHZhciBvcHRpb25zID0geWFyZ3MuZ2V0T3B0aW9ucygpXG5cbiAgICBpZiAob3B0aW9ucy5yZXF1aXJlc0FyZy5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgbWlzc2luZ1JlcXVpcmVkQXJncyA9IFtdXG5cbiAgICAgIG9wdGlvbnMucmVxdWlyZXNBcmcuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFyZ3Zba2V5XVxuXG4gICAgICAgIC8vIGlmIGEgdmFsdWUgaXMgZXhwbGljaXRseSByZXF1ZXN0ZWQsXG4gICAgICAgIC8vIGZsYWcgYXJndW1lbnQgYXMgbWlzc2luZyBpZiBpdCBkb2VzIG5vdFxuICAgICAgICAvLyBsb29rIGxpa2UgZm9vPWJhciB3YXMgZW50ZXJlZC5cbiAgICAgICAgaWYgKH5kZWZhdWx0VmFsdWVzLmluZGV4T2YodmFsdWUpIHx8XG4gICAgICAgICAgKEFycmF5LmlzQXJyYXkodmFsdWUpICYmICF2YWx1ZS5sZW5ndGgpKSB7XG4gICAgICAgICAgbWlzc2luZ1JlcXVpcmVkQXJncy5wdXNoKGtleSlcbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgICAgaWYgKG1pc3NpbmdSZXF1aXJlZEFyZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICB1c2FnZS5mYWlsKF9fbihcbiAgICAgICAgICAnTWlzc2luZyBhcmd1bWVudCB2YWx1ZTogJXMnLFxuICAgICAgICAgICdNaXNzaW5nIGFyZ3VtZW50IHZhbHVlczogJXMnLFxuICAgICAgICAgIG1pc3NpbmdSZXF1aXJlZEFyZ3MubGVuZ3RoLFxuICAgICAgICAgIG1pc3NpbmdSZXF1aXJlZEFyZ3Muam9pbignLCAnKVxuICAgICAgICApKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIG1ha2Ugc3VyZSBhbGwgdGhlIHJlcXVpcmVkIGFyZ3VtZW50cyBhcmUgcHJlc2VudC5cbiAgc2VsZi5yZXF1aXJlZEFyZ3VtZW50cyA9IGZ1bmN0aW9uIChhcmd2KSB7XG4gICAgdmFyIGRlbWFuZGVkID0geWFyZ3MuZ2V0RGVtYW5kZWQoKVxuICAgIHZhciBtaXNzaW5nID0gbnVsbFxuXG4gICAgT2JqZWN0LmtleXMoZGVtYW5kZWQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgaWYgKCFhcmd2Lmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgbWlzc2luZyA9IG1pc3NpbmcgfHwge31cbiAgICAgICAgbWlzc2luZ1trZXldID0gZGVtYW5kZWRba2V5XVxuICAgICAgfVxuICAgIH0pXG5cbiAgICBpZiAobWlzc2luZykge1xuICAgICAgdmFyIGN1c3RvbU1zZ3MgPSBbXVxuICAgICAgT2JqZWN0LmtleXMobWlzc2luZykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciBtc2cgPSBtaXNzaW5nW2tleV0ubXNnXG4gICAgICAgIGlmIChtc2cgJiYgY3VzdG9tTXNncy5pbmRleE9mKG1zZykgPCAwKSB7XG4gICAgICAgICAgY3VzdG9tTXNncy5wdXNoKG1zZylcbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgICAgdmFyIGN1c3RvbU1zZyA9IGN1c3RvbU1zZ3MubGVuZ3RoID8gJ1xcbicgKyBjdXN0b21Nc2dzLmpvaW4oJ1xcbicpIDogJydcblxuICAgICAgdXNhZ2UuZmFpbChfX24oXG4gICAgICAgICdNaXNzaW5nIHJlcXVpcmVkIGFyZ3VtZW50OiAlcycsXG4gICAgICAgICdNaXNzaW5nIHJlcXVpcmVkIGFyZ3VtZW50czogJXMnLFxuICAgICAgICBPYmplY3Qua2V5cyhtaXNzaW5nKS5sZW5ndGgsXG4gICAgICAgIE9iamVjdC5rZXlzKG1pc3NpbmcpLmpvaW4oJywgJykgKyBjdXN0b21Nc2dcbiAgICAgICkpXG4gICAgfVxuICB9XG5cbiAgLy8gY2hlY2sgZm9yIHVua25vd24gYXJndW1lbnRzIChzdHJpY3QtbW9kZSkuXG4gIHNlbGYudW5rbm93bkFyZ3VtZW50cyA9IGZ1bmN0aW9uIChhcmd2LCBhbGlhc2VzKSB7XG4gICAgdmFyIGFsaWFzTG9va3VwID0ge31cbiAgICB2YXIgZGVzY3JpcHRpb25zID0gdXNhZ2UuZ2V0RGVzY3JpcHRpb25zKClcbiAgICB2YXIgZGVtYW5kZWQgPSB5YXJncy5nZXREZW1hbmRlZCgpXG4gICAgdmFyIHVua25vd24gPSBbXVxuXG4gICAgT2JqZWN0LmtleXMoYWxpYXNlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBhbGlhc2VzW2tleV0uZm9yRWFjaChmdW5jdGlvbiAoYWxpYXMpIHtcbiAgICAgICAgYWxpYXNMb29rdXBbYWxpYXNdID0ga2V5XG4gICAgICB9KVxuICAgIH0pXG5cbiAgICBPYmplY3Qua2V5cyhhcmd2KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIGlmIChrZXkgIT09ICckMCcgJiYga2V5ICE9PSAnXycgJiZcbiAgICAgICAgIWRlc2NyaXB0aW9ucy5oYXNPd25Qcm9wZXJ0eShrZXkpICYmXG4gICAgICAgICFkZW1hbmRlZC5oYXNPd25Qcm9wZXJ0eShrZXkpICYmXG4gICAgICAgICFhbGlhc0xvb2t1cC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIHVua25vd24ucHVzaChrZXkpXG4gICAgICB9XG4gICAgfSlcblxuICAgIGlmICh1bmtub3duLmxlbmd0aCA+IDApIHtcbiAgICAgIHVzYWdlLmZhaWwoX19uKFxuICAgICAgICAnVW5rbm93biBhcmd1bWVudDogJXMnLFxuICAgICAgICAnVW5rbm93biBhcmd1bWVudHM6ICVzJyxcbiAgICAgICAgdW5rbm93bi5sZW5ndGgsXG4gICAgICAgIHVua25vd24uam9pbignLCAnKVxuICAgICAgKSlcbiAgICB9XG4gIH1cblxuICAvLyB2YWxpZGF0ZSBhcmd1bWVudHMgbGltaXRlZCB0byBlbnVtZXJhdGVkIGNob2ljZXNcbiAgc2VsZi5saW1pdGVkQ2hvaWNlcyA9IGZ1bmN0aW9uIChhcmd2KSB7XG4gICAgdmFyIG9wdGlvbnMgPSB5YXJncy5nZXRPcHRpb25zKClcbiAgICB2YXIgaW52YWxpZCA9IHt9XG5cbiAgICBpZiAoIU9iamVjdC5rZXlzKG9wdGlvbnMuY2hvaWNlcykubGVuZ3RoKSByZXR1cm5cblxuICAgIE9iamVjdC5rZXlzKGFyZ3YpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgaWYgKGtleSAhPT0gJyQwJyAmJiBrZXkgIT09ICdfJyAmJlxuICAgICAgICBvcHRpb25zLmNob2ljZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBbXS5jb25jYXQoYXJndltrZXldKS5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIC8vIFRPRE8gY2FzZS1pbnNlbnNpdGl2ZSBjb25maWd1cmFiaWxpdHlcbiAgICAgICAgICBpZiAob3B0aW9ucy5jaG9pY2VzW2tleV0uaW5kZXhPZih2YWx1ZSkgPT09IC0xKSB7XG4gICAgICAgICAgICBpbnZhbGlkW2tleV0gPSAoaW52YWxpZFtrZXldIHx8IFtdKS5jb25jYXQodmFsdWUpXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0pXG5cbiAgICB2YXIgaW52YWxpZEtleXMgPSBPYmplY3Qua2V5cyhpbnZhbGlkKVxuXG4gICAgaWYgKCFpbnZhbGlkS2V5cy5sZW5ndGgpIHJldHVyblxuXG4gICAgdmFyIG1zZyA9IF9fKCdJbnZhbGlkIHZhbHVlczonKVxuICAgIGludmFsaWRLZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgbXNnICs9ICdcXG4gICcgKyBfXyhcbiAgICAgICAgJ0FyZ3VtZW50OiAlcywgR2l2ZW46ICVzLCBDaG9pY2VzOiAlcycsXG4gICAgICAgIGtleSxcbiAgICAgICAgdXNhZ2Uuc3RyaW5naWZpZWRWYWx1ZXMoaW52YWxpZFtrZXldKSxcbiAgICAgICAgdXNhZ2Uuc3RyaW5naWZpZWRWYWx1ZXMob3B0aW9ucy5jaG9pY2VzW2tleV0pXG4gICAgICApXG4gICAgfSlcbiAgICB1c2FnZS5mYWlsKG1zZylcbiAgfVxuXG4gIC8vIGN1c3RvbSBjaGVja3MsIGFkZGVkIHVzaW5nIHRoZSBgY2hlY2tgIG9wdGlvbiBvbiB5YXJncy5cbiAgdmFyIGNoZWNrcyA9IFtdXG4gIHNlbGYuY2hlY2sgPSBmdW5jdGlvbiAoZikge1xuICAgIGNoZWNrcy5wdXNoKGYpXG4gIH1cblxuICBzZWxmLmN1c3RvbUNoZWNrcyA9IGZ1bmN0aW9uIChhcmd2LCBhbGlhc2VzKSB7XG4gICAgY2hlY2tzLmZvckVhY2goZnVuY3Rpb24gKGYpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBmKGFyZ3YsIGFsaWFzZXMpXG4gICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgdXNhZ2UuZmFpbChfXygnQXJndW1lbnQgY2hlY2sgZmFpbGVkOiAlcycsIGYudG9TdHJpbmcoKSkpXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB1c2FnZS5mYWlsKHJlc3VsdClcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHVzYWdlLmZhaWwoZXJyLm1lc3NhZ2UgPyBlcnIubWVzc2FnZSA6IGVycilcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgLy8gY2hlY2sgaW1wbGljYXRpb25zLCBhcmd1bWVudCBmb28gaW1wbGllcyA9PiBhcmd1bWVudCBiYXIuXG4gIHZhciBpbXBsaWVkID0ge31cbiAgc2VsZi5pbXBsaWVzID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIGtleSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIE9iamVjdC5rZXlzKGtleSkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICBzZWxmLmltcGxpZXMoaywga2V5W2tdKVxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgaW1wbGllZFtrZXldID0gdmFsdWVcbiAgICB9XG4gIH1cbiAgc2VsZi5nZXRJbXBsaWVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBpbXBsaWVkXG4gIH1cblxuICBzZWxmLmltcGxpY2F0aW9ucyA9IGZ1bmN0aW9uIChhcmd2KSB7XG4gICAgdmFyIGltcGx5RmFpbCA9IFtdXG5cbiAgICBPYmplY3Qua2V5cyhpbXBsaWVkKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHZhciBudW1cbiAgICAgIHZhciBvcmlnS2V5ID0ga2V5XG4gICAgICB2YXIgdmFsdWUgPSBpbXBsaWVkW2tleV1cblxuICAgICAgLy8gY29udmVydCBzdHJpbmcgJzEnIHRvIG51bWJlciAxXG4gICAgICBudW0gPSBOdW1iZXIoa2V5KVxuICAgICAga2V5ID0gaXNOYU4obnVtKSA/IGtleSA6IG51bVxuXG4gICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgLy8gY2hlY2sgbGVuZ3RoIG9mIGFyZ3YuX1xuICAgICAgICBrZXkgPSBhcmd2Ll8ubGVuZ3RoID49IGtleVxuICAgICAgfSBlbHNlIGlmIChrZXkubWF0Y2goL14tLW5vLS4rLykpIHtcbiAgICAgICAgLy8gY2hlY2sgaWYga2V5IGRvZXNuJ3QgZXhpc3RcbiAgICAgICAga2V5ID0ga2V5Lm1hdGNoKC9eLS1uby0oLispLylbMV1cbiAgICAgICAga2V5ID0gIWFyZ3Zba2V5XVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY2hlY2sgaWYga2V5IGV4aXN0c1xuICAgICAgICBrZXkgPSBhcmd2W2tleV1cbiAgICAgIH1cblxuICAgICAgbnVtID0gTnVtYmVyKHZhbHVlKVxuICAgICAgdmFsdWUgPSBpc05hTihudW0pID8gdmFsdWUgOiBudW1cblxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgdmFsdWUgPSBhcmd2Ll8ubGVuZ3RoID49IHZhbHVlXG4gICAgICB9IGVsc2UgaWYgKHZhbHVlLm1hdGNoKC9eLS1uby0uKy8pKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUubWF0Y2goL14tLW5vLSguKykvKVsxXVxuICAgICAgICB2YWx1ZSA9ICFhcmd2W3ZhbHVlXVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSBhcmd2W3ZhbHVlXVxuICAgICAgfVxuXG4gICAgICBpZiAoa2V5ICYmICF2YWx1ZSkge1xuICAgICAgICBpbXBseUZhaWwucHVzaChvcmlnS2V5KVxuICAgICAgfVxuICAgIH0pXG5cbiAgICBpZiAoaW1wbHlGYWlsLmxlbmd0aCkge1xuICAgICAgdmFyIG1zZyA9IF9fKCdJbXBsaWNhdGlvbnMgZmFpbGVkOicpICsgJ1xcbidcblxuICAgICAgaW1wbHlGYWlsLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBtc2cgKz0gKCcgICcgKyBrZXkgKyAnIC0+ICcgKyBpbXBsaWVkW2tleV0pXG4gICAgICB9KVxuXG4gICAgICB1c2FnZS5mYWlsKG1zZylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc2VsZlxufVxuIiwiLy8gQ29weXJpZ2h0IChjKSAyMDE1LTIwMTYgWXV5YSBPY2hpYWlcbi8vIENvcHlyaWdodCAoYykgMjAxNi1wcmVzZW50IE1hdHRlcm1vc3QsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vIFNlZSBMSUNFTlNFLnR4dCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbmltcG9ydCB1cmwgZnJvbSAndXJsJztcblxuaW1wb3J0IGVsZWN0cm9uIGZyb20gJ2VsZWN0cm9uJztcbmltcG9ydCB7aXNVcmksIGlzSHR0cFVyaSwgaXNIdHRwc1VyaX0gZnJvbSAndmFsaWQtdXJsJztcblxuZnVuY3Rpb24gZ2V0RG9tYWluKGlucHV0VVJMKSB7XG4gIGNvbnN0IHBhcnNlZFVSTCA9IHVybC5wYXJzZShpbnB1dFVSTCk7XG4gIHJldHVybiBgJHtwYXJzZWRVUkwucHJvdG9jb2x9Ly8ke3BhcnNlZFVSTC5ob3N0fWA7XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWRVUkwodGVzdFVSTCkge1xuICByZXR1cm4gQm9vbGVhbihpc0h0dHBVcmkodGVzdFVSTCkgfHwgaXNIdHRwc1VyaSh0ZXN0VVJMKSk7XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWRVUkkodGVzdFVSTCkge1xuICByZXR1cm4gQm9vbGVhbihpc1VyaSh0ZXN0VVJMKSk7XG59XG5cbi8vIGlzSW50ZXJuYWxVUkwgZGV0ZXJtaW5lcyBpZiB0aGUgdGFyZ2V0IHVybCBpcyBpbnRlcm5hbCB0byB0aGUgYXBwbGljYXRpb24uXG4vLyAtIGN1cnJlbnRVUkwgaXMgdGhlIGN1cnJlbnQgdXJsIGluc2lkZSB0aGUgd2Vidmlld1xuLy8gLSBiYXNlbmFtZSBpcyB0aGUgZ2xvYmFsIGV4cG9ydCBmcm9tIHRoZSBNYXR0ZXJtb3N0IGFwcGxpY2F0aW9uIGRlZmluaW5nIHRoZSBzdWJwYXRoLCBpZiBhbnlcbmZ1bmN0aW9uIGlzSW50ZXJuYWxVUkwodGFyZ2V0VVJMLCBjdXJyZW50VVJMLCBiYXNlbmFtZSA9ICcvJykge1xuICBpZiAodGFyZ2V0VVJMLmhvc3QgIT09IGN1cnJlbnRVUkwuaG9zdCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICghKHRhcmdldFVSTC5wYXRobmFtZSB8fCAnLycpLnN0YXJ0c1dpdGgoYmFzZW5hbWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGdldERpc3BsYXlCb3VuZGFyaWVzKCkge1xuICBjb25zdCB7c2NyZWVufSA9IGVsZWN0cm9uO1xuXG4gIGNvbnN0IGRpc3BsYXlzID0gc2NyZWVuLmdldEFsbERpc3BsYXlzKCk7XG5cbiAgcmV0dXJuIGRpc3BsYXlzLm1hcCgoZGlzcGxheSkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBtYXhYOiBkaXNwbGF5LndvcmtBcmVhLnggKyBkaXNwbGF5LndvcmtBcmVhLndpZHRoLFxuICAgICAgbWF4WTogZGlzcGxheS53b3JrQXJlYS55ICsgZGlzcGxheS53b3JrQXJlYS5oZWlnaHQsXG4gICAgICBtaW5YOiBkaXNwbGF5LndvcmtBcmVhLngsXG4gICAgICBtaW5ZOiBkaXNwbGF5LndvcmtBcmVhLnksXG4gICAgICBtYXhXaWR0aDogZGlzcGxheS53b3JrQXJlYS53aWR0aCxcbiAgICAgIG1heEhlaWdodDogZGlzcGxheS53b3JrQXJlYS5oZWlnaHQsXG4gICAgfTtcbiAgfSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZ2V0RG9tYWluLFxuICBpc1ZhbGlkVVJMLFxuICBpc1ZhbGlkVVJJLFxuICBpc0ludGVybmFsVVJMLFxuICBnZXREaXNwbGF5Qm91bmRhcmllcyxcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJhc3NlcnRcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiY2hpbGRfcHJvY2Vzc1wiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJjcnlwdG9cIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiZWxlY3Ryb25cIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiZXZlbnRzXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImZzXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImh0dHBcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiaHR0cHNcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwibmV0XCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIm9zXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInBhdGhcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicHVueWNvZGVcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwic3RyZWFtXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInR0eVwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJ1cmxcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwidXRpbFwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJ6bGliXCIpOyJdLCJzb3VyY2VSb290IjoiIn0=
